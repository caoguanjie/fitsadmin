var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { defineComponent, openBlock, createElementBlock, createElementVNode, resolveComponent, createVNode, mergeProps as mergeProps$1, unref as unref$1, isRef, withCtx, withDirectives, vShow, Fragment, renderList, createBlock, normalizeClass, toDisplayString, toRefs as toRefs$1, reactive as reactive$1, useAttrs as useAttrs$1, watch as watch$1, onMounted as onMounted$1, createTextVNode, toRef, nextTick as nextTick$1, markRaw, isVNode, computed as computed$1, getCurrentInstance as getCurrentInstance$1, ref as ref$1, createApp, h as h$6, provide, inject, onBeforeUnmount, onUpdated, resolveDirective, useCssVars, createSlots, renderSlot, createCommentVNode, shallowRef as shallowRef$1, onUnmounted, normalizeStyle as normalizeStyle$1, pushScopeId, popScopeId, Teleport, onActivated, onDeactivated, getCurrentScope, onScopeDispose, warn, Transition, toRaw, useSlots, resolveDynamicComponent, vModelCheckbox, toHandlers, effectScope, withModifiers, shallowReactive, render as render$a, watchEffect } from "vue";
var _export_sfc$3 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val2] of props) {
    target[key] = val2;
  }
  return target;
};
const _sfc_main$F = defineComponent({
  name: "ArrowDown"
});
const _hoisted_1$t = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1);
const _hoisted_3$h = [
  _hoisted_2$j
];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$t, _hoisted_3$h);
}
var arrowDown = /* @__PURE__ */ _export_sfc$3(_sfc_main$F, [["render", _sfc_render$9]]);
const _sfc_main$E = defineComponent({
  name: "ArrowUp"
});
const _hoisted_1$s = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$i = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
}, null, -1);
const _hoisted_3$g = [
  _hoisted_2$i
];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$s, _hoisted_3$g);
}
var arrowUp = /* @__PURE__ */ _export_sfc$3(_sfc_main$E, [["render", _sfc_render$8]]);
const _sfc_main$D = defineComponent({
  name: "CaretBottom"
});
const _hoisted_1$r = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$h = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m192 384 320 384 320-384z"
}, null, -1);
const _hoisted_3$f = [
  _hoisted_2$h
];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$r, _hoisted_3$f);
}
var caretBottom = /* @__PURE__ */ _export_sfc$3(_sfc_main$D, [["render", _sfc_render$7]]);
const _sfc_main$C = defineComponent({
  name: "Delete"
});
const _hoisted_1$q = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$g = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32zm192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32z"
}, null, -1);
const _hoisted_3$e = [
  _hoisted_2$g
];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$q, _hoisted_3$e);
}
var _delete = /* @__PURE__ */ _export_sfc$3(_sfc_main$C, [["render", _sfc_render$6]]);
const _sfc_main$B = defineComponent({
  name: "RefreshLeft"
});
const _hoisted_1$p = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$f = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
}, null, -1);
const _hoisted_3$d = [
  _hoisted_2$f
];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$d);
}
var refreshLeft = /* @__PURE__ */ _export_sfc$3(_sfc_main$B, [["render", _sfc_render$5]]);
const _sfc_main$A = defineComponent({
  name: "Search"
});
const _hoisted_1$o = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$e = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"
}, null, -1);
const _hoisted_3$c = [
  _hoisted_2$e
];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$c);
}
var search = /* @__PURE__ */ _export_sfc$3(_sfc_main$A, [["render", _sfc_render$4]]);
class FitsSelectProps {
  constructor({
    disabled: disabled3,
    size,
    clearable,
    effect,
    placeholder,
    popperClass,
    teleported,
    persistent,
    clearIcon,
    fitInputWidth,
    suffixIcon,
    validateEvent,
    multiple,
    collapseTags,
    collapseTagsTooltip
  } = {}) {
    __publicField(this, "disabled");
    __publicField(this, "size");
    __publicField(this, "clearable");
    __publicField(this, "effect");
    __publicField(this, "placeholder");
    __publicField(this, "popperClass");
    __publicField(this, "teleported");
    __publicField(this, "persistent");
    __publicField(this, "clearIcon");
    __publicField(this, "fitInputWidth");
    __publicField(this, "suffixIcon");
    __publicField(this, "validateEvent");
    __publicField(this, "multiple");
    __publicField(this, "collapseTags");
    __publicField(this, "collapseTagsTooltip");
    this.disabled = disabled3 != null ? disabled3 : false;
    this.size = size != null ? size : "default";
    this.clearable = clearable != null ? clearable : false;
    this.effect = effect != null ? effect : "light";
    this.placeholder = placeholder != null ? placeholder : "\u8BF7\u9009\u62E9";
    this.popperClass = popperClass != null ? popperClass : "";
    this.teleported = teleported != null ? teleported : true;
    this.persistent = persistent != null ? persistent : true;
    this.clearIcon = clearIcon;
    this.fitInputWidth = fitInputWidth != null ? fitInputWidth : true;
    this.suffixIcon = suffixIcon != null ? suffixIcon : h(caretBottom);
    this.validateEvent = validateEvent != null ? validateEvent : true;
    this.multiple = multiple != null ? multiple : false;
    this.collapseTags = collapseTags != null ? collapseTags : false;
    this.collapseTagsTooltip = collapseTagsTooltip != null ? collapseTagsTooltip : false;
  }
}
class FitsTreeSelectModel {
  constructor({
    tree,
    select: select2,
    input: input4
  } = {}) {
    __publicField(this, "tree");
    __publicField(this, "select");
    __publicField(this, "input");
    this.tree = tree;
    this.select = new FitsSelectProps({ ...select2 });
    this.input = input4;
  }
}
class FitsIconSelectModel {
  constructor({
    select: select2,
    input: input4,
    noListText,
    showInput
  } = {}) {
    __publicField(this, "select");
    __publicField(this, "input");
    __publicField(this, "noListText");
    __publicField(this, "showInput");
    this.select = new FitsSelectProps({ ...select2 });
    this.input = input4;
    this.noListText = noListText != null ? noListText : "\u6682\u65E0\u6570\u636E";
    this.showInput = showInput != null ? showInput : true;
  }
}
class FitsCheckboxAllModel {
  constructor({
    option,
    checkboxGroup
  } = {}) {
    __publicField(this, "option");
    __publicField(this, "checkboxGroup");
    this.option = option;
    this.checkboxGroup = checkboxGroup;
  }
}
var FitsTreeSelect_vue_vue_type_style_index_0_scoped_true_lang = "";
var FitsTreeSelect_vue_vue_type_style_index_1_lang = "";
var _export_sfc$2 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val2] of props) {
    target[key] = val2;
  }
  return target;
};
const _hoisted_1$n = { class: "tree-search" };
const _hoisted_2$d = { style: { "padding": "10px" } };
const _hoisted_3$b = { class: "CustomTree" };
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  __name: "FitsTreeSelect",
  props: {
    options: { default: () => new FitsTreeSelectModel() }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const { options } = toRefs(props);
    const state = reactive({
      filterText: "",
      isMultiple: options.value.select.multiple,
      expandNode: options.value.tree.showCheckbox ? !options.value.tree.checkOnClickNode : !options.value.tree.checkStrictly
    });
    const { filterText, isMultiple: isMultiple2, expandNode } = toRefs(state);
    const selectedValue = isMultiple2.value ? ref([]) : ref("");
    const _attrs = useAttrs();
    const treeRef = ref();
    const selectInputRef = ref();
    expose({
      treeRef
    });
    watch(() => _attrs.modelValue, (val2) => {
      if (!(val2 == null ? void 0 : val2.length)) {
        selectedValue.value = val2;
        return;
      }
      initValue(val2);
    });
    watch(filterText, (val2) => {
      treeRef.value.filter(val2);
    });
    onMounted(() => {
      initValue(_attrs.modelValue);
    });
    function initValue(val2) {
      var _a2;
      if (!val2 || !(val2 == null ? void 0 : val2.length))
        return;
      if (!isMultiple2.value) {
        treeRef.value.setCurrentKey(val2);
        selectedValue.value = (_a2 = treeRef.value.getNode(val2)) == null ? void 0 : _a2.label;
        emit("update:modelValue", val2);
      } else {
        let arr = [];
        arr = typeof val2 === "string" ? [val2] : val2;
        treeRef.value.setCheckedKeys(arr);
        selectedValue.value = [];
        treeRef.value.getCheckedNodes(true).map((item) => selectedValue.value.push(item.label));
        emit("update:modelValue", treeRef.value.getCheckedKeys(true));
      }
    }
    function VisibleChange() {
      var _a2;
      filterText.value = "";
      (_a2 = treeRef.value) == null ? void 0 : _a2.filter("");
    }
    function clearSelected() {
      if (!isMultiple2.value) {
        treeRef.value.setCurrentKey(null);
      } else {
        treeRef.value.setCheckedKeys([]);
      }
      emit("update:modelValue", "");
    }
    function filterNode(value, data5, node) {
      if (!value)
        return true;
      return data5[node.store.props.label].includes(value);
    }
    function nodeClick(node, option, event) {
      if (options.value.tree.showCheckbox) {
        return;
      }
      const isCheckStrictly = options.value.tree.checkStrictly;
      if (option.isLeaf && !isCheckStrictly || isCheckStrictly) {
        selectedValue.value = node[event.props.props.label];
        selectInputRef.value.blur();
        emit("update:modelValue", node.id);
      }
    }
    function Check(obj, treeObj) {
      const index = selectedValue.value.indexOf(obj.label);
      if (index !== -1) {
        selectedValue.value.splice(index, 1);
      } else {
        const leafArr = treeObj.checkedNodes.filter((item) => !item["children"]);
        selectedValue.value = [];
        leafArr.map((item) => selectedValue.value.push(item.label));
      }
      emit("update:modelValue", treeRef.value.getCheckedKeys(true));
    }
    function RemoveTag(val2) {
      const checkNodes = treeRef.value.getCheckedNodes(true);
      const removeNode = checkNodes.find((item) => item.label === val2);
      treeRef.value.setChecked(removeNode.id, false);
      emit("update:modelValue", treeRef.value.getCheckedKeys(true));
    }
    return (_ctx, _cache) => {
      var _a2;
      const _component_el_input = resolveComponent("el-input");
      const _component_el_tree = resolveComponent("el-tree");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select = resolveComponent("el-select");
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        createVNode(_component_el_select, mergeProps$1(unref$1(options).select, {
          ref_key: "selectInputRef",
          ref: selectInputRef,
          modelValue: unref$1(selectedValue),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(selectedValue) ? selectedValue.value = $event : null),
          onVisibleChange: VisibleChange,
          onClear: clearSelected,
          "popper-class": `${(_a2 = unref$1(options).select) == null ? void 0 : _a2.popperClass} tree-popper`,
          onRemoveTag: RemoveTag
        }), {
          empty: withCtx(() => [
            createElementVNode("div", _hoisted_2$d, [
              createVNode(_component_el_input, mergeProps$1({ placeholder: "\u8BF7\u8F93\u5165\u5173\u952E\u5B57" }, unref$1(options).input, {
                modelValue: unref$1(filterText),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(filterText) ? filterText.value = $event : null),
                class: "filterInput"
              }), null, 16, ["modelValue"]),
              createVNode(_component_el_scrollbar, { "max-height": "30vh" }, {
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_3$b, [
                    createVNode(_component_el_tree, mergeProps$1({
                      ref_key: "treeRef",
                      ref: treeRef,
                      highlightCurrent: true,
                      "filter-node-method": filterNode,
                      "empty-text": "\u6682\u65E0\u6570\u636E"
                    }, unref$1(options).tree, {
                      "expand-on-click-node": unref$1(expandNode),
                      onNodeClick: nodeClick,
                      onCheck: Check,
                      indent: 8
                    }), null, 16, ["expand-on-click-node"])
                  ])
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 16, ["modelValue", "popper-class"])
      ]);
    };
  }
});
var FitsTreeSelect = /* @__PURE__ */ _export_sfc$2(_sfc_main$z, [["__scopeId", "data-v-9e87f8c6"]]);
var FitsIconSelect_vue_vue_type_style_index_0_scoped_true_lang = "";
var FitsIconSelect_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$m = { class: "IconSelect" };
const _hoisted_2$c = {
  key: 0,
  class: "IconSelect__list"
};
const _hoisted_3$a = { class: "inner-content" };
const _hoisted_4$4 = {
  key: 1,
  class: "no-data-text"
};
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "FitsIconSelect",
  props: {
    options: { default: () => new FitsIconSelectModel() }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const { options } = toRefs(props);
    const icons = [];
    const modules = { "../../assets/icons/404.svg": () => import("./404.js"), "../../assets/icons/accoutlogo.svg": () => import("./accoutlogo.js"), "../../assets/icons/advert.svg": () => import("./advert.js"), "../../assets/icons/android.svg": () => import("./android.js"), "../../assets/icons/brand.svg": () => import("./brand.js"), "../../assets/icons/bug.svg": () => import("./bug.js"), "../../assets/icons/bussis.svg": () => import("./bussis.js"), "../../assets/icons/cascader.svg": () => import("./cascader.js"), "../../assets/icons/chart.svg": () => import("./chart.js"), "../../assets/icons/client.svg": () => import("./client.js"), "../../assets/icons/dashboard.svg": () => import("./dashboard.js"), "../../assets/icons/dict.svg": () => import("./dict.js"), "../../assets/icons/dict_item.svg": () => import("./dict_item.js"), "../../assets/icons/down.svg": () => import("./down.js"), "../../assets/icons/download.svg": () => import("./download.js"), "../../assets/icons/drag.svg": () => import("./drag.js"), "../../assets/icons/draggable.svg": () => import("./draggable.js"), "../../assets/icons/edit.svg": () => import("./edit.js"), "../../assets/icons/ewnlogin.svg": () => import("./ewnlogin.js"), "../../assets/icons/example.svg": () => import("./example.js"), "../../assets/icons/exit-fullscreen.svg": () => import("./exit-fullscreen.js"), "../../assets/icons/eye-open.svg": () => import("./eye-open.js"), "../../assets/icons/eye.svg": () => import("./eye.js"), "../../assets/icons/eyeclose.svg": () => import("./eyeclose.js"), "../../assets/icons/eyeopen.svg": () => import("./eyeopen.js"), "../../assets/icons/fits-base-setting.svg": () => import("./fits-base-setting.js"), "../../assets/icons/fits-calendars.svg": () => import("./fits-calendars.js"), "../../assets/icons/fits-changyong.svg": () => import("./fits-changyong.js"), "../../assets/icons/fits-charts.svg": () => import("./fits-charts.js"), "../../assets/icons/fits-close-all.svg": () => import("./fits-close-all.js"), "../../assets/icons/fits-close-left.svg": () => import("./fits-close-left.js"), "../../assets/icons/fits-close-other.svg": () => import("./fits-close-other.js"), "../../assets/icons/fits-close-right.svg": () => import("./fits-close-right.js"), "../../assets/icons/fits-close.svg": () => import("./fits-close.js"), "../../assets/icons/fits-component1.svg": () => import("./fits-component1.js"), "../../assets/icons/fits-execle.svg": () => import("./fits-execle.js"), "../../assets/icons/fits-fujian.svg": () => import("./fits-fujian.js"), "../../assets/icons/fits-gongzuoliu.svg": () => import("./fits-gongzuoliu.js"), "../../assets/icons/fits-home.svg": () => import("./fits-home.js"), "../../assets/icons/fits-pdf.svg": () => import("./fits-pdf.js"), "../../assets/icons/fits-refresh.svg": () => import("./fits-refresh.js"), "../../assets/icons/fits-system.svg": () => import("./fits-system.js"), "../../assets/icons/fits-table-menu.svg": () => import("./fits-table-menu.js"), "../../assets/icons/fits-yewu.svg": () => import("./fits-yewu.js"), "../../assets/icons/fits-zhuji.svg": () => import("./fits-zhuji.js"), "../../assets/icons/fits-zujianguanli.svg": () => import("./fits-zujianguanli.js"), "../../assets/icons/fullscreen.svg": () => import("./fullscreen.js"), "../../assets/icons/github.svg": () => import("./github.js"), "../../assets/icons/goods-list.svg": () => import("./goods-list.js"), "../../assets/icons/goods.svg": () => import("./goods.js"), "../../assets/icons/guide.svg": () => import("./guide.js"), "../../assets/icons/home.svg": () => import("./home.js"), "../../assets/icons/ios.svg": () => import("./ios.js"), "../../assets/icons/lab.svg": () => import("./lab.js"), "../../assets/icons/language.svg": () => import("./language.js"), "../../assets/icons/link.svg": () => import("./link.js"), "../../assets/icons/menu.svg": () => import("./menu.js"), "../../assets/icons/message.svg": () => import("./message.js"), "../../assets/icons/money.svg": () => import("./money.js"), "../../assets/icons/monitor.svg": () => import("./monitor.js"), "../../assets/icons/nested.svg": () => import("./nested.js"), "../../assets/icons/nodata.svg": () => import("./nodata.js"), "../../assets/icons/number.svg": () => import("./number.js"), "../../assets/icons/order.svg": () => import("./order.js"), "../../assets/icons/password.svg": () => import("./password.js"), "../../assets/icons/peoples.svg": () => import("./peoples.js"), "../../assets/icons/perm.svg": () => import("./perm.js"), "../../assets/icons/publish.svg": () => import("./publish.js"), "../../assets/icons/rabbitmq.svg": () => import("./rabbitmq.js"), "../../assets/icons/rate.svg": () => import("./rate.js"), "../../assets/icons/redis.svg": () => import("./redis.js"), "../../assets/icons/role.svg": () => import("./role.js"), "../../assets/icons/security.svg": () => import("./security.js"), "../../assets/icons/shopping.svg": () => import("./shopping.js"), "../../assets/icons/size.svg": () => import("./size.js"), "../../assets/icons/skill.svg": () => import("./skill.js"), "../../assets/icons/system.svg": () => import("./system.js"), "../../assets/icons/theme.svg": () => import("./theme.js"), "../../assets/icons/tree.svg": () => import("./tree.js"), "../../assets/icons/user.svg": () => import("./user.js"), "../../assets/icons/uv.svg": () => import("./uv.js"), "../../assets/icons/valid_code.svg": () => import("./valid_code.js"), "../../assets/icons/zhuti.svg": () => import("./zhuti.js") };
    for (const path in modules) {
      const p2 = path.split("assets/icons/")[1].split(".svg")[0];
      icons.push({
        name: p2,
        isSelected: false
      });
    }
    const state = reactive({
      filterText: "",
      iconList: icons,
      isMultiple: options.value.select.multiple
    });
    const { filterText, iconList, isMultiple: isMultiple2 } = toRefs(state);
    const selectedNames = isMultiple2.value ? ref([]) : ref("");
    const _attrs = useAttrs();
    const selectInputRef = ref();
    watch(() => _attrs.modelValue, (val2) => {
      if (!val2 || !(val2 == null ? void 0 : val2.length)) {
        selectedNames.value = isMultiple2.value ? [] : "";
        iconList.value.map((item) => {
          item.isSelected = false;
        });
        return;
      }
      initData2(val2);
    });
    onMounted(() => {
      initData2(_attrs.modelValue);
    });
    function initData2(val2) {
      if (!val2 || !(val2 == null ? void 0 : val2.length))
        return;
      selectedNames.value = val2;
      if (!isMultiple2.value) {
        iconList.value.find((item) => item.name === val2).isSelected = true;
      } else {
        iconList.value.map((item) => {
          item.isSelected = val2.includes(item.name);
        });
      }
      emit("update:modelValue", val2);
    }
    function filterMethod(val2) {
      iconList.value = icons.filter((item) => item.name.indexOf(val2) !== -1);
    }
    function VisibleChange() {
      filterText.value = "";
      iconList.value = icons;
    }
    function selectedIcon(item) {
      if (!isMultiple2.value) {
        iconList.value.map((item2) => item2.isSelected = false);
        item.isSelected = !item.isSelected;
        if (item.isSelected) {
          selectedNames.value = item.name;
        }
        selectInputRef.value.blur();
      } else {
        item.isSelected = !item.isSelected;
        if (!item.isSelected) {
          const arr = [...selectedNames.value];
          const index = arr.indexOf(item.name);
          arr.splice(index, 1);
          selectedNames.value = [...arr];
        } else {
          selectedNames.value = [...selectedNames.value, item.name];
        }
      }
      emit("update:modelValue", selectedNames.value);
    }
    function RemoveTag(val2) {
      iconList.value.find((item) => item.name === val2).isSelected = false;
      emit("update:modelValue", selectedNames.value);
    }
    function clearSelected() {
      selectedNames.value = isMultiple2.value ? [] : "";
      iconList.value.map((item) => item.isSelected = false);
      emit("update:modelValue", selectedNames.value);
    }
    return (_ctx, _cache) => {
      var _a2;
      const _component_el_input = resolveComponent("el-input");
      const _component_svg_icon = resolveComponent("svg-icon");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_card = resolveComponent("el-card");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_select = resolveComponent("el-select");
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createVNode(_component_el_select, mergeProps$1({ "filter-method": filterMethod }, unref$1(options).select, {
          modelValue: unref$1(selectedNames),
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => isRef(selectedNames) ? selectedNames.value = $event : null),
          ref_key: "selectInputRef",
          ref: selectInputRef,
          onVisibleChange: VisibleChange,
          onClear: clearSelected,
          "popper-class": `${(_a2 = unref$1(options).select) == null ? void 0 : _a2.popperClass} icon-popper`,
          onRemoveTag: RemoveTag
        }), {
          empty: withCtx(() => [
            withDirectives(createVNode(_component_el_input, mergeProps$1(unref$1(options).input, {
              modelValue: unref$1(filterText),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(filterText) ? filterText.value = $event : null),
              class: "filterInput",
              onInput: _cache[1] || (_cache[1] = ($event) => filterMethod(unref$1(filterText)))
            }), null, 16, ["modelValue"]), [
              [vShow, unref$1(options).showInput]
            ]),
            createVNode(_component_el_scrollbar, {
              class: "icon-scrollbar",
              "max-height": "40vh"
            }, {
              default: withCtx(() => [
                unref$1(iconList).length ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(iconList), (item, index) => {
                    return openBlock(), createBlock(_component_el_card, {
                      shadow: "hover",
                      key: index,
                      onClick: ($event) => selectedIcon(item),
                      class: normalizeClass(["icon-wrapper", { "isSelected": item.isSelected }])
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_el_tooltip, {
                          effect: "dark",
                          content: item.name,
                          placement: "top"
                        }, {
                          default: withCtx(() => [
                            createElementVNode("div", _hoisted_3$a, [
                              createVNode(_component_svg_icon, {
                                color: "#999",
                                "icon-class": item.name
                              }, null, 8, ["icon-class"]),
                              createElementVNode("div", {
                                class: normalizeClass("itemName-" + item.name)
                              }, toDisplayString(item.name), 3)
                            ])
                          ]),
                          _: 2
                        }, 1032, ["content"])
                      ]),
                      _: 2
                    }, 1032, ["onClick", "class"]);
                  }), 128))
                ])) : (openBlock(), createElementBlock("div", _hoisted_4$4, toDisplayString(unref$1(options).noListText), 1))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 16, ["modelValue", "popper-class"])
      ]);
    };
  }
});
var FitsIconSelect = /* @__PURE__ */ _export_sfc$2(_sfc_main$y, [["__scopeId", "data-v-e3391d3e"]]);
const _hoisted_1$l = { class: "checkboxAll" };
const _hoisted_2$b = /* @__PURE__ */ createTextVNode(" \u5168\u9009 ");
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "FitsCheckboxAll",
  props: {
    options: { default: () => new FitsCheckboxAllModel() }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit }) {
    const props = __props;
    const { option, checkboxGroup } = toRefs$1(props.options);
    const state = reactive$1({
      checkAll: false,
      isIndeterminate: true,
      checkedValue: []
    });
    const { checkAll, isIndeterminate, checkedValue } = toRefs$1(state);
    const _attrs = useAttrs$1();
    watch$1(() => _attrs.modelValue, () => {
      checkedValue.value = _attrs.modelValue;
    });
    watch$1(checkedValue, (val2) => {
      if (val2 === void 0)
        return;
      checkAll.value = (val2 == null ? void 0 : val2.length) === option.value.length;
      isIndeterminate.value = (val2 == null ? void 0 : val2.length) < option.value.length && val2.length > 0;
    });
    onMounted$1(() => {
      if (!_attrs.modelValue)
        return;
      checkedValue.value = _attrs.modelValue;
    });
    function handleCheckAllChange(val2) {
      checkedValue.value = [];
      if (val2) {
        option.value.map((item) => checkedValue.value.push(item.label));
      }
      emit("update:modelValue", [...checkedValue.value]);
    }
    function handleCheckedChange(val2) {
      checkAll.value = val2.length === option.value.length;
      emit("update:modelValue", [...checkedValue.value]);
    }
    return (_ctx, _cache) => {
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createVNode(_component_el_checkbox, {
          modelValue: unref$1(checkAll),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(checkAll) ? checkAll.value = $event : null),
          indeterminate: unref$1(isIndeterminate),
          onChange: handleCheckAllChange
        }, {
          default: withCtx(() => [
            _hoisted_2$b
          ]),
          _: 1
        }, 8, ["modelValue", "indeterminate"]),
        createVNode(_component_el_checkbox_group, mergeProps$1({
          modelValue: unref$1(checkedValue),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(checkedValue) ? checkedValue.value = $event : null),
          onChange: handleCheckedChange
        }, unref$1(checkboxGroup)), {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref$1(option), (item) => {
              return openBlock(), createBlock(_component_el_checkbox, mergeProps$1({
                key: item.label
              }, item), {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(item.label), 1)
                ]),
                _: 2
              }, 1040);
            }), 128))
          ]),
          _: 1
        }, 16, ["modelValue"])
      ]);
    };
  }
});
/*!
 * @form-create/element-ui v3.1.15
 * (c) 2018-2022 xaboy
 * Github https://github.com/xaboy/form-create
 * Released under the MIT License.
 */
function ownKeys$a(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i2 = 0, arr2 = new Array(len2); i2 < len2; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function getSlot(slots, exclude) {
  return Object.keys(slots).reduce(function(lst, name2) {
    if (!exclude || exclude.indexOf(name2) === -1) {
      lst.push(slots[name2]);
    }
    return lst;
  }, []);
}
var NAME$9 = "fcCheckbox";
var Checkbox$1 = defineComponent({
  name: NAME$9,
  inheritAttrs: false,
  props: {
    formCreateInject: Object,
    modelValue: {
      type: Array,
      "default": function _default() {
        return [];
      }
    },
    type: String
  },
  emits: ["update:modelValue"],
  setup: function setup2(props, _2) {
    var options = toRef(props.formCreateInject, "options", []);
    var value = toRef(props, "modelValue");
    var _options = function _options2() {
      return Array.isArray(options.value) ? options.value : [];
    };
    return {
      options: _options,
      value,
      onInput: function onInput(n2) {
        _2.emit("update:modelValue", n2);
      }
    };
  },
  render: function render2() {
    var _this$$slots$default, _this$$slots, _this = this;
    var name2 = this.type === "button" ? "ElCheckboxButton" : "ElCheckbox";
    var Type = resolveComponent(name2);
    return createVNode(resolveComponent("ElCheckboxGroup"), mergeProps$1(this.$attrs, {
      "modelValue": this.value,
      "onUpdate:modelValue": this.onInput
    }), _objectSpread2({
      "default": function _default15() {
        return [_this.options().map(function(opt, index) {
          var props = _objectSpread2({}, opt);
          var value = props.value;
          delete props.value;
          return createVNode(Type, mergeProps$1(props, {
            "label": value,
            "key": name2 + index + "-" + opt.value
          }), {
            "default": function _default16() {
              return [props.label || props.value || ""];
            }
          });
        }), (_this$$slots$default = (_this$$slots = _this.$slots)["default"]) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)];
      }
    }, getSlot(this.$slots, ["default"])));
  }
});
function toArray$5(value) {
  return Array.isArray(value) ? value : [null, void 0, ""].indexOf(value) > -1 ? [] : [value];
}
function Mitt(all) {
  all = all || /* @__PURE__ */ new Map();
  var mitt2 = {
    $on: function $on(type2, handler3) {
      var handlers = all.get(type2);
      var added = handlers && handlers.push(handler3);
      if (!added) {
        all.set(type2, [handler3]);
      }
    },
    $once: function $once(type2, handler3) {
      handler3._once = true;
      mitt2.$on(type2, handler3);
    },
    $off: function $off(type2, handler3) {
      var handlers = all.get(type2);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler3) >>> 0, 1);
      }
    },
    $emit: function $emit(type2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      (all.get(type2) || []).slice().map(function(handler3) {
        if (handler3._once) {
          mitt2.$off(type2, handler3);
          delete handler3._once;
        }
        handler3.apply(void 0, args);
      });
      (all.get("*") || []).slice().map(function(handler3) {
        handler3(type2, args);
      });
    }
  };
  return mitt2;
}
function styleInject(css2, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css_248z$2 = "._fc-frame ._fc-files img{display:inline-block;height:100%;vertical-align:top;width:100%}._fc-frame ._fc-upload-btn{border:1px dashed #c0ccda;cursor:pointer}._fc-frame ._fc-upload-cover{background:rgba(0,0,0,.6);bottom:0;left:0;opacity:0;position:absolute;right:0;top:0;-webkit-transition:opacity .3s;-o-transition:opacity .3s;transition:opacity .3s}._fc-frame ._fc-upload-cover i{color:#fff;cursor:pointer;font-size:20px;margin:0 2px}._fc-frame ._fc-files:hover ._fc-upload-cover{opacity:1}._fc-frame .el-upload{display:block}._fc-frame ._fc-upload-icon{cursor:pointer}._fc-files,._fc-frame ._fc-upload-btn{background:#fff;border:1px solid #c0ccda;border-radius:4px;-webkit-box-shadow:2px 2px 5px rgba(0,0,0,.1);box-shadow:2px 2px 5px rgba(0,0,0,.1);-webkit-box-sizing:border-box;box-sizing:border-box;display:inline-block;height:58px;line-height:58px;margin-right:4px;overflow:hidden;position:relative;text-align:center;width:58px}";
styleInject(css_248z$2);
var script$8 = {
  name: "IconCircleClose"
};
var _hoisted_1$8$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$8$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M466.752 512l-90.496-90.496a32 32 0 0145.248-45.248L512 466.752l90.496-90.496a32 32 0 1145.248 45.248L557.248 512l90.496 90.496a32 32 0 11-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 01-45.248-45.248L466.752 512z"
}, null, -1);
var _hoisted_3$8 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
var _hoisted_4$2 = [_hoisted_2$8$1, _hoisted_3$8];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8$1, _hoisted_4$2);
}
script$8.render = render$8;
var script$7 = {
  name: "IconDocument"
};
var _hoisted_1$7$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$7$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 01-32 32H160a32 32 0 01-32-32V96a32 32 0 0132-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1);
var _hoisted_3$7 = [_hoisted_2$7$1];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$7$1, _hoisted_3$7);
}
script$7.render = render$7;
var script$6 = {
  name: "IconDelete"
};
var _hoisted_1$6$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$6$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 256H96a32 32 0 010-64h256V95.936a32 32 0 0132-32h256a32 32 0 0132 32V192h256a32 32 0 110 64h-64v672a32 32 0 01-32 32H192a32 32 0 01-32-32V256zm448-64v-64H416v64h192zM224 896h576V256H224v640zm192-128a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32zm192 0a32 32 0 01-32-32V416a32 32 0 0164 0v320a32 32 0 01-32 32z"
}, null, -1);
var _hoisted_3$6 = [_hoisted_2$6$1];
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6$1, _hoisted_3$6);
}
script$6.render = render$6;
var script$5 = {
  name: "IconView"
};
var _hoisted_1$5$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$5$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 110 448 224 224 0 010-448zm0 64a160.192 160.192 0 00-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1);
var _hoisted_3$5 = [_hoisted_2$5$1];
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5$1, _hoisted_3$5);
}
script$5.render = render$5;
var script$4 = {
  name: "IconFolderOpened"
};
var _hoisted_1$4$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$4$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M878.08 448H241.92l-96 384h636.16l96-384zM832 384v-64H485.76L357.504 192H128v448l57.92-231.744A32 32 0 01216.96 384H832zm-24.96 512H96a32 32 0 01-32-32V160a32 32 0 0132-32h287.872l128.384 128H864a32 32 0 0132 32v96h23.04a32 32 0 0131.04 39.744l-112 448A32 32 0 01807.04 896z"
}, null, -1);
var _hoisted_3$4 = [_hoisted_2$4$1];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4$1, _hoisted_3$4);
}
script$4.render = render$4;
function _isSlot$1(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var NAME$8 = "fcFrame";
var Frame = defineComponent({
  name: NAME$8,
  props: {
    type: {
      type: String,
      "default": "input"
    },
    field: String,
    helper: {
      type: Boolean,
      "default": true
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    src: {
      type: String,
      required: true
    },
    icon: {
      type: String,
      "default": "IconFolderOpened"
    },
    width: {
      type: String,
      "default": "500px"
    },
    height: {
      type: String,
      "default": "370px"
    },
    maxLength: {
      type: Number,
      "default": 0
    },
    okBtnText: {
      type: String,
      "default": "\u786E\u5B9A"
    },
    closeBtnText: {
      type: String,
      "default": "\u5173\u95ED"
    },
    modalTitle: String,
    handleIcon: {
      type: [String, Boolean],
      "default": void 0
    },
    title: String,
    allowRemove: {
      type: Boolean,
      "default": true
    },
    onOpen: {
      type: Function,
      "default": function _default2() {
      }
    },
    onOk: {
      type: Function,
      "default": function _default3() {
      }
    },
    onCancel: {
      type: Function,
      "default": function _default4() {
      }
    },
    onLoad: {
      type: Function,
      "default": function _default5() {
      }
    },
    onBeforeRemove: {
      type: Function,
      "default": function _default6() {
      }
    },
    onRemove: {
      type: Function,
      "default": function _default7() {
      }
    },
    onHandle: Function,
    modal: {
      type: Object,
      "default": function _default8() {
        return {};
      }
    },
    srcKey: [String, Number],
    modelValue: [Array, String, Number, Object],
    previewMask: void 0,
    footer: {
      type: Boolean,
      "default": true
    },
    reload: {
      type: Boolean,
      "default": true
    },
    closeBtn: {
      type: Boolean,
      "default": true
    },
    okBtn: {
      type: Boolean,
      "default": true
    },
    formCreateInject: Object
  },
  emits: ["update:modelValue", "change"],
  components: {
    IconFolderOpened: script$4,
    IconView: script$5
  },
  data: function data() {
    return {
      fileList: toArray$5(this.modelValue),
      previewVisible: false,
      frameVisible: false,
      previewImage: "",
      bus: new Mitt()
    };
  },
  watch: {
    modelValue: function modelValue(n2) {
      this.fileList = toArray$5(n2);
    }
  },
  methods: {
    close: function close() {
      this.closeModel(true);
    },
    closeModel: function closeModel(close2) {
      this.bus.$emit(close2 ? "$close" : "$ok");
      if (this.reload) {
        this.bus.$off("$ok");
        this.bus.$off("$close");
      }
      this.frameVisible = false;
    },
    handleCancel: function handleCancel() {
      this.previewVisible = false;
    },
    showModel: function showModel() {
      if (this.disabled || false === this.onOpen()) {
        return;
      }
      this.frameVisible = true;
    },
    input: function input2() {
      var n2 = this.fileList;
      var val2 = this.maxLength === 1 ? n2[0] || "" : n2;
      this.$emit("update:modelValue", val2);
      this.$emit("change", val2);
    },
    makeInput: function makeInput() {
      var _this = this;
      return createVNode(resolveComponent("ElInput"), mergeProps$1({
        type: "text",
        modelValue: this.fileList.map(function(v2) {
          return _this.getSrc(v2);
        }).toString(),
        readonly: true
      }, {
        "key": 1
      }), {
        append: function append2() {
          return createVNode(resolveComponent("ElButton"), {
            "icon": resolveComponent(_this.icon),
            "onClick": function onClick() {
              return _this.showModel();
            }
          }, null);
        },
        suffix: function suffix() {
          return _this.fileList.length ? createVNode(resolveComponent("ElIcon"), {
            "class": "el-input__icon _fc-upload-icon",
            "onClick": function onClick() {
              _this.fileList = [];
              _this.input();
            }
          }, {
            "default": function _default15() {
              return [createVNode(script$8, null, null)];
            }
          }) : null;
        }
      });
    },
    makeGroup: function makeGroup(children2) {
      if (!this.maxLength || this.fileList.length < this.maxLength) {
        children2.push(this.makeBtn());
      }
      return createVNode("div", {
        "key": 2
      }, [children2]);
    },
    makeItem: function makeItem(index, children2) {
      return createVNode("div", {
        "class": "_fc-files",
        "key": "3" + index
      }, [children2]);
    },
    valid: function valid(f2) {
      var field = this.formCreateInject.field || this.field;
      if (field && f2 !== field) {
        throw new Error("[frame]\u65E0\u6548\u7684\u5B57\u6BB5\u503C");
      }
    },
    makeIcons: function makeIcons(val2, index) {
      if (this.handleIcon !== false || this.allowRemove === true) {
        var icons = [];
        if (this.type !== "file" && this.handleIcon !== false || this.type === "file" && this.handleIcon) {
          icons.push(this.makeHandleIcon(val2, index));
        }
        if (this.allowRemove) {
          icons.push(this.makeRemoveIcon(val2, index));
        }
        return createVNode("div", {
          "class": "_fc-upload-cover",
          "key": 4
        }, [icons]);
      }
    },
    makeHandleIcon: function makeHandleIcon(val2, index) {
      var _this2 = this;
      var Type = resolveComponent(this.handleIcon === true || this.handleIcon === void 0 ? "icon-view" : this.handleIcon);
      return createVNode(resolveComponent("ElIcon"), {
        "onClick": function onClick() {
          return _this2.handleClick(val2);
        },
        "key": "5" + index
      }, {
        "default": function _default15() {
          return [createVNode(Type, null, null)];
        }
      });
    },
    makeRemoveIcon: function makeRemoveIcon(val2, index) {
      var _this3 = this;
      return createVNode(resolveComponent("ElIcon"), {
        "onClick": function onClick() {
          return _this3.handleRemove(val2);
        },
        "key": "6" + index
      }, {
        "default": function _default15() {
          return [createVNode(script$6, null, null)];
        }
      });
    },
    makeFiles: function makeFiles() {
      var _this4 = this;
      return this.makeGroup(this.fileList.map(function(src, index) {
        return _this4.makeItem(index, [createVNode(resolveComponent("ElIcon"), {
          "onClick": function onClick() {
            return _this4.handleClick(src);
          }
        }, {
          "default": function _default15() {
            return [createVNode(script$7, null, null)];
          }
        }), _this4.makeIcons(src, index)]);
      }));
    },
    makeImages: function makeImages() {
      var _this5 = this;
      return this.makeGroup(this.fileList.map(function(src, index) {
        return _this5.makeItem(index, [createVNode("img", {
          "src": _this5.getSrc(src)
        }, null), _this5.makeIcons(src, index)]);
      }));
    },
    makeBtn: function makeBtn() {
      var _this6 = this;
      var Type = resolveComponent(this.icon);
      return createVNode("div", {
        "class": "_fc-upload-btn",
        "onClick": function onClick() {
          return _this6.showModel();
        },
        "key": 7
      }, [createVNode(resolveComponent("ElIcon"), null, {
        "default": function _default15() {
          return [createVNode(Type, null, null)];
        }
      })]);
    },
    handleClick: function handleClick(src) {
      if (this.onHandle) {
        return this.onHandle(src);
      } else {
        this.previewImage = this.getSrc(src);
        this.previewVisible = true;
      }
    },
    handleRemove: function handleRemove(src) {
      if (this.disabled) {
        return;
      }
      if (false !== this.onBeforeRemove(src)) {
        this.fileList.splice(this.fileList.indexOf(src), 1);
        this.input();
        this.onRemove(src);
      }
    },
    getSrc: function getSrc(src) {
      return !this.srcKey ? src : src[this.srcKey];
    },
    frameLoad: function frameLoad(iframe) {
      var _this7 = this;
      this.onLoad(iframe);
      try {
        if (this.helper === true) {
          iframe["form_create_helper"] = {
            api: this.formCreateInject.api,
            close: function close2(field) {
              _this7.valid(field);
              _this7.closeModel();
            },
            set: function set2(field, value) {
              _this7.valid(field);
              !_this7.disabled && _this7.$emit("update:modelValue", value);
            },
            get: function get3(field) {
              _this7.valid(field);
              return _this7.modelValue;
            },
            onOk: function onOk(fn2) {
              return _this7.bus.$on("$ok", fn2);
            },
            onClose: function onClose(fn2) {
              return _this7.bus.$on("$close", fn2);
            }
          };
        }
      } catch (e3) {
        console.error(e3);
      }
    },
    makeFooter: function makeFooter() {
      var _this8 = this;
      var _this$$props = this.$props, okBtnText = _this$$props.okBtnText, closeBtnText = _this$$props.closeBtnText, closeBtn = _this$$props.closeBtn, okBtn = _this$$props.okBtn, footer = _this$$props.footer;
      if (!footer) {
        return;
      }
      return createVNode("div", null, [closeBtn ? createVNode(resolveComponent("ElButton"), {
        "onClick": function onClick() {
          return _this8.onCancel() !== false && (_this8.frameVisible = false);
        }
      }, _isSlot$1(closeBtnText) ? closeBtnText : {
        "default": function _default15() {
          return [closeBtnText];
        }
      }) : null, okBtn ? createVNode(resolveComponent("ElButton"), {
        "type": "primary",
        "onClick": function onClick() {
          return _this8.onOk() !== false && _this8.closeModel();
        }
      }, _isSlot$1(okBtnText) ? okBtnText : {
        "default": function _default15() {
          return [okBtnText];
        }
      }) : null]);
    }
  },
  render: function render3() {
    var _this9 = this;
    var type2 = this.type;
    var node;
    if (type2 === "input") {
      node = this.makeInput();
    } else if (type2 === "image") {
      node = this.makeImages();
    } else {
      node = this.makeFiles();
    }
    var _this$$props2 = this.$props, _this$$props2$width = _this$$props2.width, width2 = _this$$props2$width === void 0 ? "30%" : _this$$props2$width, height2 = _this$$props2.height, src = _this$$props2.src, title = _this$$props2.title, modalTitle = _this$$props2.modalTitle;
    nextTick$1(function() {
      if (_this9.$refs.frame) {
        _this9.frameLoad(_this9.$refs.frame.contentWindow || {});
      }
    });
    return createVNode("div", {
      "class": "_fc-frame"
    }, [node, createVNode(resolveComponent("ElDialog"), {
      "appendToBody": true,
      "modal": this.previewMask,
      "title": modalTitle,
      "modelValue": this.previewVisible,
      "onClose": this.handleCancel
    }, {
      "default": function _default15() {
        return [createVNode("img", {
          "style": "width: 100%",
          "src": _this9.previewImage
        }, null)];
      }
    }), createVNode(resolveComponent("ElDialog"), mergeProps$1({
      "appendToBody": true
    }, _objectSpread2({
      width: width2,
      title
    }, this.modal), {
      "modelValue": this.frameVisible,
      "onClose": function onClose() {
        return _this9.closeModel(true);
      }
    }), {
      "default": function _default15() {
        return [_this9.frameVisible || !_this9.reload ? createVNode("iframe", {
          "ref": "frame",
          "src": src,
          "frameBorder": "0",
          "style": {
            height: height2,
            "border": "0 none",
            "width": "100%"
          }
        }, null) : null];
      },
      footer: function footer() {
        return _this9.makeFooter();
      }
    })]);
  },
  beforeMount: function beforeMount() {
    var _this$formCreateInjec = this.formCreateInject, name2 = _this$formCreateInjec.name, field = _this$formCreateInjec.field, api = _this$formCreateInjec.api;
    name2 && api.on("fc:closeModal:" + name2, this.close);
    field && api.on("fc:closeModal:" + field, this.close);
  },
  beforeUnmount: function beforeUnmount() {
    var _this$formCreateInjec2 = this.formCreateInject, name2 = _this$formCreateInjec2.name, field = _this$formCreateInjec2.field, api = _this$formCreateInjec2.api;
    name2 && api.off("fc:closeModal:" + name2, this.close);
    field && api.off("fc:closeModal:" + field, this.close);
  }
});
var NAME$7 = "fcRadio";
var Radio = defineComponent({
  name: NAME$7,
  inheritAttrs: false,
  props: {
    formCreateInject: Object,
    modelValue: {
      type: [String, Number, Boolean],
      "default": ""
    },
    type: String
  },
  emits: ["update:modelValue"],
  setup: function setup3(props, _2) {
    var options = toRef(props.formCreateInject, "options", []);
    var value = toRef(props, "modelValue");
    var _options = function _options2() {
      return Array.isArray(options.value) ? options.value : [];
    };
    return {
      options: _options,
      value,
      onInput: function onInput(n2) {
        _2.emit("update:modelValue", n2);
      }
    };
  },
  render: function render4() {
    var _this$$slots$default, _this$$slots, _this = this;
    var name2 = this.type === "button" ? "ElRadioButton" : "ElRadio";
    var Type = resolveComponent(name2);
    return createVNode(resolveComponent("ElRadioGroup"), mergeProps$1(this.$attrs, {
      "modelValue": this.value,
      "onUpdate:modelValue": this.onInput
    }), _objectSpread2({
      "default": function _default15() {
        return [_this.options().map(function(opt, index) {
          var props = _objectSpread2({}, opt);
          var value = props.value;
          delete props.value;
          return createVNode(Type, mergeProps$1(props, {
            "label": value,
            "key": name2 + index + "-" + opt.value
          }), {
            "default": function _default16() {
              return [props.label || props.value || ""];
            }
          });
        }), (_this$$slots$default = (_this$$slots = _this.$slots)["default"]) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)];
      }
    }, getSlot(this.$slots, ["default"])));
  }
});
var NAME$6 = "fcSelect";
var Select = defineComponent({
  name: NAME$6,
  inheritAttrs: false,
  props: {
    formCreateInject: Object,
    modelValue: {
      type: [Array, String, Number, Boolean, Object],
      "default": void 0
    },
    type: String
  },
  emits: ["update:modelValue"],
  setup: function setup4(props) {
    var options = toRef(props.formCreateInject, "options", []);
    var value = toRef(props, "modelValue");
    var _options = function _options2() {
      return Array.isArray(options.value) ? options.value : [];
    };
    return {
      options: _options,
      value
    };
  },
  render: function render5() {
    var _this = this, _this$$slots$default, _this$$slots;
    return createVNode(resolveComponent("ElSelect"), mergeProps$1(this.$attrs, {
      "modelValue": this.value,
      "onUpdate:modelValue": function onUpdateModelValue(v2) {
        return _this.$emit("update:modelValue", v2);
      }
    }), _objectSpread2({
      "default": function _default15() {
        return [_this.options().map(function(props, index) {
          return createVNode(resolveComponent("ElOption"), mergeProps$1(props, {
            "key": "" + index + "-" + props.value
          }), null);
        }), (_this$$slots$default = (_this$$slots = _this.$slots)["default"]) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)];
      }
    }, getSlot(this.$slots, ["default"])));
  }
});
var NAME$5 = "fcTree";
var Tree$1 = defineComponent({
  name: NAME$5,
  inheritAttrs: false,
  formCreateParser: {
    mergeProp: function mergeProp(ctx) {
      var props = ctx.prop.props;
      if (!props.nodeKey)
        props.nodeKey = "id";
      if (!props.props)
        props.props = {
          label: "title"
        };
    }
  },
  props: {
    type: String,
    modelValue: {
      type: [Array, String, Number],
      "default": function _default9() {
        return [];
      }
    }
  },
  emits: ["update:modelValue"],
  watch: {
    modelValue: function modelValue2() {
      this.setValue();
    }
  },
  methods: {
    updateValue: function updateValue() {
      if (!this.$refs.tree)
        return;
      var value;
      if (this.type === "selected") {
        value = this.$refs.tree.getCurrentKey();
      } else {
        value = this.$refs.tree.getCheckedKeys();
      }
      this.$emit("update:modelValue", value);
    },
    setValue: function setValue() {
      if (!this.$refs.tree)
        return;
      var type2 = this.type;
      if (type2 === "selected") {
        this.$refs.tree.setCurrentKey(this.modelValue);
      } else {
        this.$refs.tree.setCheckedKeys(toArray$5(this.modelValue));
      }
    }
  },
  render: function render6() {
    return createVNode(resolveComponent("ElTree"), mergeProps$1(this.$attrs, {
      "ref": "tree",
      "onCheck": this.updateValue,
      "onNode-click": this.updateValue
    }), this.$slots);
  },
  mounted: function mounted() {
    this.setValue();
  }
});
var css_248z$1 = "._fc-exceed .el-upload{display:none}";
styleInject(css_248z$1);
var script$3 = {
  name: "IconUpload"
};
var _hoisted_1$3$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$3$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M160 832h704a32 32 0 110 64H160a32 32 0 110-64zm384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248L544 253.696z"
}, null, -1);
var _hoisted_3$3$1 = [_hoisted_2$3$1];
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3$1, _hoisted_3$3$1);
}
script$3.render = render$3;
function parseFile$1(file, i2) {
  return {
    url: file,
    name: getFileName$1(file),
    uid: i2
  };
}
function getFileName$1(file) {
  return ("" + file).split("/").pop();
}
var NAME$4 = "fcUpload";
var Upload = defineComponent({
  name: NAME$4,
  inheritAttrs: false,
  props: {
    previewMask: void 0,
    modalTitle: String,
    modelValue: [Array, String]
  },
  emits: ["update:modelValue", "change", "remove"],
  data: function data2() {
    return {
      previewVisible: false,
      previewImage: "",
      fileList: []
    };
  },
  created: function created() {
    this.fileList = toArray$5(this.modelValue).map(parseFile$1);
  },
  watch: {
    modelValue: function modelValue3(n2) {
      this.fileList = toArray$5(n2).map(parseFile$1);
    },
    limit: function limit(n2, o2) {
      if (o2 === 1 || n2 === 1) {
        this.update();
      }
    }
  },
  methods: {
    handlePreview: function handlePreview(file) {
      if (this.onPreview) {
        this.onPreview.apply(this, arguments);
      } else {
        this.previewImage = file.url;
        this.previewVisible = true;
      }
    },
    update: function update(fileList) {
      var files = fileList.map(function(file) {
        return file.url;
      }).filter(function(url) {
        return url !== void 0;
      });
      this.$emit("update:modelValue", this.limit === 1 ? files[0] || "" : files);
    },
    handleCancel: function handleCancel2() {
      this.previewVisible = false;
    },
    handleChange: function handleChange(file, fileList) {
      this.$emit.apply(this, ["change"].concat(Array.prototype.slice.call(arguments)));
      if (file.status === "success") {
        this.update(fileList);
      }
    },
    handleRemove: function handleRemove2(file, fileList) {
      this.$emit.apply(this, ["remove"].concat(Array.prototype.slice.call(arguments)));
      this.update(fileList);
    }
  },
  render: function render7() {
    var _this$$slots$default, _this$$slots, _this = this;
    return createVNode(Fragment, null, [createVNode(resolveComponent("ElUpload"), mergeProps$1({
      "key": this.modelValue.length,
      "list-type": "picture-card"
    }, this.$attrs, {
      "class": {
        "_fc-exceed": this.$attrs.limit ? this.$attrs.limit <= this.modelValue.length : false
      },
      "onPreview": this.handlePreview,
      "onChange": this.handleChange,
      "onRemove": this.handleRemove,
      "fileList": this.fileList
    }), _objectSpread2({
      "default": function _default15() {
        return [((_this$$slots$default = (_this$$slots = _this.$slots)["default"]) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)) || createVNode(resolveComponent("ElIcon"), null, {
          "default": function _default16() {
            return [createVNode(script$3, null, null)];
          }
        })];
      }
    }, getSlot(this.$slots, ["default"]))), createVNode(resolveComponent("ElDialog"), {
      "appendToBody": true,
      "modal": this.previewMask,
      "title": this.modalTitle,
      "modelValue": this.previewVisible,
      "onClose": this.handleCancel
    }, {
      "default": function _default15() {
        return [createVNode("img", {
          "style": "width: 100%",
          "src": _this.previewImage
        }, null)];
      }
    })]);
  }
});
var is$3 = {
  type: function type(arg, _type) {
    return Object.prototype.toString.call(arg) === "[object " + _type + "]";
  },
  Undef: function Undef(v2) {
    return v2 === void 0 || v2 === null;
  },
  Element: function Element2(arg) {
    return _typeof(arg) === "object" && arg !== null && arg.nodeType === 1 && !is$3.Object(arg);
  },
  trueArray: function trueArray(data5) {
    return Array.isArray(data5) && data5.length > 0;
  },
  Function: function Function2(v2) {
    var type2 = this.getType(v2);
    return type2 === "Function" || type2 === "AsyncFunction";
  },
  getType: function getType2(v2) {
    var str = Object.prototype.toString.call(v2);
    return /^\[object (.*)\]$/.exec(str)[1];
  },
  empty: function empty2(value) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (Array.isArray(value) && Array.isArray(value) && !value.length) {
      return true;
    }
    return typeof value === "string" && !value;
  }
};
["Date", "Object", "String", "Boolean", "Array", "Number"].forEach(function(t2) {
  is$3[t2] = function(arg) {
    return is$3.type(arg, t2);
  };
});
function hasProperty$1(rule2, k2) {
  return {}.hasOwnProperty.call(rule2, k2);
}
var script$2 = {
  name: "IconCirclePlus"
};
var _hoisted_1$2$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$2$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 110 64H352a32 32 0 010-64z"
}, null, -1);
var _hoisted_3$2$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M480 672V352a32 32 0 1164 0v320a32 32 0 01-64 0z"
}, null, -1);
var _hoisted_4$1$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
var _hoisted_5$1 = [_hoisted_2$2$1, _hoisted_3$2$1, _hoisted_4$1$1];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2$1, _hoisted_5$1);
}
script$2.render = render$2;
var script$1 = {
  name: "IconRemove"
};
var _hoisted_1$1$1 = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$1$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M352 480h320a32 32 0 110 64H352a32 32 0 010-64z"
}, null, -1);
var _hoisted_3$1$1 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 100-768 384 384 0 000 768zm0 64a448 448 0 110-896 448 448 0 010 896z"
}, null, -1);
var _hoisted_4$3 = [_hoisted_2$1$1, _hoisted_3$1$1];
function render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$1, _hoisted_4$3);
}
script$1.render = render$1$1;
function $set(target, field, value) {
  target[field] = value;
}
function $del(target, field) {
  delete target[field];
}
function deepExtend(origin) {
  var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var mode = arguments.length > 2 ? arguments[2] : void 0;
  var isArr = false;
  for (var key in target) {
    if (Object.prototype.hasOwnProperty.call(target, key)) {
      var clone2 = target[key];
      if ((isArr = Array.isArray(clone2)) || is$3.Object(clone2)) {
        var nst = origin[key] === void 0;
        if (isArr) {
          isArr = false;
          nst && $set(origin, key, []);
        } else if (clone2._clone && mode !== void 0) {
          if (mode) {
            clone2 = clone2.getRule();
            nst && $set(origin, key, {});
          } else {
            $set(origin, key, clone2._clone());
            continue;
          }
        } else {
          nst && $set(origin, key, {});
        }
        origin[key] = deepExtend(origin[key], clone2, mode);
      } else {
        $set(origin, key, clone2);
        if (!is$3.Undef(clone2)) {
          if (!is$3.Undef(clone2.__json)) {
            origin[key].__json = clone2.__json;
          }
          if (!is$3.Undef(clone2.__origin)) {
            origin[key].__origin = clone2.__origin;
          }
        }
      }
    }
  }
  return mode !== void 0 && Array.isArray(origin) ? origin.filter(function(v2) {
    return !v2 || !v2.__ctrl;
  }) : origin;
}
function deepCopy(value) {
  return deepExtend({}, {
    value
  }).value;
}
var _extends = Object.assign || function(a2) {
  for (var b2, c2 = 1; c2 < arguments.length; c2++) {
    for (var d3 in b2 = arguments[c2], b2) {
      Object.prototype.hasOwnProperty.call(b2, d3) && $set(a2, d3, b2[d3]);
    }
  }
  return a2;
};
function extend$2() {
  return _extends.apply(this, arguments);
}
function _isSlot(s2) {
  return typeof s2 === "function" || Object.prototype.toString.call(s2) === "[object Object]" && !isVNode(s2);
}
var NAME$3 = "fcGroup";
var Group$4 = defineComponent({
  name: NAME$3,
  props: {
    field: String,
    rule: Array,
    expand: Number,
    options: Object,
    button: {
      type: Boolean,
      "default": true
    },
    max: {
      type: Number,
      "default": 0
    },
    min: {
      type: Number,
      "default": 0
    },
    modelValue: {
      type: Array,
      "default": function _default10() {
        return [];
      }
    },
    defaultValue: Object,
    disabled: {
      type: Boolean,
      "default": false
    },
    syncDisabled: {
      type: Boolean,
      "default": true
    },
    fontSize: {
      type: Number,
      "default": 28
    },
    onBeforeRemove: {
      type: Function,
      "default": function _default11() {
      }
    },
    onBeforeAdd: {
      type: Function,
      "default": function _default12() {
      }
    },
    formCreateInject: Object
  },
  data: function data3() {
    return {
      len: 0,
      cacheRule: {},
      cacheValue: {},
      form: markRaw(this.formCreateInject.form.$form())
    };
  },
  emits: ["update:modelValue", "change", "itemMounted", "remove", "add"],
  watch: {
    rule: {
      handler: function handler(n2, o2) {
        var _this = this;
        Object.keys(this.cacheRule).forEach(function(v2) {
          var item = _this.cacheRule[v2];
          if (item.$f) {
            var val2 = item.$f.formData();
            if (n2 === o2) {
              item.$f.deferSyncValue(function() {
                deepExtend(item.rule, n2);
                item.$f.setValue(val2);
              }, true);
            } else {
              var _val = item.$f.formData();
              item.$f.once("reloading", function() {
                item.$f.setValue(_val);
              });
              item.rule = deepCopy(n2);
            }
          }
        });
      },
      deep: true
    },
    disabled: function disabled(n2) {
      if (this.syncDisabled) {
        var lst = this.cacheRule;
        Object.keys(lst).forEach(function(k2) {
          lst[k2].$f.disabled(n2);
        });
      }
    },
    expand: function expand(n2) {
      var d3 = n2 - this.modelValue.length;
      if (d3 > 0) {
        this.expandRule(d3);
      }
    },
    modelValue: {
      handler: function handler2(n2) {
        var _this2 = this;
        n2 = n2 || [];
        var keys2 = Object.keys(this.cacheRule), total = keys2.length, len2 = total - n2.length;
        if (len2 < 0) {
          for (var i2 = len2; i2 < 0; i2++) {
            this.addRule(n2.length + i2, true);
          }
          for (var _i2 = 0; _i2 < total; _i2++) {
            this.setValue(keys2[_i2], n2[_i2]);
          }
        } else {
          if (len2 > 0) {
            for (var _i22 = 0; _i22 < len2; _i22++) {
              this.removeRule(keys2[total - _i22 - 1]);
            }
          }
          n2.forEach(function(val2, i3) {
            _this2.setValue(keys2[i3], n2[i3]);
          });
        }
      },
      deep: true
    }
  },
  methods: {
    _value: function _value(v2) {
      return v2 && hasProperty$1(v2, this.field) ? v2[this.field] : v2;
    },
    cache: function cache(k2, val2) {
      this.cacheValue[k2] = JSON.stringify(val2);
    },
    input: function input3(value) {
      this.$emit("update:modelValue", value);
      this.$emit("change", value);
    },
    formData: function formData(key, _formData) {
      var _this3 = this;
      var cacheRule = this.cacheRule;
      var keys2 = Object.keys(cacheRule);
      if (keys2.filter(function(k2) {
        return cacheRule[k2].$f;
      }).length !== keys2.length) {
        return;
      }
      var value = keys2.map(function(k2) {
        var data5 = key === k2 ? _formData : _objectSpread2({}, _this3.cacheRule[k2].$f.form);
        var value2 = _this3.field ? data5[_this3.field] || null : data5;
        _this3.cache(k2, value2);
        return value2;
      });
      this.input(value);
    },
    setValue: function setValue2(key, value) {
      var field = this.field;
      if (field) {
        value = _defineProperty$1({}, field, this._value(value));
      }
      if (this.cacheValue[key] === JSON.stringify(field ? value[field] : value)) {
        return;
      }
      this.cache(key, value);
    },
    addRule: function addRule(i2, emit) {
      var _this4 = this;
      var rule2 = this.formCreateInject.form.copyRules(this.rule || []);
      var options = this.options ? _objectSpread2({}, this.options) : {
        submitBtn: false,
        resetBtn: false
      };
      if (this.defaultValue) {
        if (!options.formData)
          options.formData = {};
        var defVal = deepCopy(this.defaultValue);
        extend$2(options.formData, this.field ? _defineProperty$1({}, this.field, defVal) : defVal);
      }
      this.cacheRule[++this.len] = {
        rule: rule2,
        options
      };
      if (emit) {
        nextTick$1(function() {
          return _this4.$emit("add", rule2, Object.keys(_this4.cacheRule).length - 1);
        });
      }
    },
    add$f: function add$f(i2, key, $f2) {
      var _this5 = this;
      this.cacheRule[key].$f = $f2;
      this.formData(key, $f2.formData());
      nextTick$1(function() {
        if (_this5.syncDisabled) {
          $f2.disabled(_this5.disabled);
        }
        _this5.$emit("itemMounted", $f2, Object.keys(_this5.cacheRule).indexOf(key));
      });
    },
    removeRule: function removeRule(key, emit) {
      var _this6 = this;
      var index = Object.keys(this.cacheRule).indexOf(key);
      delete this.cacheRule[key];
      delete this.cacheValue[key];
      if (emit) {
        nextTick$1(function() {
          return _this6.$emit("remove", index);
        });
      }
    },
    add: function add2() {
      if (this.disabled || false === this.onBeforeAdd(this.modelValue)) {
        return;
      }
      this.modelValue.push(this.field ? null : {});
      this.$emit("update:modelValue", this.modelValue);
    },
    del: function del(index, key) {
      if (this.disabled || false === this.onBeforeRemove(this.modelValue, index)) {
        return;
      }
      this.removeRule(key, true);
      this.modelValue.splice(index, 1);
      this.input(this.modelValue);
    },
    addIcon: function addIcon(key) {
      return createVNode(resolveComponent("ElIcon"), {
        "key": "a".concat(key),
        "style": "font-size:".concat(this.fontSize, "px;cursor:").concat(this.disabled ? "not-allowed;color:#c9cdd4" : "pointer", ";"),
        "onClick": this.add
      }, {
        "default": function _default15() {
          return [createVNode(script$2, null, null)];
        }
      });
    },
    delIcon: function delIcon(index, key) {
      var _this7 = this;
      return createVNode(resolveComponent("ElIcon"), {
        "key": "d".concat(key),
        "class": "el-icon-remove-outline",
        "style": "font-size:".concat(this.fontSize, "px;cursor:").concat(this.disabled ? "not-allowed;color:#c9cdd4" : "pointer;color:#606266", ";"),
        "onClick": function onClick() {
          return _this7.del(index, key);
        }
      }, {
        "default": function _default15() {
          return [createVNode(script$1, null, null)];
        }
      });
    },
    makeIcon: function makeIcon(total, index, key) {
      var _this8 = this;
      if (this.$slots.button) {
        return this.$slots.button({
          total,
          index,
          vm: this,
          key,
          del: function del2() {
            return _this8.del(index, key);
          },
          add: this.add
        });
      }
      if (index === 0) {
        return [this.max !== 0 && total >= this.max ? null : this.addIcon(key), this.min === 0 || total > this.min ? this.delIcon(index, key) : null];
      }
      if (index >= this.min) {
        return this.delIcon(index, key);
      }
    },
    emitEvent: function emitEvent(name2, args, index, key) {
      this.$emit.apply(this, [name2].concat(_toConsumableArray(args), [this.cacheRule[key].$f, index]));
    },
    expandRule: function expandRule(n2) {
      for (var i2 = 0; i2 < n2; i2++) {
        this.modelValue.push(this.field ? null : {});
      }
    }
  },
  created: function created2() {
    var d3 = (this.expand || 0) - this.modelValue.length;
    for (var i2 = 0; i2 < this.modelValue.length; i2++) {
      this.addRule(i2);
    }
    if (d3 > 0) {
      this.expandRule(d3);
    }
  },
  render: function render8() {
    var _this9 = this;
    var keys2 = Object.keys(this.cacheRule);
    var button = this.button;
    var Type = this.form;
    return keys2.length === 0 ? this.$slots["default"] ? this.$slots["default"]({
      vm: this,
      add: this.add
    }) : createVNode(resolveComponent("ElIcon"), {
      "key": 1,
      "style": "font-size:".concat(this.fontSize, "px;vertical-align:middle;color:").concat(this.disabled ? "#c9cdd4;cursor: not-allowed" : "#606266;cursor:pointer", ";"),
      "onClick": this.add
    }, {
      "default": function _default15() {
        return [createVNode(script$2, null, null)];
      }
    }) : createVNode("div", {
      "key": 2
    }, [keys2.map(function(key, index) {
      var _slot;
      var _this9$cacheRule$key = _this9.cacheRule[key], rule2 = _this9$cacheRule$key.rule, options = _this9$cacheRule$key.options;
      return createVNode(resolveComponent("ElRow"), {
        "align": "middle",
        "type": "flex",
        "key": key,
        "style": "border-bottom:1px dashed #DCDFE6;margin-bottom:10px;"
      }, {
        "default": function _default15() {
          return [createVNode(resolveComponent("ElCol"), {
            "span": button ? 20 : 24
          }, {
            "default": function _default16() {
              return [createVNode(Type, {
                "key": key,
                "inFor": true,
                "onUpdate:modelValue": function onUpdateModelValue(formData3) {
                  return _this9.formData(key, formData3);
                },
                "modelValue": _this9.field ? _defineProperty$1({}, _this9.field, _this9._value(_this9.modelValue[index])) : _this9.modelValue[index],
                "onEmit-event": function onEmitEvent(name2) {
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  return _this9.emitEvent(name2, args, index, key);
                },
                "onUpdate:api": function onUpdateApi($f2) {
                  return _this9.add$f(index, key, $f2);
                },
                "rule": rule2,
                "option": options,
                "extendOption": true
              }, null)];
            }
          }), button ? createVNode(resolveComponent("ElCol"), {
            "span": 2,
            "pull": 1,
            "push": 1
          }, _isSlot(_slot = _this9.makeIcon(keys2.length, index, key)) ? _slot : {
            "default": function _default16() {
              return [_slot];
            }
          }) : null];
        }
      });
    })]);
  }
});
var NAME$2 = "fcSubForm";
var Sub = defineComponent({
  name: NAME$2,
  props: {
    rule: Array,
    options: {
      type: Object,
      "default": function _default13() {
        return reactive$1({
          submitBtn: false,
          resetBtn: false
        });
      }
    },
    modelValue: {
      type: Object,
      "default": function _default14() {
        return {};
      }
    },
    disabled: {
      type: Boolean,
      "default": false
    },
    syncDisabled: {
      type: Boolean,
      "default": true
    },
    formCreateInject: Object
  },
  data: function data4() {
    return {
      cacheValue: {},
      subApi: {},
      form: markRaw(this.formCreateInject.form.$form())
    };
  },
  emits: ["fc:subform", "update:modelValue", "change", "itemMounted"],
  watch: {
    disabled: function disabled2(n2) {
      this.syncDisabled && this.subApi.disabled(n2);
    },
    modelValue: function modelValue4(n2) {
      this.setValue(n2);
    }
  },
  methods: {
    formData: function formData2(value) {
      this.cacheValue = JSON.stringify(value);
      this.$emit("update:modelValue", value);
      this.$emit("change", value);
    },
    setValue: function setValue3(value) {
      var str = JSON.stringify(value);
      if (this.cacheValue === str) {
        return;
      }
      this.cacheValue = str;
      this.subApi.coverValue(value || {});
    },
    add$f: function add$f2(api) {
      var _this = this;
      this.subApi = api;
      nextTick$1(function() {
        _this.syncDisabled && api.disabled(_this.disabled);
        _this.$emit("itemMounted", api);
      });
    }
  },
  render: function render9() {
    var Type = this.form;
    return createVNode(Type, {
      "onUpdate:modelValue": this.formData,
      "modelValue": this.modelValue,
      "onEmit-event": this.$emit,
      "onUpdate:api": this.add$f,
      "rule": this.rule,
      "option": this.options,
      "extendOption": true
    }, null);
  }
});
var script = {
  name: "IconWarning"
};
var _hoisted_1$k = {
  "class": "icon",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
};
var _hoisted_2$a = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 110 896 448 448 0 010-896zm0 832a384 384 0 000-768 384 384 0 000 768zm48-176a48 48 0 11-96 0 48 48 0 0196 0zm-48-464a32 32 0 0132 32v288a32 32 0 01-64 0V288a32 32 0 0132-32z"
}, null, -1);
var _hoisted_3$9 = [_hoisted_2$a];
function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$9);
}
script.render = render$9;
var components = [Checkbox$1, Frame, Radio, Select, Tree$1, Upload, Group$4, Sub, script];
var NAME$1 = "FormCreate";
var getRuleInject = function getRuleInject2(vm, parent2) {
  if (!vm || vm === parent2) {
    return;
  }
  if (vm.ctx.formCreateInject) {
    return vm.ctx.formCreateInject;
  }
  if (vm.parent) {
    return getRuleInject2(vm.parent, parent2);
  }
};
function $FormCreate(FormCreate2) {
  return defineComponent({
    name: NAME$1,
    props: {
      rule: {
        type: Array,
        required: true,
        "default": function _default15() {
          return [];
        }
      },
      option: {
        type: Object,
        "default": function _default15() {
          return {};
        }
      },
      extendOption: Boolean,
      modelValue: Object,
      api: Object,
      name: String,
      subForm: {
        type: Boolean,
        "default": true
      },
      inFor: Boolean
    },
    emits: ["update:api", "update:modelValue", "mounted", "submit", "change", "emit-event", "control", "remove-rule", "remove-field", "sync", "reload", "repeat-field", "update"],
    render: function render17() {
      return this.fc.render();
    },
    setup: function setup5(props) {
      var vm = getCurrentInstance$1();
      provide("parentFC", vm);
      var parent2 = inject("parentFC", null);
      var _toRefs = toRefs$1(props), rule2 = _toRefs.rule, modelValue5 = _toRefs.modelValue, subForm = _toRefs.subForm, inFor = _toRefs.inFor;
      var data5 = reactive$1({
        ctxInject: {},
        destroyed: false,
        isShow: true,
        unique: 1,
        renderRule: _toConsumableArray(rule2.value || []),
        updateValue: JSON.stringify(modelValue5 || {})
      });
      var fc2 = new FormCreate2(vm);
      var fapi = fc2.api();
      var isMore = inFor.value;
      var addSubForm = function addSubForm2() {
        if (parent2) {
          var _inject = getRuleInject(vm, parent2);
          if (_inject) {
            var sub2;
            if (isMore) {
              sub2 = toArray$5(_inject.getSubForm());
              sub2.push(fapi);
            } else {
              sub2 = fapi;
            }
            _inject.subForm(sub2);
          }
        }
      };
      var rmSubForm = function rmSubForm2() {
        var inject2 = getRuleInject(vm, parent2);
        if (inject2) {
          if (isMore) {
            var sub2 = toArray$5(inject2.getSubForm());
            var idx = sub2.indexOf(fapi);
            if (idx > -1) {
              sub2.splice(idx, 1);
            }
          } else {
            inject2.subForm();
          }
        }
      };
      onMounted$1(function() {
        fc2.mounted();
      });
      onBeforeUnmount(function() {
        rmSubForm();
        data5.destroyed = true;
        fc2.unmount();
      });
      onUpdated(function() {
        fc2.updated();
      });
      watch$1(subForm, function(n2) {
        n2 ? addSubForm() : rmSubForm();
      }, {
        immediate: true
      });
      watch$1(function() {
        return _toConsumableArray(rule2.value);
      }, function(n2) {
        if (fc2.$handle.isBreakWatch() || n2.length === data5.renderRule.length && n2.every(function(v2) {
          return data5.renderRule.indexOf(v2) > -1;
        }))
          return;
        fc2.$handle.reloadRule(rule2.value);
        vm.setupState.renderRule();
      });
      watch$1(function() {
        return props.option;
      }, function(n2) {
        fc2.initOptions(n2);
        fapi.refresh();
      }, {
        deep: true
      });
      watch$1(modelValue5, function(n2) {
        if (JSON.stringify(n2 || {}) === data5.updateValue)
          return;
        fapi.config.forceCoverValue ? fapi.coverValue(n2 || {}) : fapi.setValue(n2 || {});
      }, {
        deep: true
      });
      return _objectSpread2(_objectSpread2({
        fc: markRaw(fc2),
        parent: parent2 ? markRaw(parent2) : parent2,
        fapi: markRaw(fapi)
      }, toRefs$1(data5)), {}, {
        refresh: function refresh() {
          ++data5.unique;
        },
        renderRule: function renderRule() {
          data5.renderRule = _toConsumableArray(rule2.value || []);
        },
        updateValue: function updateValue2(value) {
          if (data5.destroyed)
            return;
          data5.updateValue = JSON.stringify(value);
          vm.emit("update:modelValue", value);
        }
      });
    },
    created: function created3() {
      var vm = getCurrentInstance$1();
      vm.setupState.fc.init();
      vm.emit("update:api", vm.setupState.fapi);
    }
  });
}
var normalMerge = ["props"];
var toArrayMerge = ["class", "style", "directives"];
var functionalMerge = ["on"];
var mergeProps = function mergeProps2(objects) {
  var initial = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var opt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _normalMerge = [].concat(normalMerge, _toConsumableArray(opt["normal"] || []));
  var _toArrayMerge = [].concat(toArrayMerge, _toConsumableArray(opt["array"] || []));
  var _functionalMerge = [].concat(functionalMerge, _toConsumableArray(opt["functional"] || []));
  var propsMerge = opt["props"] || [];
  return objects.reduce(function(a2, b2) {
    for (var key in b2) {
      if (a2[key]) {
        if (propsMerge.indexOf(key) > -1) {
          a2[key] = mergeProps2([b2[key]], a2[key]);
        } else if (_normalMerge.indexOf(key) > -1) {
          a2[key] = _objectSpread2(_objectSpread2({}, a2[key]), b2[key]);
        } else if (_toArrayMerge.indexOf(key) > -1) {
          var arrA = a2[key] instanceof Array ? a2[key] : [a2[key]];
          var arrB = b2[key] instanceof Array ? b2[key] : [b2[key]];
          a2[key] = [].concat(_toConsumableArray(arrA), _toConsumableArray(arrB));
        } else if (_functionalMerge.indexOf(key) > -1) {
          for (var event in b2[key]) {
            if (a2[key][event]) {
              var _arrA = a2[key][event] instanceof Array ? a2[key][event] : [a2[key][event]];
              var _arrB = b2[key][event] instanceof Array ? b2[key][event] : [b2[key][event]];
              a2[key][event] = [].concat(_toConsumableArray(_arrA), _toConsumableArray(_arrB));
            } else {
              a2[key][event] = b2[key][event];
            }
          }
        } else if (key === "hook") {
          for (var hook in b2[key]) {
            if (a2[key][hook]) {
              a2[key][hook] = mergeFn(a2[key][hook], b2[key][hook]);
            } else {
              a2[key][hook] = b2[key][hook];
            }
          }
        } else {
          a2[key] = b2[key];
        }
      } else {
        if (_normalMerge.indexOf(key) > -1 || _functionalMerge.indexOf(key) > -1 || propsMerge.indexOf(key) > -1) {
          a2[key] = _objectSpread2({}, b2[key]);
        } else if (_toArrayMerge.indexOf(key) > -1) {
          a2[key] = b2[key] instanceof Array ? _toConsumableArray(b2[key]) : _typeof(b2[key]) === "object" ? _objectSpread2({}, b2[key]) : b2[key];
        } else
          a2[key] = b2[key];
      }
    }
    return a2;
  }, initial);
};
var mergeFn = function mergeFn2(fn1, fn2) {
  return function() {
    fn1 && fn1.apply(this, arguments);
    fn2 && fn2.apply(this, arguments);
  };
};
var keyAttrs = ["type", "slot", "emitPrefix", "value", "name", "native", "hidden", "display", "inject", "options", "emit", "link", "prefix", "suffix", "update", "sync", "optionsTo", "key", "slotUpdate", "computed", "preview", "component", "cache"];
var arrayAttrs = ["validate", "children", "control"];
var normalAttrs = ["effect"];
function attrs() {
  return [].concat(keyAttrs, _toConsumableArray(normalMerge), _toConsumableArray(toArrayMerge), _toConsumableArray(functionalMerge), arrayAttrs, normalAttrs);
}
function format$2(type2, msg, rule2) {
  return "[form-create ".concat(type2, "]: ").concat(msg) + (rule2 ? "\n\nrule: " + JSON.stringify(rule2.getRule ? rule2.getRule() : rule2) : "");
}
function err(msg, rule2) {
  console.error(format$2("err", msg, rule2));
}
function logError$1(e3) {
  err(e3.toString());
  console.error(e3);
}
function toLine(name2) {
  var line = name2.replace(/([A-Z])/g, "-$1").toLocaleLowerCase();
  if (line.indexOf("-") === 0)
    line = line.substr(1);
  return line;
}
function upper(str) {
  return str.replace(str[0], str[0].toLocaleUpperCase());
}
var PREFIX = "[[FORM-CREATE-PREFIX-";
var SUFFIX = "-FORM-CREATE-SUFFIX]]";
var $T = "$FN:";
var $TX = "$FNX:";
var FUNCTION = "function";
function toJson(obj, space) {
  return JSON.stringify(deepExtend([], obj, true), function(key, val2) {
    if (val2 && val2._isVue === true)
      return void 0;
    if (_typeof(val2) !== FUNCTION) {
      return val2;
    }
    if (val2.__json) {
      return val2.__json;
    }
    if (val2.__origin)
      val2 = val2.__origin;
    if (val2.__emit)
      return void 0;
    return PREFIX + val2 + SUFFIX;
  }, space);
}
function makeFn(fn) {
  return eval("(" + FUNCTION + "(){return " + fn + " })()");
}
function parseFn(fn2, mode) {
  if (fn2 && is$3.String(fn2) && fn2.length > 4) {
    var v2 = fn2.trim();
    var flag = false;
    try {
      if (v2.indexOf(SUFFIX) > 0 && v2.indexOf(PREFIX) === 0) {
        v2 = v2.replace(SUFFIX, "").replace(PREFIX, "");
        flag = true;
      } else if (v2.indexOf($T) === 0) {
        v2 = v2.replace($T, "");
        flag = true;
      } else if (v2.indexOf($TX) === 0) {
        v2 = makeFn("function($inject){" + v2.replace($TX, "") + "}");
        v2.__json = fn2;
        v2.__inject = true;
        return v2;
      } else if (!mode && v2.indexOf(FUNCTION) === 0 && v2 !== FUNCTION) {
        flag = true;
      }
      if (!flag)
        return fn2;
      var val2 = makeFn(v2.indexOf(FUNCTION) === -1 && v2.indexOf("(") !== 0 ? FUNCTION + " " + v2 : v2);
      val2.__json = fn2;
      return val2;
    } catch (e3) {
      err("\u89E3\u6790\u5931\u8D25:".concat(v2, "\n\nerr: ").concat(e3));
      return void 0;
    }
  }
  return fn2;
}
function parseJson(json, mode) {
  return JSON.parse(json, function(k2, v2) {
    if (is$3.Undef(v2) || !v2.indexOf)
      return v2;
    return parseFn(v2, mode);
  });
}
function enumerable(value, writable) {
  return {
    value,
    enumerable: false,
    configurable: false,
    writable: !!writable
  };
}
function copyRule(rule2, mode) {
  return copyRules([rule2], mode || false)[0];
}
function copyRules(rules, mode) {
  return deepExtend([], _toConsumableArray(rules), mode || false);
}
function mergeRule(rule2, merge2) {
  mergeProps(Array.isArray(merge2) ? merge2 : [merge2], rule2, {
    array: arrayAttrs,
    normal: normalAttrs
  });
  return rule2;
}
function getRule(rule2) {
  var r2 = is$3.Function(rule2.getRule) ? rule2.getRule() : rule2;
  if (!r2.type) {
    r2.type = "input";
  }
  return r2;
}
function mergeGlobal(target, merge2) {
  if (!target)
    return merge2;
  Object.keys(merge2 || {}).forEach(function(k2) {
    if (merge2[k2]) {
      target[k2] = mergeRule(target[k2] || {}, merge2[k2]);
    }
  });
  return target;
}
function funcProxy(that, proxy) {
  Object.defineProperties(that, Object.keys(proxy).reduce(function(initial, k2) {
    initial[k2] = {
      get: function get3() {
        return proxy[k2]();
      }
    };
    return initial;
  }, {}));
}
function byCtx(rule2) {
  return rule2.__fc__ || (rule2.__origin__ ? rule2.__origin__.__fc__ : null);
}
function invoke$2(fn2, def) {
  try {
    def = fn2();
  } catch (e3) {
    logError$1(e3);
  }
  return def;
}
function makeSlotBag() {
  var slotBag = {};
  var slotName = function slotName2(n2) {
    return n2 || "default";
  };
  return {
    setSlot: function setSlot(slot, vnFn) {
      slot = slotName(slot);
      if (!vnFn || Array.isArray(vnFn) && vnFn.length)
        return;
      if (!slotBag[slot])
        slotBag[slot] = [];
      slotBag[slot].push(vnFn);
    },
    getSlot: function getSlot2(slot, val2) {
      slot = slotName(slot);
      var children2 = [];
      (slotBag[slot] || []).forEach(function(fn2) {
        if (Array.isArray(fn2)) {
          children2.push.apply(children2, _toConsumableArray(fn2));
        } else if (is$3.Function(fn2)) {
          var res = fn2.apply(void 0, _toConsumableArray(val2 || []));
          if (Array.isArray(res)) {
            children2.push.apply(children2, _toConsumableArray(res));
          } else {
            children2.push(res);
          }
        } else if (!is$3.Undef(fn2)) {
          children2.push(fn2);
        }
      });
      return children2;
    },
    getSlots: function getSlots() {
      var _this = this;
      var slots = {};
      Object.keys(slotBag).forEach(function(k2) {
        slots[k2] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _this.getSlot(k2, args);
        };
      });
      return slots;
    },
    slotLen: function slotLen(slot) {
      slot = slotName(slot);
      return slotBag[slot] ? slotBag[slot].length : 0;
    },
    mergeBag: function mergeBag(bag) {
      var _this2 = this;
      if (!bag)
        return this;
      var slots = is$3.Function(bag.getSlots) ? bag.getSlots() : bag;
      if (Array.isArray(bag) || isVNode(bag)) {
        this.setSlot(void 0, function() {
          return bag;
        });
      } else {
        Object.keys(slots).forEach(function(k2) {
          _this2.setSlot(k2, slots[k2]);
        });
      }
      return this;
    }
  };
}
function toProps(rule2) {
  var prop = _objectSpread2({}, rule2.props || {});
  Object.keys(rule2.on || {}).forEach(function(k2) {
    var name2 = "on".concat(upper(k2));
    if (Array.isArray(prop[name2])) {
      prop[name2] = [].concat(_toConsumableArray(prop[name2]), [rule2.on[k2]]);
    } else if (prop[name2]) {
      prop[name2] = [prop[name2], rule2.on[k2]];
    } else {
      prop[name2] = rule2.on[k2];
    }
  });
  prop.key = rule2.key;
  prop.ref = rule2.ref;
  prop["class"] = rule2["class"];
  prop.style = rule2.style;
  if (prop.slot)
    delete prop.slot;
  return prop;
}
function baseRule() {
  return {
    props: {},
    on: {},
    options: [],
    children: [],
    hidden: false,
    display: true,
    value: void 0
  };
}
function creatorFactory(name2, init5) {
  return function(title, field, value) {
    var props = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var maker = new Creator(name2, title, field, value, props);
    if (init5) {
      if (is$3.Function(init5))
        init5(maker);
      else
        maker.props(init5);
    }
    return maker;
  };
}
function Creator(type2, title, field, value, props) {
  this._data = extend$2(baseRule(), {
    type: type2,
    title,
    field,
    value,
    props: props || {}
  });
  this.event = this.on;
}
extend$2(Creator.prototype, {
  getRule: function getRule2() {
    return this._data;
  },
  setProp: function setProp(key, value) {
    $set(this._data, key, value);
    return this;
  },
  modelField: function modelField(field) {
    this._data.modelField = field;
    return this;
  },
  _clone: function _clone() {
    var clone2 = new this.constructor();
    clone2._data = copyRule(this._data);
    return clone2;
  }
});
function appendProto(attrs2) {
  attrs2.forEach(function(name2) {
    Creator.prototype[name2] = function(key) {
      mergeRule(this._data, _defineProperty$1({}, name2, arguments.length < 2 ? key : _defineProperty$1({}, key, arguments[1])));
      return this;
    };
  });
}
appendProto(attrs());
var commonMaker = creatorFactory("");
function create$2(type2, field, title) {
  var make = commonMaker("", field);
  make._data.type = type2;
  make._data.title = title;
  return make;
}
function makerFactory() {
  return {
    create: create$2,
    factory: creatorFactory
  };
}
function copy$2(value) {
  return deepCopy(value);
}
function Api(h2) {
  function tidyFields(fields) {
    if (is$3.Undef(fields))
      fields = h2.fields();
    else if (!Array.isArray(fields))
      fields = [fields];
    return fields;
  }
  function props(fields, key, val2) {
    tidyFields(fields).forEach(function(field) {
      h2.getCtxs(field).forEach(function(ctx) {
        $set(ctx.rule, key, val2);
        h2.$render.clearCache(ctx);
      });
    });
  }
  function allSubForm() {
    var subs = h2.subForm;
    return Object.keys(subs).reduce(function(initial, k2) {
      var sub2 = subs[k2];
      if (!sub2)
        return initial;
      if (Array.isArray(sub2))
        initial.push.apply(initial, _toConsumableArray(sub2));
      else
        initial.push(sub2);
      return initial;
    }, []);
  }
  var api = {
    get config() {
      return h2.options;
    },
    set config(val2) {
      h2.fc.options.value = val2;
    },
    get options() {
      return h2.options;
    },
    set options(val2) {
      h2.fc.options.value = val2;
    },
    get form() {
      return h2.form;
    },
    get rule() {
      return h2.rules;
    },
    get parent() {
      return h2.vm.parent && h2.vm.parent.setupState.fapi;
    },
    get children() {
      return allSubForm();
    },
    formData: function formData3(fields) {
      return tidyFields(fields).reduce(function(initial, id2) {
        var ctx = h2.getFieldCtx(id2);
        if (!ctx)
          return initial;
        initial[ctx.field] = copy$2(ctx.rule.value);
        return initial;
      }, {});
    },
    getValue: function getValue2(field) {
      var ctx = h2.getFieldCtx(field);
      if (!ctx)
        return;
      return copy$2(ctx.rule.value);
    },
    coverValue: function coverValue(formData3) {
      var data5 = _objectSpread2({}, formData3 || {});
      h2.deferSyncValue(function() {
        api.fields().forEach(function(key) {
          var ctxs = h2.fieldCtx[key];
          if (ctxs) {
            var flag = hasProperty$1(formData3, key);
            ctxs.forEach(function(ctx) {
              ctx.rule.value = flag ? formData3[key] : void 0;
            });
            delete data5[key];
          }
        });
        extend$2(h2.appendData, data5);
      });
    },
    setValue: function setValue4(field) {
      var formData3 = field;
      if (arguments.length >= 2)
        formData3 = _defineProperty$1({}, field, arguments[1]);
      h2.deferSyncValue(function() {
        Object.keys(formData3).forEach(function(key) {
          var ctxs = h2.fieldCtx[key];
          if (!ctxs)
            return h2.appendData[key] = formData3[key];
          ctxs.forEach(function(ctx) {
            ctx.rule.value = formData3[key];
          });
        });
      });
    },
    removeField: function removeField(field) {
      var ctx = h2.getCtx(field);
      h2.deferSyncValue(function() {
        h2.getCtxs(field).forEach(function(ctx2) {
          ctx2.rm();
        });
      }, true);
      return ctx ? ctx.origin : void 0;
    },
    removeRule: function removeRule2(rule2) {
      var ctx = rule2 && byCtx(rule2);
      if (!ctx)
        return;
      ctx.rm();
      return ctx.origin;
    },
    fields: function fields() {
      return h2.fields();
    },
    append: function append2(rule2, after2, child) {
      var index = h2.sort.length - 1, rules;
      var ctx = h2.getCtx(after2);
      if (ctx) {
        if (child) {
          rules = ctx.getPending("children", ctx.rule.children);
          if (!Array.isArray(rules))
            return;
          index = ctx.rule.children.length - 1;
        } else {
          index = ctx.root.indexOf(ctx.origin);
          rules = ctx.root;
        }
      } else
        rules = h2.rules;
      rules.splice(index + 1, 0, rule2);
    },
    prepend: function prepend2(rule2, after2, child) {
      var index = 0, rules;
      var ctx = h2.getCtx(after2);
      if (ctx) {
        if (child) {
          rules = ctx.getPending("children", ctx.rule.children);
          if (!Array.isArray(rules))
            return;
        } else {
          index = ctx.root.indexOf(ctx.origin);
          rules = ctx.root;
        }
      } else
        rules = h2.rules;
      rules.splice(index, 0, rule2);
    },
    hidden: function hidden2(state, fields) {
      props(fields, "hidden", !!state);
      h2.refresh();
    },
    hiddenStatus: function hiddenStatus(id2) {
      var ctx = h2.getCtx(id2);
      if (!ctx)
        return;
      return !!ctx.rule.hidden;
    },
    display: function display(state, fields) {
      props(fields, "display", !!state);
      h2.refresh();
    },
    displayStatus: function displayStatus(id2) {
      var ctx = h2.getCtx(id2);
      if (!ctx)
        return;
      return !!ctx.rule.display;
    },
    disabled: function disabled3(_disabled, fields) {
      tidyFields(fields).forEach(function(field) {
        h2.getCtxs(field).forEach(function(ctx) {
          $set(ctx.rule.props, "disabled", !!_disabled);
        });
      });
      h2.refresh();
    },
    all: function all(origin) {
      return Object.keys(h2.ctxs).map(function(k2) {
        var ctx = h2.ctxs[k2];
        return origin ? ctx.origin : ctx.rule;
      });
    },
    model: function model(origin) {
      return h2.fields().reduce(function(initial, key) {
        var ctx = h2.fieldCtx[key][0];
        initial[key] = origin ? ctx.origin : ctx.rule;
        return initial;
      }, {});
    },
    component: function component(origin) {
      return Object.keys(h2.nameCtx).reduce(function(initial, key) {
        var ctx = h2.nameCtx[key].map(function(ctx2) {
          return origin ? ctx2.origin : ctx2.rule;
        });
        initial[key] = ctx.length === 1 ? ctx[0] : ctx;
        return initial;
      }, {});
    },
    bind: function bind2() {
      return api.form;
    },
    reload: function reload(rules) {
      h2.reloadRule(rules);
    },
    updateOptions: function updateOptions2(options) {
      h2.fc.updateOptions(options);
      api.refresh();
    },
    onSubmit: function onSubmit(fn2) {
      api.updateOptions({
        onSubmit: fn2
      });
    },
    sync: function sync(field) {
      if (Array.isArray(field)) {
        field.forEach(function(v2) {
          return api.sync(v2);
        });
        return;
      }
      var ctxs = is$3.Object(field) ? byCtx(field) : h2.getCtxs(field);
      if (!ctxs) {
        return;
      }
      ctxs = Array.isArray(ctxs) ? ctxs : [ctxs];
      ctxs.forEach(function(ctx) {
        if (!ctx.deleted) {
          var subForm = h2.subForm[ctx.id];
          if (subForm) {
            if (Array.isArray(subForm)) {
              subForm.forEach(function(form2) {
                form2.refresh();
              });
            } else if (subForm) {
              subForm.refresh();
            }
          }
          h2.$render.clearCache(ctx);
        }
      });
      h2.refresh();
    },
    refresh: function refresh() {
      allSubForm().forEach(function(sub2) {
        sub2.refresh();
      });
      h2.$render.clearCacheAll();
      h2.refresh();
    },
    refreshOptions: function refreshOptions() {
      h2.$manager.updateOptions(h2.options);
      api.refresh();
    },
    hideForm: function hideForm(hide2) {
      h2.vm.setupState.isShow = !hide2;
    },
    changeStatus: function changeStatus() {
      return h2.changeStatus;
    },
    clearChangeStatus: function clearChangeStatus() {
      h2.changeStatus = false;
    },
    updateRule: function updateRule(id2, rule2) {
      h2.getCtxs(id2).forEach(function(ctx) {
        extend$2(ctx.rule, rule2);
      });
    },
    updateRules: function updateRules(rules) {
      Object.keys(rules).forEach(function(id2) {
        api.updateRule(id2, rules[id2]);
      });
    },
    mergeRule: function mergeRule$1(id2, rule2) {
      h2.getCtxs(id2).forEach(function(ctx) {
        mergeRule(ctx.rule, rule2);
      });
    },
    mergeRules: function mergeRules(rules) {
      Object.keys(rules).forEach(function(id2) {
        api.mergeRule(id2, rules[id2]);
      });
    },
    getRule: function getRule3(id2, origin) {
      var ctx = h2.getCtx(id2);
      if (ctx) {
        return origin ? ctx.origin : ctx.rule;
      }
    },
    setEffect: function setEffect(id2, attr2, value) {
      var ctx = h2.getCtx(id2);
      if (ctx && attr2) {
        if (attr2[0] === "$") {
          attr2 = attr2.substr(1);
        }
        if (hasProperty$1(ctx.rule, "$" + attr2)) {
          $set(ctx.rule, "$" + attr2, value);
        }
        if (!hasProperty$1(ctx.rule, "effect")) {
          ctx.rule.effect = {};
        }
        $set(ctx.rule.effect, attr2, value);
      }
    },
    clearEffectData: function clearEffectData2(id2, attr2) {
      var ctx = h2.getCtx(id2);
      if (ctx) {
        if (attr2 && attr2[0] === "$") {
          attr2 = attr2.substr(1);
        }
        ctx.clearEffectData(attr2);
        api.sync(id2);
      }
    },
    updateValidate: function updateValidate(id2, validate2, merge2) {
      if (merge2) {
        api.mergeRule(id2, {
          validate: validate2
        });
      } else {
        props(id2, "validate", validate2);
      }
    },
    updateValidates: function updateValidates(validates, merge2) {
      Object.keys(validates).forEach(function(id2) {
        api.updateValidate(id2, validates[id2], merge2);
      });
    },
    refreshValidate: function refreshValidate() {
      api.refresh();
    },
    resetFields: function resetFields(fields) {
      tidyFields(fields).forEach(function(field) {
        h2.getCtxs(field).forEach(function(ctx) {
          h2.$render.clearCache(ctx);
          ctx.rule.value = copy$2(ctx.defaultValue);
        });
      });
    },
    method: function method(id2, name2) {
      var el2 = api.el(id2);
      if (!el2 || !el2[name2])
        throw new Error(format$2("err", "".concat(name2, "\u65B9\u6CD5\u4E0D\u5B58\u5728")));
      return function() {
        return el2[name2].apply(el2, arguments);
      };
    },
    exec: function exec(id2, name2) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return invoke$2(function() {
        return api.method(id2, name2).apply(void 0, args);
      });
    },
    toJson: function toJson$1(space) {
      return toJson(api.rule, space);
    },
    trigger: function trigger2(id2, event) {
      var el2 = api.el(id2);
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }
      el2 && el2.$emit.apply(el2, [event].concat(args));
    },
    el: function el2(id2) {
      var ctx = h2.getCtx(id2);
      if (ctx)
        return ctx.el || h2.vm.refs[ctx.ref];
    },
    closeModal: function closeModal2(id2) {
      h2.bus.$emit("fc:closeModal:" + id2);
    },
    getSubForm: function getSubForm(field) {
      var ctx = h2.getCtx(field);
      return ctx ? h2.subForm[ctx.id] : void 0;
    },
    nextTick: function nextTick2(fn2) {
      h2.bus.$once("next-tick", fn2);
      h2.refresh();
    },
    nextRefresh: function nextRefresh(fn2) {
      h2.nextRefresh();
      fn2 && invoke$2(fn2);
    },
    deferSyncValue: function deferSyncValue(fn2, sync) {
      h2.deferSyncValue(fn2, sync);
    },
    emit: function emit(name2) {
      var _h$vm;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      (_h$vm = h2.vm).emit.apply(_h$vm, [name2].concat(args));
    },
    helper: {
      tidyFields,
      props
    }
  };
  ["on", "once", "off", "set"].forEach(function(n2) {
    api[n2] = function() {
      var _h$bus;
      (_h$bus = h2.bus)["$".concat(n2)].apply(_h$bus, arguments);
    };
  });
  api.changeValue = api.changeField = api.setValue;
  return api;
}
function useCache(Render2) {
  extend$2(Render2.prototype, {
    initCache: function initCache() {
      this.clearCacheAll();
    },
    clearCache: function clearCache(ctx) {
      if (!this.cache[ctx.id]) {
        ctx.parent && this.clearCache(ctx.parent);
        return;
      }
      if (this.cache[ctx.id].use === true || this.cache[ctx.id].parent) {
        this.$handle.refresh();
      }
      var parent2 = this.cache[ctx.id].parent;
      this.cache[ctx.id] = null;
      parent2 && this.clearCache(parent2);
    },
    clearCacheAll: function clearCacheAll() {
      this.cache = {};
    },
    setCache: function setCache(ctx, vnode2, parent2) {
      this.cache[ctx.id] = {
        vnode: vnode2,
        use: false,
        parent: parent2,
        slot: ctx.rule.slot
      };
    },
    getCache: function getCache(ctx) {
      var cache2 = this.cache[ctx.id];
      if (cache2) {
        cache2.use = true;
        return cache2.vnode;
      }
      return void 0;
    }
  });
}
function toCase(str) {
  var to2 = str.replace(/(-[a-z])/g, function(v2) {
    return v2.replace("-", "").toLocaleUpperCase();
  });
  return lower(to2);
}
function lower(str) {
  return str.replace(str[0], str[0].toLowerCase());
}
function toString$2(val2) {
  return val2 == null ? "" : _typeof(val2) === "object" ? JSON.stringify(val2, null, 2) : String(val2);
}
var id$2$1 = 0;
function uniqueId$2() {
  return "F" + Math.random().toString(36).substr(3, 3) + Number("".concat(Date.now()).concat(++id$2$1)).toString(36);
}
function deepSet(data5, idx, val2) {
  var _data = data5, to2;
  (idx || "").split(".").forEach(function(v2) {
    if (to2) {
      if (!_data[to2] || _typeof(_data[to2]) != "object") {
        _data[to2] = {};
      }
      _data = _data[to2];
    }
    to2 = v2;
  });
  _data[to2] = val2;
  return _data;
}
function useRender$1(Render2) {
  extend$2(Render2.prototype, {
    initRender: function initRender() {
      this.cacheConfig = {};
    },
    getTypeSlot: function getTypeSlot(type2) {
      var name2 = "type-" + toLine(type2);
      var _fn = function _fn2(vm) {
        if (vm) {
          var slot = vm.slots[name2] || vm.slots["type-" + type2];
          if (slot) {
            return slot;
          }
          return _fn2(vm.setupState.parent);
        }
      };
      return _fn(this.vm);
    },
    render: function render17() {
      var _this = this;
      if (!this.vm.setupState.isShow) {
        return;
      }
      this.$manager.beforeRender();
      var slotBag = makeSlotBag();
      this.sort.forEach(function(k2) {
        _this.renderSlot(slotBag, _this.$handle.ctxs[k2]);
      });
      return this.$manager.render(slotBag);
    },
    renderSlot: function renderSlot2(slotBag, ctx, parent2) {
      if (this.isFragment(ctx)) {
        ctx.initProp();
        this.mergeGlobal(ctx);
        ctx.initNone();
        var slots = this.renderChildren(ctx.loadChildrenPending(), ctx);
        var def = slots["default"];
        def && slotBag.setSlot(ctx.rule.slot, function() {
          return def();
        });
        delete slots["default"];
        slotBag.mergeBag(slots);
      } else {
        slotBag.setSlot(ctx.rule.slot, this.renderCtx(ctx, parent2));
      }
    },
    mergeGlobal: function mergeGlobal2(ctx) {
      var _this2 = this;
      var g2 = this.$handle.options.global;
      if (!g2)
        return;
      if (!this.cacheConfig[ctx.trueType]) {
        this.cacheConfig[ctx.trueType] = computed$1(function() {
          var g3 = _this2.$handle.options.global;
          return mergeRule({}, [g3["*"], g3[ctx.originType] || g3[ctx.type] || g3[ctx.type] || {}]);
        });
      }
      ctx.prop = mergeRule({}, [this.cacheConfig[ctx.trueType].value, ctx.prop]);
    },
    setOptions: function setOptions(ctx) {
      var opt = ctx.loadPending({
        key: "options",
        origin: ctx.prop.options,
        def: []
      });
      ctx.prop.options = opt;
      if (ctx.prop.optionsTo && opt) {
        deepSet(ctx.prop, ctx.prop.optionsTo, opt);
      }
    },
    deepSet: function deepSet$1(ctx) {
      var deep = ctx.rule.deep;
      deep && Object.keys(deep).sort(function(a2, b2) {
        return a2.length < b2.length ? -1 : 1;
      }).forEach(function(str) {
        deepSet(ctx.prop, str, deep[str]);
      });
    },
    parseSide: function parseSide(side) {
      return is$3.Object(side) ? mergeRule({}, side) : side;
    },
    renderSides: function renderSides(vn2, ctx, temp) {
      var prop = ctx[temp ? "rule" : "prop"];
      return [this.renderRule(this.parseSide(prop.prefix)), vn2, this.renderRule(this.parseSide(prop.suffix))];
    },
    renderId: function renderId(name2, type2) {
      var _this3 = this;
      var ctxs = this.$handle[type2 === "field" ? "fieldCtx" : "nameCtx"][name2];
      return ctxs ? ctxs.map(function(ctx) {
        return _this3.renderCtx(ctx, ctx.parent);
      }) : void 0;
    },
    renderCtx: function renderCtx(ctx, parent2) {
      var _this4 = this;
      try {
        if (ctx.type === "hidden")
          return;
        var rule2 = ctx.rule;
        if (!this.cache[ctx.id] || this.cache[ctx.id].slot !== rule2.slot) {
          var vn2;
          ctx.initProp();
          this.mergeGlobal(ctx);
          ctx.initNone();
          this.$manager.tidyRule(ctx);
          this.deepSet(ctx);
          this.setOptions(ctx);
          this.ctxProp(ctx);
          var prop = ctx.prop;
          prop.preview = !!(hasProperty$1(prop, "preview") ? prop.preview : this.options.preview || false);
          prop.props.formCreateInject = this.injectProp(ctx);
          var cacheFlag = prop.cache !== false;
          var preview2 = prop.preview;
          if (prop.hidden) {
            this.setCache(ctx, void 0, parent2);
            return;
          }
          vn2 = function vn3() {
            for (var _len = arguments.length, slotValue = new Array(_len), _key = 0; _key < _len; _key++) {
              slotValue[_key] = arguments[_key];
            }
            var inject2 = {
              rule: rule2,
              prop,
              preview: preview2,
              api: _this4.$handle.api,
              model: prop.model || {},
              slotValue
            };
            if (slotValue.length && rule2.slotUpdate) {
              invoke$2(function() {
                return rule2.slotUpdate(inject2);
              });
            }
            var children2 = {};
            var _load = ctx.loadChildrenPending();
            if (ctx.parser.renderChildren) {
              children2 = ctx.parser.renderChildren(_load, ctx);
            } else if (ctx.parser.loadChildren !== false) {
              children2 = _this4.renderChildren(_load, ctx);
            }
            var slot = _this4.getTypeSlot(ctx.type);
            var _vn;
            if (slot) {
              inject2.children = children2;
              _vn = slot(inject2);
            } else {
              _vn = preview2 ? ctx.parser.preview(children2, ctx) : ctx.parser.render(children2, ctx);
            }
            _vn = _this4.renderSides(_vn, ctx);
            if (!(!ctx.input && is$3.Undef(prop["native"])) && prop["native"] !== true) {
              _vn = _this4.$manager.makeWrap(ctx, _vn);
            }
            if (ctx.none) {
              _vn = _this4.display(_vn);
            }
            cacheFlag && _this4.setCache(ctx, function() {
              return _vn;
            }, parent2);
            return _vn;
          };
          this.setCache(ctx, vn2, parent2);
        }
        return function() {
          var cache2 = _this4.getCache(ctx);
          return cache2 && cache2.apply(void 0, arguments);
        };
      } catch (e3) {
        console.error(e3);
        return;
      }
    },
    getModelField: function getModelField(ctx) {
      return ctx.rule.modelField || ctx.parser.modelField || this.fc.modelFields[this.vNode.aliasMap[ctx.type]] || this.fc.modelFields[ctx.type] || this.fc.modelFields[ctx.originType] || "modelValue";
    },
    display: function display(vn2) {
      var _this5 = this;
      if (Array.isArray(vn2)) {
        var data5 = [];
        vn2.forEach(function(v2) {
          if (Array.isArray(v2))
            return _this5.display(v2);
          if (_this5.none(v2))
            data5.push(v2);
        });
        return data5;
      } else {
        return this.none(vn2);
      }
    },
    none: function none(vn2) {
      if (vn2) {
        if (Array.isArray(vn2.props.style)) {
          vn2.props.style.push({
            display: "none"
          });
        } else {
          vn2.props.style = [vn2.props.style, {
            display: "none"
          }];
        }
        return vn2;
      }
    },
    isFragment: function isFragment(ctx) {
      return ctx.type === "fragment" || ctx.type === "template";
    },
    injectProp: function injectProp(ctx) {
      var _this6 = this;
      var state = this.vm.setupState;
      if (!state.ctxInject[ctx.id]) {
        state.ctxInject[ctx.id] = {
          api: this.$handle.api,
          form: this.fc.create,
          subForm: function subForm(_subForm) {
            _this6.$handle.addSubForm(ctx, _subForm);
          },
          getSubForm: function getSubForm() {
            return _this6.$handle.subForm[ctx.id];
          },
          options: [],
          children: [],
          preview: false,
          field: ctx.field,
          rule: ctx.rule,
          input: ctx.input
        };
      }
      var inject2 = state.ctxInject[ctx.id];
      extend$2(inject2, {
        preview: ctx.prop.preview,
        options: ctx.prop.options,
        children: ctx.loadChildrenPending()
      });
      return inject2;
    },
    ctxProp: function ctxProp(ctx, custom) {
      var _this7 = this;
      var ref2 = ctx.ref, key = ctx.key, rule2 = ctx.rule;
      this.$manager.mergeProp(ctx, custom);
      ctx.parser.mergeProp(ctx, custom);
      var props = [{
        ref: ref2,
        key: rule2.key || "".concat(key, "fc"),
        slot: void 0,
        on: {
          vnodeMounted: function vnodeMounted(vn2) {
            vn2.el.__rule__ = ctx.rule;
            _this7.onMounted(ctx, vn2.el);
          }
        }
      }];
      if (!custom && ctx.input) {
        var field = this.getModelField(ctx);
        var model = {
          callback: function callback(value) {
            _this7.onInput(ctx, value);
          },
          value: this.$handle.getFormData(ctx)
        };
        props.push({
          on: _defineProperty$1({}, "update:".concat(field), model.callback),
          props: _defineProperty$1({}, field, model.value)
        });
        ctx.prop.model = model;
      }
      mergeProps(props, ctx.prop);
      return ctx.prop;
    },
    onMounted: function onMounted2(ctx, el2) {
      ctx.el = this.vm.refs[ctx.ref] || el2;
      ctx.parser.mounted(ctx);
      this.$handle.effect(ctx, "mounted");
    },
    onInput: function onInput(ctx, value) {
      this.$handle.onInput(ctx, value);
    },
    renderChildren: function renderChildren2(children2, ctx) {
      var _this8 = this;
      if (!is$3.trueArray(children2))
        return {};
      var slotBag = makeSlotBag();
      children2.map(function(child) {
        if (!child)
          return;
        if (is$3.String(child))
          return slotBag.setSlot(null, child);
        if (child.__fc__) {
          return _this8.renderSlot(slotBag, child.__fc__, ctx);
        }
        if (child.type) {
          nextTick$1(function() {
            _this8.$handle.loadChildren(children2, ctx);
            _this8.$handle.refresh();
          });
        }
      });
      return slotBag.getSlots();
    },
    defaultRender: function defaultRender(ctx, children2) {
      var prop = ctx.prop;
      if (prop.component)
        return this.vNode.makeComponent(prop.component, prop, children2);
      if (this.vNode[ctx.type])
        return this.vNode[ctx.type](prop, children2);
      if (this.vNode[ctx.originType])
        return this.vNode[ctx.originType](prop, children2);
      return this.vNode.make(lower(ctx.originType), prop, children2);
    },
    renderRule: function renderRule(rule2, children2, origin) {
      var _this9 = this;
      if (!rule2)
        return void 0;
      if (is$3.String(rule2))
        return rule2;
      var type2;
      if (origin) {
        type2 = rule2.type;
      } else {
        type2 = rule2.is;
        if (rule2.type) {
          type2 = toCase(rule2.type);
          var alias2 = this.vNode.aliasMap[type2];
          if (alias2)
            type2 = toCase(alias2);
        }
      }
      if (!type2)
        return void 0;
      var slotBag = makeSlotBag();
      if (is$3.trueArray(rule2.children)) {
        rule2.children.forEach(function(v2) {
          v2 && slotBag.setSlot(v2 === null || v2 === void 0 ? void 0 : v2.slot, function() {
            return _this9.renderRule(v2);
          });
        });
      }
      var props = _objectSpread2({}, rule2);
      delete props.type;
      delete props.is;
      return this.vNode.make(type2, props, slotBag.mergeBag(children2).getSlots());
    }
  });
}
var id$1$1 = 1;
function Render(handle) {
  extend$2(this, {
    $handle: handle,
    fc: handle.fc,
    vm: handle.vm,
    $manager: handle.$manager,
    vNode: new handle.fc.CreateNode(handle.vm),
    id: id$1$1++
  });
  funcProxy(this, {
    options: function options() {
      return handle.options;
    },
    sort: function sort2() {
      return handle.sort;
    }
  });
  this.initCache();
  this.initRender();
}
useCache(Render);
useRender$1(Render);
function useInject(Handler2) {
  extend$2(Handler2.prototype, {
    parseInjectEvent: function parseInjectEvent(rule2, on2) {
      var inject2 = rule2.inject || this.options.injectEvent;
      return this.parseEventLst(rule2, on2, inject2);
    },
    parseEventLst: function parseEventLst(rule2, data5, inject2, deep) {
      var _this = this;
      Object.keys(data5).forEach(function(k2) {
        var fn2 = _this.parseEvent(rule2, data5[k2], inject2, deep);
        if (fn2) {
          data5[k2] = fn2;
        }
      });
      return data5;
    },
    parseEvent: function parseEvent(rule2, fn2, inject2, deep) {
      if (is$3.Function(fn2) && (inject2 !== false && !is$3.Undef(inject2) || fn2.__inject)) {
        return this.inject(rule2, fn2, inject2);
      } else if (!deep && Array.isArray(fn2) && fn2[0] && (is$3.String(fn2[0]) || is$3.Function(fn2[0]))) {
        return this.parseEventLst(rule2, fn2, inject2, true);
      } else if (is$3.String(fn2)) {
        var val2 = parseFn(fn2);
        if (val2 && fn2 !== val2) {
          return val2.__inject ? this.parseEvent(rule2, val2, inject2, true) : val2;
        }
      }
    },
    parseEmit: function parseEmit(ctx) {
      var _this2 = this;
      var event = {}, rule2 = ctx.rule, emitPrefix = rule2.emitPrefix, field = rule2.field, name2 = rule2.name, inject2 = rule2.inject;
      var emit = rule2.emit || [];
      if (is$3.trueArray(emit)) {
        var emitKey = emitPrefix || field || name2;
        if (emitKey) {
          emit.forEach(function(eventName) {
            if (!eventName)
              return;
            var eventInject;
            if (is$3.Object(eventName)) {
              eventInject = eventName.inject;
              eventName = eventName.name;
            }
            var fieldKey = toLine("".concat(emitKey, "-").concat(eventName));
            var fn2 = function fn3() {
              var _this2$vm, _this2$vm2, _this2$bus;
              for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
                arg[_key] = arguments[_key];
              }
              (_this2$vm = _this2.vm).emit.apply(_this2$vm, [fieldKey].concat(arg));
              (_this2$vm2 = _this2.vm).emit.apply(_this2$vm2, ["emit-event", fieldKey].concat(arg));
              (_this2$bus = _this2.bus).$emit.apply(_this2$bus, [fieldKey].concat(arg));
            };
            fn2.__emit = true;
            if (!eventInject && inject2 === false) {
              event[eventName] = fn2;
            } else {
              var _inject = eventInject || inject2 || _this2.options.injectEvent;
              event[eventName] = is$3.Undef(_inject) ? fn2 : _this2.inject(rule2, fn2, _inject);
            }
          });
        }
      }
      ctx.computed.on = event;
      return event;
    },
    getInjectData: function getInjectData(self2, inject2) {
      var _this$vm = this.vm, option = _this$vm.option, rule2 = _this$vm.rule;
      return {
        $f: this.api,
        api: this.api,
        rule: rule2,
        self: self2.__origin__,
        option,
        inject: inject2
      };
    },
    inject: function inject2(self2, _fn, _inject2) {
      if (_fn.__origin) {
        if (this.watching && !this.loading)
          return _fn;
        _fn = _fn.__origin;
      }
      var h2 = this;
      var fn2 = function fn3() {
        var data5 = h2.getInjectData(self2, _inject2);
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        data5.args = [].concat(args);
        args.unshift(data5);
        return _fn.apply(this, args);
      };
      fn2.__origin = _fn;
      fn2.__json = _fn.__json;
      return fn2;
    }
  });
}
var EVENT = ["hook:updated", "hook:mounted"];
function usePage(Handler2) {
  extend$2(Handler2.prototype, {
    usePage: function usePage2() {
      var _this = this;
      var page = this.options.page;
      if (!page)
        return;
      var first2 = 25;
      var limit2 = getLimit(this.rules);
      if (is$3.Object(page)) {
        if (page.first)
          first2 = parseInt(page.first, 10) || first2;
        if (page.limit)
          limit2 = parseInt(page.limit, 10) || limit2;
      }
      extend$2(this, {
        first: first2,
        limit: limit2,
        pageEnd: this.rules.length <= first2
      });
      this.bus.$on("page-end", function() {
        return _this.vm.emit("page-end", _this.api);
      });
      this.pageLoad();
    },
    pageLoad: function pageLoad() {
      var _this2 = this;
      var pageFn = function pageFn2() {
        if (_this2.pageEnd) {
          _this2.bus.$off(EVENT, pageFn2);
          _this2.bus.$emit("page-end");
        } else {
          _this2.first += _this2.limit;
          _this2.pageEnd = _this2.rules.length <= _this2.first;
          _this2.loadRule();
          _this2.refresh();
        }
      };
      this.bus.$on(EVENT, pageFn);
    }
  });
}
function getLimit(rules) {
  return rules.length < 31 ? 31 : Math.ceil(rules.length / 3);
}
function useRender(Handler2) {
  extend$2(Handler2.prototype, {
    clearNextTick: function clearNextTick() {
      this.nextTick && clearTimeout(this.nextTick);
      this.nextTick = null;
    },
    bindNextTick: function bindNextTick(fn2) {
      var _this = this;
      this.clearNextTick();
      this.nextTick = setTimeout(function() {
        fn2();
        _this.nextTick = null;
      }, 10);
    },
    render: function render17() {
      ++this.loadedId;
      if (this.vm.setupState.unique > 0)
        return this.$render.render();
      else {
        this.vm.setupState.unique = 1;
        return [];
      }
    }
  });
}
function isNone(ctx) {
  var none = !(is$3.Undef(ctx.prop.display) || !!ctx.prop.display);
  if (ctx.parent) {
    return ctx.parent.none || none;
  } else {
    return none;
  }
}
function bind$4(ctx) {
  Object.defineProperties(ctx.origin, {
    __fc__: enumerable(markRaw(ctx), true)
  });
}
function RuleContext(handle, rule2, defaultValue) {
  var id2 = uniqueId$2();
  var isInput = !!rule2.field;
  extend$2(this, {
    id: id2,
    ref: id2,
    wrapRef: id2 + "fi",
    rule: rule2,
    origin: rule2.__origin__ || rule2,
    name: rule2.name,
    pending: {},
    none: false,
    watch: [],
    linkOn: [],
    root: [],
    ctrlRule: [],
    parent: null,
    cacheConfig: null,
    prop: _objectSpread2({}, rule2),
    computed: {},
    payload: {},
    refRule: {},
    input: isInput,
    el: void 0,
    defaultValue: isInput ? deepCopy(defaultValue) : void 0,
    field: rule2.field || void 0
  });
  this.updateType();
  this.updateKey();
  bind$4(this);
  this.update(handle, true);
}
extend$2(RuleContext.prototype, {
  loadChildrenPending: function loadChildrenPending() {
    var _this = this;
    var children2 = this.rule.children || [];
    if (Array.isArray(children2))
      return children2;
    return this.loadPending({
      key: "children",
      origin: children2,
      def: [],
      onLoad: function onLoad(data5) {
        _this.$handle && _this.$handle.loadChildren(data5, _this);
      },
      onUpdate: function onUpdate(value, oldValue) {
        if (_this.$handle) {
          value === oldValue ? _this.$handle.loadChildren(value, _this) : _this.$handle.updateChildren(_this, value, oldValue);
        }
      },
      onReload: function onReload(value) {
        if (_this.$handle) {
          _this.$handle.updateChildren(_this, [], value);
        } else {
          delete _this.pending.children;
        }
      }
    });
  },
  loadPending: function loadPending(config2) {
    var _this2 = this;
    var key = config2.key, origin = config2.origin, def = config2.def, onLoad = config2.onLoad, onReload = config2.onReload, onUpdate = config2.onUpdate;
    if (this.pending[key] && this.pending[key].origin === origin) {
      return this.getPending(key, def);
    }
    delete this.pending[key];
    var value = origin;
    if (is$3.Function(origin)) {
      var source = invoke$2(function() {
        return origin({
          rule: _this2.rule,
          api: _this2.$api,
          update: function update5(data5) {
            var value2 = data5 || def;
            var oldValue = _this2.getPending(key, def);
            _this2.setPending(key, origin, value2);
            onUpdate && onUpdate(value2, oldValue);
          },
          reload: function reload() {
            var oldValue = _this2.getPending(key, def);
            delete _this2.pending[key];
            onReload && onReload(oldValue);
            _this2.$api && _this2.$api.sync(_this2.rule);
          }
        });
      });
      if (source && is$3.Function(source.then)) {
        source.then(function(data5) {
          var value2 = data5 || def;
          _this2.setPending(key, origin, value2);
          onLoad && onLoad(value2);
          _this2.$api && _this2.$api.sync(_this2.rule);
        });
        value = def;
        this.setPending(key, origin, value);
      } else {
        value = source || def;
        this.setPending(key, origin, value);
        onLoad && onLoad(value);
      }
    }
    return value;
  },
  getPending: function getPending(key, def) {
    return this.pending[key] && this.pending[key].value || def;
  },
  setPending: function setPending(key, origin, value) {
    this.pending[key] = {
      origin,
      value: reactive$1(value)
    };
  },
  effectData: function effectData(name2) {
    if (!this.payload[name2]) {
      this.payload[name2] = {};
    }
    return this.payload[name2];
  },
  clearEffectData: function clearEffectData(name2) {
    if (name2 === void 0) {
      this.payload = {};
    } else {
      delete this.payload[name2];
    }
  },
  updateKey: function updateKey(flag) {
    this.key = uniqueId$2();
    flag && this.parent && this.parent.updateKey(flag);
  },
  updateType: function updateType() {
    this.originType = this.rule.type;
    this.type = toCase(this.rule.type);
  },
  setParser: function setParser(parser) {
    this.parser = parser;
    parser.init(this);
  },
  initProp: function initProp() {
    var _this3 = this;
    var rule2 = _objectSpread2({}, this.rule);
    delete rule2.children;
    this.prop = mergeProps([rule2].concat(_toConsumableArray(Object.keys(this.payload).map(function(k2) {
      return _this3.payload[k2];
    })), [this.computed]));
  },
  initNone: function initNone() {
    this.none = isNone(this);
  },
  check: function check(handle) {
    return this.vm === handle.vm;
  },
  unwatch: function unwatch() {
    this.watch.forEach(function(un2) {
      return un2();
    });
    this.watch = [];
    this.refRule = {};
  },
  unlink: function unlink() {
    this.linkOn.forEach(function(un2) {
      return un2();
    });
    this.linkOn = [];
  },
  link: function link() {
    this.unlink();
    this.$handle.appendLink(this);
  },
  watchTo: function watchTo() {
    this.$handle.watchCtx(this);
  },
  "delete": function _delete2() {
    var undef = void 0;
    this.unwatch();
    this.unlink();
    this.rmCtrl();
    extend$2(this, {
      deleted: true,
      prop: _objectSpread2({}, this.rule),
      computed: {},
      el: undef,
      $handle: undef,
      $render: undef,
      $api: undef,
      vm: undef,
      vNode: undef,
      parent: null,
      cacheConfig: null,
      none: false
    });
  },
  rmCtrl: function rmCtrl() {
    this.ctrlRule.forEach(function(ctrl) {
      return ctrl.__fc__ && ctrl.__fc__.rm();
    });
    this.ctrlRule = [];
  },
  rm: function rm() {
    var _this4 = this;
    var _rm = function _rm2() {
      var index = _this4.root.indexOf(_this4.origin);
      if (index > -1) {
        _this4.root.splice(index, 1);
        _this4.$handle && _this4.$handle.refresh();
      }
    };
    if (this.deleted) {
      _rm();
      return;
    }
    this.$handle.noWatch(function() {
      _this4.$handle.deferSyncValue(function() {
        _this4.rmCtrl();
        _rm();
        _this4.$handle.rmCtx(_this4);
        extend$2(_this4, {
          root: []
        });
      }, _this4.input);
    });
  },
  update: function update2(handle, init5) {
    extend$2(this, {
      deleted: false,
      $handle: handle,
      $render: handle.$render,
      $api: handle.api,
      vm: handle.vm,
      trueType: handle.getType(this.originType),
      vNode: handle.$render.vNode,
      updated: false
    });
    !init5 && this.unwatch();
    this.watchTo();
    this.link();
  }
});
function useLoader(Handler2) {
  extend$2(Handler2.prototype, {
    nextRefresh: function nextRefresh(fn2) {
      var _this = this;
      var id2 = this.loadedId;
      nextTick$1(function() {
        id2 === _this.loadedId && (fn2 ? fn2() : _this.refresh());
      });
    },
    parseRule: function parseRule(_rule) {
      var _this2 = this;
      var rule2 = getRule(_rule);
      Object.defineProperties(rule2, {
        __origin__: enumerable(_rule, true)
      });
      fullRule(rule2);
      this.appendValue(rule2);
      [rule2, rule2["prefix"], rule2["suffix"]].forEach(function(item) {
        if (!item) {
          return;
        }
        _this2.loadFn(item, rule2);
      });
      this.loadCtrl(rule2);
      if (rule2.update) {
        rule2.update = parseFn(rule2.update);
      }
      return rule2;
    },
    loadFn: function loadFn(item, rule2) {
      var _this3 = this;
      ["on", "props", "deep"].forEach(function(k2) {
        item[k2] && _this3.parseInjectEvent(rule2, item[k2]);
      });
    },
    loadCtrl: function loadCtrl(rule2) {
      rule2.control && rule2.control.forEach(function(ctrl) {
        if (ctrl.handle) {
          ctrl.handle = parseFn(ctrl.handle);
        }
      });
    },
    syncProp: function syncProp(ctx) {
      var _this4 = this;
      var rule2 = ctx.rule;
      is$3.trueArray(rule2.sync) && mergeProps([{
        on: rule2.sync.reduce(function(pre, prop) {
          pre["update:".concat(prop)] = function(val2) {
            rule2.props[prop] = val2;
            _this4.vm.emit("sync", prop, val2, rule2, _this4.fapi);
          };
          return pre;
        }, {})
      }], ctx.computed);
    },
    loadRule: function loadRule() {
      var _this5 = this;
      this.cycleLoad = false;
      this.loading = true;
      if (this.pageEnd) {
        this.bus.$emit("load-start");
      }
      this.deferSyncValue(function() {
        _this5._loadRule(_this5.rules);
        _this5.loading = false;
        if (_this5.cycleLoad && _this5.pageEnd) {
          return _this5.loadRule();
        }
        _this5.syncForm();
        if (_this5.pageEnd) {
          _this5.bus.$emit("load-end");
        }
        _this5.vm.setupState.renderRule();
      });
    },
    loadChildren: function loadChildren(children2, parent2) {
      this.cycleLoad = false;
      this.loading = true;
      this.bus.$emit("load-start");
      this._loadRule(children2, parent2);
      this.loading = false;
      if (this.cycleLoad) {
        return this.loadRule();
      } else {
        this.syncForm();
        this.bus.$emit("load-end");
      }
      this.$render.clearCache(parent2);
    },
    _loadRule: function _loadRule(rules, parent2) {
      var _this6 = this;
      var preIndex = function preIndex2(i2) {
        var pre = rules[i2 - 1];
        if (!pre || !pre.__fc__) {
          return i2 > 0 ? preIndex2(i2 - 1) : -1;
        }
        var index = _this6.sort.indexOf(pre.__fc__.id);
        return index > -1 ? index : preIndex2(i2 - 1);
      };
      var loadChildren = function loadChildren2(children2, parent3) {
        if (is$3.trueArray(children2)) {
          _this6._loadRule(children2, parent3);
        }
      };
      rules.map(function(_rule, index) {
        if (parent2 && (is$3.String(_rule) || is$3.Undef(_rule)))
          return;
        if (!_this6.pageEnd && !parent2 && index >= _this6.first)
          return;
        if (_rule.__fc__ && _rule.__fc__.root === rules && _this6.ctxs[_rule.__fc__.id]) {
          loadChildren(_rule.__fc__.loadChildrenPending(), _rule.__fc__);
          return _rule.__fc__;
        }
        var rule2 = getRule(_rule);
        var isRepeat = function isRepeat2() {
          return !!(rule2.field && _this6.fieldCtx[rule2.field] && _this6.fieldCtx[rule2.field][0] !== _rule.__fc__);
        };
        _this6.ruleEffect(rule2, "init", {
          repeat: isRepeat()
        });
        if (isRepeat()) {
          _this6.vm.emit("repeat-field", _rule, _this6.api);
        }
        var ctx;
        var isCopy = false;
        var isInit = !!_rule.__fc__;
        var defaultValue = rule2.value;
        if (isInit) {
          ctx = _rule.__fc__;
          defaultValue = ctx.defaultValue;
          var check2 = !ctx.check(_this6);
          if (ctx.deleted) {
            if (check2) {
              if (isCtrl(ctx)) {
                return;
              }
              ctx.update(_this6);
            }
          } else {
            if (check2) {
              if (isCtrl(ctx)) {
                return;
              }
              rules[index] = _rule = _rule._clone ? _rule._clone() : copyRule(_rule);
              ctx = null;
              isCopy = true;
            }
          }
        }
        if (!ctx) {
          var _rule2 = _this6.parseRule(_rule);
          ctx = new RuleContext(_this6, _rule2, isInit ? defaultValue : _rule2.value);
          _this6.bindParser(ctx);
        } else {
          if (ctx.originType !== ctx.rule.type) {
            ctx.updateType();
            _this6.bindParser(ctx);
          }
          _this6.appendValue(ctx.rule);
        }
        _this6.parseEmit(ctx);
        _this6.syncProp(ctx);
        ctx.parent = parent2 || null;
        ctx.root = rules;
        _this6.setCtx(ctx);
        !isCopy && !isInit && _this6.effect(ctx, "load");
        var _load = ctx.loadChildrenPending();
        ctx.parser.loadChildren === false || loadChildren(_load, ctx);
        if (!parent2) {
          var _preIndex = preIndex(index);
          if (_preIndex > -1 || !index) {
            _this6.sort.splice(_preIndex + 1, 0, ctx.id);
          } else {
            _this6.sort.push(ctx.id);
          }
        }
        var r2 = ctx.rule;
        if (!ctx.updated) {
          ctx.updated = true;
          if (is$3.Function(r2.update)) {
            _this6.bus.$once("load-end", function() {
              _this6.refreshUpdate(ctx, r2.value);
            });
          }
          _this6.effect(ctx, "loaded");
        }
        if (_this6.refreshControl(ctx))
          _this6.cycleLoad = true;
        return ctx;
      });
    },
    refreshControl: function refreshControl(ctx) {
      return ctx.input && ctx.rule.control && this.useCtrl(ctx);
    },
    useCtrl: function useCtrl(ctx) {
      var _this7 = this;
      var controls = getCtrl(ctx), validate2 = [], api = this.api;
      if (!controls.length)
        return false;
      var _loop = function _loop2(i3) {
        var control = controls[i3], handleFn = control.handle || function(val2) {
          return val2 === control.value;
        };
        if (!is$3.trueArray(control.rule))
          return "continue";
        var data5 = _objectSpread2(_objectSpread2({}, control), {}, {
          valid: invoke$2(function() {
            return handleFn(ctx.rule.value, api);
          }),
          ctrl: findCtrl(ctx, control.rule),
          isHidden: is$3.String(control.rule[0])
        });
        if (data5.valid && data5.ctrl || !data5.valid && !data5.ctrl && !data5.isHidden)
          return "continue";
        validate2.push(data5);
      };
      for (var i2 = 0; i2 < controls.length; i2++) {
        var _ret = _loop(i2);
        if (_ret === "continue")
          continue;
      }
      if (!validate2.length)
        return false;
      var hideLst = [];
      var flag = false;
      this.deferSyncValue(function() {
        validate2.reverse().forEach(function(_ref) {
          var isHidden = _ref.isHidden, valid2 = _ref.valid, rule2 = _ref.rule, prepend2 = _ref.prepend, append2 = _ref.append, child = _ref.child, ctrl = _ref.ctrl;
          if (isHidden) {
            valid2 ? ctx.ctrlRule.push({
              __ctrl: true,
              children: rule2,
              valid: valid2
            }) : ctx.ctrlRule.splice(ctx.ctrlRule.indexOf(ctrl), 1);
            hideLst[valid2 ? "push" : "unshift"](function() {
              _this7.api.hidden(!valid2, rule2);
            });
            return;
          }
          if (valid2) {
            flag = true;
            var ruleCon = {
              type: "fragment",
              "native": true,
              __ctrl: true,
              children: rule2
            };
            ctx.ctrlRule.push(ruleCon);
            _this7.bus.$once("load-start", function() {
              if (prepend2) {
                api.prepend(ruleCon, prepend2, child);
              } else if (append2 || child) {
                api.append(ruleCon, append2 || ctx.id, child);
              } else {
                ctx.root.splice(ctx.root.indexOf(ctx.origin) + 1, 0, ruleCon);
              }
            });
          } else {
            ctx.ctrlRule.splice(ctx.ctrlRule.indexOf(ctrl), 1);
            var ctrlCtx = byCtx(ctrl);
            ctrlCtx && ctrlCtx.rm();
          }
        });
      });
      hideLst.length && nextTick$1(function() {
        hideLst.forEach(function(v2) {
          return v2();
        });
      });
      this.vm.emit("control", ctx.origin, this.api);
      this.effect(ctx, "control");
      return flag;
    },
    reloadRule: function reloadRule(rules) {
      return this._reloadRule(rules);
    },
    _reloadRule: function _reloadRule(rules) {
      var _this8 = this;
      if (!rules)
        rules = this.rules;
      var ctxs = _objectSpread2({}, this.ctxs);
      this.clearNextTick();
      this.initData(rules);
      this.fc.rules = rules;
      this.deferSyncValue(function() {
        _this8.bus.$once("load-end", function() {
          Object.keys(ctxs).filter(function(id2) {
            return _this8.ctxs[id2] === void 0;
          }).forEach(function(id2) {
            return _this8.rmCtx(ctxs[id2]);
          });
          _this8.$render.clearCacheAll();
        });
        _this8.reloading = true;
        _this8.loadRule();
        _this8.reloading = false;
        _this8.refresh();
        _this8.bus.$emit("reloading", _this8.api);
      });
      this.bus.$off("next-tick", this.nextReload);
      this.bus.$once("next-tick", this.nextReload);
      this.bus.$emit("update", this.api);
    },
    refresh: function refresh() {
      this.vm.setupState.refresh();
    }
  });
}
function fullRule(rule2) {
  var def = baseRule();
  Object.keys(def).forEach(function(k2) {
    if (!hasProperty$1(rule2, k2))
      rule2[k2] = def[k2];
  });
  return rule2;
}
function getCtrl(ctx) {
  var control = ctx.rule.control || [];
  if (is$3.Object(control))
    return [control];
  else
    return control;
}
function findCtrl(ctx, rule2) {
  for (var i2 = 0; i2 < ctx.ctrlRule.length; i2++) {
    var ctrl = ctx.ctrlRule[i2];
    if (ctrl.children === rule2)
      return ctrl;
  }
}
function isCtrl(ctx) {
  return !!ctx.rule.__ctrl;
}
function useInput(Handler2) {
  extend$2(Handler2.prototype, {
    setValue: function setValue4(ctx, value, formValue, setFlag) {
      if (ctx.deleted)
        return;
      ctx.rule.value = value;
      this.changeStatus = true;
      this.nextRefresh();
      this.$render.clearCache(ctx);
      this.setFormData(ctx, formValue);
      this.syncValue();
      this.valueChange(ctx, value);
      this.vm.emit("change", ctx.field, value, ctx.origin, this.api, setFlag || false);
      this.effect(ctx, "value");
    },
    onInput: function onInput(ctx, value) {
      var val2;
      if (ctx.input && (this.isQuote(ctx, val2 = ctx.parser.toValue(value, ctx)) || this.isChange(ctx, value))) {
        this.setValue(ctx, val2, value);
      }
    },
    setFormData: function setFormData(ctx, value) {
      $set(this.formData, ctx.id, value);
    },
    getFormData: function getFormData(ctx) {
      return this.formData[ctx.id];
    },
    syncForm: function syncForm() {
      var _this = this;
      var data5 = reactive$1({});
      this.fields().reduce(function(initial, field) {
        var ctx = _this.getCtx(field);
        initial[field] = toRef(ctx.rule, "value");
        return initial;
      }, data5);
      this.form = data5;
      this.syncValue();
    },
    appendValue: function appendValue(rule2) {
      if (!rule2.field || !hasProperty$1(this.appendData, rule2.field))
        return;
      rule2.value = this.appendData[rule2.field];
      delete this.appendData[rule2.field];
    },
    addSubForm: function addSubForm(ctx, subForm) {
      this.subForm[ctx.id] = subForm;
    },
    deferSyncValue: function deferSyncValue(fn2, sync) {
      if (!this.deferSyncFn) {
        this.deferSyncFn = fn2;
      }
      if (!this.deferSyncFn.sync) {
        this.deferSyncFn.sync = sync;
      }
      invoke$2(fn2);
      if (this.deferSyncFn === fn2) {
        this.deferSyncFn = null;
        if (fn2.sync) {
          this.syncValue();
        }
      }
    },
    syncValue: function syncValue() {
      if (this.deferSyncFn) {
        return this.deferSyncFn.sync = true;
      }
      this.vm.setupState.updateValue(_objectSpread2({}, this.form));
    },
    isChange: function isChange(ctx, value) {
      return JSON.stringify(this.getFormData(ctx), strFn) !== JSON.stringify(value, strFn);
    },
    isQuote: function isQuote(ctx, value) {
      return (is$3.Object(value) || Array.isArray(value)) && value === ctx.rule.value;
    },
    refreshUpdate: function refreshUpdate(ctx, val2) {
      var _this2 = this;
      if (is$3.Function(ctx.rule.update)) {
        var state = invoke$2(function() {
          return ctx.rule.update(val2, ctx.origin, _this2.api);
        });
        if (state === void 0)
          return;
        ctx.rule.hidden = state === true;
      }
    },
    valueChange: function valueChange(ctx, val2) {
      this.refreshRule(ctx, val2);
      this.bus.$emit("change-" + ctx.field, val2);
    },
    refreshRule: function refreshRule(ctx, val2) {
      if (this.refreshControl(ctx)) {
        this.$render.clearCacheAll();
        this.loadRule();
        this.bus.$emit("update", this.api);
        this.refresh();
      }
      this.refreshUpdate(ctx, val2);
    },
    appendLink: function appendLink(ctx) {
      var _this3 = this;
      var link2 = ctx.rule.link;
      is$3.trueArray(link2) && link2.forEach(function(field) {
        var fn2 = function fn3() {
          return _this3.refreshRule(ctx, ctx.rule.value);
        };
        _this3.bus.$on("change-" + field, fn2);
        ctx.linkOn.push(function() {
          return _this3.bus.$off("change-" + field, fn2);
        });
      });
    },
    fields: function fields() {
      return Object.keys(this.fieldCtx);
    }
  });
}
function strFn(key, val2) {
  return typeof val2 === "function" ? "" + val2 : val2;
}
var BaseParser = {
  init: function init2(ctx) {
  },
  toFormValue: function toFormValue(value, ctx) {
    return value;
  },
  toValue: function toValue(formValue, ctx) {
    return formValue;
  },
  mounted: function mounted2(ctx) {
  },
  render: function render10(children2, ctx) {
    return ctx.$render.defaultRender(ctx, children2);
  },
  preview: function preview(children2, ctx) {
    return this.render(children2, ctx);
  },
  mergeProp: function mergeProp2(ctx) {
  }
};
var _$8 = {
  sum: function sum2(arr) {
    if (Array.isArray(arr)) {
      var val2 = 0;
      arr.map(function(v2) {
        return val2 += v2 || 0;
      });
      return val2;
    }
  },
  column: function column(arr, field) {
    if (Array.isArray(arr)) {
      return arr.map(function(v2) {
        return v2[field];
      });
    }
    return [];
  },
  get: function get2(obj, field, def) {
    var lst = field.split(".");
    var val2 = obj;
    for (var i2 = 0; i2 < lst.length; i2++) {
      if (hasProperty$1(val2, lst[i2])) {
        val2 = val2[lst[i2]];
      } else {
        return def === void 0 ? 0 : def;
      }
    }
    return val2;
  }
};
var noneKey = ["field", "value", "vm", "template", "name", "config", "control", "inject", "sync", "payload", "optionsTo", "update", "slotUpdate", "computed", "component", "cache"];
function useContext(Handler2) {
  extend$2(Handler2.prototype, {
    getCtx: function getCtx(id2) {
      return this.getFieldCtx(id2) || this.getNameCtx(id2)[0] || this.ctxs[id2];
    },
    getCtxs: function getCtxs(id2) {
      return this.fieldCtx[id2] || this.nameCtx[id2] || (this.ctxs[id2] ? [this.ctxs[id2]] : []);
    },
    setIdCtx: function setIdCtx(ctx, key, type2) {
      var field = "".concat(type2, "Ctx");
      if (!this[field][key]) {
        this[field][key] = [ctx];
      } else {
        this[field][key].push(ctx);
      }
    },
    rmIdCtx: function rmIdCtx(ctx, key, type2) {
      var field = "".concat(type2, "Ctx");
      var lst = this[field][key];
      if (!lst)
        return false;
      var flag = lst.splice(lst.indexOf(ctx) >>> 0, 1).length > 0;
      if (!lst.length) {
        delete this[field][key];
      }
      return flag;
    },
    getFieldCtx: function getFieldCtx(field) {
      return (this.fieldCtx[field] || [])[0];
    },
    getNameCtx: function getNameCtx(name2) {
      return this.nameCtx[name2] || [];
    },
    setCtx: function setCtx(ctx) {
      var id2 = ctx.id, field = ctx.field, name2 = ctx.name, rule2 = ctx.rule;
      this.ctxs[id2] = ctx;
      name2 && this.setIdCtx(ctx, name2, "name");
      if (!ctx.input)
        return;
      this.setIdCtx(ctx, field, "field");
      this.setFormData(ctx, ctx.parser.toFormValue(rule2.value, ctx));
      if (this.isMounted && !this.reloading) {
        this.vm.emit("change", ctx.field, rule2.value, ctx.origin, this.api);
      }
    },
    getParser: function getParser(ctx) {
      var list = this.fc.parsers;
      return list[ctx.originType] || list[toCase(ctx.type)] || list[ctx.trueType] || BaseParser;
    },
    bindParser: function bindParser(ctx) {
      ctx.setParser(this.getParser(ctx));
    },
    getType: function getType3(alias2) {
      var map2 = this.fc.CreateNode.aliasMap;
      var type2 = map2[alias2] || map2[toCase(alias2)] || alias2;
      return toCase(type2);
    },
    noWatch: function noWatch(fn2) {
      if (!this.noWatchFn) {
        this.noWatchFn = fn2;
      }
      invoke$2(fn2);
      if (this.noWatchFn === fn2) {
        this.noWatchFn = null;
      }
    },
    watchCtx: function watchCtx(ctx) {
      var _this = this;
      var all = attrs();
      all.filter(function(k2) {
        return k2[0] !== "_" && k2[0] !== "$" && noneKey.indexOf(k2) === -1;
      }).forEach(function(key) {
        var ref2 = toRef(ctx.rule, key);
        var flag = key === "children";
        ctx.refRule[key] = ref2;
        ctx.watch.push(watch$1(flag ? function() {
          return is$3.Function(ref2.value) ? ref2.value : _toConsumableArray(ref2.value || []);
        } : function() {
          return ref2.value;
        }, function(_2, o2) {
          var n2 = ref2.value;
          if (_this.isBreakWatch())
            return;
          if (flag && ctx.parser.loadChildren === false) {
            _this.$render.clearCache(ctx);
            _this.nextRefresh();
            return;
          }
          _this.watching = true;
          if (key === "link") {
            ctx.link();
            return;
          } else if (["props", "on", "deep"].indexOf(key) > -1) {
            _this.parseInjectEvent(ctx.rule, n2 || {});
            if (key === "props" && ctx.input) {
              _this.setFormData(ctx, ctx.parser.toFormValue(ctx.rule.value, ctx));
            }
          } else if (key === "emit")
            _this.parseEmit(ctx);
          else if (["prefix", "suffix"].indexOf(key) > -1)
            n2 && _this.loadFn(n2, ctx.rule);
          else if (key === "type") {
            ctx.updateType();
            _this.bindParser(ctx);
          } else if (flag) {
            if (is$3.Function(o2)) {
              o2 = ctx.getPending("children", []);
            }
            if (is$3.Function(n2)) {
              n2 = ctx.loadChildrenPending();
            }
            _this.updateChildren(ctx, n2, o2);
          }
          _this.$render.clearCache(ctx);
          _this.refresh();
          _this.watching = false;
        }, {
          deep: !flag,
          sync: flag
        }));
      });
      if (ctx.input) {
        var val2 = toRef(ctx.rule, "value");
        ctx.watch.push(watch$1(function() {
          return val2.value;
        }, function() {
          var formValue = ctx.parser.toFormValue(val2.value, ctx);
          if (_this.isChange(ctx, formValue)) {
            _this.setValue(ctx, val2.value, formValue, true);
          }
        }));
        this.bus.$once("load-end", function() {
          var computedRef = toRef(ctx.rule, "computed");
          ctx.watch.push(watch$1(function() {
            var computed2 = computedRef.value;
            if (!computed2)
              return void 0;
            var fn2;
            if (is$3.Function(computed2)) {
              fn2 = function fn3() {
                return computed2(_this.api.form, _this.api);
              };
            } else {
              fn2 = function fn3() {
                return new Function("_", "with(this){ return ".concat(computed2, " }")).call(_this.api.form, _$8);
              };
            }
            return invoke$2(fn2, void 0);
          }, function(n2) {
            val2.value = n2;
          }, {
            immediate: !!computedRef.value
          }));
        });
      }
      this.watchEffect(ctx);
    },
    updateChildren: function updateChildren(ctx, n2, o2) {
      var _this2 = this;
      this.deferSyncValue(function() {
        o2 && o2.forEach(function(child) {
          if ((n2 || []).indexOf(child) === -1 && child && !is$3.String(child) && child.__fc__ && child.__fc__.parent === ctx) {
            _this2.rmCtx(child.__fc__);
          }
        });
        if (is$3.trueArray(n2)) {
          _this2.loadChildren(n2, ctx);
          _this2.bus.$emit("update", _this2.api);
        }
      });
    },
    rmSub: function rmSub(sub2) {
      var _this3 = this;
      is$3.trueArray(sub2) && sub2.forEach(function(r2) {
        r2 && r2.__fc__ && _this3.rmCtx(r2.__fc__);
      });
    },
    rmCtx: function rmCtx(ctx) {
      var _this4 = this;
      if (ctx.deleted)
        return;
      var id2 = ctx.id, field = ctx.field, input4 = ctx.input, name2 = ctx.name;
      $del(this.ctxs, id2);
      $del(this.formData, id2);
      $del(this.subForm, id2);
      $del(this.vm.setupState.ctxInject, id2);
      input4 && this.rmIdCtx(ctx, field, "field");
      name2 && this.rmIdCtx(ctx, name2, "name");
      if (input4 && !hasProperty$1(this.fieldCtx, field)) {
        $del(this.form, field);
      }
      this.deferSyncValue(function() {
        if (!_this4.reloading) {
          if (ctx.parser.loadChildren !== false) {
            var children2 = ctx.getPending("children", ctx.rule.children);
            if (is$3.trueArray(children2)) {
              children2.forEach(function(h2) {
                return h2.__fc__ && _this4.rmCtx(h2.__fc__);
              });
            }
          }
          if (ctx.root === _this4.rules) {
            _this4.vm.setupState.renderRule();
          }
        }
      }, input4);
      var index = this.sort.indexOf(id2);
      if (index > -1) {
        this.sort.splice(index, 1);
      }
      this.$render.clearCache(ctx);
      ctx["delete"]();
      this.effect(ctx, "deleted");
      input4 && !this.fieldCtx[field] && this.vm.emit("remove-field", field, ctx.rule, this.api);
      ctx.rule.__ctrl || this.vm.emit("remove-rule", ctx.rule, this.api);
      return ctx;
    }
  });
}
function useLifecycle(Handler2) {
  extend$2(Handler2.prototype, {
    mounted: function mounted3() {
      var _this = this;
      var _mounted = function _mounted2() {
        _this.isMounted = true;
        _this.lifecycle("mounted");
      };
      if (this.pageEnd) {
        _mounted();
      } else {
        this.bus.$once("page-end", _mounted);
      }
    },
    lifecycle: function lifecycle2(name2) {
      var _this2 = this;
      var fn2 = this.options[name2];
      is$3.Function(fn2) && invoke$2(function() {
        return fn2(_this2.api);
      });
      this.vm.emit(name2, this.api);
    }
  });
}
function useEffect(Handler2) {
  extend$2(Handler2.prototype, {
    useProvider: function useProvider() {
      var _this = this;
      var ps2 = this.fc.providers;
      Object.keys(ps2).forEach(function(k2) {
        var prop = ps2[k2];
        if (is$3.Function(prop)) {
          prop = prop(_this.fc);
        }
        prop._c = getComponent(prop);
        _this.onEffect(prop);
        _this.providers[k2] = prop;
      });
    },
    onEffect: function onEffect(provider) {
      var _this2 = this;
      var used = [];
      (provider._c || ["*"]).forEach(function(name2) {
        var type2 = name2 === "*" ? "*" : _this2.getType(name2);
        if (used.indexOf(type2) > -1)
          return;
        used.push(type2);
        _this2.bus.$on("p:".concat(provider.name, ":").concat(type2, ":").concat(provider.input ? 1 : 0), function(event, args) {
          provider[event] && provider[event].apply(provider, _toConsumableArray(args));
        });
      });
      provider._used = used;
    },
    watchEffect: function watchEffect2(ctx) {
      var _this3 = this;
      var effect = {};
      Object.keys(ctx.rule.effect || {}).forEach(function(k2) {
        effect[k2] = function() {
          return ctx.rule.effect[k2];
        };
      });
      Object.keys(ctx.rule).forEach(function(k2) {
        if (k2[0] === "$") {
          effect[k2.substr(1)] = function() {
            return ctx.rule[k2];
          };
        }
      });
      Object.keys(effect).forEach(function(k2) {
        ctx.watch.push(watch$1(effect[k2], function(n2) {
          _this3.effect(ctx, "watch", _defineProperty$1({}, k2, n2));
        }, {
          deep: true
        }));
      });
    },
    ruleEffect: function ruleEffect(rule2, event, append2) {
      this.emitEffect({
        rule: rule2,
        input: !!rule2.field,
        type: this.getType(rule2.type)
      }, event, append2);
    },
    effect: function effect(ctx, event, custom) {
      this.emitEffect({
        rule: ctx.rule,
        input: ctx.input,
        type: ctx.trueType,
        ctx,
        custom
      }, event);
    },
    getEffect: function getEffect(rule2, name2) {
      if (hasProperty$1(rule2, "$" + name2)) {
        return rule2["$" + name2];
      }
      if (hasProperty$1(rule2, "effect") && hasProperty$1(rule2.effect, name2))
        return rule2.effect[name2];
      return void 0;
    },
    emitEffect: function emitEffect(_ref, event, append2) {
      var _this4 = this;
      var ctx = _ref.ctx, rule2 = _ref.rule, input4 = _ref.input, type2 = _ref.type, custom = _ref.custom;
      if (!type2 || ["fcFragment", "fragment"].indexOf(type2) > -1)
        return;
      var effect = custom ? custom : Object.keys(rule2).reduce(function(i2, k2) {
        if (k2[0] === "$") {
          i2[k2.substr(1)] = rule2[k2];
        }
        return i2;
      }, _objectSpread2({}, rule2.effect || {}));
      Object.keys(effect).forEach(function(attr2) {
        var p2 = _this4.providers[attr2];
        if (!p2 || p2.input && !input4)
          return;
        var _type;
        if (!p2._c) {
          _type = "*";
        } else if (p2._used.indexOf(type2) > -1) {
          _type = type2;
        } else {
          return;
        }
        var data5 = _objectSpread2({
          value: effect[attr2],
          getValue: function getValue2() {
            return _this4.getEffect(rule2, attr2);
          }
        }, append2 || {});
        if (ctx) {
          data5.getProp = function() {
            return ctx.effectData(attr2);
          };
          data5.clearProp = function() {
            return ctx.clearEffectData(attr2);
          };
          data5.mergeProp = function(prop) {
            return mergeProps([prop], data5.getProp());
          };
        }
        _this4.bus.$emit("p:".concat(attr2, ":").concat(_type, ":").concat(p2.input ? 1 : 0), event, [data5, rule2, _this4.api]);
      });
    }
  });
}
function unique(arr) {
  return arr.filter(function(item, index, arr2) {
    return arr2.indexOf(item, 0) === index;
  });
}
function getComponent(p2) {
  var c2 = p2.components;
  if (Array.isArray(c2))
    return unique(c2.filter(function(v2) {
      return v2 !== "*";
    }));
  else if (is$3.String(c2))
    return [c2];
  else
    return false;
}
function Handler$2(fc2) {
  var _this = this;
  funcProxy(this, {
    options: function options() {
      return fc2.options.value || {};
    },
    bus: function bus() {
      return fc2.bus;
    }
  });
  extend$2(this, {
    fc: fc2,
    vm: fc2.vm,
    watching: false,
    loading: false,
    reloading: false,
    noWatchFn: null,
    deferSyncFn: null,
    isMounted: false,
    formData: reactive$1({}),
    subForm: {},
    form: reactive$1({}),
    appendData: {},
    providers: {},
    cycleLoad: null,
    loadedId: 1,
    nextTick: null,
    changeStatus: false,
    pageEnd: true,
    nextReload: function nextReload() {
      _this.lifecycle("reload");
    }
  });
  this.initData(fc2.rules);
  this.$manager = new fc2.manager(this);
  this.$render = new Render(this);
  this.api = fc2.extendApi(Api(this), this);
}
extend$2(Handler$2.prototype, {
  initData: function initData(rules) {
    extend$2(this, {
      ctxs: {},
      fieldCtx: {},
      nameCtx: {},
      sort: [],
      rules
    });
  },
  init: function init3() {
    this.appendData = _objectSpread2(_objectSpread2(_objectSpread2({}, this.options.formData || {}), this.fc.vm.props.modelValue || {}), this.appendData);
    this.useProvider();
    this.usePage();
    this.loadRule();
    this.$manager.__init();
  },
  isBreakWatch: function isBreakWatch() {
    return this.loading || this.noWatchFn || this.reloading;
  }
});
useInject(Handler$2);
usePage(Handler$2);
useRender(Handler$2);
useLoader(Handler$2);
useInput(Handler$2);
useContext(Handler$2);
useLifecycle(Handler$2);
useEffect(Handler$2);
function getError(action, option, xhr) {
  var msg = "fail to ".concat(action, " ").concat(xhr.status, "'");
  var err2 = new Error(msg);
  err2.status = xhr.status;
  err2.url = action;
  return err2;
}
function getBody(xhr) {
  var text2 = xhr.responseText || xhr.response;
  if (!text2) {
    return text2;
  }
  try {
    return JSON.parse(text2);
  } catch (e3) {
    return text2;
  }
}
function fetch$1(option) {
  if (typeof XMLHttpRequest === "undefined") {
    return;
  }
  var xhr = new XMLHttpRequest();
  var action = option.action;
  xhr.onerror = function error(e3) {
    option.onError(e3);
  };
  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr), getBody(xhr));
    }
    option.onSuccess(getBody(xhr));
  };
  xhr.open(option.method || "get", action, true);
  var formData3;
  if (option.data) {
    if ((option.dataType || "").toLowerCase() !== "json") {
      formData3 = new FormData();
      Object.keys(option.data).map(function(key) {
        formData3.append(key, option.data[key]);
      });
    } else {
      formData3 = JSON.stringify(option.data);
      xhr.setRequestHeader("content-type", "application/json");
    }
  }
  if (option.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  var headers = option.headers || {};
  Object.keys(headers).forEach(function(item) {
    if (headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  });
  xhr.send(formData3);
}
var NAME = "fcFragment";
var fragment = defineComponent({
  name: NAME,
  inheritAttrs: false,
  props: ["vnode"],
  render: function render11() {
    return this.vnode;
  }
});
function tidyDirectives(directives) {
  return Object.keys(directives).map(function(n2) {
    var data5 = directives[n2];
    var directive = resolveDirective(n2);
    if (!directive)
      return;
    return [directive, data5.value, data5.arg, data5.modifiers];
  }).filter(function(v2) {
    return !!v2;
  });
}
function makeDirective(data5, vn2) {
  var directives = data5.directives;
  if (!directives)
    return vn2;
  if (!Array.isArray(directives)) {
    directives = [directives];
  }
  return withDirectives(vn2, directives.reduce(function(lst, v2) {
    return lst.concat(tidyDirectives(v2));
  }, []));
}
function CreateNodeFactory() {
  var aliasMap = {};
  function CreateNode() {
  }
  extend$2(CreateNode.prototype, {
    make: function make(tag, data5, children2) {
      return makeDirective(data5, this.h(tag, toProps(data5), children2));
    },
    makeComponent: function makeComponent(type2, data5, children2) {
      try {
        return makeDirective(data5, createVNode(type2, toProps(data5), children2));
      } catch (e3) {
        console.error(e3);
        return createVNode("");
      }
    },
    h: function h2(tag, data5, children2) {
      var isNativeTag = getCurrentInstance$1().appContext.config.isNativeTag(tag);
      if (isNativeTag) {
        delete data5.formCreateInject;
      }
      try {
        return createVNode(isNativeTag ? tag : resolveComponent(tag), data5, children2);
      } catch (e3) {
        console.error(e3);
        return createVNode("");
      }
    },
    aliasMap
  });
  extend$2(CreateNode, {
    aliasMap,
    alias: function alias2(_alias, name2) {
      aliasMap[_alias] = name2;
    },
    use: function use2(nodes) {
      Object.keys(nodes).forEach(function(k2) {
        var line = toLine(k2);
        var lower2 = toString$2(k2).toLocaleLowerCase();
        var v2 = nodes[k2];
        [k2, line, lower2].forEach(function(n2) {
          CreateNode.alias(k2, v2);
          CreateNode.prototype[n2] = function(data5, children2) {
            return this.make(v2, data5, children2);
          };
        });
      });
    }
  });
  return CreateNode;
}
function createManager(proto2) {
  var CustomManager = /* @__PURE__ */ function(_Manager) {
    _inherits(CustomManager2, _Manager);
    var _super = _createSuper(CustomManager2);
    function CustomManager2() {
      _classCallCheck(this, CustomManager2);
      return _super.apply(this, arguments);
    }
    return CustomManager2;
  }(Manager);
  Object.assign(CustomManager.prototype, proto2);
  return CustomManager;
}
function Manager(handler3) {
  extend$2(this, {
    $handle: handler3,
    vm: handler3.vm,
    options: {},
    ref: "fcForm",
    mergeOptionsRule: {
      normal: ["form", "row", "info", "submitBtn", "resetBtn"]
    }
  });
  this.updateKey();
  this.init();
}
extend$2(Manager.prototype, {
  __init: function __init() {
    var _this = this;
    this.$render = this.$handle.$render;
    this.$r = function() {
      var _this$$render;
      return (_this$$render = _this.$render).renderRule.apply(_this$$render, arguments);
    };
  },
  updateKey: function updateKey2() {
    this.key = uniqueId$2();
  },
  init: function init4() {
  },
  update: function update3() {
  },
  beforeRender: function beforeRender() {
  },
  form: function form() {
    return this.vm.refs[this.ref];
  },
  mergeOptions: function mergeOptions(args, opt) {
    var _this2 = this;
    return mergeProps(args.map(function(v2) {
      return _this2.tidyOptions(v2);
    }), opt, this.mergeOptionsRule);
  },
  updateOptions: function updateOptions(options) {
    this.options = this.mergeOptions([options], this.getDefaultOptions());
    this.update();
  },
  tidyOptions: function tidyOptions(options) {
    return options;
  },
  tidyRule: function tidyRule2(ctx) {
  },
  mergeProp: function mergeProp3(ctx) {
  },
  getDefaultOptions: function getDefaultOptions() {
    return {};
  },
  render: function render12(children2) {
  }
});
var fetch$2 = function fetch2(fc2) {
  function parseOpt(option) {
    if (is$3.String(option)) {
      option = {
        action: option,
        to: "options"
      };
    }
    return option;
  }
  function run(inject2, rule2, api) {
    var option = inject2.value;
    if (is$3.Function(option)) {
      option = option(rule2, api);
    }
    option = parseOpt(option);
    if (!option || !option.action) {
      return false;
    }
    if (!option.to) {
      option.to = "options";
    }
    var _onError = option.onError;
    var check2 = function check3() {
      if (!inject2.getValue()) {
        inject2.clearProp();
        api.sync(rule2);
        return true;
      }
    };
    var set2 = function set3(val2) {
      if (val2 === void 0) {
        inject2.clearProp();
        api.sync(rule2);
      } else {
        deepSet(inject2.getProp(), option.to, val2);
      }
    };
    invoke$2(function() {
      return fc2.create.fetch(_objectSpread2(_objectSpread2({}, option), {}, {
        onSuccess: function onSuccess(body) {
          if (check2())
            return;
          var fn2 = function fn3(v2) {
            return v2.data;
          };
          if (is$3.Function(option.parse)) {
            fn2 = option.parse;
          }
          set2(fn2(body, rule2, api));
          api.sync(rule2);
        },
        onError: function onError(e3) {
          set2(void 0);
          if (check2())
            return;
          (_onError || function(e4) {
            return err(e4.message || "fetch fail " + option.action);
          })(e3, rule2, api);
        }
      }), {
        inject: inject2,
        rule: rule2,
        api
      });
    });
    return true;
  }
  return {
    name: "fetch",
    loaded: function loaded() {
      run.apply(void 0, arguments);
    },
    watch: function watch3(inject2, rule2, api) {
      if (!run(inject2, rule2, api)) {
        inject2.clearProp();
        api.sync(rule2);
      }
    }
  };
};
var $provider = {
  fetch: fetch$2
};
var name$6 = "html";
var html$1 = {
  name: name$6,
  loadChildren: false,
  render: function render13(children2, ctx) {
    ctx.prop.props.innerHTML = children2["default"]();
    return ctx.vNode.make(ctx.prop.props.tag || "div", ctx.prop);
  },
  renderChildren: function renderChildren(children2) {
    return {
      "default": function _default15() {
        return children2.filter(function(v2) {
          return is$3.String(v2);
        }).join("");
      }
    };
  }
};
function parseProp(name2, id2) {
  var prop;
  if (arguments.length === 2) {
    prop = arguments[1];
    id2 = prop[name2];
  } else {
    prop = arguments[2];
  }
  return {
    id: id2,
    prop
  };
}
function nameProp() {
  return parseProp.apply(void 0, ["name"].concat(Array.prototype.slice.call(arguments)));
}
function exportAttrs(attrs2) {
  var key = attrs2.key || [];
  var array2 = attrs2.array || [];
  var normal = attrs2.normal || [];
  keyAttrs.push.apply(keyAttrs, _toConsumableArray(key));
  arrayAttrs.push.apply(arrayAttrs, _toConsumableArray(array2));
  normalAttrs.push.apply(normalAttrs, _toConsumableArray(normal));
  appendProto([].concat(_toConsumableArray(key), _toConsumableArray(array2), _toConsumableArray(normal)));
}
var id$b = 1;
var instance = {};
function FormCreateFactory(config2) {
  var components2 = _defineProperty$1({}, fragment.name, fragment);
  var parsers2 = {};
  var directives = {};
  var modelFields = {};
  var useApps = [];
  var providers = _objectSpread2({}, $provider);
  var maker = makerFactory();
  var globalConfig2 = {
    global: {}
  };
  var data5 = {};
  var CreateNode = CreateNodeFactory();
  exportAttrs(config2.attrs || {});
  function getApi(name2) {
    var val2 = instance[name2];
    if (Array.isArray(val2))
      return _toConsumableArray(val2);
    return val2;
  }
  function useApp(fn2) {
    useApps.push(fn2);
  }
  function directive() {
    var data6 = nameProp.apply(void 0, arguments);
    if (data6.id && data6.prop)
      directives[data6.id] = data6.prop;
  }
  function register2() {
    var data6 = nameProp.apply(void 0, arguments);
    if (data6.id && data6.prop)
      providers[data6.id] = _objectSpread2(_objectSpread2({}, data6.prop), {}, {
        name: data6.id
      });
  }
  function componentAlias(alias2) {
    CreateNode.use(alias2);
  }
  function parser() {
    var data6 = nameProp.apply(void 0, arguments);
    if (!data6.id || !data6.prop)
      return;
    var name2 = toCase(data6.id);
    var parser2 = data6.prop;
    var base2 = parser2.merge === true ? parsers2[name2] : void 0;
    parsers2[name2] = _objectSpread2(_objectSpread2({}, base2 || BaseParser), parser2);
    maker[name2] = creatorFactory(name2);
    parser2.maker && extend$2(maker, parser2.maker);
  }
  function component(id2, component2) {
    var name2;
    if (is$3.String(id2)) {
      name2 = toCase(id2);
      if (component2 === void 0) {
        return components2[name2];
      }
    } else {
      name2 = toCase(id2.displayName || id2.name);
      component2 = id2;
    }
    if (!name2 || !component2)
      return;
    components2[name2] = component2;
    if (component2.formCreateParser)
      parser(name2, component2.formCreateParser);
  }
  function $form() {
    return $FormCreate(FormCreate2);
  }
  function createFormApp(rule2, option) {
    var Type = $form();
    return createApp({
      data: function data6() {
        return reactive$1({
          rule: rule2,
          option
        });
      },
      render: function render17() {
        return h$6(Type, _objectSpread2({
          ref: "fc"
        }, this.$data));
      }
    });
  }
  function $vnode() {
    return fragment;
  }
  function use2(fn2, opt) {
    if (is$3.Function(fn2.install))
      fn2.install(create2, opt);
    else if (is$3.Function(fn2))
      fn2(create2, opt);
    return this;
  }
  function create2(rules, option) {
    var app = createFormApp(rules, option || {});
    useApps.forEach(function(v2) {
      invoke$2(function() {
        return v2(create2, app);
      });
    });
    var div2 = document.createElement("div");
    ((option === null || option === void 0 ? void 0 : option.el) || document.body).appendChild(div2);
    var vm = app.mount(div2);
    return vm.$refs.fc.fapi;
  }
  function factory(inherit2) {
    var _config = _objectSpread2({}, config2);
    if (inherit2) {
      _config.inherit = {
        components: components2,
        parsers: parsers2,
        directives,
        modelFields,
        providers,
        useApps,
        maker,
        data: data5
      };
    } else {
      delete _config.inherit;
    }
    return FormCreateFactory(_config);
  }
  function setModelField(name2, field) {
    modelFields[name2] = field;
  }
  function FormCreate2(vm) {
    var _this = this;
    extend$2(this, {
      id: id$b++,
      create: create2,
      vm,
      manager: createManager(config2.manager),
      parsers: parsers2,
      providers,
      modelFields,
      rules: vm.props.rule,
      name: vm.props.name,
      inFor: vm.props.inFor,
      prop: {
        components: components2,
        directives
      },
      CreateNode,
      bus: new Mitt(),
      unwatch: null,
      options: ref$1(vm.props.option || {}),
      extendApi: config2.extendApi || function(api) {
        return api;
      }
    });
    nextTick$1(function() {
      watch$1(_this.options, function() {
        _this.$handle.$manager.updateOptions(_this.options.value);
        _this.api().refresh();
      }, {
        deep: true
      });
    });
    extend$2(vm.appContext.components, components2);
    extend$2(vm.appContext.directives, directives);
    this.$handle = new Handler$2(this);
    if (this.name) {
      if (this.inFor) {
        if (!instance[this.name])
          instance[this.name] = [];
        instance[this.name].push(this.api());
      } else {
        instance[this.name] = this.api();
      }
    }
  }
  extend$2(FormCreate2.prototype, {
    init: function init5() {
      var _this2 = this;
      if (this.isSub()) {
        this.unwatch = watch$1(function() {
          return _this2.vm.parent.option;
        }, function() {
          _this2.initOptions(_this2.options.value);
          _this2.$handle.api.refresh();
        }, {
          deep: true
        });
      }
      this.initOptions(this.options.value);
      this.$handle.init();
    },
    isSub: function isSub() {
      return this.vm.setupState.parent && this.vm.setupState.extendOption;
    },
    initOptions: function initOptions(options) {
      this.options.value = _objectSpread2({
        formData: {},
        submitBtn: {},
        resetBtn: {}
      }, deepCopy(globalConfig2));
      if (this.isSub()) {
        this.options.value = this.mergeOptions(this.options.value, this.vm.setupState.parent.setupState.fapi.config || {}, true);
      }
      this.updateOptions(options);
    },
    mergeOptions: function mergeOptions2(target, opt, parent2) {
      opt = deepCopy(opt);
      parent2 && ["page", "onSubmit", "mounted", "reload", "formData", "el"].forEach(function(n2) {
        delete opt[n2];
      });
      if (opt.global) {
        target.global = mergeGlobal(target.global, opt.global);
        delete opt.global;
      }
      this.$handle.$manager.mergeOptions([opt], target);
      return target;
    },
    updateOptions: function updateOptions2(options) {
      this.options.value = this.mergeOptions(this.options.value, options);
      this.$handle.$manager.updateOptions(this.options.value);
    },
    api: function api() {
      return this.$handle.api;
    },
    render: function render17() {
      return this.$handle.render();
    },
    mounted: function mounted3() {
      this.$handle.mounted();
    },
    unmount: function unmount() {
      if (this.name) {
        if (this.inFor) {
          var idx = instance[this.name].indexOf(this.api());
          instance[this.name].splice(idx, 1);
        } else {
          delete instance[this.name];
        }
      }
      this.unwatch && this.unwatch();
      this.$handle.reloadRule([]);
    },
    updated: function updated() {
      var _this3 = this;
      this.$handle.bindNextTick(function() {
        return _this3.bus.$emit("next-tick", _this3.$handle.api);
      });
    }
  });
  function useAttr(formCreate) {
    extend$2(formCreate, {
      version: config2.version,
      ui: config2.ui,
      data: data5,
      maker,
      component,
      directive,
      setModelField,
      register: register2,
      $vnode,
      parser,
      use: use2,
      factory,
      componentAlias,
      copyRule,
      copyRules,
      fetch: fetch$1,
      $form,
      parseFn,
      parseJson,
      toJson,
      useApp,
      getApi
    });
  }
  function useStatic(formCreate) {
    extend$2(formCreate, {
      create: create2,
      install: function install2(app, options) {
        globalConfig2 = _objectSpread2(_objectSpread2({}, globalConfig2), options || {});
        if (app._installedFormCreate === true)
          return;
        app._installedFormCreate = true;
        var $formCreate = function $formCreate2(rules) {
          var opt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return create2(rules, opt);
        };
        useAttr($formCreate);
        app.config.globalProperties.$formCreate = $formCreate;
        app.component("FormCreate", $form());
        useApps.forEach(function(v2) {
          invoke$2(function() {
            return v2(formCreate, app);
          });
        });
      }
    });
  }
  useAttr(create2);
  useStatic(create2);
  CreateNode.use({
    fragment: "fcFragment"
  });
  config2.install && create2.use(config2);
  useApp(function(_2, app) {
    app.mixin({
      props: ["formCreateInject"]
    });
  });
  parser(html$1);
  if (config2.inherit) {
    var inherit = config2.inherit;
    inherit.components && extend$2(components2, inherit.components);
    inherit.parsers && extend$2(parsers2, inherit.parsers);
    inherit.directives && extend$2(directives, inherit.directives);
    inherit.modelFields && extend$2(modelFields, inherit.modelFields);
    inherit.providers && extend$2(providers, inherit.providers);
    inherit.useApps && extend$2(useApps, inherit.useApps);
    inherit.maker && extend$2(maker, inherit.maker);
    inherit.data && extend$2(data5, inherit.data);
  }
  return create2;
}
var DEFAULT_FORMATS = {
  date: "YYYY-MM-DD",
  month: "YYYY-MM",
  datetime: "YYYY-MM-DD HH:mm:ss",
  timerange: "HH:mm:ss",
  daterange: "YYYY-MM-DD",
  monthrange: "YYYY-MM",
  datetimerange: "YYYY-MM-DD HH:mm:ss",
  year: "YYYY"
};
var name$5 = "datePicker";
var datePicker = {
  name: name$5,
  maker: function() {
    return ["year", "month", "date", "dates", "week", "datetime", "datetimeRange", "dateRange", "monthRange"].reduce(function(initial, type2) {
      initial[type2] = creatorFactory(name$5, {
        type: type2.toLowerCase()
      });
      return initial;
    }, {});
  }(),
  mergeProp: function mergeProp4(ctx) {
    var props = ctx.prop.props;
    if (!props.valueFormat) {
      props.valueFormat = DEFAULT_FORMATS[props.type] || DEFAULT_FORMATS["date"];
    }
  }
};
var name$4 = "hidden";
var hidden = {
  name: name$4,
  maker: _defineProperty$1({}, name$4, function(field, value) {
    return creatorFactory(name$4)("", field, value);
  }),
  render: function render14() {
    return [];
  }
};
var name$3 = "input";
var input = {
  name: name$3,
  maker: function() {
    var maker = ["password", "url", "email", "text", "textarea"].reduce(function(maker2, type2) {
      maker2[type2] = creatorFactory(name$3, {
        type: type2
      });
      return maker2;
    }, {});
    maker.idate = creatorFactory(name$3, {
      type: "date"
    });
    return maker;
  }(),
  mergeProp: function mergeProp5(ctx) {
    var props = ctx.prop.props;
    if (props && props.autosize && props.autosize.minRows) {
      props.rows = props.autosize.minRows || 2;
    }
  }
};
var name$2 = "slider";
var slider = {
  name: name$2,
  maker: {
    sliderRange: creatorFactory(name$2, {
      range: true
    })
  },
  toFormValue: function toFormValue2(value, ctx) {
    var isArr = Array.isArray(value), props = ctx.prop.props, min3 = props.min || 0, parseValue;
    if (props.range === true) {
      parseValue = isArr ? value : [min3, parseFloat(value) || min3];
    } else {
      parseValue = isArr ? parseFloat(value[0]) || min3 : parseFloat(value);
    }
    return parseValue;
  }
};
var name$1 = "timePicker";
var timePicker = {
  name: name$1,
  maker: {
    time: creatorFactory(name$1, function(m2) {
      return m2.props.isRange = false;
    }),
    timeRange: creatorFactory(name$1, function(m2) {
      return m2.props.isRange = true;
    })
  },
  mergeProp: function mergeProp6(ctx) {
    var props = ctx.prop.props;
    if (!props.valueFormat) {
      props.valueFormat = "HH:mm:ss";
    }
  }
};
var row = {
  name: "FcRow",
  render: function render15(_2, ctx) {
    return ctx.vNode.col({
      props: {
        span: 24
      }
    }, {
      "default": function _default15() {
        return [ctx.vNode.row(ctx.prop, _2)];
      }
    });
  }
};
var name = "select";
var select = {
  name,
  toFormValue: function toFormValue3(value, ctx) {
    if (ctx.prop.props.multiple && !Array.isArray(value)) {
      return toArray$5(value);
    } else {
      return value;
    }
  }
};
var parsers = [datePicker, hidden, input, slider, timePicker, row, select];
var PRE = "el";
var alias = {
  button: PRE + "-button",
  icon: PRE + "-icon",
  slider: PRE + "-slider",
  rate: PRE + "-rate",
  upload: "fc-upload",
  cascader: PRE + "-cascader",
  popover: PRE + "-popover",
  tooltip: PRE + "-tooltip",
  colorPicker: PRE + "-colorPicker",
  timePicker: PRE + "-time-picker",
  timeSelect: PRE + "-time-select",
  datePicker: PRE + "-date-picker",
  "switch": PRE + "-switch",
  select: "fc-select",
  checkbox: "fc-checkbox",
  radio: "fc-radio",
  inputNumber: PRE + "-input-number",
  number: PRE + "-input-number",
  input: PRE + "-input",
  formItem: PRE + "-form-item",
  form: PRE + "-form",
  frame: "fc-frame",
  col: PRE + "-col",
  row: PRE + "-row",
  tree: "fc-tree",
  autoComplete: PRE + "-autocomplete",
  auto: PRE + "-autocomplete",
  group: "fc-group",
  object: "fc-sub-form",
  subForm: "fc-sub-form"
};
function getConfig() {
  return {
    form: {
      inline: false,
      labelPosition: "right",
      labelWidth: "125px",
      disabled: false,
      size: void 0
    },
    row: {
      show: true,
      gutter: 0
    },
    submitBtn: {
      type: "primary",
      loading: false,
      disabled: false,
      innerText: "\u63D0\u4EA4",
      show: true,
      col: void 0,
      click: void 0
    },
    resetBtn: {
      type: "default",
      loading: false,
      disabled: false,
      innerText: "\u91CD\u7F6E",
      show: false,
      col: void 0,
      click: void 0
    }
  };
}
function isTooltip(info2) {
  return info2.type === "tooltip";
}
function tidy(props, name2) {
  if (!hasProperty$1(props, name2))
    return;
  if (is$3.String(props[name2])) {
    var _props$name;
    props[name2] = (_props$name = {}, _defineProperty$1(_props$name, name2, props[name2]), _defineProperty$1(_props$name, "show", true), _props$name);
  }
}
function isFalse(val2) {
  return val2 === false;
}
function tidyBool(opt, name2) {
  if (hasProperty$1(opt, name2) && !is$3.Object(opt[name2])) {
    opt[name2] = {
      show: !!opt[name2]
    };
  }
}
function tidyRule(rule2) {
  var _rule = _objectSpread2({}, rule2);
  delete _rule.children;
  return _rule;
}
var manager = {
  validate: function validate() {
    var form2 = this.form();
    if (form2) {
      return form2.validate();
    } else {
      return new Promise(function(v2) {
        return v2();
      });
    }
  },
  validateField: function validateField(field) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var form2 = _this.form();
      if (form2) {
        form2.validateField(field, function(res) {
          res ? reject(res) : resolve(null);
        });
      } else {
        resolve();
      }
    });
  },
  clearValidateState: function clearValidateState(ctx) {
    var fItem = this.vm.refs[ctx.wrapRef];
    if (fItem) {
      fItem.clearValidate();
    }
  },
  tidyOptions: function tidyOptions2(options) {
    ["submitBtn", "resetBtn", "row", "info", "wrap", "col"].forEach(function(name2) {
      tidyBool(options, name2);
    });
    return options;
  },
  tidyRule: function tidyRule3(_ref) {
    var prop = _ref.prop;
    tidy(prop, "title");
    tidy(prop, "info");
    return prop;
  },
  mergeProp: function mergeProp7(ctx) {
    ctx.prop = mergeProps([{
      info: this.options.info || {},
      wrap: this.options.wrap || {},
      col: this.options.col || {}
    }, ctx.prop], {
      info: {
        trigger: "hover",
        placement: "top-start",
        icon: true
      },
      title: {},
      col: {
        span: 24
      },
      wrap: {}
    }, {
      normal: ["title", "info", "col", "wrap"]
    });
  },
  getDefaultOptions: function getDefaultOptions2() {
    return getConfig();
  },
  update: function update4() {
    var form2 = this.options.form;
    this.rule = {
      props: _objectSpread2({}, form2),
      on: {
        submit: function submit(e3) {
          e3.preventDefault();
        }
      },
      "class": [form2.className, form2["class"], "form-create"],
      style: form2.style,
      type: "form"
    };
  },
  beforeRender: function beforeRender2() {
    var key = this.key, ref2 = this.ref, $handle = this.$handle;
    extend$2(this.rule, {
      key,
      ref: ref2
    });
    extend$2(this.rule.props, {
      model: $handle.formData
    });
  },
  render: function render16(children2) {
    var _this2 = this;
    if (children2.slotLen()) {
      children2.setSlot(void 0, function() {
        return _this2.makeFormBtn();
      });
    }
    return this.$r(this.rule, isFalse(this.options.row.show) ? children2.getSlots() : [this.makeRow(children2)]);
  },
  makeWrap: function makeWrap(ctx, children2) {
    var _this3 = this;
    var rule2 = ctx.prop;
    var uni = "".concat(this.key).concat(ctx.key);
    var col = rule2.col;
    var isTitle2 = this.isTitle(rule2);
    var labelWidth = !col.labelWidth && !isTitle2 ? 0 : col.labelWidth;
    var _this$rule$props = this.rule.props, inline = _this$rule$props.inline, _col = _this$rule$props.col;
    var item = isFalse(rule2.wrap.show) ? children2 : this.$r(mergeProps([rule2.wrap, {
      props: _objectSpread2(_objectSpread2({
        labelWidth: labelWidth === void 0 ? labelWidth : toString$2(labelWidth),
        label: isTitle2 ? rule2.title.title : void 0
      }, tidyRule(rule2.wrap || {})), {}, {
        prop: ctx.id,
        rules: rule2.validate
      }),
      "class": rule2.className,
      key: "".concat(uni, "fi"),
      ref: ctx.wrapRef,
      type: "formItem"
    }]), _objectSpread2({
      "default": function _default15() {
        return children2;
      }
    }, isTitle2 ? {
      label: function label() {
        return _this3.makeInfo(rule2, uni);
      }
    } : {}));
    return inline === true || isFalse(_col) || isFalse(col.show) ? item : this.makeCol(rule2, uni, [item]);
  },
  isTitle: function isTitle(rule2) {
    if (this.options.form.title === false)
      return false;
    var title = rule2.title;
    return !(!title.title && !title["native"] || isFalse(title.show));
  },
  makeInfo: function makeInfo(rule2, uni) {
    var _this4 = this;
    var titleProp = _objectSpread2({}, rule2.title);
    var infoProp = _objectSpread2({}, rule2.info);
    var isTip = isTooltip(infoProp);
    var form2 = this.options.form;
    var children2 = [(titleProp.title || "") + (form2.labelSuffix || form2["label-suffix"] || "")];
    if (!isFalse(infoProp.show) && (infoProp.info || infoProp["native"]) && !isFalse(infoProp.icon)) {
      var prop = {
        type: infoProp.type || "popover",
        props: tidyRule(infoProp),
        key: "".concat(uni, "pop")
      };
      delete prop.props.icon;
      delete prop.props.show;
      delete prop.props.info;
      delete prop.props.align;
      delete prop.props["native"];
      var field = "content";
      if (infoProp.info && !hasProperty$1(prop.props, field)) {
        prop.props[field] = infoProp.info;
      }
      children2[infoProp.align !== "left" ? "unshift" : "push"](this.$r(mergeProps([infoProp, prop]), _defineProperty$1({}, titleProp.slot || (isTip ? "default" : "reference"), function() {
        return _this4.$r({
          type: "ElIcon",
          style: "top:2px",
          key: "".concat(uni, "i")
        }, {
          "default": function _default15() {
            return _this4.$r({
              type: infoProp.icon === true ? "icon-warning" : infoProp.icon
            });
          }
        }, true);
      })));
    }
    var _prop = mergeProps([titleProp, {
      props: tidyRule(titleProp),
      key: "".concat(uni, "tit"),
      type: titleProp.type || "span"
    }]);
    delete _prop.props.show;
    delete _prop.props.title;
    delete _prop.props["native"];
    return this.$r(_prop, children2);
  },
  makeCol: function makeCol(rule2, uni, children2) {
    var col = rule2.col;
    return this.$r({
      "class": col["class"],
      type: "col",
      props: col || {
        span: 24
      },
      key: "".concat(uni, "col")
    }, children2);
  },
  makeRow: function makeRow(children2) {
    var row2 = this.options.row || {};
    return this.$r({
      type: "row",
      props: row2,
      "class": row2["class"],
      key: "".concat(this.key, "row")
    }, children2);
  },
  makeFormBtn: function makeFormBtn() {
    var vn2 = [];
    if (!isFalse(this.options.submitBtn.show)) {
      vn2.push(this.makeSubmitBtn());
    }
    if (!isFalse(this.options.resetBtn.show)) {
      vn2.push(this.makeResetBtn());
    }
    if (!vn2.length) {
      return;
    }
    var item = this.$r({
      type: "formItem",
      key: "".concat(this.key, "fb")
    }, vn2);
    return this.rule.props.inline === true ? item : this.$r({
      type: "col",
      props: {
        span: 24
      },
      key: "".concat(this.key, "fc")
    }, [item]);
  },
  makeResetBtn: function makeResetBtn() {
    var _this5 = this;
    var resetBtn = _objectSpread2({}, this.options.resetBtn);
    var innerText = resetBtn.innerText;
    delete resetBtn.innerText;
    delete resetBtn.click;
    delete resetBtn.col;
    delete resetBtn.show;
    return this.$r({
      type: "button",
      props: resetBtn,
      style: {
        width: resetBtn.width
      },
      on: {
        click: function click2() {
          var fApi = _this5.$handle.api;
          _this5.options.resetBtn.click ? _this5.options.resetBtn.click(fApi) : fApi.resetFields();
        }
      },
      key: "".concat(this.key, "b2")
    }, [innerText]);
  },
  makeSubmitBtn: function makeSubmitBtn() {
    var _this6 = this;
    var submitBtn = _objectSpread2({}, this.options.submitBtn);
    var innerText = submitBtn.innerText;
    delete submitBtn.innerText;
    delete submitBtn.click;
    delete submitBtn.col;
    delete submitBtn.show;
    return this.$r({
      type: "button",
      props: submitBtn,
      style: {
        width: submitBtn.width
      },
      on: {
        click: function click2() {
          var fApi = _this6.$handle.api;
          _this6.options.submitBtn.click ? _this6.options.submitBtn.click(fApi) : fApi.submit();
        }
      },
      key: "".concat(this.key, "b1")
    }, [innerText]);
  }
};
var maker$1 = {};
useAlias(maker$1);
useSelect(maker$1);
useTree(maker$1);
useUpload(maker$1);
useFrame(maker$1);
function useAlias(maker) {
  ["group", "tree", "switch", "upload", "autoComplete", "checkbox", "cascader", "colorPicker", "datePicker", "frame", "inputNumber", "radio", "rate"].forEach(function(name2) {
    maker[name2] = creatorFactory(name2);
  });
  maker.auto = maker.autoComplete;
  maker.number = maker.inputNumber;
  maker.color = maker.colorPicker;
}
function useSelect(maker) {
  var select2 = "select";
  var multiple = "multiple";
  maker["selectMultiple"] = creatorFactory(select2, _defineProperty$1({}, multiple, true));
  maker["selectOne"] = creatorFactory(select2, _defineProperty$1({}, multiple, false));
}
function useTree(maker) {
  var name2 = "tree";
  var types = {
    "treeSelected": "selected",
    "treeChecked": "checked"
  };
  Object.keys(types).reduce(function(m2, key) {
    m2[key] = creatorFactory(name2, {
      type: types[key]
    });
    return m2;
  }, maker);
}
function useUpload(maker) {
  var name2 = "upload";
  var types = {
    image: ["image", 0],
    file: ["file", 0],
    uploadFileOne: ["file", 1],
    uploadImageOne: ["image", 1]
  };
  Object.keys(types).reduce(function(m2, key) {
    m2[key] = creatorFactory(name2, function(m3) {
      return m3.props({
        uploadType: types[key][0],
        maxLength: types[key][1]
      });
    });
    return m2;
  }, maker);
  maker.uploadImage = maker.image;
  maker.uploadFile = maker.file;
}
function useFrame(maker) {
  var types = {
    frameInputs: ["input", 0],
    frameFiles: ["file", 0],
    frameImages: ["image", 0],
    frameInputOne: ["input", 1],
    frameFileOne: ["file", 1],
    frameImageOne: ["image", 1]
  };
  Object.keys(types).reduce(function(maker2, key) {
    maker2[key] = creatorFactory("frame", function(m2) {
      return m2.props({
        type: types[key][0],
        maxLength: types[key][1]
      });
    });
    return maker2;
  }, maker);
  maker.frameInput = maker.frameInputs;
  maker.frameFile = maker.frameFiles;
  maker.frameImage = maker.frameImages;
  return maker;
}
var css_248z = ".form-create .form-create .el-form-item{margin-bottom:22px}.form-create .form-create .el-form-item .el-form-item{margin-bottom:0}.form-create{width:100%}";
styleInject(css_248z);
function tidyBtnProp(btn, def) {
  if (is$3.Boolean(btn))
    btn = {
      show: btn
    };
  else if (!is$3.Undef(btn) && !is$3.Object(btn))
    btn = {
      show: def
    };
  return btn;
}
function extendApi(api, h2) {
  extend$2(api, {
    validate: function validate2(callback) {
      return new Promise(function(resolve, reject) {
        var forms = api.children;
        var all = [h2.$manager.validate()];
        forms.forEach(function(v2) {
          all.push(v2.validate());
        });
        Promise.all(all).then(function() {
          resolve(true);
          callback && callback(true);
        })["catch"](function(e3) {
          reject(e3);
          callback && callback(e3);
        });
      });
    },
    validateField: function validateField2(field, callback) {
      return new Promise(function(resolve, reject) {
        var ctx = h2.getFieldCtx(field);
        if (!ctx)
          return;
        var sub2 = h2.subForm[ctx.id];
        var all = [h2.$manager.validateField(ctx.id)];
        toArray$5(sub2).forEach(function(v2) {
          all.push(v2.validate());
        });
        Promise.all(all).then(function() {
          resolve(null);
          callback && callback(null);
        })["catch"](function(e3) {
          reject(e3);
          callback && callback(e3);
        });
      });
    },
    clearValidateState: function clearValidateState2(fields) {
      var _this = this;
      var clearSub = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      api.helper.tidyFields(fields).forEach(function(field) {
        if (clearSub)
          _this.clearSubValidateState(field);
        h2.getCtxs(field).forEach(function(ctx) {
          h2.$manager.clearValidateState(ctx);
        });
      });
    },
    clearSubValidateState: function clearSubValidateState(fields) {
      api.helper.tidyFields(fields).forEach(function(field) {
        h2.getCtxs(field).forEach(function(ctx) {
          var subForm = h2.subForm[ctx.id];
          if (!subForm)
            return;
          if (Array.isArray(subForm)) {
            subForm.forEach(function(form2) {
              form2.clearValidateState();
            });
          } else if (subForm) {
            subForm.clearValidateState();
          }
        });
      });
    },
    btn: {
      loading: function loading() {
        var _loading = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.submitBtnProps({
          loading: !!_loading
        });
      },
      disabled: function disabled3() {
        var _disabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.submitBtnProps({
          disabled: !!_disabled
        });
      },
      show: function show2() {
        var isShow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.submitBtnProps({
          show: !!isShow
        });
      }
    },
    resetBtn: {
      loading: function loading() {
        var _loading2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.resetBtnProps({
          loading: !!_loading2
        });
      },
      disabled: function disabled3() {
        var _disabled2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.resetBtnProps({
          disabled: !!_disabled2
        });
      },
      show: function show2() {
        var isShow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        api.resetBtnProps({
          show: !!isShow
        });
      }
    },
    submitBtnProps: function submitBtnProps() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var btn = tidyBtnProp(h2.options.submitBtn, true);
      extend$2(btn, props);
      h2.options.submitBtn = btn;
      api.refreshOptions();
    },
    resetBtnProps: function resetBtnProps() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var btn = tidyBtnProp(h2.options.resetBtn, false);
      extend$2(btn, props);
      h2.options.resetBtn = btn;
      api.refreshOptions();
    },
    submit: function submit(successFn, failFn) {
      return new Promise(function(resolve, reject) {
        api.validate().then(function() {
          var formData3 = api.formData();
          is$3.Function(successFn) && invoke$2(function() {
            return successFn(formData3, api);
          });
          is$3.Function(h2.options.onSubmit) && invoke$2(function() {
            return h2.options.onSubmit(formData3, api);
          });
          h2.vm.emit("submit", formData3, api);
          resolve(formData3);
        })["catch"](function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          is$3.Function(failFn) && invoke$2(function() {
            return failFn.apply(void 0, [api].concat(args));
          });
          reject.apply(void 0, args);
        });
      });
    }
  });
  return api;
}
var required = {
  name: "required",
  load: function load(inject2, rule2, api) {
    var val2 = parseVal(inject2.getValue());
    if (val2.required === false) {
      inject2.clearProp();
    } else {
      var validate2 = _objectSpread2({
        required: true,
        validator: function validator(_2, v2, call) {
          is$3.empty(v2) ? call(validate2.message) : call();
        }
      }, val2);
      if (!validate2.message) {
        var title = rule2.title || "";
        validate2.message = ((_typeof(title) === "object" ? title.title : title) || "") + "\u4E0D\u80FD\u4E3A\u7A7A";
      }
      inject2.getProp().validate = [validate2];
    }
    api.sync(rule2);
  },
  watch: function watch2() {
    required.load.apply(required, arguments);
  }
};
function parseVal(val2) {
  if (is$3.Boolean(val2)) {
    return {
      required: val2
    };
  } else if (is$3.String(val2)) {
    return {
      message: val2
    };
  } else if (is$3.Function(val2)) {
    return {
      validator: val2
    };
  } else if (!is$3.Object(val2)) {
    return {};
  } else {
    return val2;
  }
}
function install$f(FormCreate2) {
  FormCreate2.componentAlias(alias);
  components.forEach(function(component) {
    FormCreate2.component(component.name, component);
  });
  FormCreate2.register(required);
  parsers.forEach(function(parser) {
    FormCreate2.parser(parser);
  });
  Object.keys(maker$1).forEach(function(name2) {
    FormCreate2.maker[name2] = maker$1[name2];
  });
  if (typeof window !== "undefined" && window.ElementPlus) {
    FormCreate2.useApp(function(_2, app) {
      app.use(window.ElementPlus);
    });
  }
}
function elmFormCreate() {
  return FormCreateFactory({
    ui: "element-ui",
    version: "3.1.15",
    manager,
    extendApi,
    install: install$f,
    attrs: {
      normal: ["col", "wrap"],
      array: ["className"],
      key: ["title", "info"]
    }
  });
}
var FormCreate = elmFormCreate();
if (typeof window !== "undefined") {
  window.formCreate = FormCreate;
}
FormCreate.maker;
var FitsFormCreate_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$j = { class: "FitsFormCreate" };
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "FitsFormCreate",
  props: {
    form: null
  },
  setup(__props, { expose }) {
    const props = __props;
    useCssVars((_ctx) => ({
      "70d59c41": itemWidth.value
    }));
    const FormCreate$1 = FormCreate.$form();
    const formValue = ref({});
    const fApi = ref({});
    const rule2 = ref([...props.form.rule]);
    const itemWidth = ref();
    expose({
      fApi
    });
    onMounted(() => {
      if (props.form.col) {
        itemWidth.value = 100 / props.form.col + "%";
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createVNode(unref$1(FormCreate$1), {
          api: fApi.value,
          "onUpdate:api": _cache[0] || (_cache[0] = ($event) => fApi.value = $event),
          modelValue: formValue.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formValue.value = $event),
          rule: rule2.value,
          option: __props.form.option,
          class: "FormCreate"
        }, null, 8, ["api", "modelValue", "rule", "option"])
      ]);
    };
  }
});
var FitsDialog_vue_vue_type_style_index_0_scoped_true_lang = "";
var FitsDialog_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$i = { class: "dialog" };
const _hoisted_2$9 = { class: "dialog-body" };
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  __name: "FitsDialog",
  props: {
    visible: { type: Boolean, default: false },
    submitText: { default: "\u786E\u5B9A" },
    cancelText: { default: "\u53D6\u6D88" },
    class: null,
    showFooter: { type: Boolean, default: true },
    dialogProp: null
  },
  emits: ["cancel", "submit", "open"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      isVisible: false,
      dialogMarginTop: "0"
    });
    const { isVisible, dialogMarginTop } = toRefs(state);
    const elDialogRef = ref();
    watch(() => props.visible, (newVal) => {
      isVisible.value = newVal;
      newVal && emit("open");
      !newVal && emit("cancel");
      nextTick(() => {
        updatedWindowHeight();
      });
    });
    function emitSave() {
      emit("submit");
    }
    function emitcancel() {
      emit("cancel");
    }
    function updatedWindowHeight() {
      const dialogWindowHeight = elDialogRef.value.dialogContentRef.$el.getBoundingClientRect().height;
      const dialogWrapWindowHeight = elDialogRef.value.dialogContentRef.$parent.$parent.$el.getBoundingClientRect().height;
      if (dialogWindowHeight > 540) {
        dialogMarginTop.value = "0";
      } else {
        dialogMarginTop.value = dialogWrapWindowHeight < 540 ? "20px" : "-10vh";
      }
    }
    return (_ctx, _cache) => {
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_button = resolveComponent("el-button");
      const _component_el_dialog = resolveComponent("el-dialog");
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createVNode(_component_el_dialog, mergeProps$1({
          ref_key: "elDialogRef",
          ref: elDialogRef,
          class: props.class ? props.class + " fits-dialog" : "fits-dialog",
          "close-on-click-modal": false
        }, __props.dialogProp, {
          modelValue: unref$1(isVisible),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(isVisible) ? isVisible.value = $event : null),
          top: unref$1(dialogMarginTop),
          onClose: emitcancel
        }), createSlots({
          header: withCtx(({ close: close2, titleId, titleClass }) => [
            renderSlot(_ctx.$slots, "header", {
              class: "dialog-header",
              close: close2,
              titleId,
              titleClass
            }, void 0, true)
          ]),
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$9, [
              createVNode(_component_el_scrollbar, { noresize: true }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {}, void 0, true)
                ]),
                _: 3
              })
            ])
          ]),
          _: 2
        }, [
          __props.showFooter ? {
            name: "footer",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "footer", {}, () => [
                createVNode(_component_el_button, {
                  onClick: emitcancel,
                  class: "cancelBtn"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.cancelText), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_button, {
                  onClick: emitSave,
                  type: "primary",
                  class: "sureBtn"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.submitText), 1)
                  ]),
                  _: 1
                })
              ], true)
            ])
          } : void 0
        ]), 1040, ["class", "modelValue", "top"])
      ]);
    };
  }
});
var FitsDialog = /* @__PURE__ */ _export_sfc$2(_sfc_main$v, [["__scopeId", "data-v-63a3597c"]]);
var FitsDrawer_vue_vue_type_style_index_0_scoped_true_lang = "";
var FitsDrawer_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$h = { class: "drawer-container" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "FitsDrawer",
  props: {
    visible: { type: Boolean, default: false },
    submitText: { default: "\u786E\u5B9A" },
    cancelText: { default: "\u53D6\u6D88" },
    showFooter: { type: Boolean, default: true },
    dialogProp: { default: {} }
  },
  emits: ["cancel", "submit", "open"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive$1({
      isVisible: false
    });
    const { isVisible } = toRefs$1(state);
    watch$1(() => props.visible, (newVal) => {
      isVisible.value = newVal;
      newVal && emit("open");
    });
    function closeDrawer() {
      emit("cancel");
    }
    function submitDrawer() {
      emit("submit");
    }
    return (_ctx, _cache) => {
      const _component_el_button = resolveComponent("el-button");
      const _component_el_drawer = resolveComponent("el-drawer");
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createVNode(_component_el_drawer, mergeProps$1({
          modelValue: unref$1(isVisible),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(isVisible) ? isVisible.value = $event : null),
          onClose: closeDrawer
        }, __props.dialogProp), createSlots({
          header: withCtx(({ close: close2, titleId, titleClass }) => [
            renderSlot(_ctx.$slots, "header", {
              close: close2,
              titleId,
              titleClass
            }, void 0, true)
          ]),
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ]),
          _: 2
        }, [
          __props.showFooter ? {
            name: "footer",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "footer", {}, () => [
                createVNode(_component_el_button, {
                  onClick: closeDrawer,
                  class: "cancelBtn"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.cancelText), 1)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_button, {
                  type: "primary",
                  onClick: submitDrawer,
                  class: "sureBtn"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(__props.submitText), 1)
                  ]),
                  _: 1
                })
              ], true)
            ])
          } : void 0
        ]), 1040, ["modelValue"])
      ]);
    };
  }
});
var FitsDrawer = /* @__PURE__ */ _export_sfc$2(_sfc_main$u, [["__scopeId", "data-v-6a60f206"]]);
var index_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$g = {
  "aria-hidden": "true",
  class: "svg-icon"
};
const _hoisted_2$8 = ["xlink:href", "fill"];
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    prefix: {
      type: String,
      default: "icon"
    },
    iconClass: {
      type: String,
      required: false
    },
    color: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props = __props;
    const symbolId = computed$1(() => `#${props.prefix}-${props.iconClass}`);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", _hoisted_1$g, [
        createElementVNode("use", {
          "xlink:href": unref$1(symbolId),
          fill: __props.color
        }, null, 8, _hoisted_2$8)
      ]);
    };
  }
});
var SvgIcon = /* @__PURE__ */ _export_sfc$2(_sfc_main$t, [["__scopeId", "data-v-b1593994"]]);
var FormTitle_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$f = { class: "form-divider" };
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "FormTitle",
  props: {
    modelValue: null
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$f, toDisplayString(__props.modelValue), 1);
    };
  }
});
var FormTitle = /* @__PURE__ */ _export_sfc$2(_sfc_main$s, [["__scopeId", "data-v-5004f2a4"]]);
var FitsFormDialog_vue_vue_type_style_index_0_scoped_true_lang = "";
var FitsFormDialog_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$e = { class: "formType" };
const _hoisted_2$7 = { class: "title" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "FitsFormDialog",
  props: {
    option: null
  },
  emits: ["cancel", "submit"],
  setup(__props, { emit }) {
    const props = __props;
    const DialogRef = ref$1();
    const DrawerRef = ref$1();
    const currentFormRef = computed(() => props.option.formType === "drawer" ? DrawerRef.value : DialogRef.value);
    function openForm() {
      nextTick$1(() => {
        currentFormRef.value.forEach((item) => {
          item.fApi.clearValidateState();
        });
      });
    }
    function closeForm() {
      currentFormRef.value.forEach((item) => {
        item.fApi.resetFields();
      });
      emit("cancel");
    }
    function submitForm() {
      let flag = 0;
      let formValue = {};
      currentFormRef.value.forEach((item) => {
        item.fApi.submit((formData3) => {
          flag++;
          formValue = Object.assign(formValue, formData3);
        }).then(() => {
          if (flag !== props.option.forms.length)
            return;
          emit("submit", formValue);
        });
      });
    }
    return (_ctx, _cache) => {
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        __props.option.formType === "drawer" ? (openBlock(), createBlock(FitsDrawer, mergeProps$1({ key: 0 }, __props.option, {
          onCancel: closeForm,
          onSubmit: submitForm,
          onOpen: openForm,
          class: "FormTypeDrawer"
        }), {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.option.forms, (item, index) => {
              return openBlock(), createElementBlock("div", {
                class: "form-drawer-container",
                key: index
              }, [
                createVNode(_component_el_scrollbar, null, {
                  default: withCtx(() => [
                    withDirectives(createElementVNode("div", _hoisted_2$7, [
                      createVNode(SvgIcon, {
                        "icon-class": item == null ? void 0 : item.iconClass
                      }, null, 8, ["icon-class"]),
                      createTextVNode(" " + toDisplayString(item.title), 1)
                    ], 512), [
                      [vShow, item == null ? void 0 : item.title]
                    ]),
                    createVNode(_sfc_main$w, {
                      form: item.form,
                      ref_for: true,
                      ref_key: "DrawerRef",
                      ref: DrawerRef
                    }, null, 8, ["form"])
                  ]),
                  _: 2
                }, 1024)
              ]);
            }), 128))
          ]),
          _: 1
        }, 16)) : (openBlock(), createBlock(FitsDialog, mergeProps$1({
          key: 1,
          class: "FormTypeDialog"
        }, __props.option, {
          onCancel: closeForm,
          onSubmit: submitForm,
          onOpen: openForm
        }), {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(__props.option.forms, (item, index) => {
              return openBlock(), createElementBlock("div", {
                class: "form-dialog-container",
                key: index
              }, [
                (item == null ? void 0 : item.title) ? (openBlock(), createBlock(FormTitle, {
                  key: 0,
                  "model-value": item.title
                }, null, 8, ["model-value"])) : createCommentVNode("", true),
                createVNode(_sfc_main$w, {
                  form: item.form,
                  ref_for: true,
                  ref_key: "DialogRef",
                  ref: DialogRef
                }, null, 8, ["form"])
              ]);
            }), 128))
          ]),
          _: 1
        }, 16))
      ]);
    };
  }
});
var FitsFormDialog = /* @__PURE__ */ _export_sfc$2(_sfc_main$r, [["__scopeId", "data-v-a490c410"]]);
var FitsCard_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$d = { class: "desc" };
const _sfc_main$q = defineComponent({
  __name: "FitsCard",
  props: {
    title: { default: "" },
    desc: { default: "" },
    isActive: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { title, desc, isActive } = toRefs(props);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref$1(isActive) ? "fits-card active" : "fits-card")
      }, [
        createElementVNode("h1", null, [
          renderSlot(_ctx.$slots, "title", { title: unref$1(title) }, () => [
            createTextVNode(toDisplayString(unref$1(title)), 1)
          ], true)
        ]),
        createElementVNode("div", _hoisted_1$d, [
          renderSlot(_ctx.$slots, "desc", { desc: unref$1(desc) }, () => [
            createTextVNode(toDisplayString(unref$1(desc)), 1)
          ], true)
        ]),
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    };
  }
});
var FitsCard = /* @__PURE__ */ _export_sfc$2(_sfc_main$q, [["__scopeId", "data-v-02bc52b7"]]);
class FitsEchartsProps {
  constructor({
    type: type2 = "bar",
    legend = new LegendConfoig({}),
    data: data5 = [],
    xAxisNames = [],
    isShowZoom = false,
    hasBarRadius = true,
    isStack = false,
    isSmooth = false,
    isShowArea = false,
    isHasGap = false
  }) {
    __publicField(this, "type");
    __publicField(this, "legend");
    __publicField(this, "data");
    __publicField(this, "xAxisNames");
    __publicField(this, "isShowZoom");
    __publicField(this, "hasBarRadius");
    __publicField(this, "isStack");
    __publicField(this, "isSmooth");
    __publicField(this, "isShowArea");
    __publicField(this, "isHasGap");
    this.type = type2;
    this.legend = new LegendConfoig(legend);
    this.data = data5;
    this.xAxisNames = xAxisNames;
    this.isShowZoom = isShowZoom;
    this.hasBarRadius = hasBarRadius;
    this.isStack = isStack;
    this.isSmooth = isSmooth;
    this.isShowArea = isShowArea;
    this.isHasGap = isHasGap;
  }
}
class LegendConfoig {
  constructor({ show: show2 = false, positon = "topCenter", data: data5 = [] }) {
    __publicField(this, "show");
    __publicField(this, "positon");
    __publicField(this, "data");
    this.show = show2;
    this.positon = positon;
    this.data = data5;
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d4[p2] = b3[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var Browser = function() {
  function Browser2() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
  return Browser2;
}();
var Env = function() {
  function Env2() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
  return Env2;
}();
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (typeof navigator === "undefined") {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua2, env2) {
  var browser = env2.browser;
  var firefox = ua2.match(/Firefox\/([\d.]+)/);
  var ie2 = ua2.match(/MSIE\s([\d.]+)/) || ua2.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua2.match(/Edge?\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua2);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie2) {
    browser.ie = true;
    browser.version = ie2[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
    browser.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  var style = document.documentElement.style;
  env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
}
var env$1 = env;
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map2 = {};
  if (typeof JSON === "undefined") {
    return map2;
  }
  for (var i2 = 0; i2 < mapStr.length; i2++) {
    var char = String.fromCharCode(i2 + 32);
    var size = (mapStr.charCodeAt(i2) - OFFSET) / SCALE;
    map2[char] = size;
  }
  return map2;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text2, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text2);
      } else {
        text2 = text2 || "";
        font = font || DEFAULT_FONT;
        var res = /^([0-9]*?)px$/.exec(font);
        var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
        var width2 = 0;
        if (font.indexOf("mono") >= 0) {
          width2 = fontSize * text2.length;
        } else {
          for (var i2 = 0; i2 < text2.length; i2++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text2[i2]];
            width2 += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width: width2 };
      }
    };
  }(),
  loadImage: function(src, onload, onerror) {
    var image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
function setPlatformAPI(newPlatformApis) {
  for (var key in platformApi) {
    if (newPlatformApis[key]) {
      platformApi[key] = newPlatformApis[key];
    }
  }
}
var BUILTIN_OBJECT = reduce$2([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val2) {
  obj["[object " + val2 + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce$2([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val2) {
  obj["[object " + val2 + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto$1 = Array.prototype;
var nativeForEach = arrayProto$1.forEach;
var nativeFilter = arrayProto$1.filter;
var nativeSlice = arrayProto$1.slice;
var nativeMap = arrayProto$1.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone$8(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i2 = 0, len2 = source.length; i2 < len2; i2++) {
        result[i2] = clone$8(source[i2]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i2 = 0, len2 = source.length; i2 < len2; i2++) {
          result[i2] = source[i2];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone$8(source[key]);
      }
    }
  }
  return result;
}
function merge$2(target, source, overwrite) {
  if (!isObject$f(source) || !isObject$f(target)) {
    return overwrite ? clone$8(source) : target;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject$f(sourceProp) && isObject$f(targetProp) && !isArray$x(sourceProp) && !isArray$x(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge$2(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone$8(source[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];
  for (var i2 = 1, len2 = targetAndSources.length; i2 < len2; i2++) {
    result = merge$2(result, targetAndSources[i2], overwrite);
  }
  return result;
}
function extend$1(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function defaults(target, source, overlay) {
  var keysArr = keys$d(source);
  for (var i2 = 0; i2 < keysArr.length; i2++) {
    var key = keysArr[i2];
    if (overlay ? source[key] != null : target[key] == null) {
      target[key] = source[key];
    }
  }
  return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf$2(array2, value) {
  if (array2) {
    if (array2.indexOf) {
      return array2.indexOf(value);
    }
    for (var i2 = 0, len2 = array2.length; i2 < len2; i2++) {
      if (array2[i2] === value) {
        return i2;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;
  function F2() {
  }
  F2.prototype = baseClazz.prototype;
  clazz.prototype = new F2();
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin$1(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    var keyList = Object.getOwnPropertyNames(source);
    for (var i2 = 0; i2 < keyList.length; i2++) {
      var key = keyList[i2];
      if (key !== "constructor") {
        if (override ? source[key] != null : target[key] == null) {
          target[key] = source[key];
        }
      }
    }
  } else {
    defaults(target, source, override);
  }
}
function isArrayLike$2(data5) {
  if (!data5) {
    return false;
  }
  if (typeof data5 === "string") {
    return false;
  }
  return typeof data5.length === "number";
}
function each$q(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      cb.call(context, arr[i2], i2, arr);
    }
  } else {
    for (var key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map$9(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice$8(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    var result = [];
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      result.push(cb.call(context, arr[i2], i2, arr));
    }
    return result;
  }
}
function reduce$2(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
    memo = cb.call(context, memo, arr[i2], i2, arr);
  }
  return memo;
}
function filter$3(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice$8(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    var result = [];
    for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
      if (cb.call(context, arr[i2], i2, arr)) {
        result.push(arr[i2]);
      }
    }
    return result;
  }
}
function find$3(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i2 = 0, len2 = arr.length; i2 < len2; i2++) {
    if (cb.call(context, arr[i2], i2, arr)) {
      return arr[i2];
    }
  }
}
function keys$d(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keyList = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind$3 = protoFunction && isFunction$h(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(func) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray$x(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction$h(value) {
  return typeof value === "function";
}
function isString$d(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber$c(value) {
  return typeof value === "number";
}
function isObject$f(value) {
  var type2 = typeof value;
  return type2 === "function" || !!value && type2 === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp$4(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  for (var i2 = 0, len2 = args.length; i2 < len2; i2++) {
    if (args[i2] != null) {
      return args[i2];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice$8(arr) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val2) {
  if (typeof val2 === "number") {
    return [val2, val2, val2, val2];
  }
  var len2 = val2.length;
  if (len2 === 2) {
    return [val2[0], val2[1], val2[0], val2[1]];
  } else if (len2 === 3) {
    return [val2[0], val2[1], val2[2], val2[1]];
  }
  return val2;
}
function assert(condition, message2) {
  if (!condition) {
    throw new Error(message2);
  }
}
function trim$3(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var HashMap = function() {
  function HashMap2(obj) {
    this.data = {};
    var isArr = isArray$x(obj);
    this.data = {};
    var thisMap = this;
    obj instanceof HashMap2 ? obj.each(visit) : obj && each$q(obj, visit);
    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }
  HashMap2.prototype.get = function(key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  };
  HashMap2.prototype.set = function(key, value) {
    return this.data[key] = value;
  };
  HashMap2.prototype.each = function(cb, context) {
    for (var key in this.data) {
      if (this.data.hasOwnProperty(key)) {
        cb.call(context, this.data[key], key);
      }
    }
  };
  HashMap2.prototype.keys = function() {
    return keys$d(this.data);
  };
  HashMap2.prototype.removeKey = function(key) {
    delete this.data[key];
  };
  return HashMap2;
}();
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a2, b2) {
  var newArray = new a2.constructor(a2.length + b2.length);
  for (var i2 = 0; i2 < a2.length; i2++) {
    newArray[i2] = a2[i2];
  }
  var offset2 = a2.length;
  for (var i2 = 0; i2 < b2.length; i2++) {
    newArray[i2 + offset2] = b2[i2];
  }
  return newArray;
}
function createObject(proto2, properties) {
  var obj;
  if (Object.create) {
    obj = Object.create(proto2);
  } else {
    var StyleCtor = function() {
    };
    StyleCtor.prototype = proto2;
    obj = new StyleCtor();
  }
  if (properties) {
    extend$1(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  var domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn$1(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop$3() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
var util$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  guid,
  logError,
  clone: clone$8,
  merge: merge$2,
  mergeAll,
  extend: extend$1,
  defaults,
  createCanvas,
  indexOf: indexOf$2,
  inherits,
  mixin: mixin$1,
  isArrayLike: isArrayLike$2,
  each: each$q,
  map: map$9,
  reduce: reduce$2,
  filter: filter$3,
  find: find$3,
  keys: keys$d,
  bind: bind$3,
  curry: curry$1,
  isArray: isArray$x,
  isFunction: isFunction$h,
  isString: isString$d,
  isStringSafe,
  isNumber: isNumber$c,
  isObject: isObject$f,
  isBuiltInObject,
  isTypedArray,
  isDom,
  isGradientObject,
  isImagePatternObject,
  isRegExp: isRegExp$4,
  eqNaN,
  retrieve,
  retrieve2,
  retrieve3,
  slice: slice$8,
  normalizeCssArray: normalizeCssArray$1,
  assert,
  trim: trim$3,
  setAsPrimitive,
  isPrimitive,
  HashMap,
  createHashMap,
  concatArray,
  createObject,
  disableUserSelect,
  hasOwn: hasOwn$1,
  noop: noop$3,
  RADIAN_TO_DEGREE
}, Symbol.toStringTag, { value: "Module" }));
function create$1(x2, y2) {
  if (x2 == null) {
    x2 = 0;
  }
  if (y2 == null) {
    y2 = 0;
  }
  return [x2, y2];
}
function copy$1(out2, v2) {
  out2[0] = v2[0];
  out2[1] = v2[1];
  return out2;
}
function clone$7(v2) {
  return [v2[0], v2[1]];
}
function set$3(out2, a2, b2) {
  out2[0] = a2;
  out2[1] = b2;
  return out2;
}
function add$2(out2, v1, v2) {
  out2[0] = v1[0] + v2[0];
  out2[1] = v1[1] + v2[1];
  return out2;
}
function scaleAndAdd(out2, v1, v2, a2) {
  out2[0] = v1[0] + v2[0] * a2;
  out2[1] = v1[1] + v2[1] * a2;
  return out2;
}
function sub(out2, v1, v2) {
  out2[0] = v1[0] - v2[0];
  out2[1] = v1[1] - v2[1];
  return out2;
}
function len$1(v2) {
  return Math.sqrt(lenSquare(v2));
}
var length = len$1;
function lenSquare(v2) {
  return v2[0] * v2[0] + v2[1] * v2[1];
}
var lengthSquare = lenSquare;
function mul$1(out2, v1, v2) {
  out2[0] = v1[0] * v2[0];
  out2[1] = v1[1] * v2[1];
  return out2;
}
function div(out2, v1, v2) {
  out2[0] = v1[0] / v2[0];
  out2[1] = v1[1] / v2[1];
  return out2;
}
function dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1];
}
function scale$2(out2, v2, s2) {
  out2[0] = v2[0] * s2;
  out2[1] = v2[1] * s2;
  return out2;
}
function normalize$1(out2, v2) {
  var d3 = len$1(v2);
  if (d3 === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v2[0] / d3;
    out2[1] = v2[1] / d3;
  }
  return out2;
}
function distance(v1, v2) {
  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
}
var dist$1 = distance;
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
var distSquare = distanceSquare;
function negate(out2, v2) {
  out2[0] = -v2[0];
  out2[1] = -v2[1];
  return out2;
}
function lerp$1(out2, v1, v2, t2) {
  out2[0] = v1[0] + t2 * (v2[0] - v1[0]);
  out2[1] = v1[1] + t2 * (v2[1] - v1[1]);
  return out2;
}
function applyTransform$1(out2, v2, m2) {
  var x2 = v2[0];
  var y2 = v2[1];
  out2[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out2[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out2;
}
function min$3(out2, v1, v2) {
  out2[0] = Math.min(v1[0], v2[0]);
  out2[1] = Math.min(v1[1], v2[1]);
  return out2;
}
function max$4(out2, v1, v2) {
  out2[0] = Math.max(v1[0], v2[0]);
  out2[1] = Math.max(v1[1], v2[1]);
  return out2;
}
var vector = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: create$1,
  copy: copy$1,
  clone: clone$7,
  set: set$3,
  add: add$2,
  scaleAndAdd,
  sub,
  len: len$1,
  length,
  lenSquare,
  lengthSquare,
  mul: mul$1,
  div,
  dot,
  scale: scale$2,
  normalize: normalize$1,
  distance,
  dist: dist$1,
  distanceSquare,
  distSquare,
  negate,
  lerp: lerp$1,
  applyTransform: applyTransform$1,
  min: min$3,
  max: max$4
}, Symbol.toStringTag, { value: "Module" }));
var Param = function() {
  function Param2(target, e3) {
    this.target = target;
    this.topTarget = e3 && e3.topTarget;
  }
  return Param2;
}();
var Draggable = function() {
  function Draggable2(handler3) {
    this.handler = handler3;
    handler3.on("mousedown", this._dragStart, this);
    handler3.on("mousemove", this._drag, this);
    handler3.on("mouseup", this._dragEnd, this);
  }
  Draggable2.prototype._dragStart = function(e3) {
    var draggingTarget = e3.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e3.offsetX;
      this._y = e3.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e3), "dragstart", e3.event);
    }
  };
  Draggable2.prototype._drag = function(e3) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x2 = e3.offsetX;
      var y2 = e3.offsetY;
      var dx = x2 - this._x;
      var dy = y2 - this._y;
      this._x = x2;
      this._y = y2;
      draggingTarget.drift(dx, dy, e3);
      this.handler.dispatchToElement(new Param(draggingTarget, e3), "drag", e3.event);
      var dropTarget = this.handler.findHover(x2, y2, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e3), "dragleave", e3.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e3), "dragenter", e3.event);
        }
      }
    }
  };
  Draggable2.prototype._dragEnd = function(e3) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e3), "dragend", e3.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e3), "drop", e3.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  };
  return Draggable2;
}();
var Draggable$1 = Draggable;
var Eventful = function() {
  function Eventful2(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  Eventful2.prototype.on = function(event, query, handler3, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    var _h2 = this._$handlers;
    if (typeof query === "function") {
      context = handler3;
      handler3 = query;
      query = null;
    }
    if (!handler3 || !event) {
      return this;
    }
    var eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h2[event]) {
      _h2[event] = [];
    }
    for (var i2 = 0; i2 < _h2[event].length; i2++) {
      if (_h2[event][i2].h === handler3) {
        return this;
      }
    }
    var wrap = {
      h: handler3,
      query,
      ctx: context || this,
      callAtLast: handler3.zrEventfulCallAtLast
    };
    var lastIndex = _h2[event].length - 1;
    var lastWrap = _h2[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h2[event].splice(lastIndex, 0, wrap) : _h2[event].push(wrap);
    return this;
  };
  Eventful2.prototype.isSilent = function(eventName) {
    var _h2 = this._$handlers;
    return !_h2 || !_h2[eventName] || !_h2[eventName].length;
  };
  Eventful2.prototype.off = function(eventType, handler3) {
    var _h2 = this._$handlers;
    if (!_h2) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler3) {
      if (_h2[eventType]) {
        var newList = [];
        for (var i2 = 0, l2 = _h2[eventType].length; i2 < l2; i2++) {
          if (_h2[eventType][i2].h !== handler3) {
            newList.push(_h2[eventType][i2]);
          }
        }
        _h2[eventType] = newList;
      }
      if (_h2[eventType] && _h2[eventType].length === 0) {
        delete _h2[eventType];
      }
    } else {
      delete _h2[eventType];
    }
    return this;
  };
  Eventful2.prototype.trigger = function(eventType) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h2 = this._$handlers[eventType];
    var eventProcessor = this._$eventProcessor;
    if (_h2) {
      var argLen = args.length;
      var len2 = _h2.length;
      for (var i2 = 0; i2 < len2; i2++) {
        var hItem = _h2[i2];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  };
  Eventful2.prototype.triggerWithContext = function(type2) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h2 = this._$handlers[type2];
    var eventProcessor = this._$eventProcessor;
    if (_h2) {
      var argLen = args.length;
      var ctx = args[argLen - 1];
      var len2 = _h2.length;
      for (var i2 = 0; i2 < len2; i2++) {
        var hItem = _h2[i2];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type2, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type2);
    return this;
  };
  return Eventful2;
}();
var Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum3 = 0;
  for (var j2 = 0, colLocalIdx = 0; j2 < fullRank; j2++) {
    var colTag = 1 << j2;
    if (!(colTag & colMask)) {
      sum3 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j2] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum3;
  return sum3;
}
function buildTransformer(src, dest) {
  var mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  var vh2 = [];
  for (var i2 = 0; i2 < 8; i2++) {
    for (var j2 = 0; j2 < 8; j2++) {
      vh2[j2] == null && (vh2[j2] = 0);
      vh2[j2] += ((i2 + j2) % 2 ? -1 : 1) * determinant(mA, 7, i2 === 0 ? 1 : 0, 1 << i2, 1 << j2, detCache) / det * dest[i2];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh2[6] + srcPointY * vh2[7] + 1;
    out2[0] = (srcPointX * vh2[0] + srcPointY * vh2[1] + vh2[2]) / pk;
    out2[1] = (srcPointX * vh2[3] + srcPointY * vh2[4] + vh2[5]) / pk;
  };
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(out2, el2, inX, inY, inverse) {
  if (el2.getBoundingClientRect && env$1.domSupported && !isCanvasEl(el2)) {
    var saved = el2[EVENT_SAVED_PROP] || (el2[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el2, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el2, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i2 = 0; i2 < 4; i2++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i2 % 2;
    var idxTB = (i2 >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el2.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var srcCoords = [];
  var destCoords = [];
  var oldCoordTheSame = true;
  for (var i2 = 0; i2 < 4; i2++) {
    var rect = markers[i2].getBoundingClientRect();
    var ii2 = 2 * i2;
    var x2 = rect.left;
    var y2 = rect.top;
    srcCoords.push(x2, y2);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x2 === oldSrcCoords[ii2] && y2 === oldSrcCoords[ii2 + 1];
    destCoords.push(markers[i2].offsetLeft, markers[i2].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el2) {
  return el2.nodeName.toUpperCase() === "CANVAS";
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(el2, e3, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el2, e3, out2);
  } else if (firefoxNotSupportOffsetXY && e3.layerX != null && e3.layerX !== e3.offsetX) {
    out2.zrX = e3.layerX;
    out2.zrY = e3.layerY;
  } else if (e3.offsetX != null) {
    out2.zrX = e3.offsetX;
    out2.zrY = e3.offsetY;
  } else {
    calculateZrXY(el2, e3, out2);
  }
  return out2;
}
function calculateZrXY(el2, e3, out2) {
  if (env$1.domSupported && el2.getBoundingClientRect) {
    var ex = e3.clientX;
    var ey = e3.clientY;
    if (isCanvasEl(el2)) {
      var box2 = el2.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el2, ex, ey)) {
        out2.zrX = _calcOut[0];
        out2.zrY = _calcOut[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e3) {
  return e3 || window.event;
}
function normalizeEvent(el2, e3, calculate) {
  e3 = getNativeEvent(e3);
  if (e3.zrX != null) {
    return e3;
  }
  var eventType = e3.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el2, e3, e3, calculate);
    var wheelDelta = getWheelDeltaMayPolyfill(e3);
    e3.zrDelta = wheelDelta ? wheelDelta / 120 : -(e3.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e3.targetTouches[0] : e3.changedTouches[0];
    touch && clientToLocal(el2, touch, e3, calculate);
  }
  var button = e3.button;
  if (e3.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e3.type)) {
    e3.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e3;
}
function getWheelDeltaMayPolyfill(e3) {
  var rawWheelDelta = e3.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  var deltaX = e3.deltaX;
  var deltaY = e3.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  var sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign;
}
function addEventListener(el2, name2, handler3, opt) {
  el2.addEventListener(name2, handler3, opt);
}
function removeEventListener(el2, name2, handler3, opt) {
  el2.removeEventListener(name2, handler3, opt);
}
var stop = function(e3) {
  e3.preventDefault();
  e3.stopPropagation();
  e3.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e3) {
  return e3.which === 2 || e3.which === 3;
}
var GestureMgr = function() {
  function GestureMgr2() {
    this._track = [];
  }
  GestureMgr2.prototype.recognize = function(event, target, root2) {
    this._doTrack(event, target, root2);
    return this._recognize(event);
  };
  GestureMgr2.prototype.clear = function() {
    this._track.length = 0;
    return this;
  };
  GestureMgr2.prototype._doTrack = function(event, target, root2) {
    var touches = event.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (var i2 = 0, len2 = touches.length; i2 < len2; i2++) {
      var touch = touches[i2];
      var pos = clientToLocal(root2, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  };
  GestureMgr2.prototype._recognize = function(event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  };
  return GestureMgr2;
}();
function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    var trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (tracks[trackLen - 1] || {}).points;
    var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_super) {
  __extends(EmptyProxy2, _super);
  function EmptyProxy2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.handler = null;
    return _this;
  }
  EmptyProxy2.prototype.dispose = function() {
  };
  EmptyProxy2.prototype.setCursor = function() {
  };
  return EmptyProxy2;
}(Eventful$1);
var HoveredResult = function() {
  function HoveredResult2(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  return HoveredResult2;
}();
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var Handler = function(_super) {
  __extends(Handler2, _super);
  function Handler2(storage, painter, proxy, painterRoot) {
    var _this = _super.call(this) || this;
    _this._hovered = new HoveredResult(0, 0);
    _this.storage = storage;
    _this.painter = painter;
    _this.painterRoot = painterRoot;
    proxy = proxy || new EmptyProxy();
    _this.proxy = null;
    _this.setHandlerProxy(proxy);
    _this._draggingMgr = new Draggable$1(_this);
    return _this;
  }
  Handler2.prototype.setHandlerProxy = function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each$q(handlerNames, function(name2) {
        proxy.on && proxy.on(name2, this[name2], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  };
  Handler2.prototype.mousemove = function(event) {
    var x2 = event.zrX;
    var y2 = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y2);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? new HoveredResult(x2, y2) : this.findHover(x2, y2);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  };
  Handler2.prototype.mouseout = function(event) {
    var eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", { type: "globalout", event });
    }
  };
  Handler2.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  };
  Handler2.prototype.dispatch = function(eventName, eventArgs) {
    var handler3 = this[eventName];
    handler3 && handler3.call(this, eventArgs);
  };
  Handler2.prototype.dispose = function() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  };
  Handler2.prototype.setCursorStyle = function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  };
  Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el2 = targetInfo.target;
    if (el2 && el2.silent) {
      return;
    }
    var eventKey = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el2) {
      el2[eventKey] && (eventPacket.cancelBubble = !!el2[eventKey].call(el2, eventPacket));
      el2.trigger(eventName, eventPacket);
      el2 = el2.__hostTarget ? el2.__hostTarget : el2.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  };
  Handler2.prototype.findHover = function(x2, y2, exclude) {
    var list = this.storage.getDisplayList();
    var out2 = new HoveredResult(x2, y2);
    for (var i2 = list.length - 1; i2 >= 0; i2--) {
      var hoverCheckResult = void 0;
      if (list[i2] !== exclude && !list[i2].ignore && (hoverCheckResult = isHover(list[i2], x2, y2))) {
        !out2.topTarget && (out2.topTarget = list[i2]);
        if (hoverCheckResult !== SILENT) {
          out2.target = list[i2];
          break;
        }
      }
    }
    return out2;
  };
  Handler2.prototype.processGesture = function(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type2 = gestureInfo.type;
      event.gestureEvent = type2;
      var res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type2, gestureInfo.event);
    }
  };
  return Handler2;
}(Eventful$1);
each$q(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name2) {
  Handler.prototype[name2] = function(event) {
    var x2 = event.zrX;
    var y2 = event.zrY;
    var isOutside = isOutsideBoundary(this, x2, y2);
    var hovered;
    var hoveredTarget;
    if (name2 !== "mouseup" || !isOutside) {
      hovered = this.findHover(x2, y2);
      hoveredTarget = hovered.target;
    }
    if (name2 === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name2 === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name2 === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name2, event);
  };
});
function isHover(displayable, x2, y2) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x2, y2)) {
    var el2 = displayable;
    var isSilent = void 0;
    var ignoreClip = false;
    while (el2) {
      if (el2.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        var clipPath = el2.getClipPath();
        if (clipPath && !clipPath.contain(x2, y2)) {
          return false;
        }
        if (el2.silent) {
          isSilent = true;
        }
      }
      var hostEl = el2.__hostTarget;
      el2 = hostEl ? hostEl : el2.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function isOutsideBoundary(handlerInstance, x2, y2) {
  var painter = handlerInstance.painter;
  return x2 < 0 || x2 > painter.getWidth() || y2 < 0 || y2 > painter.getHeight();
}
var Handler$1 = Handler;
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n2) {
  var r2 = 0;
  while (n2 >= DEFAULT_MIN_MERGE) {
    r2 |= n2 & 1;
    n2 >>= 1;
  }
  return n2 + r2;
}
function makeAscendingRun(array2, lo2, hi2, compare2) {
  var runHi = lo2 + 1;
  if (runHi === hi2) {
    return 1;
  }
  if (compare2(array2[runHi++], array2[lo2]) < 0) {
    while (runHi < hi2 && compare2(array2[runHi], array2[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array2, lo2, runHi);
  } else {
    while (runHi < hi2 && compare2(array2[runHi], array2[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo2;
}
function reverseRun(array2, lo2, hi2) {
  hi2--;
  while (lo2 < hi2) {
    var t2 = array2[lo2];
    array2[lo2++] = array2[hi2];
    array2[hi2--] = t2;
  }
}
function binaryInsertionSort(array2, lo2, hi2, start2, compare2) {
  if (start2 === lo2) {
    start2++;
  }
  for (; start2 < hi2; start2++) {
    var pivot = array2[start2];
    var left = lo2;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare2(pivot, array2[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n2 = start2 - left;
    switch (n2) {
      case 3:
        array2[left + 3] = array2[left + 2];
      case 2:
        array2[left + 2] = array2[left + 1];
      case 1:
        array2[left + 1] = array2[left];
        break;
      default:
        while (n2 > 0) {
          array2[left + n2] = array2[left + n2 - 1];
          n2--;
        }
    }
    array2[left] = pivot;
  }
}
function gallopLeft(value, array2, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset2 = 1;
  if (compare2(value, array2[start2 + hint]) > 0) {
    maxOffset = length2 - hint;
    while (offset2 < maxOffset && compare2(value, array2[start2 + hint + offset2]) > 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    lastOffset += hint;
    offset2 += hint;
  } else {
    maxOffset = hint + 1;
    while (offset2 < maxOffset && compare2(value, array2[start2 + hint - offset2]) <= 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset2;
    offset2 = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset2) {
    var m2 = lastOffset + (offset2 - lastOffset >>> 1);
    if (compare2(value, array2[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset2 = m2;
    }
  }
  return offset2;
}
function gallopRight(value, array2, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset2 = 1;
  if (compare2(value, array2[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset2 < maxOffset && compare2(value, array2[start2 + hint - offset2]) < 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset2;
    offset2 = hint - tmp;
  } else {
    maxOffset = length2 - hint;
    while (offset2 < maxOffset && compare2(value, array2[start2 + hint + offset2]) >= 0) {
      lastOffset = offset2;
      offset2 = (offset2 << 1) + 1;
      if (offset2 <= 0) {
        offset2 = maxOffset;
      }
    }
    if (offset2 > maxOffset) {
      offset2 = maxOffset;
    }
    lastOffset += hint;
    offset2 += hint;
  }
  lastOffset++;
  while (lastOffset < offset2) {
    var m2 = lastOffset + (offset2 - lastOffset >>> 1);
    if (compare2(value, array2[start2 + m2]) < 0) {
      offset2 = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset2;
}
function TimSort(array2, compare2) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  array2.length;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n2 = stackSize - 2;
      if (n2 >= 1 && runLength[n2 - 1] <= runLength[n2] + runLength[n2 + 1] || n2 >= 2 && runLength[n2 - 2] <= runLength[n2] + runLength[n2 - 1]) {
        if (runLength[n2 - 1] < runLength[n2 + 1]) {
          n2--;
        }
      } else if (runLength[n2] > runLength[n2 + 1]) {
        break;
      }
      mergeAt(n2);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n2 = stackSize - 2;
      if (n2 > 0 && runLength[n2 - 1] < runLength[n2 + 1]) {
        n2--;
      }
      mergeAt(n2);
    }
  }
  function mergeAt(i2) {
    var start1 = runStart[i2];
    var length1 = runLength[i2];
    var start2 = runStart[i2 + 1];
    var length2 = runLength[i2 + 1];
    runLength[i2] = length1 + length2;
    if (i2 === stackSize - 3) {
      runStart[i2 + 1] = runStart[i2 + 2];
      runLength[i2 + 1] = runLength[i2 + 2];
    }
    stackSize--;
    var k2 = gallopRight(array2[start2], array2, start1, length1, 0, compare2);
    start1 += k2;
    length1 -= k2;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array2[start1 + length1 - 1], array2, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i2 = 0;
    for (i2 = 0; i2 < length1; i2++) {
      tmp[i2] = array2[start1 + i2];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array2[dest++] = array2[cursor2++];
    if (--length2 === 0) {
      for (i2 = 0; i2 < length1; i2++) {
        array2[dest + i2] = tmp[cursor1 + i2];
      }
      return;
    }
    if (length1 === 1) {
      for (i2 = 0; i2 < length2; i2++) {
        array2[dest + i2] = array2[cursor2 + i2];
      }
      array2[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array2[cursor2], tmp[cursor1]) < 0) {
          array2[dest++] = array2[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array2[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array2[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i2 = 0; i2 < count1; i2++) {
            array2[dest + i2] = tmp[cursor1 + i2];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array2[dest++] = array2[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array2, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i2 = 0; i2 < count2; i2++) {
            array2[dest + i2] = array2[cursor2 + i2];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array2[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i2 = 0; i2 < length2; i2++) {
        array2[dest + i2] = array2[cursor2 + i2];
      }
      array2[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i2 = 0; i2 < length1; i2++) {
        array2[dest + i2] = tmp[cursor1 + i2];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i2 = 0;
    for (i2 = 0; i2 < length2; i2++) {
      tmp[i2] = array2[start2 + i2];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array2[dest--] = array2[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i2 = 0; i2 < length2; i2++) {
        array2[customCursor + i2] = tmp[i2];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i2 = length1 - 1; i2 >= 0; i2--) {
        array2[customDest + i2] = array2[customCursor + i2];
      }
      array2[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array2[cursor1]) < 0) {
          array2[dest--] = array2[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array2[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array2, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i2 = count1 - 1; i2 >= 0; i2--) {
            array2[customDest + i2] = array2[customCursor + i2];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array2[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array2[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i2 = 0; i2 < count2; i2++) {
            array2[customDest + i2] = tmp[customCursor + i2];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array2[dest--] = array2[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i2 = length1 - 1; i2 >= 0; i2--) {
        array2[customDest + i2] = array2[customCursor + i2];
      }
      array2[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i2 = 0; i2 < length2; i2++) {
        array2[customCursor + i2] = tmp[i2];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort(array2, compare2, lo2, hi2) {
  if (!lo2) {
    lo2 = 0;
  }
  if (!hi2) {
    hi2 = array2.length;
  }
  var remaining = hi2 - lo2;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array2, lo2, hi2, compare2);
    binaryInsertionSort(array2, lo2, hi2, lo2 + runLength, compare2);
    return;
  }
  var ts2 = TimSort(array2, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array2, lo2, hi2, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array2, lo2, lo2 + force, lo2 + runLength, compare2);
      runLength = force;
    }
    ts2.pushRun(lo2, runLength);
    ts2.mergeRuns();
    remaining -= runLength;
    lo2 += runLength;
  } while (remaining !== 0);
  ts2.forceMergeRuns();
}
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a2, b2) {
  if (a2.zlevel === b2.zlevel) {
    if (a2.z === b2.z) {
      return a2.z2 - b2.z2;
    }
    return a2.z - b2.z;
  }
  return a2.zlevel - b2.zlevel;
}
var Storage = function() {
  function Storage2() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  Storage2.prototype.traverse = function(cb, context) {
    for (var i2 = 0; i2 < this._roots.length; i2++) {
      this._roots[i2].traverse(cb, context);
    }
  };
  Storage2.prototype.getDisplayList = function(update5, includeIgnore) {
    includeIgnore = includeIgnore || false;
    var displayList = this._displayList;
    if (update5 || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  };
  Storage2.prototype.updateDisplayList = function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i2 = 0, len2 = roots2.length; i2 < len2; i2++) {
      this._updateAndAddDisplayable(roots2[i2], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort(displayList, shapeCompareFunc);
  };
  Storage2.prototype._updateAndAddDisplayable = function(el2, clipPaths, includeIgnore) {
    if (el2.ignore && !includeIgnore) {
      return;
    }
    el2.beforeUpdate();
    el2.update();
    el2.afterUpdate();
    var userSetClipPath = el2.getClipPath();
    if (el2.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el2;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el2.childrenRef) {
      var children2 = el2.childrenRef();
      for (var i2 = 0; i2 < children2.length; i2++) {
        var child = children2[i2];
        if (el2.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el2.__dirty = 0;
    } else {
      var disp = el2;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    var decalEl = el2.getDecalElement && el2.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    var textGuide = el2.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    var textEl = el2.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  };
  Storage2.prototype.addRoot = function(el2) {
    if (el2.__zr && el2.__zr.storage === this) {
      return;
    }
    this._roots.push(el2);
  };
  Storage2.prototype.delRoot = function(el2) {
    if (el2 instanceof Array) {
      for (var i2 = 0, l2 = el2.length; i2 < l2; i2++) {
        this.delRoot(el2[i2]);
      }
      return;
    }
    var idx = indexOf$2(this._roots, el2);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  };
  Storage2.prototype.delAllRoots = function() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  };
  Storage2.prototype.getRoots = function() {
    return this._roots;
  };
  Storage2.prototype.dispose = function() {
    this._displayList = null;
    this._roots = null;
  };
  return Storage2;
}();
var Storage$1 = Storage;
var requestAnimationFrame;
requestAnimationFrame = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame$1 = requestAnimationFrame;
var easingFuncs = {
  linear: function(k2) {
    return k2;
  },
  quadraticIn: function(k2) {
    return k2 * k2;
  },
  quadraticOut: function(k2) {
    return k2 * (2 - k2);
  },
  quadraticInOut: function(k2) {
    if ((k2 *= 2) < 1) {
      return 0.5 * k2 * k2;
    }
    return -0.5 * (--k2 * (k2 - 2) - 1);
  },
  cubicIn: function(k2) {
    return k2 * k2 * k2;
  },
  cubicOut: function(k2) {
    return --k2 * k2 * k2 + 1;
  },
  cubicInOut: function(k2) {
    if ((k2 *= 2) < 1) {
      return 0.5 * k2 * k2 * k2;
    }
    return 0.5 * ((k2 -= 2) * k2 * k2 + 2);
  },
  quarticIn: function(k2) {
    return k2 * k2 * k2 * k2;
  },
  quarticOut: function(k2) {
    return 1 - --k2 * k2 * k2 * k2;
  },
  quarticInOut: function(k2) {
    if ((k2 *= 2) < 1) {
      return 0.5 * k2 * k2 * k2 * k2;
    }
    return -0.5 * ((k2 -= 2) * k2 * k2 * k2 - 2);
  },
  quinticIn: function(k2) {
    return k2 * k2 * k2 * k2 * k2;
  },
  quinticOut: function(k2) {
    return --k2 * k2 * k2 * k2 * k2 + 1;
  },
  quinticInOut: function(k2) {
    if ((k2 *= 2) < 1) {
      return 0.5 * k2 * k2 * k2 * k2 * k2;
    }
    return 0.5 * ((k2 -= 2) * k2 * k2 * k2 * k2 + 2);
  },
  sinusoidalIn: function(k2) {
    return 1 - Math.cos(k2 * Math.PI / 2);
  },
  sinusoidalOut: function(k2) {
    return Math.sin(k2 * Math.PI / 2);
  },
  sinusoidalInOut: function(k2) {
    return 0.5 * (1 - Math.cos(Math.PI * k2));
  },
  exponentialIn: function(k2) {
    return k2 === 0 ? 0 : Math.pow(1024, k2 - 1);
  },
  exponentialOut: function(k2) {
    return k2 === 1 ? 1 : 1 - Math.pow(2, -10 * k2);
  },
  exponentialInOut: function(k2) {
    if (k2 === 0) {
      return 0;
    }
    if (k2 === 1) {
      return 1;
    }
    if ((k2 *= 2) < 1) {
      return 0.5 * Math.pow(1024, k2 - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k2 - 1)) + 2);
  },
  circularIn: function(k2) {
    return 1 - Math.sqrt(1 - k2 * k2);
  },
  circularOut: function(k2) {
    return Math.sqrt(1 - --k2 * k2);
  },
  circularInOut: function(k2) {
    if ((k2 *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k2 * k2) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k2 -= 2) * k2) + 1);
  },
  elasticIn: function(k2) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k2 === 0) {
      return 0;
    }
    if (k2 === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    return -(a2 * Math.pow(2, 10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2));
  },
  elasticOut: function(k2) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k2 === 0) {
      return 0;
    }
    if (k2 === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    return a2 * Math.pow(2, -10 * k2) * Math.sin((k2 - s2) * (2 * Math.PI) / p2) + 1;
  },
  elasticInOut: function(k2) {
    var s2;
    var a2 = 0.1;
    var p2 = 0.4;
    if (k2 === 0) {
      return 0;
    }
    if (k2 === 1) {
      return 1;
    }
    if (!a2 || a2 < 1) {
      a2 = 1;
      s2 = p2 / 4;
    } else {
      s2 = p2 * Math.asin(1 / a2) / (2 * Math.PI);
    }
    if ((k2 *= 2) < 1) {
      return -0.5 * (a2 * Math.pow(2, 10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2));
    }
    return a2 * Math.pow(2, -10 * (k2 -= 1)) * Math.sin((k2 - s2) * (2 * Math.PI) / p2) * 0.5 + 1;
  },
  backIn: function(k2) {
    var s2 = 1.70158;
    return k2 * k2 * ((s2 + 1) * k2 - s2);
  },
  backOut: function(k2) {
    var s2 = 1.70158;
    return --k2 * k2 * ((s2 + 1) * k2 + s2) + 1;
  },
  backInOut: function(k2) {
    var s2 = 1.70158 * 1.525;
    if ((k2 *= 2) < 1) {
      return 0.5 * (k2 * k2 * ((s2 + 1) * k2 - s2));
    }
    return 0.5 * ((k2 -= 2) * k2 * ((s2 + 1) * k2 + s2) + 2);
  },
  bounceIn: function(k2) {
    return 1 - easingFuncs.bounceOut(1 - k2);
  },
  bounceOut: function(k2) {
    if (k2 < 1 / 2.75) {
      return 7.5625 * k2 * k2;
    } else if (k2 < 2 / 2.75) {
      return 7.5625 * (k2 -= 1.5 / 2.75) * k2 + 0.75;
    } else if (k2 < 2.5 / 2.75) {
      return 7.5625 * (k2 -= 2.25 / 2.75) * k2 + 0.9375;
    } else {
      return 7.5625 * (k2 -= 2.625 / 2.75) * k2 + 0.984375;
    }
  },
  bounceInOut: function(k2) {
    if (k2 < 0.5) {
      return easingFuncs.bounceIn(k2 * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k2 * 2 - 1) * 0.5 + 0.5;
  }
};
var easingFuncs$1 = easingFuncs;
var mathPow$1 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$3 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$1();
var _v1 = create$1();
var _v2 = create$1();
function isAroundZero(val2) {
  return val2 > -EPSILON$3 && val2 < EPSILON$3;
}
function isNotAroundZero$1(val2) {
  return val2 > EPSILON$3 || val2 < -EPSILON$3;
}
function cubicAt(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return onet * onet * (onet * p0 + 3 * t2 * p1) + t2 * t2 * (t2 * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t2) * onet + (p3 - p2) * t2 * t2);
}
function cubicRootAt(p0, p1, p2, p3, val2, roots2) {
  var a2 = p3 + 3 * (p1 - p2) - p0;
  var b2 = 3 * (p2 - p1 * 2 + p0);
  var c2 = 3 * (p1 - p0);
  var d3 = p0 - val2;
  var A2 = b2 * b2 - 3 * a2 * c2;
  var B2 = b2 * c2 - 9 * a2 * d3;
  var C2 = c2 * c2 - 3 * b2 * d3;
  var n2 = 0;
  if (isAroundZero(A2) && isAroundZero(B2)) {
    if (isAroundZero(b2)) {
      roots2[0] = 0;
    } else {
      var t1 = -c2 / b2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
    }
  } else {
    var disc = B2 * B2 - 4 * A2 * C2;
    if (isAroundZero(disc)) {
      var K2 = B2 / A2;
      var t1 = -b2 / a2 + K2;
      var t2 = -K2 / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n2++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var Y1 = A2 * b2 + 1.5 * a2 * (-B2 + discSqrt);
      var Y2 = A2 * b2 + 1.5 * a2 * (-B2 - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow$1(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow$1(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow$1(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow$1(Y2, ONE_THIRD);
      }
      var t1 = (-b2 - (Y1 + Y2)) / (3 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
    } else {
      var T2 = (2 * A2 * b2 - 3 * a2 * B2) / (2 * mathSqrt$3(A2 * A2 * A2));
      var theta = Math.acos(T2) / 3;
      var ASqrt = mathSqrt$3(A2);
      var tmp = Math.cos(theta);
      var t1 = (-b2 - 2 * ASqrt * tmp) / (3 * a2);
      var t2 = (-b2 + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a2);
      var t3 = (-b2 + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n2++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n2++] = t3;
      }
    }
  }
  return n2;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  var b2 = 6 * p2 - 12 * p1 + 6 * p0;
  var a2 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c2 = 3 * p1 - 3 * p0;
  var n2 = 0;
  if (isAroundZero(a2)) {
    if (isNotAroundZero$1(b2)) {
      var t1 = -c2 / b2;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n2++] = t1;
      }
    }
  } else {
    var disc = b2 * b2 - 4 * a2 * c2;
    if (isAroundZero(disc)) {
      extrema2[0] = -b2 / (2 * a2);
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b2 + discSqrt) / (2 * a2);
      var t2 = (-b2 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n2++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n2++] = t2;
      }
    }
  }
  return n2;
}
function cubicSubdivide(p0, p1, p2, p3, t2, out2) {
  var p01 = (p1 - p0) * t2 + p0;
  var p12 = (p2 - p1) * t2 + p1;
  var p23 = (p3 - p2) * t2 + p2;
  var p012 = (p12 - p01) * t2 + p01;
  var p123 = (p23 - p12) * t2 + p12;
  var p0123 = (p123 - p012) * t2 + p012;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, out2) {
  var t2;
  var interval = 5e-3;
  var d3 = Infinity;
  var prev;
  var next;
  var d1;
  var d22;
  _v0[0] = x4;
  _v0[1] = y4;
  for (var _t2 = 0; _t2 < 1; _t2 += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t2);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t2);
    d1 = distSquare(_v0, _v1);
    if (d1 < d3) {
      t2 = _t2;
      d3 = d1;
    }
  }
  d3 = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t2 - interval;
    next = t2 + interval;
    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d3) {
      t2 = prev;
      d3 = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d22 = distSquare(_v2, _v0);
      if (next <= 1 && d22 < d3) {
        t2 = next;
        d3 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x0, x1, x2, x3, t2);
    out2[1] = cubicAt(y0, y1, y2, y3, t2);
  }
  return mathSqrt$3(d3);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  var px = x0;
  var py = y0;
  var d3 = 0;
  var step = 1 / iteration;
  for (var i2 = 1; i2 <= iteration; i2++) {
    var t2 = i2 * step;
    var x4 = cubicAt(x0, x1, x2, x3, t2);
    var y4 = cubicAt(y0, y1, y2, y3, t2);
    var dx = x4 - px;
    var dy = y4 - py;
    d3 += Math.sqrt(dx * dx + dy * dy);
    px = x4;
    py = y4;
  }
  return d3;
}
function quadraticAt(p0, p1, p2, t2) {
  var onet = 1 - t2;
  return onet * (onet * p0 + 2 * t2 * p1) + t2 * t2 * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t2) {
  return 2 * ((1 - t2) * (p1 - p0) + t2 * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val2, roots2) {
  var a2 = p0 - 2 * p1 + p2;
  var b2 = 2 * (p1 - p0);
  var c2 = p0 - val2;
  var n2 = 0;
  if (isAroundZero(a2)) {
    if (isNotAroundZero$1(b2)) {
      var t1 = -c2 / b2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
    }
  } else {
    var disc = b2 * b2 - 4 * a2 * c2;
    if (isAroundZero(disc)) {
      var t1 = -b2 / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b2 + discSqrt) / (2 * a2);
      var t2 = (-b2 - discSqrt) / (2 * a2);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n2++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n2++] = t2;
      }
    }
  }
  return n2;
}
function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p2, t2, out2) {
  var p01 = (p1 - p0) * t2 + p0;
  var p12 = (p2 - p1) * t2 + p1;
  var p012 = (p12 - p01) * t2 + p01;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p12;
  out2[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, out2) {
  var t2;
  var interval = 5e-3;
  var d3 = Infinity;
  _v0[0] = x3;
  _v0[1] = y3;
  for (var _t2 = 0; _t2 < 1; _t2 += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t2);
    _v1[1] = quadraticAt(y0, y1, y2, _t2);
    var d1 = distSquare(_v0, _v1);
    if (d1 < d3) {
      t2 = _t2;
      d3 = d1;
    }
  }
  d3 = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev = t2 - interval;
    var next = t2 + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    var d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d3) {
      t2 = prev;
      d3 = d1;
    } else {
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      var d22 = distSquare(_v2, _v0);
      if (next <= 1 && d22 < d3) {
        t2 = next;
        d3 = d22;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt(x0, x1, x2, t2);
    out2[1] = quadraticAt(y0, y1, y2, t2);
  }
  return mathSqrt$3(d3);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
  var px = x0;
  var py = y0;
  var d3 = 0;
  var step = 1 / iteration;
  for (var i2 = 1; i2 <= iteration; i2++) {
    var t2 = i2 * step;
    var x3 = quadraticAt(x0, x1, x2, t2);
    var y3 = quadraticAt(y0, y1, y2, t2);
    var dx = x3 - px;
    var dy = y3 - py;
    d3 += Math.sqrt(dx * dx + dy * dy);
    px = x3;
    py = y3;
  }
  return d3;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic) {
    var points2 = cubic[1].split(",");
    var a_1 = +trim$3(points2[0]);
    var b_1 = +trim$3(points2[1]);
    var c_1 = +trim$3(points2[2]);
    var d_1 = +trim$3(points2[3]);
    if (isNaN(a_1 + b_1 + c_1 + d_1)) {
      return;
    }
    var roots_1 = [];
    return function(p2) {
      return p2 <= 0 ? 0 : p2 >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p2, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
    };
  }
}
var Clip = function() {
  function Clip2(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop$3;
    this.ondestroy = opts.ondestroy || noop$3;
    this.onrestart = opts.onrestart || noop$3;
    opts.easing && this.setEasing(opts.easing);
  }
  Clip2.prototype.step = function(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var life = this._life;
    var elapsedTime = globalTime - this._startTime - this._pausedTime;
    var percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    var easingFunc = this.easingFunc;
    var schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        var remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  };
  Clip2.prototype.pause = function() {
    this._paused = true;
  };
  Clip2.prototype.resume = function() {
    this._paused = false;
  };
  Clip2.prototype.setEasing = function(easing) {
    this.easing = easing;
    this.easingFunc = isFunction$h(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
  };
  return Clip2;
}();
var Clip$1 = Clip;
var Entry = function() {
  function Entry2(val2) {
    this.value = val2;
  }
  return Entry2;
}();
var LinkedList = function() {
  function LinkedList2() {
    this._len = 0;
  }
  LinkedList2.prototype.insert = function(val2) {
    var entry = new Entry(val2);
    this.insertEntry(entry);
    return entry;
  };
  LinkedList2.prototype.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  };
  LinkedList2.prototype.remove = function(entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  LinkedList2.prototype.len = function() {
    return this._len;
  };
  LinkedList2.prototype.clear = function() {
    this.head = this.tail = null;
    this._len = 0;
  };
  return LinkedList2;
}();
var LRU = function() {
  function LRU2(maxSize) {
    this._list = new LinkedList();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  LRU2.prototype.put = function(key, value) {
    var list = this._list;
    var map2 = this._map;
    var removed = null;
    if (map2[key] == null) {
      var len2 = list.len();
      var entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map2[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key;
      list.insertEntry(entry);
      map2[key] = entry;
    }
    return removed;
  };
  LRU2.prototype.get = function(key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRU2.prototype.clear = function() {
    this._list.clear();
    this._map = {};
  };
  LRU2.prototype.len = function() {
    return this._list.len();
  };
  return LRU2;
}();
var LRU$1 = LRU;
var kCSSColorTable = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte(i2) {
  i2 = Math.round(i2);
  return i2 < 0 ? 0 : i2 > 255 ? 255 : i2;
}
function clampCssAngle(i2) {
  i2 = Math.round(i2);
  return i2 < 0 ? 0 : i2 > 360 ? 360 : i2;
}
function clampCssFloat(f2) {
  return f2 < 0 ? 0 : f2 > 1 ? 1 : f2;
}
function parseCssInt(val2) {
  var str = val2;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val2) {
  var str = val2;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h2) {
  if (h2 < 0) {
    h2 += 1;
  } else if (h2 > 1) {
    h2 -= 1;
  }
  if (h2 * 6 < 1) {
    return m1 + (m2 - m1) * h2 * 6;
  }
  if (h2 * 2 < 1) {
    return m2;
  }
  if (h2 * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h2) * 6;
  }
  return m1;
}
function lerpNumber(a2, b2, p2) {
  return a2 + (b2 - a2) * p2;
}
function setRgba(out2, r2, g2, b2, a2) {
  out2[0] = r2;
  out2[1] = g2;
  out2[2] = b2;
  out2[3] = a2;
  return out2;
}
function copyRgba(out2, a2) {
  out2[0] = a2[0];
  out2[1] = a2[1];
  out2[2] = a2[2];
  out2[3] = a2[3];
  return out2;
}
var colorCache = new LRU$1(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  var strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      var iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      var iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op2 = str.indexOf("(");
  var ep2 = str.indexOf(")");
  if (op2 !== -1 && ep2 + 1 === strLen) {
    var fname = str.substr(0, op2);
    var params = str.substr(op2 + 1, ep2 - (op2 + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  var h2 = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s2 = parseCssFloat(hsla[1]);
  var l2 = parseCssFloat(hsla[2]);
  var m2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var m1 = l2 * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h2 + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h2) * 255), clampCssByte(cssHueToRgb(m1, m2, h2 - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  var R2 = rgba[0] / 255;
  var G2 = rgba[1] / 255;
  var B2 = rgba[2] / 255;
  var vMin = Math.min(R2, G2, B2);
  var vMax = Math.max(R2, G2, B2);
  var delta = vMax - vMin;
  var L2 = (vMax + vMin) / 2;
  var H2;
  var S2;
  if (delta === 0) {
    H2 = 0;
    S2 = 0;
  } else {
    if (L2 < 0.5) {
      S2 = delta / (vMax + vMin);
    } else {
      S2 = delta / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R2) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G2) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B2) / 6 + delta / 2) / delta;
    if (R2 === vMax) {
      H2 = deltaB - deltaG;
    } else if (G2 === vMax) {
      H2 = 1 / 3 + deltaR - deltaB;
    } else if (B2 === vMax) {
      H2 = 2 / 3 + deltaG - deltaR;
    }
    if (H2 < 0) {
      H2 += 1;
    }
    if (H2 > 1) {
      H2 -= 1;
    }
  }
  var hsla = [H2 * 360, S2, L2];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color2, level) {
  var colorArr = parse(color2);
  if (colorArr) {
    for (var i2 = 0; i2 < 3; i2++) {
      if (level < 0) {
        colorArr[i2] = colorArr[i2] * (1 - level) | 0;
      } else {
        colorArr[i2] = (255 - colorArr[i2]) * level + colorArr[i2] | 0;
      }
      if (colorArr[i2] > 255) {
        colorArr[i2] = 255;
      } else if (colorArr[i2] < 0) {
        colorArr[i2] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(color2) {
  var colorArr = parse(color2);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
var fastMapToColor = fastLerp;
function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color2 = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color: color2,
    leftIndex,
    rightIndex,
    value
  } : color2;
}
var mapToColor = lerp;
function modifyHSL(color2, h2, s2, l2) {
  var colorArr = parse(color2);
  if (color2) {
    colorArr = rgba2hsla(colorArr);
    h2 != null && (colorArr[0] = clampCssAngle(h2));
    s2 != null && (colorArr[1] = parseCssFloat(s2));
    l2 != null && (colorArr[2] = parseCssFloat(l2));
    return stringify(hsla2rgba(colorArr), "rgba");
  }
}
function modifyAlpha(color2, alpha) {
  var colorArr = parse(color2);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type2) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type2 === "rgba" || type2 === "hsva" || type2 === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type2 + "(" + colorStr + ")";
}
function lum(color2, backgroundLum) {
  var arr = parse(color2);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
function random$4() {
  return stringify([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parse,
  lift,
  toHex,
  fastLerp,
  fastMapToColor,
  lerp,
  mapToColor,
  modifyHSL,
  modifyAlpha,
  stringify,
  lum,
  random: random$4
}, Symbol.toStringTag, { value: "Module" }));
function isLinearGradient(val2) {
  return val2.type === "linear";
}
function isRadialGradient(val2) {
  return val2.type === "radial";
}
(function() {
  if (env$1.hasGlobalWindow && isFunction$h(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(str));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    return null;
  };
})();
var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  for (var i2 = 0; i2 < len2; i2++) {
    out2[i2] = interpolateNumber$1(p0[i2], p1[i2], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p0, p1, percent) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i2 = 0; i2 < len2; i2++) {
    if (!out2[i2]) {
      out2[i2] = [];
    }
    for (var j2 = 0; j2 < len22; j2++) {
      out2[i2][j2] = interpolateNumber$1(p0[i2][j2], p1[i2][j2], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p0, p1, sign) {
  var len2 = p0.length;
  for (var i2 = 0; i2 < len2; i2++) {
    out2[i2] = p0[i2] + p1[i2] * sign;
  }
  return out2;
}
function add2DArray(out2, p0, p1, sign) {
  var len2 = p0.length;
  var len22 = len2 && p0[0].length;
  for (var i2 = 0; i2 < len2; i2++) {
    if (!out2[i2]) {
      out2[i2] = [];
    }
    for (var j2 = 0; j2 < len22; j2++) {
      out2[i2][j2] = p0[i2][j2] + p1[i2][j2] * sign;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  var len0 = val0.length;
  var len1 = val1.length;
  var shorterArr = len0 > len1 ? val1 : val0;
  var shorterLen = Math.min(len0, len1);
  var last2 = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
  for (var i2 = shorterLen; i2 < Math.max(len0, len1); i2++) {
    shorterArr.push({
      offset: last2.offset,
      color: last2.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  var arr0 = val0;
  var arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i2 = arr0Len; i2 < arr1Len; i2++) {
        arr0.push(arrDim === 1 ? arr1[i2] : arraySlice.call(arr1[i2]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i2 = 0; i2 < arr0.length; i2++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i2])) {
        arr0[i2] = arr1[i2];
      }
    } else {
      for (var j2 = 0; j2 < len2; j2++) {
        if (isNaN(arr0[i2][j2])) {
          arr0[i2][j2] = arr1[i2][j2];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike$2(value)) {
    var len2 = value.length;
    if (isArrayLike$2(value[0])) {
      var ret = [];
      for (var i2 = 0; i2 < len2; i2++) {
        ret.push(arraySlice.call(value[i2]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike$2(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = function() {
  function Track2(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  Track2.prototype.isFinished = function() {
    return this._finished;
  };
  Track2.prototype.setFinished = function() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  };
  Track2.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  };
  Track2.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  };
  Track2.prototype.addKeyframe = function(time2, rawValue, easing) {
    this._needsSort = true;
    var keyframes = this.keyframes;
    var len2 = keyframes.length;
    var discrete = false;
    var valType = VALUE_TYPE_UNKOWN;
    var value = rawValue;
    if (isArrayLike$2(rawValue)) {
      var arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber$c(rawValue[0]) || arrayDim === 2 && !isNumber$c(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber$c(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString$d(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          var colorArray = parse(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        var parsedGradient = extend$1({}, value);
        parsedGradient.colorStops = map$9(rawValue.colorStops, function(colorStop) {
          return {
            offset: colorStop.offset,
            color: parse(colorStop.color)
          };
        });
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    var kf2 = {
      time: time2,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf2.easing = easing;
      kf2.easingFunc = isFunction$h(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf2);
    return kf2;
  };
  Track2.prototype.prepare = function(maxTime, additiveTrack) {
    var kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a2, b2) {
        return a2.time - b2.time;
      });
    }
    var valType = this.valType;
    var kfsLen = kfs.length;
    var lastKf = kfs[kfsLen - 1];
    var isDiscrete = this.discrete;
    var isArr = isArrayValueType(valType);
    var isGradient = isGradientValueType(valType);
    for (var i2 = 0; i2 < kfsLen; i2++) {
      var kf2 = kfs[i2];
      var value = kf2.value;
      var lastValue = lastKf.value;
      kf2.percent = kf2.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i2 !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      var startValue = kfs[0].value;
      for (var i2 = 0; i2 < kfsLen; i2++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i2].additiveValue = kfs[i2].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i2].additiveValue = add1DArray([], kfs[i2].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i2].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i2].value, startValue, -1) : add2DArray([], kfs[i2].value, startValue, -1);
        }
      }
    }
  };
  Track2.prototype.step = function(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    var isAdditive = this._additiveTrack != null;
    var valueKey = isAdditive ? "additiveValue" : "value";
    var valType = this.valType;
    var keyframes = this.keyframes;
    var kfsNum = keyframes.length;
    var propName = this.propName;
    var isValueColor = valType === VALUE_TYPE_COLOR;
    var frameIdx;
    var lastFrame = this._lastFr;
    var mathMin2 = Math.min;
    var frame;
    var nextFrame2;
    if (kfsNum === 1) {
      frame = nextFrame2 = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
      }
      nextFrame2 = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame2)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    var interval = nextFrame2.percent - frame.percent;
    var w2 = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
    if (nextFrame2.easingFunc) {
      w2 = nextFrame2.easingFunc(w2);
    }
    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w2 < 1 ? frame.rawValue : nextFrame2.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2) : interpolate2DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2);
    } else if (isGradientValueType(valType)) {
      var val2 = frame[valueKey];
      var nextVal_1 = nextFrame2[valueKey];
      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient_1 ? "linear" : "radial",
        x: interpolateNumber$1(val2.x, nextVal_1.x, w2),
        y: interpolateNumber$1(val2.y, nextVal_1.y, w2),
        colorStops: map$9(val2.colorStops, function(colorStop, idx) {
          var nextColorStop = nextVal_1.colorStops[idx];
          return {
            offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w2),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w2))
          };
        }),
        global: nextVal_1.global
      };
      if (isLinearGradient_1) {
        target[propName].x2 = interpolateNumber$1(val2.x2, nextVal_1.x2, w2);
        target[propName].y2 = interpolateNumber$1(val2.y2, nextVal_1.y2, w2);
      } else {
        target[propName].r = interpolateNumber$1(val2.r, nextVal_1.r, w2);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame2[valueKey], w2);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      var value = interpolateNumber$1(frame[valueKey], nextFrame2[valueKey], w2);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  };
  Track2.prototype._addToTarget = function(target) {
    var valType = this.valType;
    var propName = this.propName;
    var additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  };
  return Track2;
}();
var Animator = function() {
  function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  Animator2.prototype.getMaxTime = function() {
    return this._maxTime;
  };
  Animator2.prototype.getDelay = function() {
    return this._delay;
  };
  Animator2.prototype.getLoop = function() {
    return this._loop;
  };
  Animator2.prototype.getTarget = function() {
    return this._target;
  };
  Animator2.prototype.changeTarget = function(target) {
    this._target = target;
  };
  Animator2.prototype.when = function(time2, props, easing) {
    return this.whenWithKeys(time2, props, keys$d(props), easing);
  };
  Animator2.prototype.whenWithKeys = function(time2, props, propNames, easing) {
    var tracks = this._tracks;
    for (var i2 = 0; i2 < propNames.length; i2++) {
      var propName = propNames[i2];
      var track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        var initialValue = void 0;
        var additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          var addtiveTrackKfs = additiveTrack.keyframes;
          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time2 > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time2, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time2);
    return this;
  };
  Animator2.prototype.pause = function() {
    this._clip.pause();
    this._paused = true;
  };
  Animator2.prototype.resume = function() {
    this._clip.resume();
    this._paused = false;
  };
  Animator2.prototype.isPaused = function() {
    return !!this._paused;
  };
  Animator2.prototype.duration = function(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  };
  Animator2.prototype._doneCallback = function() {
    this._setTracksFinished();
    this._clip = null;
    var doneList = this._doneCbs;
    if (doneList) {
      var len2 = doneList.length;
      for (var i2 = 0; i2 < len2; i2++) {
        doneList[i2].call(this);
      }
    }
  };
  Animator2.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var animation = this.animation;
    var abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (var i2 = 0; i2 < abortedList.length; i2++) {
        abortedList[i2].call(this);
      }
    }
  };
  Animator2.prototype._setTracksFinished = function() {
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i2 = 0; i2 < tracksKeys.length; i2++) {
      tracks[tracksKeys[i2]].setFinished();
    }
  };
  Animator2.prototype._getAdditiveTrack = function(trackName) {
    var additiveTrack;
    var additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
        var track = additiveAnimators[i2].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  };
  Animator2.prototype.start = function(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    var self2 = this;
    var tracks = [];
    var maxTime = this._maxTime || 0;
    for (var i2 = 0; i2 < this._trackKeys.length; i2++) {
      var propName = this._trackKeys[i2];
      var track = this._tracks[propName];
      var additiveTrack = this._getAdditiveTrack(propName);
      var kfs = track.keyframes;
      var kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          var lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      var clip2 = new Clip$1({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe: function(percent) {
          self2._started = 2;
          var additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            var stillHasAdditiveAnimator = false;
            for (var i3 = 0; i3 < additiveAnimators.length; i3++) {
              if (additiveAnimators[i3]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (var i3 = 0; i3 < tracks.length; i3++) {
            tracks[i3].step(self2._target, percent);
          }
          var onframeList = self2._onframeCbs;
          if (onframeList) {
            for (var i3 = 0; i3 < onframeList.length; i3++) {
              onframeList[i3](self2._target, percent);
            }
          }
        },
        ondestroy: function() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  };
  Animator2.prototype.stop = function(forwardToLast) {
    if (!this._clip) {
      return;
    }
    var clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  };
  Animator2.prototype.delay = function(time2) {
    this._delay = time2;
    return this;
  };
  Animator2.prototype.during = function(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.done = function(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.aborted = function(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.getClip = function() {
    return this._clip;
  };
  Animator2.prototype.getTrack = function(propName) {
    return this._tracks[propName];
  };
  Animator2.prototype.getTracks = function() {
    var _this = this;
    return map$9(this._trackKeys, function(key) {
      return _this._tracks[key];
    });
  };
  Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i2 = 0; i2 < propNames.length; i2++) {
      var track = tracks[propNames[i2]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    var allAborted = true;
    for (var i2 = 0; i2 < tracksKeys.length; i2++) {
      if (!tracks[tracksKeys[i2]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  };
  Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (var i2 = 0; i2 < trackKeys.length; i2++) {
      var propName = trackKeys[i2];
      var track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      var kfs = track.keyframes;
      var kf2 = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf2) {
        target[propName] = cloneValue(kf2.rawValue);
      }
    }
  };
  Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
    trackKeys = trackKeys || keys$d(finalProps);
    for (var i2 = 0; i2 < trackKeys.length; i2++) {
      var propName = trackKeys[i2];
      var track = this._tracks[propName];
      if (!track) {
        continue;
      }
      var kfs = track.keyframes;
      if (kfs.length > 1) {
        var lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  };
  return Animator2;
}();
var Animator$1 = Animator;
function getTime() {
  return new Date().getTime();
}
var Animation = function(_super) {
  __extends(Animation2, _super);
  function Animation2(opts) {
    var _this = _super.call(this) || this;
    _this._running = false;
    _this._time = 0;
    _this._pausedTime = 0;
    _this._pauseStart = 0;
    _this._paused = false;
    opts = opts || {};
    _this.stage = opts.stage || {};
    return _this;
  }
  Animation2.prototype.addClip = function(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  };
  Animation2.prototype.addAnimator = function(animator) {
    animator.animation = this;
    var clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  };
  Animation2.prototype.removeClip = function(clip2) {
    if (!clip2.animation) {
      return;
    }
    var prev = clip2.prev;
    var next = clip2.next;
    if (prev) {
      prev.next = next;
    } else {
      this._head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  };
  Animation2.prototype.removeAnimator = function(animator) {
    var clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  };
  Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
    var time2 = getTime() - this._pausedTime;
    var delta = time2 - this._time;
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      var finished = clip2.step(time2, delta);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time2;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  };
  Animation2.prototype._startLoop = function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame$1(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame$1(step);
  };
  Animation2.prototype.start = function() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  };
  Animation2.prototype.stop = function() {
    this._running = false;
  };
  Animation2.prototype.pause = function() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  };
  Animation2.prototype.resume = function() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  };
  Animation2.prototype.clear = function() {
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  };
  Animation2.prototype.isFinished = function() {
    return this._head == null;
  };
  Animation2.prototype.animate = function(target, options) {
    options = options || {};
    this.start();
    var animator = new Animator$1(target, options.loop);
    this.addAnimator(animator);
    return animator;
  };
  return Animation2;
}(Eventful$1);
var Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$1.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = map$9(mouseHandlerNames, function(name2) {
    var nm = name2.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name2;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance2, event) {
  return normalizeEvent(instance2.dom, new FakeGlobalEvent(instance2, event), true);
}
function isLocalEl(instance2, el2) {
  var elTmp = el2;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el2 && elTmp === instance2.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = function() {
  function FakeGlobalEvent2(instance2, event) {
    this.stopPropagation = noop$3;
    this.stopImmediatePropagation = noop$3;
    this.preventDefault = noop$3;
    this.type = event.type;
    this.target = this.currentTarget = instance2.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
  return FakeGlobalEvent2;
}();
var localDOMHandlers = {
  mousedown: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove: function(event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout: function(event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel: function(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel: function(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each$q(["click", "dblclick", "contextmenu"], function(name2) {
  localDOMHandlers[name2] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name2, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    var pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance2, scope) {
  var domHandlers = scope.domHandlers;
  if (env$1.pointerEventsSupported) {
    each$q(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance2, event);
      });
    });
  } else {
    if (env$1.touchEventsSupported) {
      each$q(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance2, event);
          setTouchTimer(scope);
        });
      });
    }
    each$q(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance2, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance2, scope) {
  if (env$1.pointerEventsSupported) {
    each$q(globalNativeListenerNames.pointer, mount);
  } else if (!env$1.touchEventsSupported) {
    each$q(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance2, event.target)) {
        event = normalizeGlobalEvent(instance2, event);
        scope.domHandlers[nativeEventName].call(instance2, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted3 = scope.mounted;
  for (var nativeEventName in mounted3) {
    if (mounted3.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted3[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = function() {
  function DOMHandlerScope2(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
  return DOMHandlerScope2;
}();
var HandlerDomProxy = function(_super) {
  __extends(HandlerDomProxy2, _super);
  function HandlerDomProxy2(dom, painterRoot) {
    var _this = _super.call(this) || this;
    _this.__pointerCapturing = false;
    _this.dom = dom;
    _this.painterRoot = painterRoot;
    _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(_this, _this._localHandlerScope);
    return _this;
  }
  HandlerDomProxy2.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };
  HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  };
  HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      var globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  };
  return HandlerDomProxy2;
}(Eventful$1);
var HandlerProxy = HandlerDomProxy;
var dpr = 1;
if (env$1.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function identity$2(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul(out2, m1, m2) {
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out22 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate$1(out2, a2, v2) {
  out2[0] = a2[0];
  out2[1] = a2[1];
  out2[2] = a2[2];
  out2[3] = a2[3];
  out2[4] = a2[4] + v2[0];
  out2[5] = a2[5] + v2[1];
  return out2;
}
function rotate(out2, a2, rad) {
  var aa2 = a2[0];
  var ac2 = a2[2];
  var atx = a2[4];
  var ab = a2[1];
  var ad2 = a2[3];
  var aty = a2[5];
  var st2 = Math.sin(rad);
  var ct2 = Math.cos(rad);
  out2[0] = aa2 * ct2 + ab * st2;
  out2[1] = -aa2 * st2 + ab * ct2;
  out2[2] = ac2 * ct2 + ad2 * st2;
  out2[3] = -ac2 * st2 + ct2 * ad2;
  out2[4] = ct2 * atx + st2 * aty;
  out2[5] = ct2 * aty - st2 * atx;
  return out2;
}
function scale$1(out2, a2, v2) {
  var vx = v2[0];
  var vy = v2[1];
  out2[0] = a2[0] * vx;
  out2[1] = a2[1] * vy;
  out2[2] = a2[2] * vx;
  out2[3] = a2[3] * vy;
  out2[4] = a2[4] * vx;
  out2[5] = a2[5] * vy;
  return out2;
}
function invert(out2, a2) {
  var aa2 = a2[0];
  var ac2 = a2[2];
  var atx = a2[4];
  var ab = a2[1];
  var ad2 = a2[3];
  var aty = a2[5];
  var det = aa2 * ad2 - ab * ac2;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad2 * det;
  out2[1] = -ab * det;
  out2[2] = -ac2 * det;
  out2[3] = aa2 * det;
  out2[4] = (ac2 * aty - ad2 * atx) * det;
  out2[5] = (ab * atx - aa2 * aty) * det;
  return out2;
}
function clone$6(a2) {
  var b2 = create();
  copy(b2, a2);
  return b2;
}
var matrix = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create,
  identity: identity$2,
  copy,
  mul,
  translate: translate$1,
  rotate,
  scale: scale$1,
  invert,
  clone: clone$6
}, Symbol.toStringTag, { value: "Module" }));
var mIdentity = identity$2;
var EPSILON$2 = 5e-5;
function isNotAroundZero(val2) {
  return val2 > EPSILON$2 || val2 < -EPSILON$2;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create();
var abs = Math.abs;
var Transformable = function() {
  function Transformable2() {
  }
  Transformable2.prototype.getLocalTransform = function(m2) {
    return Transformable2.getLocalTransform(this, m2);
  };
  Transformable2.prototype.setPosition = function(arr) {
    this.x = arr[0];
    this.y = arr[1];
  };
  Transformable2.prototype.setScale = function(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  };
  Transformable2.prototype.setSkew = function(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  };
  Transformable2.prototype.setOrigin = function(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  };
  Transformable2.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  };
  Transformable2.prototype.updateTransform = function() {
    var parentTransform = this.parent && this.parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      m2 && mIdentity(m2);
      return;
    }
    m2 = m2 || create();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul(m2, parentTransform, m2);
      } else {
        copy(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  };
  Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
    var globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create();
    invert(this.invTransform, m2);
  };
  Transformable2.prototype.getComputedTransform = function() {
    var transformNode = this;
    var ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  };
  Transformable2.prototype.setLocalTransform = function(m2) {
    if (!m2) {
      return;
    }
    var sx = m2[0] * m2[0] + m2[1] * m2[1];
    var sy = m2[2] * m2[2] + m2[3] * m2[3];
    var rotation = Math.atan2(m2[1], m2[0]);
    var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  };
  Transformable2.prototype.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent2 = this.parent;
    var m2 = this.transform;
    if (parent2 && parent2.transform) {
      mul(tmpTransform, parent2.invTransform, m2);
      m2 = tmpTransform;
    }
    var ox = this.originX;
    var oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  };
  Transformable2.prototype.getGlobalScale = function(out2) {
    var m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  };
  Transformable2.prototype.transformCoordToLocal = function(x2, y2) {
    var v2 = [x2, y2];
    var invTransform = this.invTransform;
    if (invTransform) {
      applyTransform$1(v2, v2, invTransform);
    }
    return v2;
  };
  Transformable2.prototype.transformCoordToGlobal = function(x2, y2) {
    var v2 = [x2, y2];
    var transform = this.transform;
    if (transform) {
      applyTransform$1(v2, v2, transform);
    }
    return v2;
  };
  Transformable2.prototype.getLineScale = function() {
    var m2 = this.transform;
    return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  };
  Transformable2.prototype.copyTransform = function(source) {
    copyTransform(this, source);
  };
  Transformable2.getLocalTransform = function(target, m2) {
    m2 = m2 || [];
    var ox = target.originX || 0;
    var oy = target.originY || 0;
    var sx = target.scaleX;
    var sy = target.scaleY;
    var ax = target.anchorX;
    var ay = target.anchorY;
    var rotation = target.rotation || 0;
    var x2 = target.x;
    var y2 = target.y;
    var skewX = target.skewX ? Math.tan(target.skewX) : 0;
    var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      var dx = ox + ax;
      var dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x2;
    m2[5] += oy + y2;
    return m2;
  };
  Transformable2.initDefaultProps = function() {
    var proto2 = Transformable2.prototype;
    proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
    proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
  }();
  return Transformable2;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (var i2 = 0; i2 < TRANSFORMABLE_PROPS.length; i2++) {
    var propName = TRANSFORMABLE_PROPS[i2];
    target[propName] = source[propName];
  }
}
var Transformable$1 = Transformable;
var Point$1 = function() {
  function Point2(x2, y2) {
    this.x = x2 || 0;
    this.y = y2 || 0;
  }
  Point2.prototype.copy = function(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.set = function(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  };
  Point2.prototype.equal = function(other) {
    return other.x === this.x && other.y === this.y;
  };
  Point2.prototype.add = function(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  };
  Point2.prototype.scale = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  };
  Point2.prototype.scaleAndAdd = function(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  };
  Point2.prototype.sub = function(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  };
  Point2.prototype.dot = function(other) {
    return this.x * other.x + this.y * other.y;
  };
  Point2.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Point2.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  };
  Point2.prototype.normalize = function() {
    var len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  };
  Point2.prototype.distance = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.distanceSquare = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return dx * dx + dy * dy;
  };
  Point2.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  Point2.prototype.transform = function(m2) {
    if (!m2) {
      return;
    }
    var x2 = this.x;
    var y2 = this.y;
    this.x = m2[0] * x2 + m2[2] * y2 + m2[4];
    this.y = m2[1] * x2 + m2[3] * y2 + m2[5];
    return this;
  };
  Point2.prototype.toArray = function(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  };
  Point2.prototype.fromArray = function(input4) {
    this.x = input4[0];
    this.y = input4[1];
  };
  Point2.set = function(p2, x2, y2) {
    p2.x = x2;
    p2.y = y2;
  };
  Point2.copy = function(p2, p22) {
    p2.x = p22.x;
    p2.y = p22.y;
  };
  Point2.len = function(p2) {
    return Math.sqrt(p2.x * p2.x + p2.y * p2.y);
  };
  Point2.lenSquare = function(p2) {
    return p2.x * p2.x + p2.y * p2.y;
  };
  Point2.dot = function(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  };
  Point2.add = function(out2, p0, p1) {
    out2.x = p0.x + p1.x;
    out2.y = p0.y + p1.y;
  };
  Point2.sub = function(out2, p0, p1) {
    out2.x = p0.x - p1.x;
    out2.y = p0.y - p1.y;
  };
  Point2.scale = function(out2, p0, scalar) {
    out2.x = p0.x * scalar;
    out2.y = p0.y * scalar;
  };
  Point2.scaleAndAdd = function(out2, p0, p1, scalar) {
    out2.x = p0.x + p1.x * scalar;
    out2.y = p0.y + p1.y * scalar;
  };
  Point2.lerp = function(out2, p0, p1, t2) {
    var onet = 1 - t2;
    out2.x = onet * p0.x + t2 * p1.x;
    out2.y = onet * p0.y + t2 * p1.y;
  };
  return Point2;
}();
var Point$2 = Point$1;
var mathMin$6 = Math.min;
var mathMax$6 = Math.max;
var lt$7 = new Point$2();
var rb = new Point$2();
var lb = new Point$2();
var rt$7 = new Point$2();
var minTv$1 = new Point$2();
var maxTv$1 = new Point$2();
var BoundingRect = function() {
  function BoundingRect2(x2, y2, width2, height2) {
    if (width2 < 0) {
      x2 = x2 + width2;
      width2 = -width2;
    }
    if (height2 < 0) {
      y2 = y2 + height2;
      height2 = -height2;
    }
    this.x = x2;
    this.y = y2;
    this.width = width2;
    this.height = height2;
  }
  BoundingRect2.prototype.union = function(other) {
    var x2 = mathMin$6(other.x, this.x);
    var y2 = mathMin$6(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax$6(other.x + other.width, this.x + this.width) - x2;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax$6(other.y + other.height, this.y + this.height) - y2;
    } else {
      this.height = other.height;
    }
    this.x = x2;
    this.y = y2;
  };
  BoundingRect2.prototype.applyTransform = function(m2) {
    BoundingRect2.applyTransform(this, this, m2);
  };
  BoundingRect2.prototype.calculateTransform = function(b2) {
    var a2 = this;
    var sx = b2.width / a2.width;
    var sy = b2.height / a2.height;
    var m2 = create();
    translate$1(m2, m2, [-a2.x, -a2.y]);
    scale$1(m2, m2, [sx, sy]);
    translate$1(m2, m2, [b2.x, b2.y]);
    return m2;
  };
  BoundingRect2.prototype.intersect = function(b2, mtv) {
    if (!b2) {
      return false;
    }
    if (!(b2 instanceof BoundingRect2)) {
      b2 = BoundingRect2.create(b2);
    }
    var a2 = this;
    var ax0 = a2.x;
    var ax1 = a2.x + a2.width;
    var ay0 = a2.y;
    var ay1 = a2.y + a2.height;
    var bx0 = b2.x;
    var bx1 = b2.x + b2.width;
    var by0 = b2.y;
    var by1 = b2.y + b2.height;
    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      var dMin = Infinity;
      var dMax = 0;
      var d0 = Math.abs(ax1 - bx0);
      var d1 = Math.abs(bx1 - ax0);
      var d22 = Math.abs(ay1 - by0);
      var d3 = Math.abs(by1 - ay0);
      var dx = Math.min(d0, d1);
      var dy = Math.min(d22, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point$2.set(maxTv$1, -d0, 0);
          } else {
            Point$2.set(maxTv$1, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point$2.set(minTv$1, d0, 0);
          } else {
            Point$2.set(minTv$1, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d22 < d3) {
            Point$2.set(maxTv$1, 0, -d22);
          } else {
            Point$2.set(maxTv$1, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d22 < d3) {
            Point$2.set(minTv$1, 0, d22);
          } else {
            Point$2.set(minTv$1, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point$2.copy(mtv, overlap ? minTv$1 : maxTv$1);
    }
    return overlap;
  };
  BoundingRect2.prototype.contain = function(x2, y2) {
    var rect = this;
    return x2 >= rect.x && x2 <= rect.x + rect.width && y2 >= rect.y && y2 <= rect.y + rect.height;
  };
  BoundingRect2.prototype.clone = function() {
    return new BoundingRect2(this.x, this.y, this.width, this.height);
  };
  BoundingRect2.prototype.copy = function(other) {
    BoundingRect2.copy(this, other);
  };
  BoundingRect2.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };
  BoundingRect2.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  };
  BoundingRect2.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  };
  BoundingRect2.create = function(rect) {
    return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
  };
  BoundingRect2.copy = function(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
  };
  BoundingRect2.applyTransform = function(target, source, m2) {
    if (!m2) {
      if (target !== source) {
        BoundingRect2.copy(target, source);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      var sx = m2[0];
      var sy = m2[3];
      var tx = m2[4];
      var ty = m2[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt$7.x = lb.x = source.x;
    lt$7.y = rt$7.y = source.y;
    rb.x = rt$7.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt$7.transform(m2);
    rt$7.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin$6(lt$7.x, rb.x, lb.x, rt$7.x);
    target.y = mathMin$6(lt$7.y, rb.y, lb.y, rt$7.y);
    var maxX = mathMax$6(lt$7.x, rb.x, lb.x, rt$7.x);
    var maxY = mathMax$6(lt$7.y, rb.y, lb.y, rt$7.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  };
  return BoundingRect2;
}();
var BoundingRect$1 = BoundingRect;
var textWidthCache = {};
function getWidth(text2, font) {
  font = font || DEFAULT_FONT;
  var cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRU$1(500);
  }
  var width2 = cacheOfFont.get(text2);
  if (width2 == null) {
    width2 = platformApi.measureText(text2, font).width;
    cacheOfFont.put(text2, width2);
  }
  return width2;
}
function innerGetBoundingRect(text2, font, textAlign, textBaseline) {
  var width2 = getWidth(text2, font);
  var height2 = getLineHeight(font);
  var x2 = adjustTextX(0, width2, textAlign);
  var y2 = adjustTextY(0, height2, textBaseline);
  var rect = new BoundingRect$1(x2, y2, width2, height2);
  return rect;
}
function getBoundingRect(text2, font, textAlign, textBaseline) {
  var textLines = ((text2 || "") + "").split("\n");
  var len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    var uniondRect = new BoundingRect$1(0, 0, 0, 0);
    for (var i2 = 0; i2 < textLines.length; i2++) {
      var rect = innerGetBoundingRect(textLines[i2], font, textAlign, textBaseline);
      i2 === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x2, width2, textAlign) {
  if (textAlign === "right") {
    x2 -= width2;
  } else if (textAlign === "center") {
    x2 -= width2 / 2;
  }
  return x2;
}
function adjustTextY(y2, height2, verticalAlign) {
  if (verticalAlign === "middle") {
    y2 -= height2 / 2;
  } else if (verticalAlign === "bottom") {
    y2 -= height2;
  }
  return y2;
}
function getLineHeight(font) {
  return getWidth("\u56FD", font);
}
function parsePercent$1(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  var textPosition = opts.position || "inside";
  var distance2 = opts.distance != null ? opts.distance : 5;
  var height2 = rect.height;
  var width2 = rect.width;
  var halfHeight = height2 / 2;
  var x2 = rect.x;
  var y2 = rect.y;
  var textAlign = "left";
  var textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x2 += parsePercent$1(textPosition[0], rect.width);
    y2 += parsePercent$1(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x2 -= distance2;
        y2 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x2 += distance2 + width2;
        y2 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x2 += width2 / 2;
        y2 -= distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x2 += width2 / 2;
        y2 += height2 + distance2;
        textAlign = "center";
        break;
      case "inside":
        x2 += width2 / 2;
        y2 += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x2 += distance2;
        y2 += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x2 += width2 - distance2;
        y2 += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x2 += width2 / 2;
        y2 += distance2;
        textAlign = "center";
        break;
      case "insideBottom":
        x2 += width2 / 2;
        y2 += height2 - distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x2 += distance2;
        y2 += distance2;
        break;
      case "insideTopRight":
        x2 += width2 - distance2;
        y2 += distance2;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x2 += distance2;
        y2 += height2 - distance2;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x2 += width2 - distance2;
        y2 += height2 - distance2;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x2;
  out2.y = y2;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce$2(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = true;
  return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0);
var Element$2 = function() {
  function Element3(props) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  Element3.prototype._init = function(props) {
    this.attr(props);
  };
  Element3.prototype.drift = function(dx, dy, e3) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  };
  Element3.prototype.beforeUpdate = function() {
  };
  Element3.prototype.afterUpdate = function() {
  };
  Element3.prototype.update = function() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  };
  Element3.prototype.updateInnerText = function(forceUpdate) {
    var textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      var textConfig = this.textConfig;
      var isLocal = textConfig.local;
      var innerTransformable = textEl.innerTransformable;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      var innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        var layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        var textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          var relOriginX = void 0;
          var relOriginY = void 0;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent$1(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent$1(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      var textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      var textFill = void 0;
      var textStroke = void 0;
      var autoStroke = void 0;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  };
  Element3.prototype.canBeInsideText = function() {
    return true;
  };
  Element3.prototype.getInsideTextFill = function() {
    return "#fff";
  };
  Element3.prototype.getInsideTextStroke = function(textFill) {
    return "#000";
  };
  Element3.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  };
  Element3.prototype.getOutsideStroke = function(textFill) {
    var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    var alpha = colorArr[3];
    var isDark = this.__zr.isDarkMode();
    for (var i2 = 0; i2 < 3; i2++) {
      colorArr[i2] = colorArr[i2] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  };
  Element3.prototype.traverse = function(cb, context) {
  };
  Element3.prototype.attrKV = function(key, value) {
    if (key === "textConfig") {
      this.setTextConfig(value);
    } else if (key === "textContent") {
      this.setTextContent(value);
    } else if (key === "clipPath") {
      this.setClipPath(value);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend$1(this.extra, value);
    } else {
      this[key] = value;
    }
  };
  Element3.prototype.hide = function() {
    this.ignore = true;
    this.markRedraw();
  };
  Element3.prototype.show = function() {
    this.ignore = false;
    this.markRedraw();
  };
  Element3.prototype.attr = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject$f(keyOrObj)) {
      var obj = keyOrObj;
      var keysArr = keys$d(obj);
      for (var i2 = 0; i2 < keysArr.length; i2++) {
        var key = keysArr[i2];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  };
  Element3.prototype.saveCurrentToNormalState = function(toState) {
    this._innerSaveToNormal(toState);
    var normalState = this._normalState;
    for (var i2 = 0; i2 < this.animators.length; i2++) {
      var animator = this.animators[i2];
      var fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      var targetName = animator.targetName;
      var target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  };
  Element3.prototype._innerSaveToNormal = function(toState) {
    var normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
  };
  Element3.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
    for (var i2 = 0; i2 < primaryKeys.length; i2++) {
      var key = primaryKeys[i2];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  };
  Element3.prototype.hasState = function() {
    return this.currentStates.length > 0;
  };
  Element3.prototype.getState = function(name2) {
    return this.states[name2];
  };
  Element3.prototype.ensureState = function(name2) {
    var states = this.states;
    if (!states[name2]) {
      states[name2] = {};
    }
    return states[name2];
  };
  Element3.prototype.clearStates = function(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  };
  Element3.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    var toNormalState = stateName === PRESERVED_NORMAL_STATE;
    var hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    var currentStates = this.currentStates;
    var animationCfg = this.stateTransition;
    if (indexOf$2(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    var state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError("State " + stateName + " not exists.");
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  };
  Element3.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      var stateObjects = [];
      var currentStates = this.currentStates;
      var len2 = states.length;
      var notChange = len2 === currentStates.length;
      if (notChange) {
        for (var i2 = 0; i2 < len2; i2++) {
          if (states[i2] !== currentStates[i2]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (var i2 = 0; i2 < len2; i2++) {
        var stateName = states[i2];
        var stateObj = void 0;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      var lastStateObj = stateObjects[len2 - 1];
      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      var mergedState = this._mergeStates(stateObjects);
      var animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  };
  Element3.prototype._updateAnimationTargets = function() {
    for (var i2 = 0; i2 < this.animators.length; i2++) {
      var animator = this.animators[i2];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  };
  Element3.prototype.removeState = function(state) {
    var idx = indexOf$2(this.currentStates, state);
    if (idx >= 0) {
      var currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  };
  Element3.prototype.replaceState = function(oldState, newState, forceAdd) {
    var currentStates = this.currentStates.slice();
    var idx = indexOf$2(currentStates, oldState);
    var newStateExists = indexOf$2(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  };
  Element3.prototype.toggleState = function(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  };
  Element3.prototype._mergeStates = function(states) {
    var mergedState = {};
    var mergedTextConfig;
    for (var i2 = 0; i2 < states.length; i2++) {
      var state = states[i2];
      extend$1(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend$1(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  };
  Element3.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    var needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend$1({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend$1(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    var transitionTarget = {};
    var hasTransition = false;
    for (var i2 = 0; i2 < PRIMARY_STATES_KEYS$1.length; i2++) {
      var key = PRIMARY_STATES_KEYS$1[i2];
      var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (var i2 = 0; i2 < this.animators.length; i2++) {
        var animator = this.animators[i2];
        var targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  };
  Element3.prototype._attachComponent = function(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      return;
    }
    if (componentEl === this) {
      return;
    }
    var zr2 = this.__zr;
    if (zr2) {
      componentEl.addSelfToZr(zr2);
    }
    componentEl.__zr = zr2;
    componentEl.__hostTarget = this;
  };
  Element3.prototype._detachComponent = function(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  };
  Element3.prototype.getClipPath = function() {
    return this._clipPath;
  };
  Element3.prototype.setClipPath = function(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  };
  Element3.prototype.removeClipPath = function() {
    var clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  };
  Element3.prototype.getTextContent = function() {
    return this._textContent;
  };
  Element3.prototype.setTextContent = function(textEl) {
    var previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    textEl.innerTransformable = new Transformable$1();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  };
  Element3.prototype.setTextConfig = function(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend$1(this.textConfig, cfg);
    this.markRedraw();
  };
  Element3.prototype.removeTextConfig = function() {
    this.textConfig = null;
    this.markRedraw();
  };
  Element3.prototype.removeTextContent = function() {
    var textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  };
  Element3.prototype.getTextGuideLine = function() {
    return this._textGuide;
  };
  Element3.prototype.setTextGuideLine = function(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  };
  Element3.prototype.removeTextGuideLine = function() {
    var textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  };
  Element3.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var zr2 = this.__zr;
    if (zr2) {
      if (this.__inHover) {
        zr2.refreshHover();
      } else {
        zr2.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  };
  Element3.prototype.dirty = function() {
    this.markRedraw();
  };
  Element3.prototype._toggleHoverLayerFlag = function(inHover) {
    this.__inHover = inHover;
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  };
  Element3.prototype.addSelfToZr = function(zr2) {
    if (this.__zr === zr2) {
      return;
    }
    this.__zr = zr2;
    var animators = this.animators;
    if (animators) {
      for (var i2 = 0; i2 < animators.length; i2++) {
        zr2.animation.addAnimator(animators[i2]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr2);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr2);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr2);
    }
  };
  Element3.prototype.removeSelfFromZr = function(zr2) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i2 = 0; i2 < animators.length; i2++) {
        zr2.animation.removeAnimator(animators[i2]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr2);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr2);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr2);
    }
  };
  Element3.prototype.animate = function(key, loop, allowDiscreteAnimation) {
    var target = key ? this[key] : this;
    var animator = new Animator$1(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  };
  Element3.prototype.addAnimator = function(animator, key) {
    var zr2 = this.__zr;
    var el2 = this;
    animator.during(function() {
      el2.updateDuringAnimation(key);
    }).done(function() {
      var animators = el2.animators;
      var idx = indexOf$2(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr2) {
      zr2.animation.addAnimator(animator);
    }
    zr2 && zr2.wakeUp();
  };
  Element3.prototype.updateDuringAnimation = function(key) {
    this.markRedraw();
  };
  Element3.prototype.stopAnimation = function(scope, forwardToLast) {
    var animators = this.animators;
    var len2 = animators.length;
    var leftAnimators = [];
    for (var i2 = 0; i2 < len2; i2++) {
      var animator = animators[i2];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  };
  Element3.prototype.animateTo = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  };
  Element3.prototype.animateFrom = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  };
  Element3.prototype._transitionState = function(stateName, target, cfg, animationProps) {
    var animators = animateTo(this, target, cfg, animationProps);
    for (var i2 = 0; i2 < animators.length; i2++) {
      animators[i2].__fromStateTransition = stateName;
    }
  };
  Element3.prototype.getBoundingRect = function() {
    return null;
  };
  Element3.prototype.getPaintRect = function() {
    return null;
  };
  Element3.initDefaultProps = function() {
    var elProto = Element3.prototype;
    elProto.type = "element";
    elProto.name = "";
    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
    elProto.__dirty = REDRAW_BIT;
    function createLegacyProperty(key, privateKey, xKey, yKey) {
      Object.defineProperty(elProto, key, {
        get: function() {
          if (!this[privateKey]) {
            var pos = this[privateKey] = [];
            enhanceArray(this, pos);
          }
          return this[privateKey];
        },
        set: function(pos) {
          this[xKey] = pos[0];
          this[yKey] = pos[1];
          this[privateKey] = pos;
          enhanceArray(this, pos);
        }
      });
      function enhanceArray(self2, pos) {
        Object.defineProperty(pos, 0, {
          get: function() {
            return self2[xKey];
          },
          set: function(val2) {
            self2[xKey] = val2;
          }
        });
        Object.defineProperty(pos, 1, {
          get: function() {
            return self2[yKey];
          },
          set: function(val2) {
            self2[yKey] = val2;
          }
        });
      }
    }
    if (Object.defineProperty) {
      createLegacyProperty("position", "_legacyPos", "x", "y");
      createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
      createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
    }
  }();
  return Element3;
}();
mixin$1(Element$2, Eventful$1);
mixin$1(Element$2, Transformable$1);
function animateTo(animatable, target, cfg, animationProps, reverse2) {
  cfg = cfg || {};
  var animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
  var finishCount = animators.length;
  var doneHappened = false;
  var cfgDone = cfg.done;
  var cfgAborted = cfg.aborted;
  var doneCb = function() {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  var abortedCb = function() {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during(function(target2, percent) {
      cfg.during(percent);
    });
  }
  for (var i2 = 0; i2 < animators.length; i2++) {
    var animator = animators[i2];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (var i2 = 0; i2 < len2; i2++) {
    source[i2] = target[i2];
  }
}
function is2DArray(value) {
  return isArrayLike$2(value[0]);
}
function copyValue$1(target, source, key) {
  if (isArrayLike$2(source[key])) {
    if (!isArrayLike$2(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source[key])) {
      var len2 = source[key].length;
      if (target[key].length !== len2) {
        target[key] = new source[key].constructor(len2);
        copyArrShallow(target[key], source[key], len2);
      }
    } else {
      var sourceArr = source[key];
      var targetArr = target[key];
      var len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        var len1 = sourceArr[0].length;
        for (var i2 = 0; i2 < len0; i2++) {
          if (!targetArr[i2]) {
            targetArr[i2] = Array.prototype.slice.call(sourceArr[i2]);
          } else {
            copyArrShallow(targetArr[i2], sourceArr[i2], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike$2(val1) && isArrayLike$2(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  var len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (var i2 = 0; i2 < len2; i2++) {
    if (arr0[i2] !== arr1[i2]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
  var targetKeys = keys$d(target);
  var duration = cfg.duration;
  var delay2 = cfg.delay;
  var additive = cfg.additive;
  var setToFinal = cfg.setToFinal;
  var animateAll = !isObject$f(animationProps);
  var existsAnimators = animatable.animators;
  var animationKeys = [];
  for (var k2 = 0; k2 < targetKeys.length; k2++) {
    var innerKey = targetKeys[k2];
    var targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject$f(targetVal) && !isArrayLike$2(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse2) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse2) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  var keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (var i2 = 0; i2 < existsAnimators.length; i2++) {
      var animator = existsAnimators[i2];
      if (animator.targetName === topKey) {
        var allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          var idx = indexOf$2(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter$3(animationKeys, function(key) {
      return !isValueSame(target[key], animateObj[key]);
    });
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    var revertedSource = void 0;
    var reversedTarget = void 0;
    var sourceClone = void 0;
    if (reverse2) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (var i2 = 0; i2 < keyLen; i2++) {
        var innerKey = animationKeys[i2];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (var i2 = 0; i2 < keyLen; i2++) {
        var innerKey = animationKeys[i2];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue$1(animateObj, target, innerKey);
      }
    }
    var animator = new Animator$1(animateObj, false, false, additive ? filter$3(existsAnimators, function(animator2) {
      return animator2.targetName === topKey;
    }) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay2 || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element$3 = Element$2;
var Group$2 = function(_super) {
  __extends(Group2, _super);
  function Group2(opts) {
    var _this = _super.call(this) || this;
    _this.isGroup = true;
    _this._children = [];
    _this.attr(opts);
    return _this;
  }
  Group2.prototype.childrenRef = function() {
    return this._children;
  };
  Group2.prototype.children = function() {
    return this._children.slice();
  };
  Group2.prototype.childAt = function(idx) {
    return this._children[idx];
  };
  Group2.prototype.childOfName = function(name2) {
    var children2 = this._children;
    for (var i2 = 0; i2 < children2.length; i2++) {
      if (children2[i2].name === name2) {
        return children2[i2];
      }
    }
  };
  Group2.prototype.childCount = function() {
    return this._children.length;
  };
  Group2.prototype.add = function(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.addBefore = function(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      var children2 = this._children;
      var idx = children2.indexOf(nextSibling2);
      if (idx >= 0) {
        children2.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.replace = function(oldChild, newChild) {
    var idx = indexOf$2(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  };
  Group2.prototype.replaceAt = function(child, index) {
    var children2 = this._children;
    var old = children2[index];
    if (child && child !== this && child.parent !== this && child !== old) {
      children2[index] = child;
      old.parent = null;
      var zr2 = this.__zr;
      if (zr2) {
        old.removeSelfFromZr(zr2);
      }
      this._doAdd(child);
    }
    return this;
  };
  Group2.prototype._doAdd = function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var zr2 = this.__zr;
    if (zr2 && zr2 !== child.__zr) {
      child.addSelfToZr(zr2);
    }
    zr2 && zr2.refresh();
  };
  Group2.prototype.remove = function(child) {
    var zr2 = this.__zr;
    var children2 = this._children;
    var idx = indexOf$2(children2, child);
    if (idx < 0) {
      return this;
    }
    children2.splice(idx, 1);
    child.parent = null;
    if (zr2) {
      child.removeSelfFromZr(zr2);
    }
    zr2 && zr2.refresh();
    return this;
  };
  Group2.prototype.removeAll = function() {
    var children2 = this._children;
    var zr2 = this.__zr;
    for (var i2 = 0; i2 < children2.length; i2++) {
      var child = children2[i2];
      if (zr2) {
        child.removeSelfFromZr(zr2);
      }
      child.parent = null;
    }
    children2.length = 0;
    return this;
  };
  Group2.prototype.eachChild = function(cb, context) {
    var children2 = this._children;
    for (var i2 = 0; i2 < children2.length; i2++) {
      var child = children2[i2];
      cb.call(context, child, i2);
    }
    return this;
  };
  Group2.prototype.traverse = function(cb, context) {
    for (var i2 = 0; i2 < this._children.length; i2++) {
      var child = this._children[i2];
      var stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  };
  Group2.prototype.addSelfToZr = function(zr2) {
    _super.prototype.addSelfToZr.call(this, zr2);
    for (var i2 = 0; i2 < this._children.length; i2++) {
      var child = this._children[i2];
      child.addSelfToZr(zr2);
    }
  };
  Group2.prototype.removeSelfFromZr = function(zr2) {
    _super.prototype.removeSelfFromZr.call(this, zr2);
    for (var i2 = 0; i2 < this._children.length; i2++) {
      var child = this._children[i2];
      child.removeSelfFromZr(zr2);
    }
  };
  Group2.prototype.getBoundingRect = function(includeChildren) {
    var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
    var children2 = includeChildren || this._children;
    var tmpMat = [];
    var rect = null;
    for (var i2 = 0; i2 < children2.length; i2++) {
      var child = children2[i2];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat);
      if (transform) {
        BoundingRect$1.applyTransform(tmpRect2, childRect, transform);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  };
  return Group2;
}(Element$3);
Group$2.prototype.type = "group";
var Group$3 = Group$2;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances$2 = {};
function delInstance(id2) {
  delete instances$2[id2];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    var colorStops = backgroundColor2.colorStops;
    var totalLum = 0;
    var len2 = colorStops.length;
    for (var i2 = 0; i2 < len2; i2++) {
      totalLum += lum(colorStops[i2].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = function() {
  function ZRender2(id2, dom, opts) {
    var _this = this;
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id2;
    var storage = new Storage$1();
    var rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys$d(painterCtors)[0];
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    var painter = new painterCtors[rendererType](dom, storage, opts, id2);
    var ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage;
    this.painter = painter;
    var handerProxy = !env$1.node && !env$1.worker && !ssrMode ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
    this.handler = new Handler$1(storage, painter, handerProxy, painter.root);
    this.animation = new Animation$1({
      stage: {
        update: ssrMode ? null : function() {
          return _this._flush(true);
        }
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  ZRender2.prototype.add = function(el2) {
    if (!el2) {
      return;
    }
    this.storage.addRoot(el2);
    el2.addSelfToZr(this);
    this.refresh();
  };
  ZRender2.prototype.remove = function(el2) {
    if (!el2) {
      return;
    }
    this.storage.delRoot(el2);
    el2.removeSelfFromZr(this);
    this.refresh();
  };
  ZRender2.prototype.configLayer = function(zLevel, config2) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config2);
    }
    this.refresh();
  };
  ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  };
  ZRender2.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  };
  ZRender2.prototype.setDarkMode = function(darkMode) {
    this._darkMode = darkMode;
  };
  ZRender2.prototype.isDarkMode = function() {
    return this._darkMode;
  };
  ZRender2.prototype.refreshImmediately = function(fromInside) {
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  };
  ZRender2.prototype.refresh = function() {
    this._needsRefresh = true;
    this.animation.start();
  };
  ZRender2.prototype.flush = function() {
    this._flush(false);
  };
  ZRender2.prototype._flush = function(fromInside) {
    var triggerRendered;
    var start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    var end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  };
  ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  };
  ZRender2.prototype.wakeUp = function() {
    this.animation.start();
    this._stillFrameAccum = 0;
  };
  ZRender2.prototype.refreshHover = function() {
    this._needsRefreshHover = true;
  };
  ZRender2.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  };
  ZRender2.prototype.resize = function(opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  };
  ZRender2.prototype.clearAnimation = function() {
    this.animation.clear();
  };
  ZRender2.prototype.getWidth = function() {
    return this.painter.getWidth();
  };
  ZRender2.prototype.getHeight = function() {
    return this.painter.getHeight();
  };
  ZRender2.prototype.setCursorStyle = function(cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  };
  ZRender2.prototype.findHover = function(x2, y2) {
    return this.handler.findHover(x2, y2);
  };
  ZRender2.prototype.on = function(eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
    return this;
  };
  ZRender2.prototype.off = function(eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  };
  ZRender2.prototype.trigger = function(eventName, event) {
    this.handler.trigger(eventName, event);
  };
  ZRender2.prototype.clear = function() {
    var roots2 = this.storage.getRoots();
    for (var i2 = 0; i2 < roots2.length; i2++) {
      if (roots2[i2] instanceof Group$3) {
        roots2[i2].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  };
  ZRender2.prototype.dispose = function() {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  };
  return ZRender2;
}();
function init$2(dom, opts) {
  var zr2 = new ZRender(guid(), dom, opts);
  instances$2[zr2.id] = zr2;
  return zr2;
}
function dispose$1(zr2) {
  zr2.dispose();
}
function disposeAll() {
  for (var key in instances$2) {
    if (instances$2.hasOwnProperty(key)) {
      instances$2[key].dispose();
    }
  }
  instances$2 = {};
}
function getInstance$1(id2) {
  return instances$2[id2];
}
function registerPainter(name2, Ctor) {
  painterCtors[name2] = Ctor;
}
var version$1 = "5.3.2";
var zrender = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$2,
  dispose: dispose$1,
  disposeAll,
  getInstance: getInstance$1,
  registerPainter,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap(val2, domain, range2, clamp2) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range2[0];
  var r1 = range2[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp2) {
    if (subDomain > 0) {
      if (val2 <= d0) {
        return r0;
      } else if (val2 >= d1) {
        return r1;
      }
    } else {
      if (val2 >= d0) {
        return r0;
      } else if (val2 <= d1) {
        return r1;
      }
    }
  } else {
    if (val2 === d0) {
      return r0;
    }
    if (val2 === d1) {
      return r1;
    }
  }
  return (val2 - d0) / subDomain * subRange + r0;
}
function parsePercent(percent, all) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString$d(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round$5(x2, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x2 = (+x2).toFixed(precision);
  return returnStr ? x2 : +x2;
}
function asc$1(arr) {
  arr.sort(function(a2, b2) {
    return a2 - b2;
  });
  return arr;
}
function getPrecision(val2) {
  val2 = +val2;
  if (isNaN(val2)) {
    return 0;
  }
  if (val2 > 1e-14) {
    var e3 = 1;
    for (var i2 = 0; i2 < 15; i2++, e3 *= 10) {
      if (Math.round(val2 * e3) / e3 === val2) {
        return i2;
      }
    }
  }
  return getPrecisionSafe(val2);
}
function getPrecisionSafe(val2) {
  var str = val2.toString().toLowerCase();
  var eIndex = str.indexOf("e");
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf(".");
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }
  var sum3 = reduce$2(valueList, function(acc, val2) {
    return acc + (isNaN(val2) ? 0 : val2);
  }, 0);
  if (sum3 === 0) {
    return 0;
  }
  var digits = Math.pow(10, precision);
  var votesPerQuota = map$9(valueList, function(val2) {
    return (isNaN(val2) ? 0 : val2) / sum3 * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map$9(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  var currentSum = reduce$2(seats, function(acc, val2) {
    return acc + val2;
  }, 0);
  var remainder = map$9(votesPerQuota, function(votes, idx2) {
    return votes - seats[idx2];
  });
  while (currentSum < targetSeats) {
    var max3 = Number.NEGATIVE_INFINITY;
    var maxId = null;
    for (var i2 = 0, len2 = remainder.length; i2 < len2; ++i2) {
      if (remainder[i2] > max3) {
        max3 = remainder[i2];
        maxId = i2;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return seats[idx] / digits;
}
function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  var sum3 = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum3 : round$5(sum3, maxPrecision);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val2) {
  return val2 > -RADIAN_EPSILON && val2 < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate$1(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString$d(value)) {
    var match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      var hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val2) {
  return Math.pow(10, quantityExponent(val2));
}
function quantityExponent(val2) {
  if (val2 === 0) {
    return 0;
  }
  var exp = Math.floor(Math.log(val2) / Math.LN10);
  if (val2 / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val2, round2) {
  var exponent = quantityExponent(val2);
  var exp10 = Math.pow(10, exponent);
  var f2 = val2 / exp10;
  var nf2;
  if (round2) {
    if (f2 < 1.5) {
      nf2 = 1;
    } else if (f2 < 2.5) {
      nf2 = 2;
    } else if (f2 < 4) {
      nf2 = 3;
    } else if (f2 < 7) {
      nf2 = 5;
    } else {
      nf2 = 10;
    }
  } else {
    if (f2 < 1) {
      nf2 = 1;
    } else if (f2 < 2) {
      nf2 = 2;
    } else if (f2 < 3) {
      nf2 = 3;
    } else if (f2 < 5) {
      nf2 = 5;
    } else {
      nf2 = 10;
    }
  }
  val2 = nf2 * exp10;
  return exponent >= -20 ? +val2.toFixed(exponent < 0 ? -exponent : 0) : val2;
}
function quantile(ascArr, p2) {
  var H2 = (ascArr.length - 1) * p2 + 1;
  var h2 = Math.floor(H2);
  var v2 = +ascArr[h2 - 1];
  var e3 = H2 - h2;
  return e3 ? v2 + e3 * (ascArr[h2] - v2) : v2;
}
function reformIntervals(list) {
  list.sort(function(a2, b2) {
    return littleThan(a2, b2, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;
  for (var i2 = 0; i2 < list.length; ) {
    var interval = list[i2].interval;
    var close_1 = list[i2].close;
    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close_1[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close_1[lg];
    }
    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
      list.splice(i2, 1);
    } else {
      i2++;
    }
  }
  return list;
  function littleThan(a2, b2, lg2) {
    return a2.interval[lg2] < b2.interval[lg2] || a2.interval[lg2] === b2.interval[lg2] && (a2.close[lg2] - b2.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan(a2, b2, 1));
  }
}
function numericToNumber(val2) {
  var valFloat = parseFloat(val2);
  return valFloat == val2 && (valFloat !== 0 || !isString$d(val2) || val2.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val2) {
  return !isNaN(numericToNumber(val2));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a2, b2) {
  if (b2 === 0) {
    return a2;
  }
  return getGreatestCommonDividor(b2, a2 % b2);
}
function getLeastCommonMultiple(a2, b2) {
  if (a2 == null) {
    return b2;
  }
  if (b2 == null) {
    return a2;
  }
  return a2 * b2 / getGreatestCommonDividor(a2, b2);
}
function throwError(msg) {
  throw new Error(msg);
}
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (var i2 = 0, len2 = subOpts.length; i2 < len2; i2++) {
      var subOptName = subOpts[i2];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(dataItem) {
  return isObject$f(dataItem) && !isArray$x(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject$f(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === "normalMerge";
  var isReplaceMergeMode = mode === "replaceMerge";
  var isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap();
  each$q(newCmptOptions, function(cmptOption, index) {
    if (!isObject$f(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }
  });
  var result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  var result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (var index = 0; index < existings.length; index++) {
    var existing = existings[index];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each$q(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each$q(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (var i2 = 0; i2 < result.length; i2++) {
      var existing = result[i2].existing;
      if (!result[i2].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i2].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each$q(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    var resultItem;
    var nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each$q(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  var idMap = createHashMap();
  each$q(mapResult, function(item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each$q(mapResult, function(item) {
    var opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each$q(mapResult, function(item, index) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;
    if (!isObject$f(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr2, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr2], null);
  var key2 = convertOptionIdName(obj2[attr2], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val2) {
  return convertOptionIdName(val2, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString$d(idOrName) ? idOrName : isNumber$c(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function isNameSpecified(componentModel) {
  var name2 = componentModel.name;
  return !!(name2 && name2.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each$q(mappingResult, function(item) {
    var newOption = item.newOption;
    if (isObject$f(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function queryDataIndex(data5, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray$x(payload.dataIndex) ? map$9(payload.dataIndex, function(value) {
      return data5.indexOfRawIndex(value);
    }) : data5.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray$x(payload.name) ? map$9(payload.name, function(value) {
      return data5.indexOfName(value);
    }) : data5.indexOfName(payload.name);
  }
}
function makeInner() {
  var key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder(ecModel, finderInput, opt) {
  var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;
  if (isString$d(finderInput)) {
    var obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each$q(finder, function(value, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value;
      return;
    }
    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf$2(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {
    mainTypeSpecified,
    queryOptionMap,
    others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
var MULTIPLE_REFERRING = {
  useDefault: false,
  enableAll: true,
  enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    var firstCmpt = void 0;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env$1.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function interpolateRawValues(data5, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber$c(targetValue)) {
    var value = interpolateNumber(sourceValue || 0, targetValue, percent);
    return round$5(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString$d(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (var i2 = 0; i2 < length_1; ++i2) {
      var info2 = data5.getDimensionInfo(i2);
      if (info2 && info2.type === "ordinal") {
        interpolated[i2] = (percent < 1 && leftArr ? leftArr : rightArr)[i2];
      } else {
        var leftVal = leftArr && leftArr[i2] ? leftArr[i2] : 0;
        var rightVal = rightArr[i2];
        var value = interpolateNumber(leftVal, rightVal, percent);
        interpolated[i2] = round$5(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  var ret = {
    main: "",
    sub: ""
  };
  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto2) {
    var superClass = this;
    var ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          return _super.apply(this, arguments) || this;
        }
        return class_1;
      }(superClass);
    } else {
      ExtendedClass = function() {
        (proto2.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend$1(ExtendedClass.prototype, proto2);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn2) {
  return isFunction$h(fn2) && /^class\s/.test(Function.prototype.toString.call(fn2));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  var classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  var storage = {};
  target.registerClass = function(clz) {
    var componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        storage[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    var clz = storage[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each$q(obj, function(o2, type2) {
        type2 !== IS_CONTAINER && result.push(o2);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    return !!storage[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    var types = [];
    each$q(storage, function(obj, type2) {
      types.push(type2);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    var container = storage[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}
function makeStyleMapper(properties, ignoreParent) {
  for (var i2 = 0; i2 < properties.length; i2++) {
    if (!properties[i2][1]) {
      properties[i2][1] = properties[i2][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes2) {
    var style = {};
    for (var i3 = 0; i3 < properties.length; i3++) {
      var propName = properties[i3][1];
      if (excludes && indexOf$2(excludes, propName) >= 0 || includes2 && indexOf$2(includes2, propName) < 0) {
        continue;
      }
      var val2 = model.getShallow(propName, ignoreParent);
      if (val2 != null) {
        style[properties[i3][0]] = val2;
      }
    }
    return style;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
  function AreaStyleMixin2() {
  }
  AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes2) {
    return getAreaStyle(this, excludes, includes2);
  };
  return AreaStyleMixin2;
}();
var globalImageCache = new LRU$1(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = { hostEl, cb: onload, cbPayload };
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i2 = 0; i2 < cachedImgObj.pending.length; i2++) {
    var pendingWrap = cachedImgObj.pending[i2];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text2, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  var textLines = (text2 + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (var i2 = 0, len2 = textLines.length; i2 < len2; i2++) {
    textLines[i2] = truncateSingleLine(textLines[i2], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  var preparedOpts = extend$1({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth("\u56FD", font);
  var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i2 = 0; i2 < minChar && contentWidth >= ascCharWidth; i2++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  var lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (var j2 = 0; ; j2++) {
    if (lineWidth <= contentWidth || j2 >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j2 === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text2, contentWidth, ascCharWidth, cnCharWidth) {
  var width2 = 0;
  var i2 = 0;
  for (var len2 = text2.length; i2 < len2 && width2 < contentWidth; i2++) {
    var charCode = text2.charCodeAt(i2);
    width2 += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i2;
}
function parsePlainText(text2, style) {
  text2 != null && (text2 += "");
  var overflow = style.overflow;
  var padding = style.padding;
  var font = style.font;
  var truncate = overflow === "truncate";
  var calculatedLineHeight = getLineHeight(font);
  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  var bgColorDrawn = !!style.backgroundColor;
  var truncateLineOverflow = style.lineOverflow === "truncate";
  var width2 = style.width;
  var lines;
  if (width2 != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text2 ? wrapText(text2, style.font, width2, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text2 ? text2.split("\n") : [];
  }
  var contentHeight = lines.length * lineHeight;
  var height2 = retrieve2(style.height, contentHeight);
  if (contentHeight > height2 && truncateLineOverflow) {
    var lineCount = Math.floor(height2 / lineHeight);
    lines = lines.slice(0, lineCount);
  }
  if (text2 && truncate && width2 != null) {
    var options = prepareTruncateOptions(width2, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    for (var i2 = 0; i2 < lines.length; i2++) {
      lines[i2] = truncateSingleLine(lines[i2], options);
    }
  }
  var outerHeight = height2;
  var contentWidth = 0;
  for (var i2 = 0; i2 < lines.length; i2++) {
    contentWidth = Math.max(getWidth(lines[i2], font), contentWidth);
  }
  if (width2 == null) {
    width2 = contentWidth;
  }
  var outerWidth = contentWidth;
  if (padding) {
    outerHeight += padding[0] + padding[2];
    outerWidth += padding[1] + padding[3];
    width2 += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth = width2;
  }
  return {
    lines,
    height: height2,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width: width2
  };
}
var RichTextToken = function() {
  function RichTextToken2() {
  }
  return RichTextToken2;
}();
var RichTextLine = function() {
  function RichTextLine2(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
  return RichTextLine2;
}();
var RichTextContentBlock = function() {
  function RichTextContentBlock2() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
  }
  return RichTextContentBlock2;
}();
function parseRichText(text2, style) {
  var contentBlock = new RichTextContentBlock();
  text2 != null && (text2 += "");
  if (!text2) {
    return contentBlock;
  }
  var topWidth = style.width;
  var topHeight = style.height;
  var overflow = style.overflow;
  var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text2)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text2.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text2.length) {
    pushTokens(contentBlock, text2.substring(lastIndex, text2.length), style, wrapInfo);
  }
  var pendingList = [];
  var calculatedHeight = 0;
  var calculatedWidth = 0;
  var stlPadding = style.padding;
  var truncate = overflow === "truncate";
  var truncateLine = style.lineOverflow === "truncate";
  function finishLine(line2, lineWidth2, lineHeight2) {
    line2.width = lineWidth2;
    line2.lineHeight = lineHeight2;
    calculatedHeight += lineHeight2;
    calculatedWidth = Math.max(calculatedWidth, lineWidth2);
  }
  outer:
    for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
      var line = contentBlock.lines[i2];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j2 = 0; j2 < line.tokens.length; j2++) {
        var token = line.tokens[j2];
        var tokenStyle = token.styleName && style.rich[token.styleName] || {};
        var textPadding = token.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || style.align;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          if (j2 > 0) {
            line.tokens = line.tokens.slice(0, j2);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i2 + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i2);
          }
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = getWidth(token.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token.width = token.contentWidth = getWidth(token.text, font);
            }
          } else {
            token.contentWidth = getWidth(token.text, font);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i2 = 0; i2 < pendingList.length; i2++) {
    var token = pendingList[i2];
    var percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  var isEmptyStr = str === "";
  var tokenStyle = styleName && style.rich[styleName] || {};
  var lines = block.lines;
  var font = tokenStyle.font || style.font;
  var newLine = false;
  var strLines;
  var linesWidths;
  if (wrapInfo) {
    var tokenPadding = tokenStyle.padding;
    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      var outerWidth_1 = parsePercent$1(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth_1;
    } else {
      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split("\n");
  }
  for (var i2 = 0; i2 < strLines.length; i2++) {
    var text2 = strLines[i2];
    var token = new RichTextToken();
    token.styleName = styleName;
    token.text = text2;
    token.isLineHolder = !text2 && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i2] : getWidth(text2, font);
    }
    if (!i2 && !newLine) {
      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text2 || !tokensLen || isEmptyStr) && tokens.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isLatin(ch2) {
  var code = ch2.charCodeAt(0);
  return code >= 33 && code <= 383;
}
var breakCharMap = reduce$2(",&?/;] ".split(""), function(obj, ch2) {
  obj[ch2] = true;
  return obj;
}, {});
function isWordBreakChar(ch2) {
  if (isLatin(ch2)) {
    if (breakCharMap[ch2]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text2, font, lineWidth, isBreakAll, lastAccumWidth) {
  var lines = [];
  var linesWidths = [];
  var line = "";
  var currentWord = "";
  var currentWordWidth = 0;
  var accumWidth = 0;
  for (var i2 = 0; i2 < text2.length; i2++) {
    var ch2 = text2.charAt(i2);
    if (ch2 === "\n") {
      if (currentWord) {
        line += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line);
      linesWidths.push(accumWidth);
      line = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    var chWidth = getWidth(ch2, font);
    var inWord = isBreakAll ? false : !isWordBreakChar(ch2);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch2;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch2);
          linesWidths.push(chWidth);
        }
      } else if (line || currentWord) {
        if (inWord) {
          if (!line) {
            line = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch2;
          currentWordWidth += chWidth;
          line = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line);
          linesWidths.push(accumWidth);
          line = ch2;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch2;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line += ch2;
    }
  }
  if (!lines.length && !line) {
    line = text2;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line += currentWord;
  }
  if (line) {
    lines.push(line);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
  __extends(Displayable2, _super);
  function Displayable2(props) {
    return _super.call(this, props) || this;
  }
  Displayable2.prototype._init = function(props) {
    var keysArr = keys$d(props);
    for (var i2 = 0; i2 < keysArr.length; i2++) {
      var key = keysArr[i2];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        _super.prototype.attrKV.call(this, key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Displayable2.prototype.beforeBrush = function() {
  };
  Displayable2.prototype.afterBrush = function() {
  };
  Displayable2.prototype.innerBeforeBrush = function() {
  };
  Displayable2.prototype.innerAfterBrush = function() {
  };
  Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    var m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (var i2 = 0; i2 < this.__clipPaths.length; ++i2) {
        if (this.__clipPaths[i2].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      var parent_1 = this.parent;
      while (parent_1) {
        if (parent_1.ignore) {
          return false;
        }
        parent_1 = parent_1.parent;
      }
    }
    return true;
  };
  Displayable2.prototype.contain = function(x2, y2) {
    return this.rectContain(x2, y2);
  };
  Displayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  Displayable2.prototype.rectContain = function(x2, y2) {
    var coord = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  };
  Displayable2.prototype.getPaintRect = function() {
    var rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var transform = this.transform;
      var elRect = this.getBoundingRect();
      var style = this.style;
      var shadowSize = style.shadowBlur || 0;
      var shadowOffsetX = style.shadowOffsetX || 0;
      var shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0));
      if (transform) {
        BoundingRect$1.applyTransform(rect, elRect, transform);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      var tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  };
  Displayable2.prototype.setPrevPaintRect = function(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  };
  Displayable2.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  };
  Displayable2.prototype.animateStyle = function(loop) {
    return this.animate("style", loop);
  };
  Displayable2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  };
  Displayable2.prototype.attrKV = function(key, value) {
    if (key !== "style") {
      _super.prototype.attrKV.call(this, key, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  };
  Displayable2.prototype.setStyle = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend$1(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  };
  Displayable2.prototype.dirtyStyle = function(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  };
  Displayable2.prototype.dirty = function() {
    this.dirtyStyle();
  };
  Displayable2.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  };
  Displayable2.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  };
  Displayable2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  };
  Displayable2.prototype.useStyle = function(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  };
  Displayable2.prototype.isStyleObject = function(obj) {
    return obj[STYLE_MAGIC_KEY];
  };
  Displayable2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  };
  Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        var sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          var changedKeys = keys$d(sourceStyle);
          for (var i2 = 0; i2 < changedKeys.length; i2++) {
            var key = changedKeys[i2];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        var targetKeys = keys$d(targetStyle);
        for (var i2 = 0; i2 < targetKeys.length; i2++) {
          var key = targetKeys[i2];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
    for (var i2 = 0; i2 < statesKeys.length; i2++) {
      var key = statesKeys[i2];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  };
  Displayable2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedStyle;
    for (var i2 = 0; i2 < states.length; i2++) {
      var state = states[i2];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  };
  Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    extend$1(targetStyle, sourceStyle);
    return targetStyle;
  };
  Displayable2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  };
  Displayable2.initDefaultProps = function() {
    var dispProto = Displayable2.prototype;
    dispProto.type = "displayable";
    dispProto.invisible = false;
    dispProto.z = 0;
    dispProto.z2 = 0;
    dispProto.zlevel = 0;
    dispProto.culling = false;
    dispProto.cursor = "pointer";
    dispProto.rectHover = false;
    dispProto.incremental = false;
    dispProto._rect = null;
    dispProto.dirtyRectTolerance = 0;
    dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }();
  return Displayable2;
}(Element$3);
var tmpRect = new BoundingRect$1(0, 0, 0, 0);
var viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(el2, width2, height2) {
  tmpRect.copy(el2.getBoundingRect());
  if (el2.transform) {
    tmpRect.applyTransform(el2.transform);
  }
  viewRect.width = width2;
  viewRect.height = height2;
  return !tmpRect.intersect(viewRect);
}
var Displayable$1 = Displayable;
var mathMin$5 = Math.min;
var mathMax$5 = Math.max;
var mathSin$3 = Math.sin;
var mathCos$3 = Math.cos;
var PI2$7 = Math.PI * 2;
var start = create$1();
var end = create$1();
var extremity = create$1();
function fromPoints(points2, min3, max3) {
  if (points2.length === 0) {
    return;
  }
  var p2 = points2[0];
  var left = p2[0];
  var right = p2[0];
  var top = p2[1];
  var bottom = p2[1];
  for (var i2 = 1; i2 < points2.length; i2++) {
    p2 = points2[i2];
    left = mathMin$5(left, p2[0]);
    right = mathMax$5(right, p2[0]);
    top = mathMin$5(top, p2[1]);
    bottom = mathMax$5(bottom, p2[1]);
  }
  min3[0] = left;
  min3[1] = top;
  max3[0] = right;
  max3[1] = bottom;
}
function fromLine(x0, y0, x1, y1, min3, max3) {
  min3[0] = mathMin$5(x0, x1);
  min3[1] = mathMin$5(y0, y1);
  max3[0] = mathMax$5(x0, x1);
  max3[1] = mathMax$5(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
  var cubicExtrema$1 = cubicExtrema;
  var cubicAt$1 = cubicAt;
  var n2 = cubicExtrema$1(x0, x1, x2, x3, xDim);
  min3[0] = Infinity;
  min3[1] = Infinity;
  max3[0] = -Infinity;
  max3[1] = -Infinity;
  for (var i2 = 0; i2 < n2; i2++) {
    var x4 = cubicAt$1(x0, x1, x2, x3, xDim[i2]);
    min3[0] = mathMin$5(x4, min3[0]);
    max3[0] = mathMax$5(x4, max3[0]);
  }
  n2 = cubicExtrema$1(y0, y1, y2, y3, yDim);
  for (var i2 = 0; i2 < n2; i2++) {
    var y4 = cubicAt$1(y0, y1, y2, y3, yDim[i2]);
    min3[1] = mathMin$5(y4, min3[1]);
    max3[1] = mathMax$5(y4, max3[1]);
  }
  min3[0] = mathMin$5(x0, min3[0]);
  max3[0] = mathMax$5(x0, max3[0]);
  min3[0] = mathMin$5(x3, min3[0]);
  max3[0] = mathMax$5(x3, max3[0]);
  min3[1] = mathMin$5(y0, min3[1]);
  max3[1] = mathMax$5(y0, max3[1]);
  min3[1] = mathMin$5(y3, min3[1]);
  max3[1] = mathMax$5(y3, max3[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
  var quadraticExtremum$1 = quadraticExtremum;
  var quadraticAt$1 = quadraticAt;
  var tx = mathMax$5(mathMin$5(quadraticExtremum$1(x0, x1, x2), 1), 0);
  var ty = mathMax$5(mathMin$5(quadraticExtremum$1(y0, y1, y2), 1), 0);
  var x3 = quadraticAt$1(x0, x1, x2, tx);
  var y3 = quadraticAt$1(y0, y1, y2, ty);
  min3[0] = mathMin$5(x0, x2, x3);
  min3[1] = mathMin$5(y0, y2, y3);
  max3[0] = mathMax$5(x0, x2, x3);
  max3[1] = mathMax$5(y0, y2, y3);
}
function fromArc(x2, y2, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
  var vec2Min = min$3;
  var vec2Max = max$4;
  var diff = Math.abs(startAngle - endAngle);
  if (diff % PI2$7 < 1e-4 && diff > 1e-4) {
    min3[0] = x2 - rx;
    min3[1] = y2 - ry;
    max3[0] = x2 + rx;
    max3[1] = y2 + ry;
    return;
  }
  start[0] = mathCos$3(startAngle) * rx + x2;
  start[1] = mathSin$3(startAngle) * ry + y2;
  end[0] = mathCos$3(endAngle) * rx + x2;
  end[1] = mathSin$3(endAngle) * ry + y2;
  vec2Min(min3, start, end);
  vec2Max(max3, start, end);
  startAngle = startAngle % PI2$7;
  if (startAngle < 0) {
    startAngle = startAngle + PI2$7;
  }
  endAngle = endAngle % PI2$7;
  if (endAngle < 0) {
    endAngle = endAngle + PI2$7;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2$7;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2$7;
  }
  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos$3(angle) * rx + x2;
      extremity[1] = mathSin$3(angle) * ry + y2;
      vec2Min(min3, extremity, min3);
      vec2Max(max3, extremity, max3);
    }
  }
}
var CMD$4 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min$2 = [];
var max$3 = [];
var min2 = [];
var max2 = [];
var mathMin$4 = Math.min;
var mathMax$4 = Math.max;
var mathCos$2 = Math.cos;
var mathSin$2 = Math.sin;
var mathAbs$1 = Math.abs;
var PI$4 = Math.PI;
var PI2$6 = PI$4 * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  var n2 = Math.round(radian / PI$4 * 1e8) / 1e8;
  return n2 % 2 * PI$4;
}
function normalizeArcAngles(angles, anticlockwise) {
  var newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI2$6;
  }
  var delta = newStartAngle - angles[0];
  var newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI2$6) {
    newEndAngle = newStartAngle + PI2$6;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$6) {
    newEndAngle = newStartAngle - PI2$6;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI2$6 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI2$6 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy = function() {
  function PathProxy2(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  PathProxy2.prototype.increaseVersion = function() {
    this._version++;
  };
  PathProxy2.prototype.getVersion = function() {
    return this._version;
  };
  PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs$1(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  };
  PathProxy2.prototype.setDPR = function(dpr2) {
    this.dpr = dpr2;
  };
  PathProxy2.prototype.setContext = function(ctx) {
    this._ctx = ctx;
  };
  PathProxy2.prototype.getContext = function() {
    return this._ctx;
  };
  PathProxy2.prototype.beginPath = function() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  };
  PathProxy2.prototype.reset = function() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  };
  PathProxy2.prototype.moveTo = function(x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$4.M, x2, y2);
    this._ctx && this._ctx.moveTo(x2, y2);
    this._x0 = x2;
    this._y0 = y2;
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.lineTo = function(x2, y2) {
    var dx = mathAbs$1(x2 - this._xi);
    var dy = mathAbs$1(y2 - this._yi);
    var exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD$4.L, x2, y2);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x2, y2);
    }
    if (exceedUnit) {
      this._xi = x2;
      this._yi = y2;
      this._pendingPtDist = 0;
    } else {
      var d22 = dx * dx + dy * dy;
      if (d22 > this._pendingPtDist) {
        this._pendingPtX = x2;
        this._pendingPtY = y2;
        this._pendingPtDist = d22;
      }
    }
    return this;
  };
  PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD$4.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$4.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.arc = function(cx, cy, r2, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    var delta = endAngle - startAngle;
    this.addData(CMD$4.A, cx, cy, r2, r2, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r2, startAngle, endAngle, anticlockwise);
    this._xi = mathCos$2(endAngle) * r2 + cx;
    this._yi = mathSin$2(endAngle) * r2 + cy;
    return this;
  };
  PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  };
  PathProxy2.prototype.rect = function(x2, y2, w2, h2) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x2, y2, w2, h2);
    this.addData(CMD$4.R, x2, y2, w2, h2);
    return this;
  };
  PathProxy2.prototype.closePath = function() {
    this._drawPendingPt();
    this.addData(CMD$4.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  };
  PathProxy2.prototype.fill = function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  };
  PathProxy2.prototype.stroke = function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  };
  PathProxy2.prototype.len = function() {
    return this._len;
  };
  PathProxy2.prototype.setData = function(data5) {
    var len2 = data5.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (var i2 = 0; i2 < len2; i2++) {
      this.data[i2] = data5[i2];
    }
    this._len = len2;
  };
  PathProxy2.prototype.appendPath = function(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    var len2 = path.length;
    var appendSize = 0;
    var offset2 = this._len;
    for (var i2 = 0; i2 < len2; i2++) {
      appendSize += path[i2].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset2 + appendSize);
    }
    for (var i2 = 0; i2 < len2; i2++) {
      var appendPathData = path[i2].data;
      for (var k2 = 0; k2 < appendPathData.length; k2++) {
        this.data[offset2++] = appendPathData[k2];
      }
    }
    this._len = offset2;
  };
  PathProxy2.prototype.addData = function(cmd, a2, b2, c2, d3, e3, f2, g2, h2) {
    if (!this._saveData) {
      return;
    }
    var data5 = this.data;
    if (this._len + arguments.length > data5.length) {
      this._expandData();
      data5 = this.data;
    }
    for (var i2 = 0; i2 < arguments.length; i2++) {
      data5[this._len++] = arguments[i2];
    }
  };
  PathProxy2.prototype._drawPendingPt = function() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  };
  PathProxy2.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i2 = 0; i2 < this._len; i2++) {
        newData[i2] = this.data[i2];
      }
      this.data = newData;
    }
  };
  PathProxy2.prototype.toStatic = function() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    var data5 = this.data;
    if (data5 instanceof Array) {
      data5.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data5);
      }
    }
  };
  PathProxy2.prototype.getBoundingRect = function() {
    min$2[0] = min$2[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max$3[0] = max$3[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data5 = this.data;
    var xi2 = 0;
    var yi2 = 0;
    var x0 = 0;
    var y0 = 0;
    var i2;
    for (i2 = 0; i2 < this._len; ) {
      var cmd = data5[i2++];
      var isFirst = i2 === 1;
      if (isFirst) {
        xi2 = data5[i2];
        yi2 = data5[i2 + 1];
        x0 = xi2;
        y0 = yi2;
      }
      switch (cmd) {
        case CMD$4.M:
          xi2 = x0 = data5[i2++];
          yi2 = y0 = data5[i2++];
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;
        case CMD$4.L:
          fromLine(xi2, yi2, data5[i2], data5[i2 + 1], min2, max2);
          xi2 = data5[i2++];
          yi2 = data5[i2++];
          break;
        case CMD$4.C:
          fromCubic(xi2, yi2, data5[i2++], data5[i2++], data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], min2, max2);
          xi2 = data5[i2++];
          yi2 = data5[i2++];
          break;
        case CMD$4.Q:
          fromQuadratic(xi2, yi2, data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], min2, max2);
          xi2 = data5[i2++];
          yi2 = data5[i2++];
          break;
        case CMD$4.A:
          var cx = data5[i2++];
          var cy = data5[i2++];
          var rx = data5[i2++];
          var ry = data5[i2++];
          var startAngle = data5[i2++];
          var endAngle = data5[i2++] + startAngle;
          i2 += 1;
          var anticlockwise = !data5[i2++];
          if (isFirst) {
            x0 = mathCos$2(startAngle) * rx + cx;
            y0 = mathSin$2(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi2 = mathCos$2(endAngle) * rx + cx;
          yi2 = mathSin$2(endAngle) * ry + cy;
          break;
        case CMD$4.R:
          x0 = xi2 = data5[i2++];
          y0 = yi2 = data5[i2++];
          var width2 = data5[i2++];
          var height2 = data5[i2++];
          fromLine(x0, y0, x0 + width2, y0 + height2, min2, max2);
          break;
        case CMD$4.Z:
          xi2 = x0;
          yi2 = y0;
          break;
      }
      min$3(min$2, min$2, min2);
      max$4(max$3, max$3, max2);
    }
    if (i2 === 0) {
      min$2[0] = min$2[1] = max$3[0] = max$3[1] = 0;
    }
    return new BoundingRect$1(min$2[0], min$2[1], max$3[0] - min$2[0], max$3[1] - min$2[1]);
  };
  PathProxy2.prototype._calculateLength = function() {
    var data5 = this.data;
    var len2 = this._len;
    var ux = this._ux;
    var uy = this._uy;
    var xi2 = 0;
    var yi2 = 0;
    var x0 = 0;
    var y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    var pathSegLen = this._pathSegLen;
    var pathTotalLen = 0;
    var segCount = 0;
    for (var i2 = 0; i2 < len2; ) {
      var cmd = data5[i2++];
      var isFirst = i2 === 1;
      if (isFirst) {
        xi2 = data5[i2];
        yi2 = data5[i2 + 1];
        x0 = xi2;
        y0 = yi2;
      }
      var l2 = -1;
      switch (cmd) {
        case CMD$4.M:
          xi2 = x0 = data5[i2++];
          yi2 = y0 = data5[i2++];
          break;
        case CMD$4.L: {
          var x2 = data5[i2++];
          var y2 = data5[i2++];
          var dx = x2 - xi2;
          var dy = y2 - yi2;
          if (mathAbs$1(dx) > ux || mathAbs$1(dy) > uy || i2 === len2 - 1) {
            l2 = Math.sqrt(dx * dx + dy * dy);
            xi2 = x2;
            yi2 = y2;
          }
          break;
        }
        case CMD$4.C: {
          var x1 = data5[i2++];
          var y1 = data5[i2++];
          var x2 = data5[i2++];
          var y2 = data5[i2++];
          var x3 = data5[i2++];
          var y3 = data5[i2++];
          l2 = cubicLength(xi2, yi2, x1, y1, x2, y2, x3, y3, 10);
          xi2 = x3;
          yi2 = y3;
          break;
        }
        case CMD$4.Q: {
          var x1 = data5[i2++];
          var y1 = data5[i2++];
          var x2 = data5[i2++];
          var y2 = data5[i2++];
          l2 = quadraticLength(xi2, yi2, x1, y1, x2, y2, 10);
          xi2 = x2;
          yi2 = y2;
          break;
        }
        case CMD$4.A:
          var cx = data5[i2++];
          var cy = data5[i2++];
          var rx = data5[i2++];
          var ry = data5[i2++];
          var startAngle = data5[i2++];
          var delta = data5[i2++];
          var endAngle = delta + startAngle;
          i2 += 1;
          !data5[i2++];
          if (isFirst) {
            x0 = mathCos$2(startAngle) * rx + cx;
            y0 = mathSin$2(startAngle) * ry + cy;
          }
          l2 = mathMax$4(rx, ry) * mathMin$4(PI2$6, Math.abs(delta));
          xi2 = mathCos$2(endAngle) * rx + cx;
          yi2 = mathSin$2(endAngle) * ry + cy;
          break;
        case CMD$4.R: {
          x0 = xi2 = data5[i2++];
          y0 = yi2 = data5[i2++];
          var width2 = data5[i2++];
          var height2 = data5[i2++];
          l2 = width2 * 2 + height2 * 2;
          break;
        }
        case CMD$4.Z: {
          var dx = x0 - xi2;
          var dy = y0 - yi2;
          l2 = Math.sqrt(dx * dx + dy * dy);
          xi2 = x0;
          yi2 = y0;
          break;
        }
      }
      if (l2 >= 0) {
        pathSegLen[segCount++] = l2;
        pathTotalLen += l2;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  };
  PathProxy2.prototype.rebuildPath = function(ctx, percent) {
    var d3 = this.data;
    var ux = this._ux;
    var uy = this._uy;
    var len2 = this._len;
    var x0;
    var y0;
    var xi2;
    var yi2;
    var x2;
    var y2;
    var drawPart = percent < 1;
    var pathSegLen;
    var pathTotalLen;
    var accumLength = 0;
    var segCount = 0;
    var displayedLength;
    var pendingPtDist = 0;
    var pendingPtX;
    var pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (var i2 = 0; i2 < len2; ) {
        var cmd = d3[i2++];
        var isFirst = i2 === 1;
        if (isFirst) {
          xi2 = d3[i2];
          yi2 = d3[i2 + 1];
          x0 = xi2;
          y0 = yi2;
        }
        if (cmd !== CMD$4.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$4.M:
            x0 = xi2 = d3[i2++];
            y0 = yi2 = d3[i2++];
            ctx.moveTo(xi2, yi2);
            break;
          case CMD$4.L: {
            x2 = d3[i2++];
            y2 = d3[i2++];
            var dx = mathAbs$1(x2 - xi2);
            var dy = mathAbs$1(y2 - yi2);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l2 = pathSegLen[segCount++];
                if (accumLength + l2 > displayedLength) {
                  var t2 = (displayedLength - accumLength) / l2;
                  ctx.lineTo(xi2 * (1 - t2) + x2 * t2, yi2 * (1 - t2) + y2 * t2);
                  break lo;
                }
                accumLength += l2;
              }
              ctx.lineTo(x2, y2);
              xi2 = x2;
              yi2 = y2;
              pendingPtDist = 0;
            } else {
              var d22 = dx * dx + dy * dy;
              if (d22 > pendingPtDist) {
                pendingPtX = x2;
                pendingPtY = y2;
                pendingPtDist = d22;
              }
            }
            break;
          }
          case CMD$4.C: {
            var x1 = d3[i2++];
            var y1 = d3[i2++];
            var x22 = d3[i2++];
            var y22 = d3[i2++];
            var x3 = d3[i2++];
            var y3 = d3[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                cubicSubdivide(xi2, x1, x22, x3, t2, tmpOutX);
                cubicSubdivide(yi2, y1, y22, y3, t2, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.bezierCurveTo(x1, y1, x22, y22, x3, y3);
            xi2 = x3;
            yi2 = y3;
            break;
          }
          case CMD$4.Q: {
            var x1 = d3[i2++];
            var y1 = d3[i2++];
            var x22 = d3[i2++];
            var y22 = d3[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                quadraticSubdivide(xi2, x1, x22, t2, tmpOutX);
                quadraticSubdivide(yi2, y1, y22, t2, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l2;
            }
            ctx.quadraticCurveTo(x1, y1, x22, y22);
            xi2 = x22;
            yi2 = y22;
            break;
          }
          case CMD$4.A:
            var cx = d3[i2++];
            var cy = d3[i2++];
            var rx = d3[i2++];
            var ry = d3[i2++];
            var startAngle = d3[i2++];
            var delta = d3[i2++];
            var psi = d3[i2++];
            var anticlockwise = !d3[i2++];
            var r2 = rx > ry ? rx : ry;
            var isEllipse = mathAbs$1(rx - ry) > 1e-3;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l2;
                breakBuild = true;
              }
              accumLength += l2;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r2, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos$2(startAngle) * rx + cx;
              y0 = mathSin$2(startAngle) * ry + cy;
            }
            xi2 = mathCos$2(endAngle) * rx + cx;
            yi2 = mathSin$2(endAngle) * ry + cy;
            break;
          case CMD$4.R:
            x0 = xi2 = d3[i2];
            y0 = yi2 = d3[i2 + 1];
            x2 = d3[i2++];
            y2 = d3[i2++];
            var width2 = d3[i2++];
            var height2 = d3[i2++];
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + mathMin$4(d_1, width2), y2);
                d_1 -= width2;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + width2, y2 + mathMin$4(d_1, height2));
                }
                d_1 -= height2;
                if (d_1 > 0) {
                  ctx.lineTo(x2 + mathMax$4(width2 - d_1, 0), y2 + height2);
                }
                d_1 -= width2;
                if (d_1 > 0) {
                  ctx.lineTo(x2, y2 + mathMax$4(height2 - d_1, 0));
                }
                break lo;
              }
              accumLength += l2;
            }
            ctx.rect(x2, y2, width2, height2);
            break;
          case CMD$4.Z:
            if (drawPart) {
              var l2 = pathSegLen[segCount++];
              if (accumLength + l2 > displayedLength) {
                var t2 = (displayedLength - accumLength) / l2;
                ctx.lineTo(xi2 * (1 - t2) + x0 * t2, yi2 * (1 - t2) + y0 * t2);
                break lo;
              }
              accumLength += l2;
            }
            ctx.closePath();
            xi2 = x0;
            yi2 = y0;
        }
      }
  };
  PathProxy2.prototype.clone = function() {
    var newProxy = new PathProxy2();
    var data5 = this.data;
    newProxy.data = data5.slice ? data5.slice() : Array.prototype.slice.call(data5);
    newProxy._len = this._len;
    return newProxy;
  };
  PathProxy2.CMD = CMD$4;
  PathProxy2.initDefaultProps = function() {
    var proto2 = PathProxy2.prototype;
    proto2._saveData = true;
    proto2._ux = 0;
    proto2._uy = 0;
    proto2._pendingPtDist = 0;
    proto2._version = 0;
  }();
  return PathProxy2;
}();
var PathProxy$1 = PathProxy;
function containStroke$4(x0, y0, x1, y1, lineWidth, x2, y2) {
  if (lineWidth === 0) {
    return false;
  }
  var _l2 = lineWidth;
  var _a2 = 0;
  var _b2 = x0;
  if (y2 > y0 + _l2 && y2 > y1 + _l2 || y2 < y0 - _l2 && y2 < y1 - _l2 || x2 > x0 + _l2 && x2 > x1 + _l2 || x2 < x0 - _l2 && x2 < x1 - _l2) {
    return false;
  }
  if (x0 !== x1) {
    _a2 = (y0 - y1) / (x0 - x1);
    _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x2 - x0) <= _l2 / 2;
  }
  var tmp = _a2 * x2 - y2 + _b2;
  var _s2 = tmp * tmp / (_a2 * _a2 + 1);
  return _s2 <= _l2 / 2 * _l2 / 2;
}
function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x4, y4) {
  if (lineWidth === 0) {
    return false;
  }
  var _l2 = lineWidth;
  if (y4 > y0 + _l2 && y4 > y1 + _l2 && y4 > y2 + _l2 && y4 > y3 + _l2 || y4 < y0 - _l2 && y4 < y1 - _l2 && y4 < y2 - _l2 && y4 < y3 - _l2 || x4 > x0 + _l2 && x4 > x1 + _l2 && x4 > x2 + _l2 && x4 > x3 + _l2 || x4 < x0 - _l2 && x4 < x1 - _l2 && x4 < x2 - _l2 && x4 < x3 - _l2) {
    return false;
  }
  var d3 = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4, null);
  return d3 <= _l2 / 2;
}
function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x3, y3) {
  if (lineWidth === 0) {
    return false;
  }
  var _l2 = lineWidth;
  if (y3 > y0 + _l2 && y3 > y1 + _l2 && y3 > y2 + _l2 || y3 < y0 - _l2 && y3 < y1 - _l2 && y3 < y2 - _l2 || x3 > x0 + _l2 && x3 > x1 + _l2 && x3 > x2 + _l2 || x3 < x0 - _l2 && x3 < x1 - _l2 && x3 < x2 - _l2) {
    return false;
  }
  var d3 = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, null);
  return d3 <= _l2 / 2;
}
var PI2$5 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI2$5;
  if (angle < 0) {
    angle += PI2$5;
  }
  return angle;
}
var PI2$4 = Math.PI * 2;
function containStroke$1(cx, cy, r2, startAngle, endAngle, anticlockwise, lineWidth, x2, y2) {
  if (lineWidth === 0) {
    return false;
  }
  var _l2 = lineWidth;
  x2 -= cx;
  y2 -= cy;
  var d3 = Math.sqrt(x2 * x2 + y2 * y2);
  if (d3 - _l2 > r2 || d3 + _l2 < r2) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI2$4 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$4;
  }
  var angle = Math.atan2(y2, x2);
  if (angle < 0) {
    angle += PI2$4;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle;
}
function windingLine(x0, y0, x1, y1, x2, y2) {
  if (y2 > y0 && y2 > y1 || y2 < y0 && y2 < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  var t2 = (y2 - y0) / (y1 - y0);
  var dir3 = y1 < y0 ? 1 : -1;
  if (t2 === 1 || t2 === 0) {
    dir3 = y1 < y0 ? 0.5 : -0.5;
  }
  var x_ = t2 * (x1 - x0) + x0;
  return x_ === x2 ? Infinity : x_ > x2 ? dir3 : 0;
}
var CMD$3 = PathProxy$1.CMD;
var PI2$3 = Math.PI * 2;
var EPSILON$1 = 1e-4;
function isAroundEqual$1(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON$1;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x4, y4) {
  if (y4 > y0 && y4 > y1 && y4 > y2 && y4 > y3 || y4 < y0 && y4 < y1 && y4 < y2 && y4 < y3) {
    return 0;
  }
  var nRoots = cubicRootAt(y0, y1, y2, y3, y4, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w2 = 0;
    var nExtrema = -1;
    var y0_ = void 0;
    var y1_ = void 0;
    for (var i2 = 0; i2 < nRoots; i2++) {
      var t2 = roots[i2];
      var unit = t2 === 0 || t2 === 1 ? 0.5 : 1;
      var x_ = cubicAt(x0, x1, x2, x3, t2);
      if (x_ < x4) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t2 < extrema[0]) {
          w2 += y0_ < y0 ? unit : -unit;
        } else if (t2 < extrema[1]) {
          w2 += y1_ < y0_ ? unit : -unit;
        } else {
          w2 += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t2 < extrema[0]) {
          w2 += y0_ < y0 ? unit : -unit;
        } else {
          w2 += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w2;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x3, y3) {
  if (y3 > y0 && y3 > y1 && y3 > y2 || y3 < y0 && y3 < y1 && y3 < y2) {
    return 0;
  }
  var nRoots = quadraticRootAt(y0, y1, y2, y3, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t2 = quadraticExtremum(y0, y1, y2);
    if (t2 >= 0 && t2 <= 1) {
      var w2 = 0;
      var y_ = quadraticAt(y0, y1, y2, t2);
      for (var i2 = 0; i2 < nRoots; i2++) {
        var unit = roots[i2] === 0 || roots[i2] === 1 ? 0.5 : 1;
        var x_ = quadraticAt(x0, x1, x2, roots[i2]);
        if (x_ < x3) {
          continue;
        }
        if (roots[i2] < t2) {
          w2 += y_ < y0 ? unit : -unit;
        } else {
          w2 += y2 < y_ ? unit : -unit;
        }
      }
      return w2;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x3) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r2, startAngle, endAngle, anticlockwise, x2, y2) {
  y2 -= cy;
  if (y2 > r2 || y2 < -r2) {
    return 0;
  }
  var tmp = Math.sqrt(r2 * r2 - y2 * y2);
  roots[0] = -tmp;
  roots[1] = tmp;
  var dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI2$3 - 1e-4) {
    startAngle = 0;
    endAngle = PI2$3;
    var dir3 = anticlockwise ? 1 : -1;
    if (x2 >= roots[0] + cx && x2 <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    var tmp_1 = startAngle;
    startAngle = endAngle;
    endAngle = tmp_1;
  }
  if (startAngle < 0) {
    startAngle += PI2$3;
    endAngle += PI2$3;
  }
  var w2 = 0;
  for (var i2 = 0; i2 < 2; i2++) {
    var x_ = roots[i2];
    if (x_ + cx > x2) {
      var angle = Math.atan2(y2, x_);
      var dir3 = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI2$3 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w2 += dir3;
      }
    }
  }
  return w2;
}
function containPath(path, lineWidth, isStroke, x2, y2) {
  var data5 = path.data;
  var len2 = path.len();
  var w2 = 0;
  var xi2 = 0;
  var yi2 = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  for (var i2 = 0; i2 < len2; ) {
    var cmd = data5[i2++];
    var isFirst = i2 === 1;
    if (cmd === CMD$3.M && i2 > 1) {
      if (!isStroke) {
        w2 += windingLine(xi2, yi2, x0, y0, x2, y2);
      }
    }
    if (isFirst) {
      xi2 = data5[i2];
      yi2 = data5[i2 + 1];
      x0 = xi2;
      y0 = yi2;
    }
    switch (cmd) {
      case CMD$3.M:
        x0 = data5[i2++];
        y0 = data5[i2++];
        xi2 = x0;
        yi2 = y0;
        break;
      case CMD$3.L:
        if (isStroke) {
          if (containStroke$4(xi2, yi2, data5[i2], data5[i2 + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w2 += windingLine(xi2, yi2, data5[i2], data5[i2 + 1], x2, y2) || 0;
        }
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$3.C:
        if (isStroke) {
          if (containStroke$3(xi2, yi2, data5[i2++], data5[i2++], data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w2 += windingCubic(xi2, yi2, data5[i2++], data5[i2++], data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], x2, y2) || 0;
        }
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$3.Q:
        if (isStroke) {
          if (containStroke$2(xi2, yi2, data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w2 += windingQuadratic(xi2, yi2, data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], x2, y2) || 0;
        }
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$3.A:
        var cx = data5[i2++];
        var cy = data5[i2++];
        var rx = data5[i2++];
        var ry = data5[i2++];
        var theta = data5[i2++];
        var dTheta = data5[i2++];
        i2 += 1;
        var anticlockwise = !!(1 - data5[i2++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w2 += windingLine(xi2, yi2, x1, y1, x2, y2);
        } else {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x2 - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y2)) {
            return true;
          }
        } else {
          w2 += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2);
        }
        xi2 = Math.cos(theta + dTheta) * rx + cx;
        yi2 = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$3.R:
        x0 = xi2 = data5[i2++];
        y0 = yi2 = data5[i2++];
        var width2 = data5[i2++];
        var height2 = data5[i2++];
        x1 = x0 + width2;
        y1 = y0 + height2;
        if (isStroke) {
          if (containStroke$4(x0, y0, x1, y0, lineWidth, x2, y2) || containStroke$4(x1, y0, x1, y1, lineWidth, x2, y2) || containStroke$4(x1, y1, x0, y1, lineWidth, x2, y2) || containStroke$4(x0, y1, x0, y0, lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w2 += windingLine(x1, y0, x1, y1, x2, y2);
          w2 += windingLine(x0, y1, x0, y0, x2, y2);
        }
        break;
      case CMD$3.Z:
        if (isStroke) {
          if (containStroke$4(xi2, yi2, x0, y0, lineWidth, x2, y2)) {
            return true;
          }
        } else {
          w2 += windingLine(xi2, yi2, x0, y0, x2, y2);
        }
        xi2 = x0;
        yi2 = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual$1(yi2, y0)) {
    w2 += windingLine(xi2, yi2, x0, y0, x2, y2) || 0;
  }
  return w2 !== 0;
}
function contain$2(pathProxy, x2, y2) {
  return containPath(pathProxy, 0, false, x2, y2);
}
function containStroke(pathProxy, lineWidth, x2, y2) {
  return containPath(pathProxy, lineWidth, true, x2, y2);
}
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path$1 = function(_super) {
  __extends(Path2, _super);
  function Path2(opts) {
    return _super.call(this, opts) || this;
  }
  Path2.prototype.update = function() {
    var _this = this;
    _super.prototype.update.call(this);
    var style = this.style;
    if (style.decal) {
      var decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = function(ctx) {
          _this.buildPath(ctx, _this.shape);
        };
      }
      decalEl.silent = true;
      var decalElStyle = decalEl.style;
      for (var key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (var i2 = 0; i2 < pathCopyParams.length; ++i2) {
        decalEl[pathCopyParams[i2]] = this[pathCopyParams[i2]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  };
  Path2.prototype.getDecalElement = function() {
    return this._decalEl;
  };
  Path2.prototype._init = function(props) {
    var keysArr = keys$d(props);
    this.shape = this.getDefaultShape();
    var defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (var i2 = 0; i2 < keysArr.length; i2++) {
      var key = keysArr[i2];
      var value = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend$1(this.style, value);
        }
      } else if (key === "shape") {
        extend$1(this.shape, value);
      } else {
        _super.prototype.attrKV.call(this, key, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Path2.prototype.getDefaultStyle = function() {
    return null;
  };
  Path2.prototype.getDefaultShape = function() {
    return {};
  };
  Path2.prototype.canBeInsideText = function() {
    return this.hasFill();
  };
  Path2.prototype.getInsideTextFill = function() {
    var pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString$d(pathFill)) {
        var fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  };
  Path2.prototype.getInsideTextStroke = function(textFill) {
    var pathFill = this.style.fill;
    if (isString$d(pathFill)) {
      var zr2 = this.__zr;
      var isDarkMode2 = !!(zr2 && zr2.isDarkMode());
      var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  };
  Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
  };
  Path2.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  };
  Path2.prototype.getUpdatedPathProxy = function(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  };
  Path2.prototype.createPathProxy = function() {
    this.path = new PathProxy$1(false);
  };
  Path2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  };
  Path2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  Path2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      var path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        var w2 = style.lineWidth;
        if (!this.hasFill()) {
          var strokeContainThreshold = this.strokeContainThreshold;
          w2 = Math.max(w2, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w2 / lineScale;
          rectStroke.height += w2 / lineScale;
          rectStroke.x -= w2 / lineScale / 2;
          rectStroke.y -= w2 / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  };
  Path2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    var style = this.style;
    x2 = localPos[0];
    y2 = localPos[1];
    if (rect.contain(x2, y2)) {
      var pathProxy = this.path;
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke(pathProxy, lineWidth / lineScale, x2, y2)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain$2(pathProxy, x2, y2);
      }
    }
    return false;
  };
  Path2.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  };
  Path2.prototype.dirty = function() {
    this.dirtyStyle();
    this.dirtyShape();
  };
  Path2.prototype.animateShape = function(loop) {
    return this.animate("shape", loop);
  };
  Path2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  };
  Path2.prototype.attrKV = function(key, value) {
    if (key === "shape") {
      this.setShape(value);
    } else {
      _super.prototype.attrKV.call(this, key, value);
    }
  };
  Path2.prototype.setShape = function(keyOrObj, value) {
    var shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend$1(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  };
  Path2.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  };
  Path2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  };
  Path2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend$1({}, this.shape);
    }
  };
  Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend$1({}, normalState.shape);
          extend$1(targetShape, state.shape);
        }
      } else {
        targetShape = extend$1({}, keepCurrentStates ? this.shape : normalState.shape);
        extend$1(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend$1({}, this.shape);
        var targetShapePrimaryProps = {};
        var shapeKeys = keys$d(targetShape);
        for (var i2 = 0; i2 < shapeKeys.length; i2++) {
          var key = shapeKeys[i2];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  };
  Path2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedShape;
    for (var i2 = 0; i2 < states.length; i2++) {
      var state = states[i2];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  };
  Path2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  };
  Path2.prototype.isZeroArea = function() {
    return false;
  };
  Path2.extend = function(defaultProps) {
    var Sub2 = function(_super2) {
      __extends(Sub3, _super2);
      function Sub3(opts) {
        var _this = _super2.call(this, opts) || this;
        defaultProps.init && defaultProps.init.call(_this, opts);
        return _this;
      }
      Sub3.prototype.getDefaultStyle = function() {
        return clone$8(defaultProps.style);
      };
      Sub3.prototype.getDefaultShape = function() {
        return clone$8(defaultProps.shape);
      };
      return Sub3;
    }(Path2);
    for (var key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub2.prototype[key] = defaultProps[key];
      }
    }
    return Sub2;
  };
  Path2.initDefaultProps = function() {
    var pathProto = Path2.prototype;
    pathProto.type = "path";
    pathProto.strokeContainThreshold = 5;
    pathProto.segmentIgnoreThreshold = 0;
    pathProto.subPixelOptimize = false;
    pathProto.autoBatch = false;
    pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }();
  return Path2;
}(Displayable$1);
var Path$2 = Path$1;
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
  __extends(TSpan2, _super);
  function TSpan2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TSpan2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  };
  TSpan2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  TSpan2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  };
  TSpan2.prototype.setBoundingRect = function(rect) {
    this._rect = rect;
  };
  TSpan2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      var text2 = style.text;
      text2 != null ? text2 += "" : text2 = "";
      var rect = getBoundingRect(text2, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        var w2 = style.lineWidth;
        rect.x -= w2 / 2;
        rect.y -= w2 / 2;
        rect.width += w2;
        rect.height += w2;
      }
      this._rect = rect;
    }
    return this._rect;
  };
  TSpan2.initDefaultProps = function() {
    var tspanProto = TSpan2.prototype;
    tspanProto.dirtyRectTolerance = 10;
  }();
  return TSpan2;
}(Displayable$1);
TSpan.prototype.type = "tspan";
var TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = function(_super) {
  __extends(ZRImage2, _super);
  function ZRImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZRImage2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  };
  ZRImage2.prototype._getSize = function(dim) {
    var style = this.style;
    var size = style[dim];
    if (size != null) {
      return size;
    }
    var imageSource = isImageLike(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    var otherDim = dim === "width" ? "height" : "width";
    var otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  };
  ZRImage2.prototype.getWidth = function() {
    return this._getSize("width");
  };
  ZRImage2.prototype.getHeight = function() {
    return this._getSize("height");
  };
  ZRImage2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  };
  ZRImage2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect$1(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  };
  return ZRImage2;
}(Displayable$1);
ZRImage.prototype.type = "image";
var ZRImage$1 = ZRImage;
function buildPath$2(ctx, shape) {
  var x2 = shape.x;
  var y2 = shape.y;
  var width2 = shape.width;
  var height2 = shape.height;
  var r2 = shape.r;
  var r1;
  var r22;
  var r3;
  var r4;
  if (width2 < 0) {
    x2 = x2 + width2;
    width2 = -width2;
  }
  if (height2 < 0) {
    y2 = y2 + height2;
    height2 = -height2;
  }
  if (typeof r2 === "number") {
    r1 = r22 = r3 = r4 = r2;
  } else if (r2 instanceof Array) {
    if (r2.length === 1) {
      r1 = r22 = r3 = r4 = r2[0];
    } else if (r2.length === 2) {
      r1 = r3 = r2[0];
      r22 = r4 = r2[1];
    } else if (r2.length === 3) {
      r1 = r2[0];
      r22 = r4 = r2[1];
      r3 = r2[2];
    } else {
      r1 = r2[0];
      r22 = r2[1];
      r3 = r2[2];
      r4 = r2[3];
    }
  } else {
    r1 = r22 = r3 = r4 = 0;
  }
  var total;
  if (r1 + r22 > width2) {
    total = r1 + r22;
    r1 *= width2 / total;
    r22 *= width2 / total;
  }
  if (r3 + r4 > width2) {
    total = r3 + r4;
    r3 *= width2 / total;
    r4 *= width2 / total;
  }
  if (r22 + r3 > height2) {
    total = r22 + r3;
    r22 *= height2 / total;
    r3 *= height2 / total;
  }
  if (r1 + r4 > height2) {
    total = r1 + r4;
    r1 *= height2 / total;
    r4 *= height2 / total;
  }
  ctx.moveTo(x2 + r1, y2);
  ctx.lineTo(x2 + width2 - r22, y2);
  r22 !== 0 && ctx.arc(x2 + width2 - r22, y2 + r22, r22, -Math.PI / 2, 0);
  ctx.lineTo(x2 + width2, y2 + height2 - r3);
  r3 !== 0 && ctx.arc(x2 + width2 - r3, y2 + height2 - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x2 + r4, y2 + height2);
  r4 !== 0 && ctx.arc(x2 + r4, y2 + height2 - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x2, y2 + r1);
  r1 !== 0 && ctx.arc(x2 + r1, y2 + r1, r1, Math.PI, Math.PI * 1.5);
}
var round$4 = Math.round;
function subPixelOptimizeLine$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x1 = inputShape.x1;
  var x2 = inputShape.x2;
  var y1 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round$4(x1 * 2) === round$4(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
  }
  if (round$4(y1 * 2) === round$4(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
  outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize$1(position, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position;
  }
  var doubledPosition = round$4(position * 2);
  return (doubledPosition + round$4(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}
var RectShape = function() {
  function RectShape2() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
  return RectShape2;
}();
var subPixelOptimizeOutputShape$1 = {};
var Rect$1 = function(_super) {
  __extends(Rect2, _super);
  function Rect2(opts) {
    return _super.call(this, opts) || this;
  }
  Rect2.prototype.getDefaultShape = function() {
    return new RectShape();
  };
  Rect2.prototype.buildPath = function(ctx, shape) {
    var x2;
    var y2;
    var width2;
    var height2;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
      x2 = optimizedShape.x;
      y2 = optimizedShape.y;
      width2 = optimizedShape.width;
      height2 = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x2 = shape.x;
      y2 = shape.y;
      width2 = shape.width;
      height2 = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x2, y2, width2, height2);
    } else {
      buildPath$2(ctx, shape);
    }
  };
  Rect2.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  };
  return Rect2;
}(Path$2);
Rect$1.prototype.type = "rect";
var Rect$2 = Rect$1;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = function(_super) {
  __extends(ZRText2, _super);
  function ZRText2(opts) {
    var _this = _super.call(this) || this;
    _this.type = "text";
    _this._children = [];
    _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    _this.attr(opts);
    return _this;
  }
  ZRText2.prototype.childrenRef = function() {
    return this._children;
  };
  ZRText2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (var i2 = 0; i2 < this._children.length; i2++) {
      var child = this._children[i2];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  };
  ZRText2.prototype.updateTransform = function() {
    var innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      _super.prototype.updateTransform.call(this);
    }
  };
  ZRText2.prototype.getLocalTransform = function(m2) {
    var innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
  };
  ZRText2.prototype.getComputedTransform = function() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return _super.prototype.getComputedTransform.call(this);
  };
  ZRText2.prototype._updateSubTexts = function() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  };
  ZRText2.prototype.addSelfToZr = function(zr2) {
    _super.prototype.addSelfToZr.call(this, zr2);
    for (var i2 = 0; i2 < this._children.length; i2++) {
      this._children[i2].__zr = zr2;
    }
  };
  ZRText2.prototype.removeSelfFromZr = function(zr2) {
    _super.prototype.removeSelfFromZr.call(this, zr2);
    for (var i2 = 0; i2 < this._children.length; i2++) {
      this._children[i2].__zr = null;
    }
  };
  ZRText2.prototype.getBoundingRect = function() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
      var children2 = this._children;
      var tmpMat = [];
      var rect = null;
      for (var i2 = 0; i2 < children2.length; i2++) {
        var child = children2[i2];
        var childRect = child.getBoundingRect();
        var transform = child.getLocalTransform(tmpMat);
        if (transform) {
          tmpRect2.copy(childRect);
          tmpRect2.applyTransform(transform);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect2;
    }
    return this._rect;
  };
  ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  };
  ZRText2.prototype.setTextContent = function(textContent) {
  };
  ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    var sourceRich = sourceStyle.rich;
    var targetRich = targetStyle.rich || sourceRich && {};
    extend$1(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  };
  ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
    var richNames = keys$d(sourceRich);
    for (var i2 = 0; i2 < richNames.length; i2++) {
      var richName = richNames[i2];
      targetRich[richName] = targetRich[richName] || {};
      extend$1(targetRich[richName], sourceRich[richName]);
    }
  };
  ZRText2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  };
  ZRText2.prototype._getOrCreateChild = function(Ctor) {
    var child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  };
  ZRText2.prototype._updatePlainTexts = function() {
    var style = this.style;
    var textFont = style.font || DEFAULT_FONT;
    var textPadding = style.padding;
    var text2 = getStyleText(style);
    var contentBlock = parsePlainText(text2, style);
    var needDrawBg = needDrawBackground(style);
    var bgColorDrawn = !!style.backgroundColor;
    var outerHeight = contentBlock.outerHeight;
    var outerWidth = contentBlock.outerWidth;
    var contentWidth = contentBlock.contentWidth;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var defaultStyle = this._defaultStyle;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.align || defaultStyle.align || "left";
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    var textX = baseX;
    var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    var defaultLineWidth = 0;
    var useDefaultFill = false;
    var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow = style.textShadowBlur > 0;
    var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    var calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (var i2 = 0; i2 < textLines.length; i2++) {
      var el2 = this._getOrCreateChild(TSpan$1);
      var subElStyle = el2.createStyle();
      el2.useStyle(subElStyle);
      subElStyle.text = textLines[i2];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el2.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  };
  ZRText2.prototype._updateRichTexts = function() {
    var style = this.style;
    var text2 = getStyleText(style);
    var contentBlock = parseRichText(text2, style);
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.padding;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var defaultStyle = this._defaultStyle;
    var textAlign = style.align || defaultStyle.align;
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    var boxX = adjustTextX(baseX, outerWidth, textAlign);
    var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    var bgColorDrawn = !!style.backgroundColor;
    for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
      var line = contentBlock.lines[i2];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var remainedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token = void 0;
      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  };
  ZRText2.prototype._placeToken = function(token, style, lineHeight, lineTop, x2, textAlign, parentBgColorDrawn) {
    var tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    var verticalAlign = token.verticalAlign;
    var y2 = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y2 = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y2 = lineTop + lineHeight - token.height / 2;
    }
    var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x2 - token.width : textAlign === "center" ? x2 - token.width / 2 : x2, y2 - token.height / 2, token.width, token.height);
    var bgColorDrawn = !!tokenStyle.backgroundColor;
    var textPadding = token.textPadding;
    if (textPadding) {
      x2 = getTextXForPadding(x2, textAlign, textPadding);
      y2 -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    var el2 = this._getOrCreateChild(TSpan$1);
    var subElStyle = el2.createStyle();
    el2.useStyle(subElStyle);
    var defaultStyle = this._defaultStyle;
    var useDefaultFill = false;
    var defaultLineWidth = 0;
    var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x2;
    subElStyle.y = y2;
    if (hasShadow) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    var textWidth = token.contentWidth;
    var textHeight = token.contentHeight;
    el2.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  };
  ZRText2.prototype._renderBackground = function(style, topStyle, x2, y2, width2, height2) {
    var textBackgroundColor = style.backgroundColor;
    var textBorderWidth = style.borderWidth;
    var textBorderColor = style.borderColor;
    var isImageBg = textBackgroundColor && textBackgroundColor.image;
    var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    var textBorderRadius = style.borderRadius;
    var self2 = this;
    var rectEl;
    var imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect$2);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      var rectShape = rectEl.shape;
      rectShape.x = x2;
      rectShape.y = y2;
      rectShape.width = width2;
      rectShape.height = height2;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      var rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(ZRImage$1);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      var imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x2;
      imgStyle.y = y2;
      imgStyle.width = width2;
      imgStyle.height = height2;
    }
    if (textBorderWidth && textBorderColor) {
      var rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    var commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  };
  ZRText2.makeFont = function(style) {
    var font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim$3(font) || style.textFont || style.font;
  };
  return ZRText2;
}(Displayable$1);
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (var i2 = 0; i2 < FONT_PARTS.length; i2++) {
    var fontProp = FONT_PARTS[i2];
    var val2 = sourceStyle[fontProp];
    if (val2 != null) {
      targetStyle[fontProp] = val2;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each$q(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    var textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    var textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray$1(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x2, textAlign, textPadding) {
  return textAlign === "right" ? x2 - textPadding[1] : textAlign === "center" ? x2 + textPadding[3] / 2 - textPadding[1] / 2 : x2 + textPadding[3];
}
function getStyleText(style) {
  var text2 = style.text;
  text2 != null && (text2 += "");
  return text2;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var ZRText$1 = ZRText;
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el2) {
  if (el2) {
    var ecData = getECData(el2);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    if (el2.type === "group") {
      el2.traverse(function(child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
      });
    }
  }
};
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
var liftedColorCache = new LRU$1(100);
function liftColor(color$1) {
  if (isString$d(color$1)) {
    var liftedColor = liftedColorCache.get(color$1);
    if (!liftedColor) {
      liftedColor = lift(color$1, -0.1);
      liftedColorCache.put(color$1, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color$1)) {
    var ret = extend$1({}, color$1);
    ret.colorStops = map$9(color$1.colorStops, function(stop2) {
      return {
        offset: stop2.offset,
        color: lift(stop2.color, -0.1)
      };
    });
    return ret;
  }
  return color$1;
}
function doChangeHoverState(el2, stateName, hoverStateEnum) {
  if (el2.onHoverStateChange && (el2.hoverState || 0) !== hoverStateEnum) {
    el2.onHoverStateChange(stateName);
  }
  el2.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el2) {
  doChangeHoverState(el2, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el2) {
  if (el2.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el2, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el2) {
  doChangeHoverState(el2, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el2) {
  if (el2.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el2, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el2) {
  el2.selected = true;
}
function singleLeaveSelect(el2) {
  el2.selected = false;
}
function updateElementState(el2, updater, commonParam) {
  updater(el2, commonParam);
}
function traverseUpdateState(el2, updater, commonParam) {
  updateElementState(el2, updater, commonParam);
  el2.isGroup && el2.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el2, stateName) {
  switch (stateName) {
    case "emphasis":
      el2.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el2.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el2.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el2.selected = true;
  }
}
function getFromStateStyle(el2, props, toStateName, defaultValue) {
  var style = el2.style;
  var fromState = {};
  for (var i2 = 0; i2 < props.length; i2++) {
    var propName = props[i2];
    var val2 = style[propName];
    fromState[propName] = val2 == null ? defaultValue && defaultValue[propName] : val2;
  }
  for (var i2 = 0; i2 < el2.animators.length; i2++) {
    var animator = el2.animators[i2];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el2, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf$2(targetStates, "select") >= 0;
  var cloned = false;
  if (el2 instanceof Path$2) {
    var store = getSavedStates(el2);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend$1({}, state);
        emphasisStyle = extend$1({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend$1({}, state);
        emphasisStyle = extend$1({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend$1({}, state);
          emphasisStyle = extend$1({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend$1({}, state);
      }
      var z2EmphasisLift = el2.z2EmphasisLift;
      state.z2 = el2.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el2, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend$1({}, state);
      var z2SelectLift = el2.z2SelectLift;
      state.z2 = el2.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el2, stateName, state) {
  var hasBlur = indexOf$2(el2.currentStates, stateName) >= 0;
  var currentOpacity = el2.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el2, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend$1({}, state);
    blurStyle = extend$1({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el2) {
  el2.stateProxy = elementStateProxy;
  var textContent = el2.getTextContent();
  var textGuide = el2.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el2, e3) {
  !shouldSilent(el2, e3) && !el2.__highByOuter && traverseUpdateState(el2, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el2, e3) {
  !shouldSilent(el2, e3) && !el2.__highByOuter && traverseUpdateState(el2, singleLeaveEmphasis);
}
function enterEmphasis(el2, highlightDigit) {
  el2.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el2, singleEnterEmphasis);
}
function leaveEmphasis(el2, highlightDigit) {
  !(el2.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el2, singleLeaveEmphasis);
}
function enterBlur(el2) {
  traverseUpdateState(el2, singleEnterBlur);
}
function leaveBlur(el2) {
  traverseUpdateState(el2, singleLeaveBlur);
}
function enterSelect(el2) {
  traverseUpdateState(el2, singleEnterSelect);
}
function leaveSelect(el2) {
  traverseUpdateState(el2, singleLeaveSelect);
}
function shouldSilent(el2, e3) {
  return el2.__highDownSilentOnTouch && e3.zrByTouch;
}
function allLeaveBlur(api) {
  var model = api.getModel();
  var leaveBlurredSeries = [];
  var allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    var isSeries2 = componentType === "series";
    var view = isSeries2 ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
    !isSeries2 && allComponentViews.push(view);
    if (componentStates.isBlured) {
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries2 && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each$q(allComponentViews, function(view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus2, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data5, dataIndices) {
    for (var i2 = 0; i2 < dataIndices.length; i2++) {
      var itemEl = data5.getItemGraphicEl(dataIndices[i2]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus2 || focus2 === "none") {
    return;
  }
  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  var blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus2 === "series" && sameSeries)) {
      var view = api.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        singleEnterBlur(child);
      });
      if (isArrayLike$2(focus2)) {
        leaveBlurOfIndices(seriesModel.getData(), focus2);
      } else if (isObject$f(focus2)) {
        var dataTypes = keys$d(focus2);
        for (var d3 = 0; d3 < dataTypes.length; d3++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d3]), focus2[dataTypes[d3]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data5 = seriesModel.getData(payload.dataType);
  if (!data5) {
    return;
  }
  var dataIndex = queryDataIndex(data5, payload);
  dataIndex = (isArray$x(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el2 = data5.getItemGraphicEl(dataIndex);
  if (!el2) {
    var count = data5.count();
    var current = 0;
    while (!el2 && current < count) {
      el2 = data5.getItemGraphicEl(current++);
    }
  }
  if (el2) {
    var ecData = getECData(el2);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    var focus_1 = seriesModel.get(["emphasis", "focus"]);
    var blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name2, api) {
  var ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name2 == null) {
    return ret;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }
  var dispatchers = view.findHighDownDispatchers(name2);
  var focusSelf;
  for (var i2 = 0; i2 < dispatchers.length; i2++) {
    if (getECData(dispatchers[i2]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {
    focusSelf,
    dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e3, api) {
  var ecData = getECData(dispatcher);
  var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    each$q(dispatchers, function(dispatcher2) {
      return enterEmphasisWhenMouseOver(dispatcher2, e3);
    });
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    enterEmphasisWhenMouseOver(dispatcher, e3);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e3, api) {
  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
  if (dispatchers) {
    each$q(dispatchers, function(dispatcher2) {
      return leaveEmphasisWhenMouseOut(dispatcher2, e3);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e3);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  var dataType = payload.dataType;
  var data5 = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data5, payload);
  if (!isArray$x(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each$q(allData, function(_a2) {
    var data5 = _a2.data, type2 = _a2.type;
    data5.eachItemGraphicEl(function(el2, idx) {
      seriesModel.isSelected(idx, type2) ? enterSelect(el2) : leaveSelect(el2);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret = [];
  ecModel.eachSeries(function(seriesModel) {
    var allData = seriesModel.getAllData();
    each$q(allData, function(_a2) {
      _a2.data;
      var type2 = _a2.type;
      var dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type2 != null) {
          item.dataType = type2;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el2, focus2, blurScope) {
  setAsHighDownDispatcher(el2, true);
  traverseUpdateState(el2, setDefaultStateProxy);
  enableHoverFocus(el2, focus2, blurScope);
}
function disableHoverEmphasis(el2) {
  setAsHighDownDispatcher(el2, false);
}
function toggleHoverEmphasis(el2, focus2, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el2) : enableHoverEmphasis(el2, focus2, blurScope);
}
function enableHoverFocus(el2, focus2, blurScope) {
  var ecData = getECData(el2);
  if (focus2 != null) {
    ecData.focus = focus2;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el2, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (var i2 = 0; i2 < OTHER_STATES.length; i2++) {
    var stateName = OTHER_STATES[i2];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el2.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el2, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el2;
  if (el2.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el2.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el2) {
  return !!(el2 && el2.__highDownDispatcher);
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el2) {
  var store = getSavedStates(el2);
  store.normalFill = el2.style.fill;
  store.normalStroke = el2.style.stroke;
  var selectState = el2.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}
var CMD$2 = PathProxy$1.CMD;
var points = [[], [], []];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  var data5 = path.data;
  var len2 = path.len();
  var cmd;
  var nPoint;
  var i2;
  var j2;
  var k2;
  var p2;
  var M2 = CMD$2.M;
  var C2 = CMD$2.C;
  var L2 = CMD$2.L;
  var R2 = CMD$2.R;
  var A2 = CMD$2.A;
  var Q2 = CMD$2.Q;
  for (i2 = 0, j2 = 0; i2 < len2; ) {
    cmd = data5[i2++];
    j2 = i2;
    nPoint = 0;
    switch (cmd) {
      case M2:
        nPoint = 1;
        break;
      case L2:
        nPoint = 1;
        break;
      case C2:
        nPoint = 3;
        break;
      case Q2:
        nPoint = 2;
        break;
      case A2:
        var x2 = m2[4];
        var y2 = m2[5];
        var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
        var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
        var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data5[i2] *= sx;
        data5[i2++] += x2;
        data5[i2] *= sy;
        data5[i2++] += y2;
        data5[i2++] *= sx;
        data5[i2++] *= sy;
        data5[i2++] += angle;
        data5[i2++] += angle;
        i2 += 2;
        j2 = i2;
        break;
      case R2:
        p2[0] = data5[i2++];
        p2[1] = data5[i2++];
        applyTransform$1(p2, p2, m2);
        data5[j2++] = p2[0];
        data5[j2++] = p2[1];
        p2[0] += data5[i2++];
        p2[1] += data5[i2++];
        applyTransform$1(p2, p2, m2);
        data5[j2++] = p2[0];
        data5[j2++] = p2[1];
    }
    for (k2 = 0; k2 < nPoint; k2++) {
      var p_1 = points[k2];
      p_1[0] = data5[i2++];
      p_1[1] = data5[i2++];
      applyTransform$1(p_1, p_1, m2);
      data5[j2++] = p_1[0];
      data5[j2++] = p_1[1];
    }
  }
  path.increaseVersion();
}
var mathSqrt$1 = Math.sqrt;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var PI$3 = Math.PI;
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function processArc(x1, y1, x2, y2, fa2, fs2, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI$3 / 180);
  var xp2 = mathCos$1(psi) * (x1 - x2) / 2 + mathSin$1(psi) * (y1 - y2) / 2;
  var yp2 = -1 * mathSin$1(psi) * (x1 - x2) / 2 + mathCos$1(psi) * (y1 - y2) / 2;
  var lambda = xp2 * xp2 / (rx * rx) + yp2 * yp2 / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt$1(lambda);
    ry *= mathSqrt$1(lambda);
  }
  var f2 = (fa2 === fs2 ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp2 * yp2) - ry * ry * (xp2 * xp2)) / (rx * rx * (yp2 * yp2) + ry * ry * (xp2 * xp2))) || 0;
  var cxp = f2 * rx * yp2 / ry;
  var cyp = f2 * -ry * xp2 / rx;
  var cx = (x1 + x2) / 2 + mathCos$1(psi) * cxp - mathSin$1(psi) * cyp;
  var cy = (y1 + y2) / 2 + mathSin$1(psi) * cxp + mathCos$1(psi) * cyp;
  var theta = vAngle([1, 0], [(xp2 - cxp) / rx, (yp2 - cyp) / ry]);
  var u2 = [(xp2 - cxp) / rx, (yp2 - cyp) / ry];
  var v2 = [(-1 * xp2 - cxp) / rx, (-1 * yp2 - cyp) / ry];
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = PI$3;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    var n2 = Math.round(dTheta / PI$3 * 1e6) / 1e6;
    dTheta = PI$3 * 2 + n2 % 2 * PI$3;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs2);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data5) {
  var path = new PathProxy$1();
  if (!data5) {
    return path;
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var CMD2 = PathProxy$1.CMD;
  var cmdList = data5.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (var l2 = 0; l2 < cmdList.length; l2++) {
    var cmdText = cmdList[l2];
    var cmdStr = cmdText.charAt(0);
    var cmd = void 0;
    var p2 = cmdText.match(numberReg) || [];
    var pLen = p2.length;
    for (var i2 = 0; i2 < pLen; i2++) {
      p2[i2] = parseFloat(p2[i2]);
    }
    var off2 = 0;
    while (off2 < pLen) {
      var ctlPtx = void 0;
      var ctlPty = void 0;
      var rx = void 0;
      var ry = void 0;
      var psi = void 0;
      var fa2 = void 0;
      var fs2 = void 0;
      var x1 = cpx;
      var y1 = cpy;
      var len2 = void 0;
      var pathData = void 0;
      switch (cmdStr) {
        case "l":
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p2[off2++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD2.C;
          path.addData(cmd, p2[off2++], p2[off2++], p2[off2++], p2[off2++], p2[off2++], p2[off2++]);
          cpx = p2[off2 - 2];
          cpy = p2[off2 - 1];
          break;
        case "c":
          cmd = CMD2.C;
          path.addData(cmd, p2[off2++] + cpx, p2[off2++] + cpy, p2[off2++] + cpx, p2[off2++] + cpy, p2[off2++] + cpx, p2[off2++] + cpy);
          cpx += p2[off2 - 2];
          cpy += p2[off2 - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = p2[off2++];
          y1 = p2[off2++];
          cpx = p2[off2++];
          cpy = p2[off2++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = cpx + p2[off2++];
          y1 = cpy + p2[off2++];
          cpx += p2[off2++];
          cpy += p2[off2++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p2[off2++];
          y1 = p2[off2++];
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p2[off2++] + cpx;
          y1 = p2[off2++] + cpy;
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p2[off2++];
          ry = p2[off2++];
          psi = p2[off2++];
          fa2 = p2[off2++];
          fs2 = p2[off2++];
          x1 = cpx, y1 = cpy;
          cpx = p2[off2++];
          cpy = p2[off2++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa2, fs2, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p2[off2++];
          ry = p2[off2++];
          psi = p2[off2++];
          fa2 = p2[off2++];
          fs2 = p2[off2++];
          x1 = cpx, y1 = cpy;
          cpx += p2[off2++];
          cpy += p2[off2++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa2, fs2, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD2.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = function(_super) {
  __extends(SVGPath2, _super);
  function SVGPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGPath2.prototype.applyTransform = function(m2) {
  };
  return SVGPath2;
}(Path$2);
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  var innerOpts = extend$1({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  var innerOpts = createPathOptions(str, defaultOpts);
  var Sub2 = function(_super) {
    __extends(Sub3, _super);
    function Sub3(opts) {
      var _this = _super.call(this, opts) || this;
      _this.applyTransform = innerOpts.applyTransform;
      _this.buildPath = innerOpts.buildPath;
      return _this;
    }
    return Sub3;
  }(SVGPath);
  return Sub2;
}
function mergePath$1(pathEls, opts) {
  var pathList = [];
  var len2 = pathEls.length;
  for (var i2 = 0; i2 < len2; i2++) {
    var pathEl = pathEls[i2];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  var pathBundle = new Path$2(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
function clonePath(sourcePath, opts) {
  opts = opts || {};
  var path = new Path$2();
  if (sourcePath.shape) {
    path.setShape(sourcePath.shape);
  }
  path.setStyle(sourcePath.style);
  if (opts.bakeTransform) {
    transformPath(path.path, sourcePath.getComputedTransform());
  } else {
    if (opts.toLocal) {
      path.setLocalTransform(sourcePath.getComputedTransform());
    } else {
      path.copyTransform(sourcePath);
    }
  }
  path.buildPath = sourcePath.buildPath;
  path.applyTransform = path.applyTransform;
  path.z = sourcePath.z;
  path.z2 = sourcePath.z2;
  path.zlevel = sourcePath.zlevel;
  return path;
}
var CircleShape = function() {
  function CircleShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
  return CircleShape2;
}();
var Circle = function(_super) {
  __extends(Circle2, _super);
  function Circle2(opts) {
    return _super.call(this, opts) || this;
  }
  Circle2.prototype.getDefaultShape = function() {
    return new CircleShape();
  };
  Circle2.prototype.buildPath = function(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  };
  return Circle2;
}(Path$2);
Circle.prototype.type = "circle";
var Circle$1 = Circle;
var EllipseShape = function() {
  function EllipseShape2() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
  return EllipseShape2;
}();
var Ellipse = function(_super) {
  __extends(Ellipse2, _super);
  function Ellipse2(opts) {
    return _super.call(this, opts) || this;
  }
  Ellipse2.prototype.getDefaultShape = function() {
    return new EllipseShape();
  };
  Ellipse2.prototype.buildPath = function(ctx, shape) {
    var k2 = 0.5522848;
    var x2 = shape.cx;
    var y2 = shape.cy;
    var a2 = shape.rx;
    var b2 = shape.ry;
    var ox = a2 * k2;
    var oy = b2 * k2;
    ctx.moveTo(x2 - a2, y2);
    ctx.bezierCurveTo(x2 - a2, y2 - oy, x2 - ox, y2 - b2, x2, y2 - b2);
    ctx.bezierCurveTo(x2 + ox, y2 - b2, x2 + a2, y2 - oy, x2 + a2, y2);
    ctx.bezierCurveTo(x2 + a2, y2 + oy, x2 + ox, y2 + b2, x2, y2 + b2);
    ctx.bezierCurveTo(x2 - ox, y2 + b2, x2 - a2, y2 + oy, x2 - a2, y2);
    ctx.closePath();
  };
  return Ellipse2;
}(Path$2);
Ellipse.prototype.type = "ellipse";
var Ellipse$1 = Ellipse;
var PI$2 = Math.PI;
var PI2$2 = PI$2 * 2;
var mathSin = Math.sin;
var mathCos = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$3 = Math.max;
var mathMin$3 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t2 = dy32 * dx10 - dx32 * dy10;
  if (t2 * t2 < e) {
    return;
  }
  t2 = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t2;
  return [x0 + t2 * dx10, y0 + t2 * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr2, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo2 = (clockwise ? cr2 : -cr2) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo2 * y01;
  var oy = -lo2 * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d22 = dx * dx + dy * dy;
  var r2 = radius - cr2;
  var s2 = x11 * y10 - x10 * y11;
  var d3 = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$3(0, r2 * r2 * d22 - s2 * s2));
  var cx0 = (s2 * dy - dx * d3) / d22;
  var cy0 = (-s2 * dx - dy * d3) / d22;
  var cx1 = (s2 * dy + dx * d3) / d22;
  var cy1 = (-s2 * dx + dy * d3) / d22;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r2 - 1),
    y1: cy0 * (radius / r2 - 1)
  };
}
function normalizeCornerRadius(cr2) {
  var arr;
  if (isArray$x(cr2)) {
    var len2 = cr2.length;
    if (!len2) {
      return cr2;
    }
    if (len2 === 1) {
      arr = [cr2[0], cr2[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr2[0], cr2[0], cr2[1], cr2[1]];
    } else if (len2 === 3) {
      arr = cr2.concat(cr2[2]);
    } else {
      arr = cr2;
    }
  } else {
    arr = [cr2, cr2, cr2, cr2];
  }
  return arr;
}
function buildPath$1(ctx, shape) {
  var _a2;
  var radius = mathMax$3(shape.r, 0);
  var innerRadius = mathMax$3(shape.r0 || 0, 0);
  var hasRadius = radius > 0;
  var hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    var tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  var startAngle = shape.startAngle, endAngle = shape.endAngle;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  var cx = shape.cx, cy = shape.cy;
  var clockwise = !!shape.clockwise;
  var arc = mathAbs(endAngle - startAngle);
  var mod = arc > PI2$2 && arc % PI2$2;
  mod > e && (arc = mod);
  if (!(radius > e)) {
    ctx.moveTo(cx, cy);
  } else if (arc > PI2$2 - e) {
    ctx.moveTo(cx + radius * mathCos(startAngle), cy + radius * mathSin(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e) {
      ctx.moveTo(cx + innerRadius * mathCos(endAngle), cy + innerRadius * mathSin(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    var icrStart = void 0;
    var icrEnd = void 0;
    var ocrStart = void 0;
    var ocrEnd = void 0;
    var ocrs = void 0;
    var ocre = void 0;
    var icrs = void 0;
    var icre = void 0;
    var ocrMax = void 0;
    var icrMax = void 0;
    var limitedOcrMax = void 0;
    var limitedIcrMax = void 0;
    var xre = void 0;
    var yre = void 0;
    var xirs = void 0;
    var yirs = void 0;
    var xrs = radius * mathCos(startAngle);
    var yrs = radius * mathSin(startAngle);
    var xire = innerRadius * mathCos(endAngle);
    var yire = innerRadius * mathSin(endAngle);
    var hasArc = arc > e;
    if (hasArc) {
      var cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
      }
      var halfRd = mathAbs(radius - innerRadius) / 2;
      ocrs = mathMin$3(halfRd, ocrStart);
      ocre = mathMin$3(halfRd, ocrEnd);
      icrs = mathMin$3(halfRd, icrStart);
      icre = mathMin$3(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax$3(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax$3(icrs, icre);
      if (ocrMax > e || icrMax > e) {
        xre = radius * mathCos(endAngle);
        yre = radius * mathSin(endAngle);
        xirs = innerRadius * mathCos(startAngle);
        yirs = innerRadius * mathSin(startAngle);
        if (arc < PI$2) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a2 = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b2 = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOcrMax = mathMin$3(ocrMax, (radius - b2) / (a2 + 1));
            limitedIcrMax = mathMin$3(icrMax, (innerRadius - b2) / (a2 - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e) {
      var crStart = mathMin$3(ocrStart, limitedOcrMax);
      var crEnd = mathMin$3(ocrEnd, limitedOcrMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e) {
      var crStart = mathMin$3(icrStart, limitedIcrMax);
      var crEnd = mathMin$3(icrEnd, limitedIcrMax);
      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}
var SectorShape = function() {
  function SectorShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
  return SectorShape2;
}();
var Sector = function(_super) {
  __extends(Sector2, _super);
  function Sector2(opts) {
    return _super.call(this, opts) || this;
  }
  Sector2.prototype.getDefaultShape = function() {
    return new SectorShape();
  };
  Sector2.prototype.buildPath = function(ctx, shape) {
    buildPath$1(ctx, shape);
  };
  Sector2.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  };
  return Sector2;
}(Path$2);
Sector.prototype.type = "sector";
var Sector$1 = Sector;
var RingShape = function() {
  function RingShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
  return RingShape2;
}();
var Ring = function(_super) {
  __extends(Ring2, _super);
  function Ring2(opts) {
    return _super.call(this, opts) || this;
  }
  Ring2.prototype.getDefaultShape = function() {
    return new RingShape();
  };
  Ring2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y2 = shape.cy;
    var PI22 = Math.PI * 2;
    ctx.moveTo(x2 + shape.r, y2);
    ctx.arc(x2, y2, shape.r, 0, PI22, false);
    ctx.moveTo(x2 + shape.r0, y2);
    ctx.arc(x2, y2, shape.r0, 0, PI22, true);
  };
  return Ring2;
}(Path$2);
Ring.prototype.type = "ring";
var Ring$1 = Ring;
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v2 = [];
  var v1 = [];
  var v22 = [];
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (var i2 = 0, len2 = points2.length; i2 < len2; i2++) {
      min$3(min3, min3, points2[i2]);
      max$4(max3, max3, points2[i2]);
    }
    min$3(min3, min3, constraint[0]);
    max$4(max3, max3, constraint[1]);
  }
  for (var i2 = 0, len2 = points2.length; i2 < len2; i2++) {
    var point = points2[i2];
    if (isLoop) {
      prevPoint = points2[i2 ? i2 - 1 : len2 - 1];
      nextPoint = points2[(i2 + 1) % len2];
    } else {
      if (i2 === 0 || i2 === len2 - 1) {
        cps.push(clone$7(points2[i2]));
        continue;
      } else {
        prevPoint = points2[i2 - 1];
        nextPoint = points2[i2 + 1];
      }
    }
    sub(v2, nextPoint, prevPoint);
    scale$2(v2, v2, smooth);
    var d0 = distance(point, prevPoint);
    var d1 = distance(point, nextPoint);
    var sum3 = d0 + d1;
    if (sum3 !== 0) {
      d0 /= sum3;
      d1 /= sum3;
    }
    scale$2(v1, v2, -d0);
    scale$2(v22, v2, d1);
    var cp0 = add$2([], point, v1);
    var cp1 = add$2([], point, v22);
    if (constraint) {
      max$4(cp0, cp0, min3);
      min$3(cp0, cp0, max3);
      max$4(cp1, cp1, min3);
      min$3(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function buildPath(ctx, shape, closePath) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (points2 && points2.length >= 2) {
    if (smooth) {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len2 = points2.length;
      for (var i2 = 0; i2 < (closePath ? len2 : len2 - 1); i2++) {
        var cp1 = controlPoints[i2 * 2];
        var cp2 = controlPoints[i2 * 2 + 1];
        var p2 = points2[(i2 + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]);
      }
    } else {
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i2 = 1, l2 = points2.length; i2 < l2; i2++) {
        ctx.lineTo(points2[i2][0], points2[i2][1]);
      }
    }
    closePath && ctx.closePath();
  }
}
var PolygonShape = function() {
  function PolygonShape2() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolygonShape2;
}();
var Polygon = function(_super) {
  __extends(Polygon2, _super);
  function Polygon2(opts) {
    return _super.call(this, opts) || this;
  }
  Polygon2.prototype.getDefaultShape = function() {
    return new PolygonShape();
  };
  Polygon2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, true);
  };
  return Polygon2;
}(Path$2);
Polygon.prototype.type = "polygon";
var Polygon$1 = Polygon;
var PolylineShape = function() {
  function PolylineShape2() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolylineShape2;
}();
var Polyline = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2(opts) {
    return _super.call(this, opts) || this;
  }
  Polyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Polyline2.prototype.getDefaultShape = function() {
    return new PolylineShape();
  };
  Polyline2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, false);
  };
  return Polyline2;
}(Path$2);
Polyline.prototype.type = "polyline";
var Polyline$1 = Polyline;
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
  function LineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return LineShape2;
}();
var Line = function(_super) {
  __extends(Line2, _super);
  function Line2(opts) {
    return _super.call(this, opts) || this;
  }
  Line2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Line2.prototype.getDefaultShape = function() {
    return new LineShape();
  };
  Line2.prototype.buildPath = function(ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  };
  Line2.prototype.pointAt = function(p2) {
    var shape = this.shape;
    return [
      shape.x1 * (1 - p2) + shape.x2 * p2,
      shape.y1 * (1 - p2) + shape.y2 * p2
    ];
  };
  return Line2;
}(Path$2);
Line.prototype.type = "line";
var Line$1 = Line;
var out = [];
var BezierCurveShape = function() {
  function BezierCurveShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
  return BezierCurveShape2;
}();
function someVectorAt(shape, t2, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t2),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t2)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t2),
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t2)
    ];
  }
}
var BezierCurve = function(_super) {
  __extends(BezierCurve2, _super);
  function BezierCurve2(opts) {
    return _super.call(this, opts) || this;
  }
  BezierCurve2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  BezierCurve2.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  };
  BezierCurve2.prototype.buildPath = function(ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  };
  BezierCurve2.prototype.pointAt = function(t2) {
    return someVectorAt(this.shape, t2, false);
  };
  BezierCurve2.prototype.tangentAt = function(t2) {
    var p2 = someVectorAt(this.shape, t2, true);
    return normalize$1(p2, p2);
  };
  return BezierCurve2;
}(Path$2);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve$1 = BezierCurve;
var ArcShape = function() {
  function ArcShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return ArcShape2;
}();
var Arc = function(_super) {
  __extends(Arc2, _super);
  function Arc2(opts) {
    return _super.call(this, opts) || this;
  }
  Arc2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Arc2.prototype.getDefaultShape = function() {
    return new ArcShape();
  };
  Arc2.prototype.buildPath = function(ctx, shape) {
    var x2 = shape.cx;
    var y2 = shape.cy;
    var r2 = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r2 + x2, unitY * r2 + y2);
    ctx.arc(x2, y2, r2, startAngle, endAngle, !clockwise);
  };
  return Arc2;
}(Path$2);
Arc.prototype.type = "arc";
var Arc$1 = Arc;
var CompoundPath = function(_super) {
  __extends(CompoundPath2, _super);
  function CompoundPath2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "compound";
    return _this;
  }
  CompoundPath2.prototype._updatePathDirty = function() {
    var paths = this.shape.paths;
    var dirtyPath = this.shapeChanged();
    for (var i2 = 0; i2 < paths.length; i2++) {
      dirtyPath = dirtyPath || paths[i2].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  };
  CompoundPath2.prototype.beforeBrush = function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale2 = this.getGlobalScale();
    for (var i2 = 0; i2 < paths.length; i2++) {
      if (!paths[i2].path) {
        paths[i2].createPathProxy();
      }
      paths[i2].path.setScale(scale2[0], scale2[1], paths[i2].segmentIgnoreThreshold);
    }
  };
  CompoundPath2.prototype.buildPath = function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i2 = 0; i2 < paths.length; i2++) {
      paths[i2].buildPath(ctx, paths[i2].shape, true);
    }
  };
  CompoundPath2.prototype.afterBrush = function() {
    var paths = this.shape.paths || [];
    for (var i2 = 0; i2 < paths.length; i2++) {
      paths[i2].pathUpdated();
    }
  };
  CompoundPath2.prototype.getBoundingRect = function() {
    this._updatePathDirty.call(this);
    return Path$2.prototype.getBoundingRect.call(this);
  };
  return CompoundPath2;
}(Path$2);
var CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function Gradient2(colorStops) {
    this.colorStops = colorStops || [];
  }
  Gradient2.prototype.addColorStop = function(offset2, color2) {
    this.colorStops.push({
      offset: offset2,
      color: color2
    });
  };
  return Gradient2;
}();
var Gradient$1 = Gradient;
var LinearGradient = function(_super) {
  __extends(LinearGradient2, _super);
  function LinearGradient2(x2, y2, x22, y22, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0 : x2;
    _this.y = y2 == null ? 0 : y2;
    _this.x2 = x22 == null ? 1 : x22;
    _this.y2 = y22 == null ? 0 : y22;
    _this.type = "linear";
    _this.global = globalCoord || false;
    return _this;
  }
  return LinearGradient2;
}(Gradient$1);
var LinearGradient$1 = LinearGradient;
var RadialGradient = function(_super) {
  __extends(RadialGradient2, _super);
  function RadialGradient2(x2, y2, r2, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x2 == null ? 0.5 : x2;
    _this.y = y2 == null ? 0.5 : y2;
    _this.r = r2 == null ? 0.5 : r2;
    _this.type = "radial";
    _this.global = globalCoord || false;
    return _this;
  }
  return RadialGradient2;
}(Gradient$1);
var RadialGradient$1 = RadialGradient;
var extent = [0, 0];
var extent2 = [0, 0];
var minTv = new Point$2();
var maxTv = new Point$2();
var OrientedBoundingRect = function() {
  function OrientedBoundingRect2(rect, transform) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (var i2 = 0; i2 < 4; i2++) {
      this._corners[i2] = new Point$2();
    }
    for (var i2 = 0; i2 < 2; i2++) {
      this._axes[i2] = new Point$2();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform);
    }
  }
  OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform) {
    var corners = this._corners;
    var axes = this._axes;
    var x2 = rect.x;
    var y2 = rect.y;
    var x22 = x2 + rect.width;
    var y22 = y2 + rect.height;
    corners[0].set(x2, y2);
    corners[1].set(x22, y2);
    corners[2].set(x22, y22);
    corners[3].set(x2, y22);
    if (transform) {
      for (var i2 = 0; i2 < 4; i2++) {
        corners[i2].transform(transform);
      }
    }
    Point$2.sub(axes[0], corners[1], corners[0]);
    Point$2.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (var i2 = 0; i2 < 2; i2++) {
      this._origin[i2] = axes[i2].dot(corners[0]);
    }
  };
  OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
    var overlapped = true;
    var noMtv = !mtv;
    minTv.set(Infinity, Infinity);
    maxTv.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point$2.copy(mtv, overlapped ? minTv : maxTv);
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv2, maxTv2, noMtv, inverse) {
    var overlapped = true;
    for (var i2 = 0; i2 < 2; i2++) {
      var axis = this._axes[i2];
      this._getProjMinMaxOnAxis(i2, self2._corners, extent);
      this._getProjMinMaxOnAxis(i2, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv2.len()) {
          if (dist0 < dist1) {
            Point$2.scale(maxTv2, axis, -dist0 * inverse);
          } else {
            Point$2.scale(maxTv2, axis, dist1 * inverse);
          }
        }
      } else if (minTv2) {
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv2.len()) {
          if (dist0 < dist1) {
            Point$2.scale(minTv2, axis, dist0 * inverse);
          } else {
            Point$2.scale(minTv2, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
    var axis = this._axes[dim];
    var origin = this._origin;
    var proj = corners[0].dot(axis) + origin[dim];
    var min3 = proj;
    var max3 = proj;
    for (var i2 = 1; i2 < corners.length; i2++) {
      var proj_1 = corners[i2].dot(axis) + origin[dim];
      min3 = Math.min(proj_1, min3);
      max3 = Math.max(proj_1, max3);
    }
    out2[0] = min3;
    out2[1] = max3;
  };
  return OrientedBoundingRect2;
}();
var OrientedBoundingRect$1 = OrientedBoundingRect;
var m$3 = [];
var IncrementalDisplayable = function(_super) {
  __extends(IncrementalDisplayable2, _super);
  function IncrementalDisplayable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.notClear = true;
    _this.incremental = true;
    _this._displayables = [];
    _this._temporaryDisplayables = [];
    _this._cursor = 0;
    return _this;
  }
  IncrementalDisplayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  IncrementalDisplayable2.prototype.useStyle = function() {
    this.style = {};
  };
  IncrementalDisplayable2.prototype.getCursor = function() {
    return this._cursor;
  };
  IncrementalDisplayable2.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  };
  IncrementalDisplayable2.prototype.clearDisplaybles = function() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  };
  IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  };
  IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  };
  IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (var i2 = 0; i2 < displayables.length; i2++) {
      this.addDisplayable(displayables[i2], notPersistent);
    }
  };
  IncrementalDisplayable2.prototype.getDisplayables = function() {
    return this._displayables;
  };
  IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  };
  IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
    for (var i2 = this._cursor; i2 < this._displayables.length; i2++) {
      cb && cb(this._displayables[i2]);
    }
    for (var i2 = 0; i2 < this._temporaryDisplayables.length; i2++) {
      cb && cb(this._temporaryDisplayables[i2]);
    }
  };
  IncrementalDisplayable2.prototype.update = function() {
    this.updateTransform();
    for (var i2 = this._cursor; i2 < this._displayables.length; i2++) {
      var displayable = this._displayables[i2];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (var i2 = 0; i2 < this._temporaryDisplayables.length; i2++) {
      var displayable = this._temporaryDisplayables[i2];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };
  IncrementalDisplayable2.prototype.getBoundingRect = function() {
    if (!this._rect) {
      var rect = new BoundingRect$1(Infinity, Infinity, -Infinity, -Infinity);
      for (var i2 = 0; i2 < this._displayables.length; i2++) {
        var displayable = this._displayables[i2];
        var childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m$3));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  };
  IncrementalDisplayable2.prototype.contain = function(x2, y2) {
    var localPos = this.transformCoordToLocal(x2, y2);
    var rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (var i2 = 0; i2 < this._displayables.length; i2++) {
        var displayable = this._displayables[i2];
        if (displayable.contain(x2, y2)) {
          return true;
        }
      }
    }
    return false;
  };
  return IncrementalDisplayable2;
}(Displayable$1);
var IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  var animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === "update";
  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay2 = void 0;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay2 = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay2 = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay2 = animationPayload.delay);
    }
    if (isFunction$h(delay2)) {
      delay2 = delay2(dataIndex, extraDelayParams);
    }
    if (isFunction$h(duration)) {
      duration = duration(dataIndex);
    }
    var config2 = {
      duration: duration || 0,
      delay: delay2,
      easing
    };
    return config2;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el2, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;
  if (isFunction$h(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject$f(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  var isRemove = animationType === "leave";
  if (!isRemove) {
    el2.stopAnimation("leave");
  }
  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el2, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el2.animateFrom(props, animateConfig) : el2.animateTo(props, animateConfig);
  } else {
    el2.stopAnimation();
    !isFrom && el2.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps$2(el2, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el2, props, animatableModel, dataIndex, cb, during);
}
function initProps(el2, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el2, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el2) {
  if (!el2.__zr) {
    return true;
  }
  for (var i2 = 0; i2 < el2.animators.length; i2++) {
    var animator = el2.animators[i2];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el2, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el2)) {
    return;
  }
  animateOrSetProps("leave", el2, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el2, animatableModel, dataIndex, done) {
  el2.removeTextContent();
  el2.removeTextGuideLine();
  removeElement(el2, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el2, animatableModel, dataIndex) {
  function doRemove() {
    el2.parent && el2.parent.remove(el2);
  }
  if (!el2.isGroup) {
    fadeOutDisplayable(el2, animatableModel, dataIndex, doRemove);
  } else {
    el2.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el2) {
  transitionStore(el2).oldStyle = el2.style;
}
function getOldStyle(el2) {
  return transitionStore(el2).oldStyle;
}
var mathMax$2 = Math.max;
var mathMin$2 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path$2.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name2, ShapeClass) {
  _customShapeMap[name2] = ShapeClass;
}
function getShapeClass(name2) {
  if (_customShapeMap.hasOwnProperty(name2)) {
    return _customShapeMap[name2];
  }
}
function makePath(pathData, opts, rect, layout2) {
  var path = createFromString(pathData, opts);
  if (rect) {
    if (layout2 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout2) {
  var zrImg = new ZRImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout2 === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width2 = rect.height * aspect;
  var height2;
  if (width2 <= rect.width) {
    height2 = rect.height;
  } else {
    width2 = rect.width;
    height2 = width2 / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width2 / 2,
    y: cy - height2 / 2,
    width: width2,
    height: height2
  };
}
var mergePath = mergePath$1;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  var pathRect = path.getBoundingRect();
  var m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine(param) {
  subPixelOptimizeLine$1(param.shape, param.shape, param.style);
  return param;
}
function subPixelOptimizeRect(param) {
  subPixelOptimizeRect$1(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform(target, ancestor) {
  var mat = identity$2([]);
  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform(target, transform, invert$1) {
  if (transform && !isArrayLike$2(transform)) {
    transform = Transformable$1.getLocalTransform(transform);
  }
  if (invert$1) {
    transform = invert([], transform);
  }
  return applyTransform$1([], target, transform);
}
function transformDirection(direction, transform, invert2) {
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el2) {
  return !el2.isGroup;
}
function isPath(el2) {
  return el2.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g3) {
    var elMap = {};
    g3.traverse(function(el2) {
      if (isNotGroup(el2) && el2.anid) {
        elMap[el2.anid] = el2;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el2) {
    var obj = {
      x: el2.x,
      y: el2.y,
      rotation: el2.rotation
    };
    if (isPath(el2)) {
      obj.shape = extend$1({}, el2.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el2) {
    if (isNotGroup(el2) && el2.anid) {
      var oldEl = elMap1[el2.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el2);
        el2.attr(getAnimatableProps(oldEl));
        updateProps$2(el2, newProp, animatableModel, getECData(el2).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return map$9(points2, function(point) {
    var x2 = point[0];
    x2 = mathMax$2(x2, rect.x);
    x2 = mathMin$2(x2, rect.x + rect.width);
    var y2 = point[1];
    y2 = mathMax$2(y2, rect.y);
    y2 = mathMin$2(y2, rect.y + rect.height);
    return [x2, y2];
  });
}
function clipRectByRect(targetRect, rect) {
  var x2 = mathMax$2(targetRect.x, rect.x);
  var x22 = mathMin$2(targetRect.x + targetRect.width, rect.x + rect.width);
  var y2 = mathMax$2(targetRect.y, rect.y);
  var y22 = mathMin$2(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x22 >= x2 && y22 >= y2) {
    return {
      x: x2,
      y: y2,
      width: x22 - x2,
      height: y22 - y2
    };
  }
}
function createIcon(iconStr, opt, rect) {
  var innerOpts = extend$1({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage$1(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i2 = 0, p2 = points2[points2.length - 1]; i2 < points2.length; i2++) {
    var p3 = points2[i2];
    if (lineLineIntersect$1(a1x, a1y, a2x, a2y, p3[0], p3[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p3;
  }
}
function lineLineIntersect$1(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d$1(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q2 = crossProduct2d$1(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q2 < 0 || q2 > 1) {
    return false;
  }
  var p2 = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p2 < 0 || p2 > 1) {
    return false;
  }
  return true;
}
function crossProduct2d$1(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val2) {
  return val2 <= 1e-6 && val2 >= -1e-6;
}
function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString$d(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each$q(keys$d(formatterParamsExtra), function(key) {
      if (!hasOwn$1(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el2, cb) {
  var stopped;
  if (el2.isGroup) {
    stopped = cb(el2);
  }
  if (!stopped) {
    el2.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray$x(els)) {
      for (var i2 = 0; i2 < els.length; i2++) {
        traverseElement(els[i2], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$1);
registerShape("rect", Rect$2);
registerShape("line", Line$1);
registerShape("bezierCurve", BezierCurve$1);
registerShape("arc", Arc$1);
var graphic$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateProps: updateProps$2,
  initProps,
  removeElement,
  removeElementWithFadeOut,
  isElementRemoved,
  extendShape,
  extendPath,
  registerShape,
  getShapeClass,
  makePath,
  makeImage,
  mergePath,
  resizePath,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  subPixelOptimize,
  getTransform,
  applyTransform,
  transformDirection,
  groupTransition,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  linePolygonIntersect,
  lineLineIntersect: lineLineIntersect$1,
  setTooltipConfig,
  traverseElements,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$2,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Point: Point$2,
  Path: Path$2
}, Symbol.toStringTag, { value: "Module" }));
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
    var stateName = SPECIAL_STATES[i2];
    var text2 = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text2;
  }
  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction$h(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  var statesText = {
    normal: baseText
  };
  for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
    var stateName = SPECIAL_STATES[i2];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof ZRText$1;
  var needsCreateText = false;
  for (var i2 = 0; i2 < DISPLAY_STATES.length; i2++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i2]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new ZRText$1();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow("show");
    var normalStyle = createTextStyle$1(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
      var stateName = SPECIAL_STATES[i2];
      var stateModel = labelStatesModels[stateName];
      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle$1(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
    var stateName = SPECIAL_STATES[i2];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle$1(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend$1(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow("rotate");
  var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        var richTextStyle = textStyleModel.getModel(["rich", name_1]);
        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  var overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  var margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys$d(rich);
      for (var i2 = 0; i2 < richKeys.length; i2++) {
        var richKey = richKeys[i2];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"];
var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow("color");
  var strokeColor = textStyleModel.getShallow("textBorderColor");
  var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (var i2 = 0; i2 < TEXT_PROPS_WITH_GLOBAL.length; i2++) {
    var key = TEXT_PROPS_WITH_GLOBAL[i2];
    var val2 = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val2 != null) {
      textStyle[key] = val2;
    }
  }
  for (var i2 = 0; i2 < TEXT_PROPS_SELF.length; i2++) {
    var key = TEXT_PROPS_SELF[i2];
    var val2 = textStyleModel.getShallow(key);
    if (val2 != null) {
      textStyle[key] = val2;
    }
  }
  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (var i2 = 0; i2 < TEXT_PROPS_BOX.length; i2++) {
      var key = TEXT_PROPS_BOX[i2];
      var val2 = textStyleModel.getShallow(key);
      if (val2 != null) {
        textStyle[key] = val2;
      }
    }
    var borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim$3([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data5, animatableModel, labelFetcher) {
  var labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  var targetValue = labelInnerStore.value;
  function during(percent) {
    var interpolated = interpolateRawValues(data5, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    var labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps$2)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
var tmpText = new ZRText$1();
var TextStyleMixin = function() {
  function TextStyleMixin2() {
  }
  TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  TextStyleMixin2.prototype.getFont = function() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  };
  TextStyleMixin2.prototype.getTextRect = function(text2) {
    var style = {
      text: text2,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (var i2 = 0; i2 < textStyleParams.length; i2++) {
      style[textStyleParams[i2]] = this.getShallow(textStyleParams[i2]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };
  return TextStyleMixin2;
}();
var TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
  function LineStyleMixin2() {
  }
  LineStyleMixin2.prototype.getLineStyle = function(excludes) {
    return getLineStyle(this, excludes);
  };
  return LineStyleMixin2;
}();
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
  function ItemStyleMixin2() {
  }
  ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes2) {
    return getItemStyle(this, excludes, includes2);
  };
  return ItemStyleMixin2;
}();
var Model = function() {
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype.init = function(option, parentModel, ecModel) {
  };
  Model2.prototype.mergeOption = function(option, ecModel) {
    merge$2(this.option, option, true);
  };
  Model2.prototype.get = function(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };
  Model2.prototype.getShallow = function(key, ignoreParent) {
    var option = this.option;
    var val2 = option == null ? option : option[key];
    if (val2 == null && !ignoreParent) {
      var parentModel = this.parentModel;
      if (parentModel) {
        val2 = parentModel.getShallow(key);
      }
    }
    return val2;
  };
  Model2.prototype.getModel = function(path, parentModel) {
    var hasPath = path != null;
    var pathFinal = hasPath ? this.parsePath(path) : null;
    var obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model2(obj, parentModel, this.ecModel);
  };
  Model2.prototype.isEmpty = function() {
    return this.option == null;
  };
  Model2.prototype.restoreData = function() {
  };
  Model2.prototype.clone = function() {
    var Ctor = this.constructor;
    return new Ctor(clone$8(this.option));
  };
  Model2.prototype.parsePath = function(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  };
  Model2.prototype.resolveParentPath = function(path) {
    return path;
  };
  Model2.prototype.isAnimationEnabled = function() {
    if (!env$1.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };
  Model2.prototype._doGet = function(pathArr, parentModel) {
    var obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (var i2 = 0; i2 < pathArr.length; i2++) {
      if (!pathArr[i2]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i2]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  };
  return Model2;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin$1(Model, LineStyleMixin);
mixin$1(Model, ItemStyleMixin);
mixin$1(Model, AreaStyleMixin);
mixin$1(Model, TextStyleMixin$1);
var Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(type2) {
  return [type2 || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    var type2 = option.type;
    if (!type2) {
      var componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type2 = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type2;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each$q(targetNameList, function(name2) {
      targetNameSet[name2] = true;
    });
    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each$q(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each$q(targetNameSet, function() {
      var errMsg = "";
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each$q(fullNameList, function(name2) {
      var thisItem = createDependencyGraphItem(graph, name2);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name2);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name2);
      }
      each$q(availableDeps, function(dependentName) {
        if (indexOf$2(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf$2(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name2);
        }
      });
    });
    return {
      graph,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph, name2) {
    if (!graph[name2]) {
      graph[name2] = {
        predecessor: [],
        successor: []
      };
    }
    return graph[name2];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each$q(originalDeps, function(dep) {
      indexOf$2(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge$2(merge$2({}, superOption, true), subOption, true);
}
var langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};
var langZH = {
  time: {
    month: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
    monthAbbr: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
    dayOfWeek: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
    dayOfWeekAbbr: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env$1.domSupported ? DEFAULT_LOCALE : function() {
  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale2, localeObj) {
  locale2 = locale2.toUpperCase();
  localeModels[locale2] = new Model$1(localeObj);
  localeStorage[locale2] = localeObj;
}
function createLocaleObject(locale2) {
  if (isString$d(locale2)) {
    var localeObj = localeStorage[locale2.toUpperCase()] || {};
    if (locale2 === LOCALE_ZH || locale2 === LOCALE_EN) {
      return clone$8(localeObj);
    } else {
      return merge$2(clone$8(localeObj), clone$8(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge$2(clone$8(locale2), clone$8(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad$1(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format$1(time2, template2, isUTC, lang) {
  var date = parseDate$1(time2);
  var y2 = date[fullYearGetterName(isUTC)]();
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var q2 = Math.floor((M2 - 1) / 3) + 1;
  var d3 = date[dateGetterName(isUTC)]();
  var e3 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  var H2 = date[hoursGetterName(isUTC)]();
  var h2 = (H2 - 1) % 12 + 1;
  var m2 = date[minutesGetterName(isUTC)]();
  var s2 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var localeModel = lang instanceof Model$1 ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel("time");
  var month = timeModel.get("month");
  var monthAbbr = timeModel.get("monthAbbr");
  var dayOfWeek = timeModel.get("dayOfWeek");
  var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template2 || "").replace(/{yyyy}/g, y2 + "").replace(/{yy}/g, y2 % 100 + "").replace(/{Q}/g, q2 + "").replace(/{MMMM}/g, month[M2 - 1]).replace(/{MMM}/g, monthAbbr[M2 - 1]).replace(/{MM}/g, pad$1(M2, 2)).replace(/{M}/g, M2 + "").replace(/{dd}/g, pad$1(d3, 2)).replace(/{d}/g, d3 + "").replace(/{eeee}/g, dayOfWeek[e3]).replace(/{ee}/g, dayOfWeekAbbr[e3]).replace(/{e}/g, e3 + "").replace(/{HH}/g, pad$1(H2, 2)).replace(/{H}/g, H2 + "").replace(/{hh}/g, pad$1(h2 + "", 2)).replace(/{h}/g, h2 + "").replace(/{mm}/g, pad$1(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad$1(s2, 2)).replace(/{s}/g, s2 + "").replace(/{SSS}/g, pad$1(S2, 3)).replace(/{S}/g, S2 + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  var template2 = null;
  if (isString$d(formatter)) {
    template2 = formatter;
  } else if (isFunction$h(formatter)) {
    template2 = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults$1 = extend$1({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (var i2 = 0; i2 < primaryTimeUnits.length; ++i2) {
        defaults$1[primaryTimeUnits[i2]] = "{primary|" + defaults$1[primaryTimeUnits[i2]] + "}";
      }
    }
    var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults$1) : defaults$1;
    var unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template2 = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      var targetId = timeUnits.indexOf(unit);
      for (var i2 = targetId - 1; i2 >= 0; --i2) {
        if (mergedFormatter[unit]) {
          template2 = mergedFormatter[unit];
          break;
        }
      }
      template2 = template2 || defaults$1.none;
    }
    if (isArray$x(template2)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template2.length + tick.level;
      levelId = Math.min(levelId, template2.length - 1);
      template2 = template2[levelId];
    }
  }
  return format$1(new Date(tick.value), template2, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  var date = parseDate$1(value);
  var M2 = date[monthGetterName(isUTC)]() + 1;
  var d3 = date[dateGetterName(isUTC)]();
  var h2 = date[hoursGetterName(isUTC)]();
  var m2 = date[minutesGetterName(isUTC)]();
  var s2 = date[secondsGetterName(isUTC)]();
  var S2 = date[millisecondsGetterName(isUTC)]();
  var isSecond = S2 === 0;
  var isMinute = isSecond && s2 === 0;
  var isHour = isMinute && m2 === 0;
  var isDay = isHour && h2 === 0;
  var isMonth = isDay && d3 === 1;
  var isYear = isMonth && M2 === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value, unit, isUTC) {
  var date = isNumber$c(value) ? parseDate$1(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}
function getTextRect(text2, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
  var textEl = new ZRText$1({
    style: {
      text: text2,
      font,
      align,
      verticalAlign,
      padding,
      rich,
      overflow: truncate ? "truncate" : null,
      lineHeight
    }
  });
  return textEl.getBoundingRect();
}
function addCommas(x2) {
  if (!isNumeric(x2)) {
    return isString$d(x2) ? x2 : "-";
  }
  var parts = (x2 + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase$1(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray = normalizeCssArray$1;
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c2) {
    return replaceMap[c2];
  });
}
function makeValueReadable(value, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim$3(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  var isTypeTime = valueType === "time";
  var isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate$1(value) : value;
    if (!isNaN(+date)) {
      return format$1(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber$c(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  var numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode) {
  if (!isArray$x(paramsList)) {
    paramsList = [paramsList];
  }
  var seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  var $vars = paramsList[0].$vars || [];
  for (var i2 = 0; i2 < $vars.length; i2++) {
    var alias2 = TPL_VAR_ALIAS[i2];
    tpl = tpl.replace(wrapVar(alias2), wrapVar(alias2, 0));
  }
  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k2 = 0; k2 < $vars.length; k2++) {
      var val2 = paramsList[seriesIdx][$vars[k2]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k2], seriesIdx), encode ? encodeHTML(val2) : val2);
    }
  }
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString$d(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  var color2 = opt.color;
  var type2 = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || "html";
  if (!color2) {
    return "";
  }
  if (renderMode === "html") {
    return type2 === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>';
  } else {
    var markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type2 === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color2
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color2
      }
    };
  }
}
function formatTime(tpl, value, isUTC) {
  if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
    tpl = "MM-dd\nyyyy";
  }
  var date = parseDate$1(value);
  var getUTC = isUTC ? "getUTC" : "get";
  var y2 = date[getUTC + "FullYear"]();
  var M2 = date[getUTC + "Month"]() + 1;
  var d3 = date[getUTC + "Date"]();
  var h2 = date[getUTC + "Hours"]();
  var m2 = date[getUTC + "Minutes"]();
  var s2 = date[getUTC + "Seconds"]();
  var S2 = date[getUTC + "Milliseconds"]();
  tpl = tpl.replace("MM", pad$1(M2, 2)).replace("M", M2).replace("yyyy", y2).replace("yy", pad$1(y2 % 100 + "", 2)).replace("dd", pad$1(d3, 2)).replace("d", d3).replace("hh", pad$1(h2, 2)).replace("h", h2).replace("mm", pad$1(m2, 2)).replace("m", m2).replace("ss", pad$1(s2, 2)).replace("s", s2).replace("SSS", pad$1(S2, 3));
  return tpl;
}
function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
function convertToColorString(color2, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString$d(color2) ? color2 : isObject$f(color2) ? color2.colorStops && (color2.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link2, target) {
  if (target === "_blank" || target === "blank") {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link2;
  } else {
    window.open(link2, target);
  }
}
var each$p = each$q;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x2 = 0;
  var y2 = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x2 + moveX;
      if (nextX > maxWidth || child.newline) {
        x2 = 0;
        nextX = moveX;
        y2 += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y2 + moveY;
      if (nextY > maxHeight || child.newline) {
        x2 += currentLineMaxSize + gap;
        y2 = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x2;
    child.y = y2;
    child.markRedraw();
    orient === "horizontal" ? x2 = nextX + gap : y2 = nextY + gap;
  });
}
var box = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width2 = parsePercent(positionInfo.width, containerWidth);
  var height2 = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width2)) {
    width2 = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height2)) {
    height2 = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width2) && isNaN(height2)) {
      if (aspect > containerWidth / containerHeight) {
        width2 = containerWidth * 0.8;
      } else {
        height2 = containerHeight * 0.8;
      }
    }
    if (isNaN(width2)) {
      width2 = aspect * height2;
    }
    if (isNaN(height2)) {
      height2 = width2 / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width2 - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height2 - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width2 / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width2 - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height2 / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height2 - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width2)) {
    width2 = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height2)) {
    height2 = containerHeight - verticalMargin - top - (bottom || 0);
  }
  var rect = new BoundingRect$1(left + margin[3], top + margin[0], width2, height2);
  rect.margin = margin;
  return rect;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject$f(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray$x(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge2(HV_NAMES[0], 0);
  var vResult = merge2(HV_NAMES[1], 1);
  copy2(HV_NAMES[0], targetOption, hResult);
  copy2(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$p(names, function(name2) {
      merged[name2] = targetOption[name2];
    });
    each$p(names, function(name2) {
      hasProp(newOption, name2) && (newParams[name2] = merged[name2] = newOption[name2]);
      hasValue(newParams, name2) && newValueCount++;
      hasValue(merged, name2) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i2 = 0; i2 < names.length; i2++) {
        var name_1 = names[i2];
        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
          newParams[name_1] = targetOption[name_1];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name2) {
    return obj.hasOwnProperty(name2);
  }
  function hasValue(obj, name2) {
    return obj[name2] != null && obj[name2] !== "auto";
  }
  function copy2(names, target, source) {
    each$p(names, function(name2) {
      target[name2] = source[name2];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each$p(LOCATION_PARAMS, function(name2) {
    source.hasOwnProperty(name2) && (target[name2] = source[name2]);
  });
  return target;
}
var inner$a = makeInner();
var ComponentModel = function(_super) {
  __extends(ComponentModel2, _super);
  function ComponentModel2(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;
    _this.uid = getUID("ec_cpt_model");
    return _this;
  }
  ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge$2(option, themeModel.get(this.mainType));
    merge$2(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  ComponentModel2.prototype.mergeOption = function(option, ecModel) {
    merge$2(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
  };
  ComponentModel2.prototype.getDefaultOption = function() {
    var ctor2 = this.constructor;
    if (!isExtendedClass(ctor2)) {
      return ctor2.defaultOption;
    }
    var fields = inner$a(this);
    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor2;
      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      var defaultOption2 = {};
      for (var i2 = optList.length - 1; i2 >= 0; i2--) {
        defaultOption2 = merge$2(defaultOption2, optList[i2], true);
      }
      fields.defaultOption = defaultOption2;
    }
    return fields.defaultOption;
  };
  ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
    var indexKey = mainType + "Index";
    var idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };
  ComponentModel2.prototype.getBoxLayoutParams = function() {
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  };
  ComponentModel2.prototype.getZLevelKey = function() {
    return "";
  };
  ComponentModel2.prototype.setZLevel = function(zlevel) {
    this.option.zlevel = zlevel;
  };
  ComponentModel2.protoInitialize = function() {
    var proto2 = ComponentModel2.prototype;
    proto2.type = "component";
    proto2.id = "";
    proto2.name = "";
    proto2.mainType = "";
    proto2.subType = "";
    proto2.componentIndex = 0;
  }();
  return ComponentModel2;
}(Model$1);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  each$q(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map$9(deps, function(type2) {
    return parseClassType(type2).main;
  });
  if (componentType !== "dataset" && indexOf$2(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var ComponentModel$1 = ComponentModel;
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault = {
  darkMode: "auto",
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode;
  }
  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key = datasetModel.uid + "_" + source.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each$q(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject$f(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  });
  each$q(coordDimensions, function(coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      var start2 = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start2, count);
      pushDim(encodeSeriesName, start2, count);
      datasetRecord.valueWayDim += count;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode[coordDimName], 0, count);
      pushDim(encodeItemName, 0, count);
    } else {
      var start2 = datasetRecord.categoryWayDim;
      pushDim(encode[coordDimName], start2, count);
      pushDim(encodeSeriesName, start2, count);
      datasetRecord.categoryWayDim += count;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i2 = 0; i2 < idxCount; i2++) {
      dimIdxArr.push(idxFrom + i2);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode;
  }
  var sourceFormat = source.sourceFormat;
  var dimensionsDefine = source.dimensionsDefine;
  var potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each$q(dimensionsDefine, function(dim, idx) {
      if ((isObject$f(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  var idxResult = function() {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = [];
    for (var i2 = 0, len2 = Math.min(5, dimCount); i2 < len2; i2++) {
      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i2);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i2 !== potentialNameDimIndex) {
        idxRes0.v = i2;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i2;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i2 !== potentialNameDimIndex) {
          idxRes1.v = i2;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i2;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode.value = [idxResult.v];
    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }
  return encode;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  var thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data5, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result;
  var maxLoop = 5;
  if (isTypedArray(data5)) {
    return BE_ORDINAL.Not;
  }
  var dimName;
  var dimType;
  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];
    if (isObject$f(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString$d(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data5;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample2 = dataArrayRows[dimIndex];
      for (var i2 = 0; i2 < (sample2 || []).length && i2 < maxLoop; i2++) {
        if ((result = detectValue(sample2[startIndex + i2])) != null) {
          return result;
        }
      }
    } else {
      for (var i2 = 0; i2 < dataArrayRows.length && i2 < maxLoop; i2++) {
        var row2 = dataArrayRows[startIndex + i2];
        if (row2 && (result = detectValue(row2[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data5;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (var i2 = 0; i2 < dataObjectRows.length && i2 < maxLoop; i2++) {
      var item = dataObjectRows[i2];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data5;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    var sample2 = dataKeyedColumns[dimName];
    if (!sample2 || isTypedArray(sample2)) {
      return BE_ORDINAL.Not;
    }
    for (var i2 = 0; i2 < sample2.length && i2 < maxLoop; i2++) {
      if ((result = detectValue(sample2[i2])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data5;
    for (var i2 = 0; i2 < dataOriginal.length && i2 < maxLoop; i2++) {
      var item = dataOriginal[i2];
      var val2 = getDataItemValue(item);
      if (!isArray$x(val2)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val2[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val3) {
    var beStr = isString$d(val3);
    if (val3 != null && isFinite(val3) && val3 !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val3 !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  var internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  return newCmptOptionList.concat(internalOptions);
}
var innerColor = makeInner();
makeInner();
var PaletteMixin = function() {
  function PaletteMixin2() {
  }
  PaletteMixin2.prototype.getColorFromPalette = function(name2, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get("color", true));
    var layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name2, scope, requestNum);
  };
  PaletteMixin2.prototype.clearColorPalette = function() {
    clearPalette(this, innerColor);
  };
  return PaletteMixin2;
}();
function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length;
  for (var i2 = 0; i2 < paletteNum; i2++) {
    if (palettes[i2].length > requestColorNum) {
      return palettes[i2];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner2, defaultPalette, layeredPalette, name2, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner2(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name2)) {
    return paletteNameMap[name2];
  }
  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  var pickedPaletteItem = palette[paletteIdx];
  if (name2) {
    paletteNameMap[name2] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner2) {
  inner2(that).paletteIdx = 0;
  inner2(that).paletteNameMap = {};
}
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var GlobalModel = function(_super) {
  __extends(GlobalModel2, _super);
  function GlobalModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale2, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model$1(theme2);
    this._locale = new Model$1(locale2);
    this._optionManager = optionManager;
  };
  GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
    var innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  };
  GlobalModel2.prototype.resetOption = function(type2, opt) {
    return this._resetOption(type2, normalizeSetOptionInput(opt));
  };
  GlobalModel2.prototype._resetOption = function(type2, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type2 || type2 === "recreate") {
      var baseOption = optionManager.mountOption(type2 === "recreate");
      if (!this.option || type2 === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type2 === "timeline" || type2 === "media") {
      this.restoreData();
    }
    if (!type2 || type2 === "recreate" || type2 === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type2 || type2 === "recreate" || type2 === "media") {
      var mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each$q(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  };
  GlobalModel2.prototype.mergeOption = function(option) {
    this._mergeOption(option, null);
  };
  GlobalModel2.prototype._mergeOption = function(newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each$q(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!ComponentModel$1.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone$8(componentOption) : merge$2(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val2, mainTypeInReplaceMerge) {
        if (ComponentModel$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    ComponentModel$1.topologicalTravel(newCmptTypes, ComponentModel$1.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel$1);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      each$q(mappingResult, function(resultItem, index) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          var isSeriesType = mainType === "series";
          var ComponentModelClass = ComponentModel$1.getClass(
            mainType,
            resultItem.keyInfo.subType,
            !isSeriesType
          );
          if (!ComponentModelClass) {
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            var extraOpt = extend$1({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend$1(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  GlobalModel2.prototype.getOption = function() {
    var option = clone$8(this.option);
    each$q(option, function(optInMainType, mainType) {
      if (ComponentModel$1.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType);
        var realLen = opts.length;
        var metNonInner = false;
        for (var i2 = realLen - 1; i2 >= 0; i2--) {
          if (opts[i2] && !isComponentIdInternal(opts[i2])) {
            metNonInner = true;
          } else {
            opts[i2] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };
  GlobalModel2.prototype.getTheme = function() {
    return this._theme;
  };
  GlobalModel2.prototype.getLocaleModel = function() {
    return this._locale;
  };
  GlobalModel2.prototype.setUpdatePayload = function(payload) {
    this._payload = payload;
  };
  GlobalModel2.prototype.getUpdatePayload = function() {
    return this._payload;
  };
  GlobalModel2.prototype.getComponent = function(mainType, idx) {
    var list = this._componentsMap.get(mainType);
    if (list) {
      var cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i2 = 0; i2 < list.length; i2++) {
          if (list[i2]) {
            return list[i2];
          }
        }
      }
    }
  };
  GlobalModel2.prototype.queryComponents = function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index = condition.index;
    var id2 = condition.id;
    var name2 = condition.name;
    var cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    var result;
    if (index != null) {
      result = [];
      each$q(normalizeToArray(index), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id2 != null) {
      result = queryByIdOrName("id", id2, cmpts);
    } else if (name2 != null) {
      result = queryByIdOrName("name", name2, cmpts);
    } else {
      result = filter$3(cmpts, function(cmpt) {
        return !!cmpt;
      });
    }
    return filterBySubType(result, condition);
  };
  GlobalModel2.prototype.findComponents = function(condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : filter$3(this._componentsMap.get(mainType), function(cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q2) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q2 && (q2[indexAttr] != null || q2[idAttr] != null || q2[nameAttr] != null) ? {
        mainType,
        index: q2[indexAttr],
        id: q2[idAttr],
        name: q2[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter$3(res, condition.filter) : res;
    }
  };
  GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (isFunction$h(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function(cmpts2, componentType) {
        for (var i3 = 0; cmpts2 && i3 < cmpts2.length; i3++) {
          var cmpt2 = cmpts2[i3];
          cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
        }
      });
    } else {
      var cmpts = isString$d(mainType) ? componentsMap.get(mainType) : isObject$f(mainType) ? this.findComponents(mainType) : null;
      for (var i2 = 0; cmpts && i2 < cmpts.length; i2++) {
        var cmpt = cmpts[i2];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  GlobalModel2.prototype.getSeriesByName = function(name2) {
    var nameStr = convertOptionIdName(name2, null);
    return filter$3(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  };
  GlobalModel2.prototype.getSeriesByType = function(subType) {
    return filter$3(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  GlobalModel2.prototype.getSeries = function() {
    return filter$3(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries;
    });
  };
  GlobalModel2.prototype.getSeriesCount = function() {
    return this._componentsCount.get("series");
  };
  GlobalModel2.prototype.eachSeries = function(cb, context) {
    assertSeriesInitialized(this);
    each$q(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  GlobalModel2.prototype.eachRawSeries = function(cb, context) {
    each$q(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
    assertSeriesInitialized(this);
    each$q(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
    return each$q(this.getSeriesByType(subType), cb, context);
  };
  GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };
  GlobalModel2.prototype.getCurrentSeriesIndices = function() {
    return (this._seriesIndices || []).slice();
  };
  GlobalModel2.prototype.filterSeries = function(cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each$q(this._seriesIndices, function(seriesRawIdx) {
      var series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };
  GlobalModel2.prototype.restoreData = function(payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function(components2, componentType) {
      if (ComponentModel$1.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    ComponentModel$1.topologicalTravel(componentTypes, ComponentModel$1.getAllClassMainTypes(), function(componentType) {
      each$q(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };
  GlobalModel2.internalField = function() {
    reCreateSeriesIndices = function(ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each$q(ecModel._componentsMap.get("series"), function(series) {
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };
    assertSeriesInitialized = function(ecModel) {
    };
    initBase = function(ecModel, baseOption) {
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap();
      var airaOption = baseOption.aria;
      if (isObject$f(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }
      mergeTheme(baseOption, ecModel._theme.option);
      merge$2(baseOption, globalDefault, false);
      ecModel._mergeOption(baseOption, null);
    };
  }();
  return GlobalModel2;
}(Model$1);
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index = payload.seriesIndex;
    var id2 = payload.seriesId;
    var name_1 = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id2 != null && seriesModel.id !== id2 || name_1 != null && seriesModel.name !== name_1;
  }
}
function mergeTheme(option, theme2) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$q(theme2, function(themeItem, name2) {
    if (name2 === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!ComponentModel$1.hasClass(name2)) {
      if (typeof themeItem === "object") {
        option[name2] = !option[name2] ? clone$8(themeItem) : merge$2(option[name2], themeItem, false);
      } else {
        if (option[name2] == null) {
          option[name2] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr2, idOrName, cmpts) {
  if (isArray$x(idOrName)) {
    var keyMap_1 = createHashMap();
    each$q(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter$3(cmpts, function(cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr2]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter$3(cmpts, function(cmpt) {
      return cmpt && idName_1 != null && cmpt[attr2] === idName_1;
    });
  }
}
function filterBySubType(components2, condition) {
  return condition.hasOwnProperty("subType") ? filter$3(components2, function(cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components2;
}
function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each$q(normalizeToArray(opts.replaceMerge), function(mainType) {
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin$1(GlobalModel, PaletteMixin);
var GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = function() {
  function ExtensionAPI2(ecInstance) {
    each$q(availableMethods, function(methodName) {
      this[methodName] = bind$3(ecInstance[methodName], ecInstance);
    }, this);
  }
  return ExtensionAPI2;
}();
var ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {};
var CoordinateSystemManager = function() {
  function CoordinateSystemManager2() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager2.prototype.create = function(ecModel, api) {
    var coordinateSystems = [];
    each$q(coordinateSystemCreators, function(creater, type2) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  };
  CoordinateSystemManager2.prototype.update = function(ecModel, api) {
    each$q(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };
  CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
    return this._coordinateSystems.slice();
  };
  CoordinateSystemManager2.register = function(type2, creator) {
    coordinateSystemCreators[type2] = creator;
  };
  CoordinateSystemManager2.get = function(type2) {
    return coordinateSystemCreators[type2];
  };
  return CoordinateSystemManager2;
}();
var CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = function() {
  function OptionManager2(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api;
  }
  OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each$q(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each$q(normalizeToArray(rawOption.dataset), function(dataset2) {
        dataset2 && dataset2.source && isTypedArray(dataset2.source) && setAsPrimitive(dataset2.source);
      });
    }
    rawOption = clone$8(rawOption);
    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };
  OptionManager2.prototype.mountOption = function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone$8(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  };
  OptionManager2.prototype.getTimelineOption = function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone$8(
          timelineOptions[timelineModel.getCurrentIndex()]
        );
      }
    }
    return option;
  };
  OptionManager2.prototype.getMediaOption = function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i2 = 0, len2 = mediaList.length; i2 < len2; i2++) {
      if (applyMediaQuery(mediaList[i2].query, ecWidth, ecHeight)) {
        indices.push(i2);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$9(indices, function(index) {
        return clone$8(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  };
  return OptionManager2;
}();
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption;
  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray$x(mediaOnRoot)) {
      each$q(mediaOnRoot, function(singleMedia) {
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    }
  }
  doPreprocess(baseOption);
  each$q(timelineOptionsOnRoot, function(option) {
    return doPreprocess(option);
  });
  each$q(mediaList, function(media) {
    return doPreprocess(media.option);
  });
  function doPreprocess(option) {
    each$q(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  var applicatable = true;
  each$q(query, function(value, attr2) {
    var matched = attr2.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager$1 = OptionManager;
var each$o = each$q;
var isObject$e = isObject$f;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i2 = 0, len2 = POSSIBLE_STYLES.length; i2 < len2; i2++) {
    var styleName = POSSIBLE_STYLES[i2];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge$2(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge$2(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject$e(opt) && opt[propName];
  var textStyle = isObject$e(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    for (var i2 = 0, len2 = TEXT_STYLE_OPTIONS.length; i2 < len2; i2++) {
      var textPropName = TEXT_STYLE_OPTIONS[i2];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject$e(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  var markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  var markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  var data5 = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data5 = data5 || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (var i2 = 0; i2 < edgeData.length; i2++) {
        compatEC3CommonStyles(edgeData[i2]);
      }
    }
    each$q(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data5 && !isTypedArray(data5)) {
    for (var i2 = 0; i2 < data5.length; i2++) {
      compatEC3CommonStyles(data5[i2]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;
    for (var i2 = 0; i2 < mpData.length; i2++) {
      compatEC3CommonStyles(mpData[i2]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    var mlData = markLine.data;
    for (var i2 = 0; i2 < mlData.length; i2++) {
      if (isArray$x(mlData[i2])) {
        compatEC3CommonStyles(mlData[i2][0]);
        compatEC3CommonStyles(mlData[i2][1]);
      } else {
        compatEC3CommonStyles(mlData[i2]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each$q(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o2) {
  return isArray$x(o2) ? o2 : o2 ? [o2] : [];
}
function toObj(o2) {
  return (isArray$x(o2) ? o2[0] : o2) || {};
}
function globalCompatStyle(option, isTheme) {
  each$o(toArr(option.series), function(seriesOpt) {
    isObject$e(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each$o(axes, function(axisName) {
    each$o(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each$o(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each$o(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each$o(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
    }
  });
  each$o(toArr(option.geo), function(geoOpt) {
    if (isObject$e(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$o(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$o(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    var data5 = timelineOpt.data;
    isArray$x(data5) && each$q(data5, function(item) {
      if (isObject$f(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each$o(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each$o(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}
function get$7(opt, path) {
  var pathArr = path.split(",");
  var obj = opt;
  for (var i2 = 0; i2 < pathArr.length; i2++) {
    obj = obj && obj[pathArr[i2]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set$2(opt, path, val2, overwrite) {
  var pathArr = path.split(",");
  var obj = opt;
  var key;
  var i2 = 0;
  for (; i2 < pathArr.length - 1; i2++) {
    key = pathArr[i2];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i2]] == null) {
    obj[pathArr[i2]] = val2;
  }
}
function compatLayoutProperties(option) {
  option && each$q(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (var i2 = 0; i2 < BAR_ITEM_STYLE_MAP.length; i2++) {
      var oldName = BAR_ITEM_STYLE_MAP[i2][1];
      var newName = BAR_ITEM_STYLE_MAP[i2][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data5, cb) {
  if (data5) {
    for (var i2 = 0; i2 < data5.length; i2++) {
      cb(data5[i2]);
      data5[i2] && traverseTree(data5[i2].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each$q(option.series, function(seriesOpt) {
    if (!isObject$f(seriesOpt)) {
      return;
    }
    var seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
      compatPieLabel(seriesOpt.label);
      var data5 = seriesOpt.data;
      if (data5 && !isTypedArray(data5)) {
        for (var i2 = 0; i2 < data5.length; i2++) {
          compatPieLabel(data5[i2]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      var pointerColor = get$7(seriesOpt, "pointer.color");
      pointerColor != null && set$2(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data5 = seriesOpt.data;
      if (data5 && !isTypedArray(data5)) {
        for (var i2 = 0; i2 < data5.length; i2++) {
          if (typeof data5[i2] === "object") {
            compatBarItemStyle(data5[i2]);
            compatBarItemStyle(data5[i2] && data5[i2].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      var highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each$q(COMPATITABLE_COMPONENTS, function(componentName) {
    var options = option[componentName];
    if (options) {
      if (!isArray$x(options)) {
        options = [options];
      }
      each$q(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}
function dataStack$1(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    var stack = seriesModel.get("stack");
    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data5 = seriesModel.getData();
      var stackInfo = {
        stackResultDimension: data5.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data5.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data5.getCalculationInfo("stackedDimension"),
        stackedByDimension: data5.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data5.getCalculationInfo("isStackedByIndex"),
        data: data5,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data5.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each$q(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    var stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
    targetData.modify(dims, function(v0, v1, dataIndex) {
      var sum3 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum3)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j2 = idxInStack - 1; j2 >= 0; j2--) {
        var stackInfo = stackInfoList[j2];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val2 = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (stackStrategy === "all" || stackStrategy === "positive" && val2 > 0 || stackStrategy === "negative" && val2 < 0 || stackStrategy === "samesign" && sum3 >= 0 && val2 > 0 || stackStrategy === "samesign" && sum3 <= 0 && val2 < 0) {
            sum3 = addSafe(sum3, val2);
            stackedOver = val2;
            break;
          }
        }
      }
      resultVal[0] = sum3;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}
var SourceImpl = function() {
  function SourceImpl2(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (var i2 = 0; i2 < dimensionsDefine.length; i2++) {
        var dim = dimensionsDefine[i2];
        if (dim.type == null) {
          if (guessOrdinal(this, i2) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
  return SourceImpl2;
}();
function isSourceInstance(val2) {
  return val2 instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone$8(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data5) {
  return new SourceImpl({
    data: data5,
    sourceFormat: isTypedArray(data5) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone$8(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data5) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data5)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray$x(data5)) {
    if (data5.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (var i2 = 0, len2 = data5.length; i2 < len2; i2++) {
      var item = data5[i2];
      if (item == null) {
        continue;
      } else if (isArray$x(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject$f(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject$f(data5)) {
    for (var key in data5) {
      if (hasOwn$1(data5, key) && isArrayLike$2(data5[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data5, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex;
  if (!data5) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data5;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val2) {
        if (val2 != null && val2 !== "-") {
          if (isString$d(val2)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber$c(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val2, index) {
        dimensionsDefine[index] = val2 != null ? val2 + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data5);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each$q(data5, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data5[0]);
    dimensionsDetectedCount = isArray$x(value0) && value0.length || 1;
  } else
    ;
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data5) {
  var firstIndex = 0;
  var obj;
  while (firstIndex < data5.length && !(obj = data5[firstIndex++])) {
  }
  if (obj) {
    var dimensions_1 = [];
    each$q(obj, function(value, key) {
      dimensions_1.push(key);
    });
    return dimensions_1;
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  var nameMap = createHashMap();
  return map$9(dimensionsDefine, function(rawItem, index) {
    rawItem = isObject$f(rawItem) ? rawItem : {
      name: rawItem
    };
    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    var exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data5, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i2 = 0; i2 < data5.length && i2 < maxLoop; i2++) {
      cb(data5[i2] ? data5[i2][0] : null, i2);
    }
  } else {
    var value0 = data5[0] || [];
    for (var i2 = 0; i2 < value0.length && i2 < maxLoop; i2++) {
      cb(value0[i2], i2);
    }
  }
}
function shouldRetrieveDataByName(source) {
  var sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a$6, _b, _c$2;
var providerMethods;
var mountMethods;
var DefaultDataProvider = function() {
  function DefaultDataProvider2(sourceParam, dimSize) {
    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    var data5 = this._data = source.data;
    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data5;
    }
    mountMethods(this, data5, source);
  }
  DefaultDataProvider2.prototype.getSource = function() {
    return this._source;
  };
  DefaultDataProvider2.prototype.count = function() {
    return 0;
  };
  DefaultDataProvider2.prototype.getItem = function(idx, out2) {
    return;
  };
  DefaultDataProvider2.prototype.appendData = function(newData) {
  };
  DefaultDataProvider2.prototype.clean = function() {
  };
  DefaultDataProvider2.protoInitialize = function() {
    var proto2 = DefaultDataProvider2.prototype;
    proto2.pure = false;
    proto2.persistent = true;
  }();
  DefaultDataProvider2.internalField = function() {
    var _a2;
    mountMethods = function(provider, data5, source) {
      var sourceFormat = source.sourceFormat;
      var seriesLayoutBy = source.seriesLayoutBy;
      var startIndex = source.startIndex;
      var dimsDef = source.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      extend$1(provider, methods);
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind$3(rawItemGetter, null, data5, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind$3(rawCounter, null, data5, startIndex, dimsDef);
      }
    };
    var getItemForTypedArray = function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var data5 = this._data;
      var dimSize = this._dimSize;
      var offset2 = dimSize * idx;
      for (var i2 = 0; i2 < dimSize; i2++) {
        out2[i2] = data5[offset2 + i2];
      }
      return out2;
    };
    var fillStorageForTypedArray = function(start2, end2, storage, extent3) {
      var data5 = this._data;
      var dimSize = this._dimSize;
      for (var dim = 0; dim < dimSize; dim++) {
        var dimExtent = extent3[dim];
        var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count = end2 - start2;
        var arr = storage[dim];
        for (var i2 = 0; i2 < count; i2++) {
          var val2 = data5[i2 * dimSize + dim];
          arr[start2 + i2] = val2;
          val2 < min3 && (min3 = val2);
          val2 > max3 && (max3 = val2);
        }
        dimExtent[0] = min3;
        dimExtent[1] = max3;
      }
    };
    var countForTypedArray = function() {
      return this._data ? this._data.length / this._dimSize : 0;
    };
    providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function(newData) {
        var data5 = this._data;
        each$q(newData, function(newCol, key) {
          var oldCol = data5[key] || (data5[key] = []);
          for (var i2 = 0; i2 < (newCol || []).length; i2++) {
            oldCol.push(newCol[i2]);
          }
        });
      }
    }, _a2[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }, _a2);
    function appendDataSimply(newData) {
      for (var i2 = 0; i2 < newData.length; i2++) {
        this._data.push(newData[i2]);
      }
    }
  }();
  return DefaultDataProvider2;
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = (_a$6 = {}, _a$6[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a$6[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
  idx += startIndex;
  var item = out2 || [];
  var data5 = rawData;
  for (var i2 = 0; i2 < data5.length; i2++) {
    var row2 = data5[i2];
    item[i2] = row2 ? row2[idx] : null;
  }
  return item;
}, _a$6[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a$6[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
  var item = out2 || [];
  for (var i2 = 0; i2 < dimsDef.length; i2++) {
    var dimName = dimsDef[i2].name;
    var col = rawData[dimName];
    item[i2] = col ? col[idx] : null;
  }
  return item;
}, _a$6[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a$6);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
  var row2 = rawData[0];
  return row2 ? Math.max(0, row2.length - startIndex) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;
  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property2) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_c$2 = {}, _c$2[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c$2[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property2) {
  return dataItem[property2];
}, _c$2[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c$2[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property2) {
  var value = getDataItemValue(dataItem);
  return !(value instanceof Array) ? value : value[dimIndex];
}, _c$2[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c$2);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data5, dataIndex, dim) {
  if (!data5) {
    return;
  }
  var dataItem = data5.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var store = data5.getStore();
  var sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    var dimIndex = data5.getDimensionIndex(dim);
    var property2 = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property2);
  } else {
    var result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
  function DataFormatMixin2() {
  }
  DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
    var data5 = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data5.getRawIndex(dataIndex);
    var name2 = data5.getName(dataIndex);
    var itemOpt = data5.getRawDataItem(dataIndex);
    var style = data5.getItemVisual(dataIndex, "style");
    var color2 = style && style[data5.getItemVisual(dataIndex, "drawType") || "fill"];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries2 = mainType === "series";
    var userOutput = data5.userOutput && data5.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name: name2,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color: color2,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  };
  DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    var data5 = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray$x(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      var itemModel = data5.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction$h(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString$d(formatter)) {
      var str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        var len2 = dimStr.length;
        var dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
        }
        var val2 = retrieveRawValue(data5, dataIndex, dimLoose);
        if (extendParams && isArray$x(extendParams.interpolatedValue)) {
          var dimIndex = data5.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val2 = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val2 != null ? val2 + "" : "";
      });
    }
  };
  DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return;
  };
  return DataFormatMixin2;
}();
function normalizeTooltipFormatResult(result) {
  var markupText;
  var markupFragment;
  if (isObject$f(result)) {
    if (result.type) {
      markupFragment = result;
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}
function createTask(define) {
  return new Task(define);
}
var Task = function() {
  function Task2(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  Task2.prototype.perform = function(performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    var planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val2) {
      !(val2 >= 1) && (val2 = 1);
      return val2;
    }
    var forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;
    if (upTask) {
      this._dueEnd = upTask._outputDueEnd;
    } else {
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      var start2 = this._dueIndex;
      var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        var progress = this._progress;
        if (isArray$x(progress)) {
          for (var i2 = 0; i2 < progress.length; i2++) {
            this._doProgress(progress[i2], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  };
  Task2.prototype.dirty = function() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };
  Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  };
  Task2.prototype._doReset = function(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray$x(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };
  Task2.prototype.unfinished = function() {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  Task2.prototype.pipe = function(downTask) {
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };
  Task2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };
  Task2.prototype.getUpstream = function() {
    return this._upstream;
  };
  Task2.prototype.getDownstream = function() {
    return this._downstream;
  };
  Task2.prototype.setOutputEnd = function(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  };
  return Task2;
}();
var iterator = function() {
  var end2;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it2 = {
    reset: function(s2, e3, sStep, sCount) {
      current = s2;
      end2 = e3;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it2.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it2;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();
function parseDataValue(value, opt) {
  var dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber$c(value) && value != null && value !== "-") {
    value = +parseDate$1(value);
  }
  return value == null || value === "" ? NaN : +value;
}
createHashMap({
  "number": function(val2) {
    return parseFloat(val2);
  },
  "time": function(val2) {
    return +parseDate$1(val2);
  },
  "trim": function(val2) {
    return isString$d(val2) ? trim$3(val2) : val2;
  }
});
var SortOrderComparator = function() {
  function SortOrderComparator2(order, incomparable) {
    var isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  SortOrderComparator2.prototype.evaluate = function(lval, rval) {
    var lvalFloat = isNumber$c(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber$c(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString$d(lval);
      var rvalIsStr = isString$d(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };
  return SortOrderComparator2;
}();
var ExternalSource = function() {
  function ExternalSource2() {
  }
  ExternalSource2.prototype.getRawData = function() {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.cloneRawData = function() {
    return;
  };
  ExternalSource2.prototype.getDimensionInfo = function(dim) {
    return;
  };
  ExternalSource2.prototype.cloneAllDimensionInfo = function() {
    return;
  };
  ExternalSource2.prototype.count = function() {
    return;
  };
  ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
    return;
  };
  ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
    return;
  };
  ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };
  return ExternalSource2;
}();
function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource();
  var data5 = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    throwError(errMsg);
  }
  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each$q(dimsDef, function(dimDef, idx) {
      var name2 = dimDef.name;
      var dimDefExt = {
        index: idx,
        name: name2,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name2 != null) {
        var errMsg_1 = "";
        if (hasOwn$1(dimsByName, name2)) {
          throwError(errMsg_1);
        }
        dimsByName[name2] = dimDefExt;
      }
    });
  } else {
    for (var i2 = 0; i2 < internalSource.dimensionsDetectedCount || 0; i2++) {
      dimensions.push({
        index: i2
      });
    }
  }
  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data5, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind$3(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind$3(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind$3(rawCounter, null, data5, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data5, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    var dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind$3(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind$3(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data5 = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];
    for (var i2 = 0, len2 = data5.length; i2 < len2; i2++) {
      result.push(data5[i2].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];
    for (var i2 = 0, len2 = data5.length; i2 < len2; i2++) {
      result.push(extend$1({}, data5[i2]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber$c(dim) || !isNaN(dim) && !hasOwn$1(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn$1(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone$8(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone$8(externalTransform);
  var type2 = externalTransform.type;
  var errMsg = "";
  if (!type2) {
    throwError(errMsg);
  }
  var typeParsed = type2.split(":");
  if (typeParsed.length !== 2) {
    throwError(errMsg);
  }
  var isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type2 = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type2, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = "";
  if (!pipeLen) {
    throwError(errMsg);
  }
  for (var i2 = 0, len2 = pipeLen; i2 < len2; i2++) {
    var transOption = pipedTransOption[i2];
    sourceList = applySingleDataTransform(transOption, sourceList);
    if (i2 !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  var errMsg = "";
  if (!upSourceList.length) {
    throwError(errMsg);
  }
  if (!isObject$f(transOption)) {
    throwError(errMsg);
  }
  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    throwError(errMsg);
  }
  var extUpSourceList = map$9(upSourceList, function(upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone$8(transOption.config)
  }));
  return map$9(resultList, function(result, resultIndex) {
    var errMsg2 = "";
    if (!isObject$f(result)) {
      throwError(errMsg2);
    }
    if (!result.data) {
      throwError(errMsg2);
    }
    var sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      throwError(errMsg2);
    }
    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      var startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  "float": CtorFloat64Array,
  "int": CtorInt32Array$1,
  "ordinal": Array,
  "number": Array,
  "time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append2) {
  var DataCtor = dataCtors[dimType || "float"];
  if (append2) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      var newStore = new DataCtor(end2);
      for (var j2 = 0; j2 < oldLen; j2++) {
        newStore[j2] = oldStore[j2];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore = function() {
  function DataStore2() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    shouldRetrieveDataByName(source);
    this._dimensions = map$9(inputDimensions, function(dim) {
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  };
  DataStore2.prototype.getProvider = function() {
    return this._provider;
  };
  DataStore2.prototype.getSource = function() {
    return this._provider.getSource();
  };
  DataStore2.prototype.ensureCalculationDimension = function(dimName, type2) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type2) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {
      type: type2
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type2 || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };
  DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
    var chunk2 = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset2 = dim.ordinalOffset || 0;
    var len2 = chunk2.length;
    if (offset2 === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    var dimRawExtent = rawExtents[dimIdx];
    for (var i2 = offset2; i2 < len2; i2++) {
      var val2 = chunk2[i2] = ordinalMeta.parseAndCollect(chunk2[i2]);
      if (!isNaN(val2)) {
        dimRawExtent[0] = Math.min(val2, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val2, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  };
  DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };
  DataStore2.prototype.getDimensionProperty = function(dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  DataStore2.prototype.appendData = function(data5) {
    var provider = this._provider;
    var start2 = this.count();
    provider.appendData(data5);
    var end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  };
  DataStore2.prototype.appendValues = function(values2, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start2 = this.count();
    var end2 = start2 + Math.max(values2.length, minFillLen || 0);
    for (var i2 = 0; i2 < dimLen; i2++) {
      var dim = dimensions[i2];
      prepareStore(chunks, i2, dim.type, end2, true);
    }
    var emptyDataItem = [];
    for (var idx = start2; idx < end2; idx++) {
      var sourceIdx = idx - start2;
      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val2 = defaultDimValueGetters.arrayRows.call(this, values2[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val2;
        var dimRawExtent = rawExtent[dimIdx];
        val2 < dimRawExtent[0] && (dimRawExtent[0] = val2);
        val2 > dimRawExtent[1] && (dimRawExtent[1] = val2);
      }
    }
    this._rawCount = this._count = end2;
    return {
      start: start2,
      end: end2
    };
  };
  DataStore2.prototype._initDataFromProvider = function(start2, end2, append2) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map$9(dimensions, function(dim2) {
      return dim2.property;
    });
    for (var i2 = 0; i2 < dimLen; i2++) {
      var dim = dimensions[i2];
      if (!rawExtent[i2]) {
        rawExtent[i2] = getInitialExtent();
      }
      prepareStore(chunks, i2, dim.type, end2, append2);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      var dataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx];
          var val2 = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val2;
          var dimRawExtent = rawExtent[dimIdx];
          val2 < dimRawExtent[0] && (dimRawExtent[0] = val2);
          val2 > dimRawExtent[1] && (dimRawExtent[1] = val2);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  };
  DataStore2.prototype.count = function() {
    return this._count;
  };
  DataStore2.prototype.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };
  DataStore2.prototype.getValues = function(dimensions, idx) {
    var values2 = [];
    var dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (var i2 = 0; i2 < this._dimensions.length; i2++) {
        dimArr.push(i2);
      }
    } else {
      dimArr = dimensions;
    }
    for (var i2 = 0, len2 = dimArr.length; i2 < len2; i2++) {
      values2.push(this.get(dimArr[i2], idx));
    }
    return values2;
  };
  DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  DataStore2.prototype.getSum = function(dim) {
    var dimData = this._chunks[dim];
    var sum3 = 0;
    if (dimData) {
      for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
        var value = this.get(dim, i2);
        if (!isNaN(value)) {
          sum3 += value;
        }
      }
    }
    return sum3;
  };
  DataStore2.prototype.getMedian = function(dim) {
    var dimDataArray = [];
    this.each([dim], function(val2) {
      if (!isNaN(val2)) {
        dimDataArray.push(val2);
      }
    });
    var sortedDimDataArray = dimDataArray.sort(function(a2, b2) {
      return a2 - b2;
    });
    var len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  };
  DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left = 0;
    var right = this._count - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
      var dataIndex = this.getRawIndex(i2);
      var diff = value - dimData[dataIndex];
      var dist2 = Math.abs(diff);
      if (dist2 <= maxDistance) {
        if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i2;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  DataStore2.prototype.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i2 = 0; i2 < thisCount; i2++) {
          newIndices[i2] = indices[i2];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (var i2 = 0; i2 < newIndices.length; i2++) {
        newIndices[i2] = i2;
      }
    }
    return newIndices;
  };
  DataStore2.prototype.filter = function(dims, cb) {
    if (!this._count) {
      return this;
    }
    var newStore = this.clone();
    var count = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count);
    var value = [];
    var dimSize = dims.length;
    var offset2 = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;
    for (var i2 = 0; i2 < count; i2++) {
      var keep = void 0;
      var rawIdx = newStore.getRawIndex(i2);
      if (dimSize === 0) {
        keep = cb(i2);
      } else if (dimSize === 1) {
        var val2 = chunks[dim0][rawIdx];
        keep = cb(val2, i2);
      } else {
        var k2 = 0;
        for (; k2 < dimSize; k2++) {
          value[k2] = chunks[dims[k2]][rawIdx];
        }
        value[k2] = i2;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset2++] = rawIdx;
      }
    }
    if (offset2 < count) {
      newStore._indices = newIndices;
    }
    newStore._count = offset2;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.selectRange = function(range2) {
    var newStore = this.clone();
    var len2 = newStore._count;
    if (!len2) {
      return this;
    }
    var dims = keys$d(range2);
    var dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset2 = 0;
    var dim0 = dims[0];
    var min3 = range2[dim0][0];
    var max3 = range2[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;
    if (!newStore._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];
        for (var i2 = 0; i2 < len2; i2++) {
          var val2 = dimStorage[i2];
          if (val2 >= min3 && val2 <= max3 || isNaN(val2)) {
            newIndices[offset2++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min22 = range2[dims[1]][0];
        var max22 = range2[dims[1]][1];
        for (var i2 = 0; i2 < len2; i2++) {
          var val2 = dimStorage[i2];
          var val22 = dimStorage2[i2];
          if ((val2 >= min3 && val2 <= max3 || isNaN(val2)) && (val22 >= min22 && val22 <= max22 || isNaN(val22))) {
            newIndices[offset2++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i2 = 0; i2 < originalCount; i2++) {
          var rawIndex = newStore.getRawIndex(i2);
          var val2 = storeArr[dims[0]][rawIndex];
          if (val2 >= min3 && val2 <= max3 || isNaN(val2)) {
            newIndices[offset2++] = rawIndex;
          }
        }
      } else {
        for (var i2 = 0; i2 < originalCount; i2++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i2);
          for (var k2 = 0; k2 < dimSize; k2++) {
            var dimk = dims[k2];
            var val2 = storeArr[dimk][rawIndex];
            if (val2 < range2[dimk][0] || val2 > range2[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset2++] = newStore.getRawIndex(i2);
          }
        }
      }
    }
    if (offset2 < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset2;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.map = function(dims, cb) {
    var target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  };
  DataStore2.prototype.modify = function(dims, cb) {
    this._updateDims(this, dims, cb);
  };
  DataStore2.prototype._updateDims = function(target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values2 = [];
    var rawExtent = target._rawExtent;
    for (var i2 = 0; i2 < dims.length; i2++) {
      rawExtent[dims[i2]] = getInitialExtent();
    }
    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);
      for (var k2 = 0; k2 < dimSize; k2++) {
        values2[k2] = targetChunks[dims[k2]][rawIndex];
      }
      values2[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values2);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i2 = 0; i2 < retValue.length; i2++) {
          var dim = dims[i2];
          var val2 = retValue[i2];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val2;
          }
          if (val2 < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val2;
          }
          if (val2 > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val2;
          }
        }
      }
    }
  };
  DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (var i2 = 1; i2 < len2 - 1; i2 += frameSize) {
      var nextFrameStart = Math.min(i2 + frameSize, len2 - 1);
      var nextFrameEnd = Math.min(i2 + frameSize * 2, len2);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;
      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y2 = dimStore[rawIndex];
        if (isNaN(y2)) {
          continue;
        }
        avgY += y2;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i2;
      var frameEnd = Math.min(i2 + frameSize, len2);
      var pointAX = i2 - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      var firstNaNIndex = -1;
      var countNaN = 0;
      for (var idx = frameStart; idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y2 = dimStore[rawIndex];
        if (isNaN(y2)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area = Math.abs((pointAX - avgX) * (y2 - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len2 = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    var offset2 = 0;
    for (var i2 = 0; i2 < len2; i2 += frameSize) {
      if (frameSize > len2 - i2) {
        frameSize = len2 - i2;
        frameValues.length = frameSize;
      }
      for (var k2 = 0; k2 < frameSize; k2++) {
        var dataIdx = this.getRawIndex(i2 + k2);
        frameValues[k2] = dimStore[dataIdx];
      }
      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i2 + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset2++] = sampleFrameIdx;
    }
    target._count = offset2;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.each = function(dims, cb) {
    if (!this._count) {
      return;
    }
    var dimSize = dims.length;
    var chunks = this._chunks;
    for (var i2 = 0, len2 = this.count(); i2 < len2; i2++) {
      var rawIdx = this.getRawIndex(i2);
      switch (dimSize) {
        case 0:
          cb(i2);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i2);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i2);
          break;
        default:
          var k2 = 0;
          var value = [];
          for (; k2 < dimSize; k2++) {
            value[k2] = chunks[dims[k2]][rawIdx];
          }
          value[k2] = i2;
          cb.apply(null, value);
      }
    }
  };
  DataStore2.prototype.getDataExtent = function(dim) {
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min3 = dimExtent[0];
    var max3 = dimExtent[1];
    for (var i2 = 0; i2 < currEnd; i2++) {
      var rawIdx = this.getRawIndex(i2);
      var value = dimData[rawIdx];
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  DataStore2.prototype.getRawDataItem = function(idx) {
    var rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      var val2 = [];
      var chunks = this._chunks;
      for (var i2 = 0; i2 < chunks.length; i2++) {
        val2.push(chunks[i2][rawIdx]);
      }
      return val2;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
    var target = new DataStore2();
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce$2(clonedDims, function(obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (var i2 = 0; i2 < chunks.length; i2++) {
        target._chunks[i2] = !clonedDimsMap[i2] ? chunks[i2] : cloneChunk(chunks[i2]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype._copyCommonProps = function(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone$8(this._extent);
    target._rawExtent = clone$8(this._rawExtent);
  };
  DataStore2.prototype._cloneIndices = function() {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = void 0;
      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (var i2 = 0; i2 < thisCount; i2++) {
          indices[i2] = this._indices[i2];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  };
  DataStore2.prototype._getRawIdxIdentity = function(idx) {
    return idx;
  };
  DataStore2.prototype._getRawIdx = function(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  };
  DataStore2.prototype._updateGetRawIdx = function() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };
  DataStore2.internalField = function() {
    function getDimValueSimply(dataItem, property2, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }
    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, property2, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property2], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, property2, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
      },
      typedArray: function(dataItem, property2, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();
  return DataStore2;
}();
var SourceManager = function() {
  function SourceManager2(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  SourceManager2.prototype.dirty = function() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  };
  SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  };
  SourceManager2.prototype._getVersionSign = function() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  };
  SourceManager2.prototype.prepareSource = function() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  };
  SourceManager2.prototype._createSource = function() {
    this._setLocalSource([], []);
    var sourceHost = this._sourceHost;
    var upSourceMgrList = this._getUpstreamSourceManagers();
    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;
    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data5 = void 0;
      var sourceFormat = void 0;
      var upSource = void 0;
      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data5 = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data5 = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data5) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data5, {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost;
      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        var sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  };
  SourceManager2.prototype._applyTransform = function(upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get("transform", true);
    var fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (fromTransformResult != null) {
      var errMsg = "";
      if (upMgrList.length !== 1) {
        doThrow(errMsg);
      }
    }
    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each$q(upMgrList, function(upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg2 = "";
      if (fromTransformResult != null && !upSource) {
        doThrow(errMsg2);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {
      sourceList,
      upstreamSignList
    };
  };
  SourceManager2.prototype._isDirty = function() {
    if (this._dirty) {
      return true;
    }
    var upSourceMgrList = this._getUpstreamSourceManagers();
    for (var i2 = 0; i2 < upSourceMgrList.length; i2++) {
      var upSrcMgr = upSourceMgrList[i2];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i2] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  SourceManager2.prototype.getSource = function(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source = this._sourceList[sourceIndex];
    if (!source) {
      var upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  };
  SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };
  SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    var cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  };
  SourceManager2.prototype._getUpstreamSourceManagers = function() {
    var sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map$9(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
        return datasetModel2.getSourceManager();
      });
    }
  };
  SourceManager2.prototype._getSourceMetaRawOption = function() {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      var model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {
      seriesLayoutBy,
      sourceHeader,
      dimensions
    };
  };
  return SourceManager2;
}();
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || "#6e7079";
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || "400";
  var valueFontColor = textStyle.color || "#464646";
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
      valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type2, option) {
  option.type = type2;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each$q(frag.blocks, function(subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }
  return 0;
}
function buildSection(ctx, fragment2, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment2.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment2));
  var subMarkupTextList = [];
  var subBlocks = fragment2.blocks || [];
  assert(!subBlocks || isArray$x(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;
  if (fragment2.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn$1(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function(a2, b2) {
        return comparator_1.evaluate(a2.sortParam, b2.sortParam);
      });
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each$q(subBlocks, function(subBlock, idx) {
    var valueFormatter = fragment2.valueFormatter;
    var subMarkupText2 = getBuilder(subBlock)(
      valueFormatter ? extend$1(extend$1({}, ctx), {
        valueFormatter
      }) : ctx,
      subBlock,
      idx > 0 ? gaps.html : 0,
      toolTipTextStyle
    );
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  var displayableHeader = makeValueReadable(fragment2.header, "ordinal", ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML('<div style="' + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment2, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment2.noName;
  var noValue = fragment2.noValue;
  var noMarker = !fragment2.markerType;
  var name2 = fragment2.name;
  var useUTC = ctx.useUTC;
  var valueFormatter = fragment2.valueFormatter || ctx.valueFormatter || function(value) {
    value = isArray$x(value) ? value : [value];
    return map$9(value, function(val2, idx) {
      return makeValueReadable(val2, isArray$x(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };
  if (noName && noValue) {
    return;
  }
  var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment2.markerType, fragment2.markerColor || "#333", renderMode);
  var readableName = noName ? "" : makeValueReadable(name2, "ordinal", useUTC);
  var valueTypeOption = fragment2.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment2.value);
  var valueAlignRight = !noMarker || !noName;
  var valueCloseToMarker = !noMarker && noName;
  var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment2, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment2) {
    return;
  }
  var builder = getBuilder(fragment2);
  var ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment2.valueFormatter
  };
  return builder(ctx, fragment2, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  return '<div style="' + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name2, leftHasMarker, style) {
  var marginCss = leftHasMarker ? "margin-left:2px" : "";
  return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name2) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  var paddingStr = valueCloseToMarker ? "10px" : "20px";
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
  valueList = isArray$x(valueList) ? valueList : [valueList];
  return '<span style="' + alignCSS + ";" + style + '">' + map$9(valueList, function(value) {
    return encodeHTML(value);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name2, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name2, style);
}
function wrapInlineValueRichText(ctx, values2, alignRight, valueCloseToMarker, style) {
  var styles = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({
    padding: [0, 0, 0, paddingLeft],
    align: "right"
  });
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray$x(values2) ? values2.join("  ") : values2, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, "style");
  var color2 = style[series.visualDrawType];
  return convertToColorString(color2);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = function() {
  function TooltipMarkupStyleCreator2() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  };
  TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
    var markerId = renderMode === "richText" ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString$d(marker)) {
      return marker;
    } else {
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text2, styles) {
    var finalStl = {};
    if (isArray$x(styles)) {
      each$q(styles, function(stl) {
        return extend$1(finalStl, stl);
      });
    } else {
      extend$1(finalStl, styles);
    }
    var styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text2 + "}";
  };
  return TooltipMarkupStyleCreator2;
}();
function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data5 = series.getData();
  var tooltipDims = data5.mapDimensionsAll("defaultedTooltip");
  var tooltipDimLen = tooltipDims.length;
  var value = series.getRawValue(dataIndex);
  var isValueArr = isArray$x(value);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data5.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data5, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || "";
  var itemName = data5.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor,
      name: inlineName,
      noName: !trim$3(inlineName),
      value: inlineValue,
      valueType: inlineValueType
    })].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  var data5 = series.getData();
  var isValueMultipleLine = reduce$2(value, function(isValueMultipleLine2, val2, idx) {
    var dimItem = data5.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each$q(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data5, dataIndex, dim), dim);
  }) : each$q(value, setEachItem);
  function setEachItem(val2, dim) {
    var dimInfo = data5.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val2,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val2);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {
    inlineValues,
    inlineValueTypes,
    blocks
  };
}
var inner$9 = makeInner();
function getSelectionKey(data5, dataIndex) {
  return data5.getName(dataIndex) || data5.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
  __extends(SeriesModel2, _super);
  function SeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectedDataIndicesMap = {};
    return _this;
  }
  SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner$9(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data5 = this.getInitialData(option, ecModel);
    wrapData(data5, this);
    this.dataTask.context.data = data5;
    inner$9(this).dataBeforeProcessed = data5;
    autoSeriesName(this);
    this._initSelectedMapFromData(data5);
  };
  SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (ComponentModel$1.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge$2(option, ecModel.getTheme().get(this.subType));
    merge$2(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
    newSeriesOption = merge$2(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    var sourceManager = inner$9(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data5 = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data5, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data5;
    inner$9(this).dataBeforeProcessed = data5;
    autoSeriesName(this);
    this._initSelectedMapFromData(data5);
  };
  SeriesModel2.prototype.fillDataTextStyle = function(data5) {
    if (data5 && !isTypedArray(data5)) {
      var props = ["show"];
      for (var i2 = 0; i2 < data5.length; i2++) {
        if (data5[i2] && data5[i2].label) {
          defaultEmphasis(data5[i2], "label", props);
        }
      }
    }
  };
  SeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return;
  };
  SeriesModel2.prototype.appendData = function(params) {
    var data5 = this.getRawData();
    data5.appendData(params.data);
  };
  SeriesModel2.prototype.getData = function(dataType) {
    var task = getCurrentTask(this);
    if (task) {
      var data5 = task.context.data;
      return dataType == null ? data5 : data5.getLinkedData(dataType);
    } else {
      return inner$9(this).data;
    }
  };
  SeriesModel2.prototype.getAllData = function() {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };
  SeriesModel2.prototype.setData = function(data5) {
    var task = getCurrentTask(this);
    if (task) {
      var context = task.context;
      context.outputData = data5;
      if (task !== this.dataTask) {
        context.data = data5;
      }
    }
    inner$9(this).data = data5;
  };
  SeriesModel2.prototype.getEncode = function() {
    var encode = this.get("encode", true);
    if (encode) {
      return createHashMap(encode);
    }
  };
  SeriesModel2.prototype.getSourceManager = function() {
    return inner$9(this).sourceManager;
  };
  SeriesModel2.prototype.getSource = function() {
    return this.getSourceManager().getSource();
  };
  SeriesModel2.prototype.getRawData = function() {
    return inner$9(this).dataBeforeProcessed;
  };
  SeriesModel2.prototype.getColorBy = function() {
    var colorBy = this.get("colorBy");
    return colorBy || "series";
  };
  SeriesModel2.prototype.isColorBySeries = function() {
    return this.getColorBy() === "series";
  };
  SeriesModel2.prototype.getBaseAxis = function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  };
  SeriesModel2.prototype.isAnimationEnabled = function() {
    var ecModel = this.ecModel;
    if (env$1.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  };
  SeriesModel2.prototype.restoreData = function() {
    this.dataTask.dirty();
  };
  SeriesModel2.prototype.getColorFromPalette = function(name2, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color2 = PaletteMixin.prototype.getColorFromPalette.call(this, name2, scope, requestColorNum);
    if (!color2) {
      color2 = ecModel.getColorFromPalette(name2, scope, requestColorNum);
    }
    return color2;
  };
  SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  SeriesModel2.prototype.getProgressive = function() {
    return this.get("progressive");
  };
  SeriesModel2.prototype.getProgressiveThreshold = function() {
    return this.get("progressiveThreshold");
  };
  SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };
  SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    var selectedMode = this.option.selectedMode;
    var data5 = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (var i2 = 0; i2 < innerDataIndices.length; i2++) {
      var dataIndex = innerDataIndices[i2];
      var nameOrId = getSelectionKey(data5, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };
  SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
    var tmpArr2 = [];
    for (var i2 = 0; i2 < innerDataIndices.length; i2++) {
      tmpArr2[0] = innerDataIndices[i2];
      this.isSelected(innerDataIndices[i2], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  };
  SeriesModel2.prototype.getSelectedDataIndices = function() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys$d(selectedDataIndicesMap);
    var dataIndices = [];
    for (var i2 = 0; i2 < nameOrIds.length; i2++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i2]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  };
  SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    var data5 = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data5, dataIndex)]) && !data5.getItemModel(dataIndex).get(["select", "disabled"]);
  };
  SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    var universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  };
  SeriesModel2.prototype._innerSelect = function(data5, innerDataIndices) {
    var _a2, _b2;
    var option = this.option;
    var selectedMode = option.selectedMode;
    var len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject$f(option.selectedMap)) {
        option.selectedMap = {};
      }
      var selectedMap = option.selectedMap;
      for (var i2 = 0; i2 < len2; i2++) {
        var dataIndex = innerDataIndices[i2];
        var nameOrId = getSelectionKey(data5, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data5.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len2 - 1];
      var nameOrId = getSelectionKey(data5, lastDataIndex);
      option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
      this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data5.getRawIndex(lastDataIndex), _b2);
    }
  };
  SeriesModel2.prototype._initSelectedMapFromData = function(data5) {
    if (this.option.selectedMap) {
      return;
    }
    var dataIndices = [];
    if (data5.hasItemOption) {
      data5.each(function(idx) {
        var rawItem = data5.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data5, dataIndices);
    }
  };
  SeriesModel2.registerClass = function(clz) {
    return ComponentModel$1.registerClass(clz);
  };
  SeriesModel2.protoInitialize = function() {
    var proto2 = SeriesModel2.prototype;
    proto2.type = "series.__base__";
    proto2.seriesIndex = 0;
    proto2.ignoreStyleOnData = false;
    proto2.hasSymbolVisual = false;
    proto2.defaultSymbol = "circle";
    proto2.visualStyleAccessPath = "itemStyle";
    proto2.visualDrawType = "fill";
  }();
  return SeriesModel2;
}(ComponentModel$1);
mixin$1(SeriesModel, DataFormatMixin);
mixin$1(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(seriesModel) {
  var name2 = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name2;
  }
}
function getSeriesAutoName(seriesModel) {
  var data5 = seriesModel.getRawData();
  var dataDims = data5.mapDimensionsAll("seriesName");
  var nameArr = [];
  each$q(dataDims, function(dataDim) {
    var dimInfo = data5.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data5, seriesModel) {
  each$q(concatArray(data5.CHANGABLE_METHODS, data5.DOWNSAMPLE_METHODS), function(methodName) {
    data5.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task = pipeline.currentTask;
    if (task) {
      var agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var SeriesModel$1 = SeriesModel;
var ComponentView = function() {
  function ComponentView2() {
    this.group = new Group$3();
    this.uid = getUID("viewComponent");
  }
  ComponentView2.prototype.init = function(ecModel, api) {
  };
  ComponentView2.prototype.render = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.dispose = function(ecModel, api) {
  };
  ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.toggleBlurSeries = function(seriesModels, isBlur, ecModel) {
  };
  ComponentView2.prototype.eachRendered = function(cb) {
    var group = this.group;
    if (group) {
      group.traverse(cb);
    }
  };
  return ComponentView2;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var inner2 = makeInner();
  return function(seriesModel) {
    var fields = inner2(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender;
    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}
var inner$8 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
  function ChartView2() {
    this.group = new Group$3();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }
  ChartView2.prototype.init = function(ecModel, api) {
  };
  ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
  };
  ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data5 = seriesModel.getData(payload && payload.dataType);
    if (!data5) {
      return;
    }
    toggleHighlight(data5, payload, "emphasis");
  };
  ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data5 = seriesModel.getData(payload && payload.dataType);
    if (!data5) {
      return;
    }
    toggleHighlight(data5, payload, "normal");
  };
  ChartView2.prototype.remove = function(ecModel, api) {
    this.group.removeAll();
  };
  ChartView2.prototype.dispose = function(ecModel, api) {
  };
  ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this.group, cb);
  };
  ChartView2.markUpdateMethod = function(payload, methodName) {
    inner$8(payload).updateMethod = methodName;
  };
  ChartView2.protoInitialize = function() {
    var proto2 = ChartView2.prototype;
    proto2.type = "chart";
  }();
  return ChartView2;
}();
function elSetState(el2, state, highlightDigit) {
  if (el2 && isHighDownDispatcher(el2)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el2, highlightDigit);
  }
}
function toggleHighlight(data5, payload, state) {
  var dataIndex = queryDataIndex(data5, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each$q(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data5.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data5.eachItemGraphicEl(function(el2) {
      elSetState(el2, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner$8(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle$4(fn2, delay2, debounce2) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay2 = delay2 || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn2.apply(scope, args || []);
  }
  var cb = function() {
    var cbArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      cbArgs[_i2] = arguments[_i2];
    }
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay2;
    var thisDebounce = debounceNextCall || debounce2;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn2 = obj[fnAttr];
  if (!fn2) {
    return;
  }
  var originFn = fn2[ORIGIN_METHOD] || fn2;
  var lastThrottleType = fn2[THROTTLE_TYPE];
  var lastRate = fn2[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn2 = obj[fnAttr] = throttle$4(originFn, rate, throttleType === "debounce");
    fn2[ORIGIN_METHOD] = originFn;
    fn2[THROTTLE_TYPE] = throttleType;
    fn2[RATE] = rate;
  }
  return fn2;
}
function clear$3(obj, fnAttr) {
  var fn2 = obj[fnAttr];
  if (fn2 && fn2[ORIGIN_METHOD]) {
    fn2.clear && fn2.clear();
    obj[fnAttr] = fn2[ORIGIN_METHOD];
  }
}
var inner$7 = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data5 = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var styleModel = seriesModel.getModel(stylePath);
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle2(styleModel);
    var decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data5.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color2 = globalStyle[colorKey];
    var colorCallback = isFunction$h(color2) ? color2 : null;
    var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      var colorPalette2 = seriesModel.getColorFromPalette(
        seriesModel.name,
        null,
        ecModel.getSeriesCount()
      );
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette2;
        data5.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction$h(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction$h(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
    }
    data5.setVisual("style", globalStyle);
    data5.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data5.setVisual("colorFromPalette", false);
      return {
        dataEach: function(data6, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend$1({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data6.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model$1();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data5 = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var colorKey = data5.getVisual("drawType");
    return {
      dataEach: data5.hasItemOption ? function(data6, idx) {
        var rawItem = data6.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle2(sharedModel);
          var existsStyle = data6.ensureUniqueItemVisual(idx, "style");
          extend$1(existsStyle, style);
          if (sharedModel.option.decal) {
            data6.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data6.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function(ecModel) {
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      var key = seriesModel.type + "-" + colorBy;
      var colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner$7(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data5 = seriesModel.getData();
      var colorScope = inner$7(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data5.each(function(idx) {
        var rawIdx = data5.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data5.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          var itemStyle = data5.ensureUniqueItemVisual(idx, "style");
          var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};
var PI$1 = Math.PI;
function defaultLoading(api, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group$3();
  var mask = new Rect$2({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  var textContent = new ZRText$1({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect$2({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;
  if (opts.showSpinner) {
    arc = new Arc$1({
      shape: {
        startAngle: -PI$1 / 2,
        endAngle: -PI$1 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1e3, {
      endAngle: PI$1 * 3 / 2
    }).start("circularInOut");
    arc.animateShape(true).when(1e3, {
      startAngle: PI$1 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc);
  }
  group.resize = function() {
    var textWidth = textContent.getBoundingRect().width;
    var r2 = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r2 * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r2);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r2,
      y: cy - r2,
      width: r2 * 2,
      height: r2 * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}
var Scheduler = function() {
  function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  Scheduler2.prototype.restoreData = function(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  };
  Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    var pipeline = this._pipelineMap.get(task.__pipeline.id);
    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step,
      modBy,
      modDataCount
    };
  };
  Scheduler2.prototype.getPipeline = function(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);
    var data5 = seriesModel.getData();
    var dataLen = data5.count();
    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  };
  Scheduler2.prototype.restorePipelines = function(ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };
  Scheduler2.prototype.prepareStageTasks = function() {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each$q(this._allHandlers, function(handler3) {
      var record = stageTaskMap.get(handler3.uid) || stageTaskMap.set(handler3.uid, {});
      var errMsg = "";
      assert(!(handler3.reset && handler3.overallReset), errMsg);
      handler3.reset && this._createSeriesStageTask(handler3, record, ecModel, api);
      handler3.overallReset && this._createOverallStageTask(handler3, record, ecModel, api);
    }, this);
  };
  Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  };
  Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };
  Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };
  Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each$q(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs_1);
        });
        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          var performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.performSeriesTasks = function(ecModel) {
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.plan = function() {
    this._pipelineMap.each(function(pipeline) {
      var task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  };
  Scheduler2.prototype.updatePayload = function(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  };
  Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create2);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create2);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create2);
    }
    function create2(seriesModel) {
      var pipelineId = seriesModel.uid;
      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  };
  Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel,
      api,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap;
    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false;
    var errMsg = "";
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } else {
      overallProgress = false;
      each$q(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };
  Scheduler2.prototype._pipe = function(seriesModel, task) {
    var pipelineId = seriesModel.uid;
    var pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };
  Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
    if (isFunction$h(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler2;
}();
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$9(resetDefines, function(v2, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data5 = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i2 = params.start; i2 < params.end; i2++) {
        resetDefine.dataEach(data5, i2);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data5);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e3) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type2) {
  seriesType = type2;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name_1 in Clz.prototype) {
    target[name_1] = noop$3;
  }
}
var Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var darkTheme = theme;
var ECEventProcessor = function() {
  function ECEventProcessor2() {
  }
  ECEventProcessor2.prototype.normalizeQuery = function(query) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {};
    if (isString$d(query)) {
      var condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      var suffixes_1 = ["Index", "Name", "Id"];
      var dataKeys_1 = {
        name: 1,
        dataIndex: 1,
        dataType: 1
      };
      each$q(query, function(val2, key) {
        var reserved = false;
        for (var i2 = 0; i2 < suffixes_1.length; i2++) {
          var propSuffix = suffixes_1[i2];
          var suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            var mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val2;
              reserved = true;
            }
          }
        }
        if (dataKeys_1.hasOwnProperty(key)) {
          dataQuery[key] = val2;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val2;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  };
  ECEventProcessor2.prototype.filter = function(eventType, query) {
    var eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    var cptQuery = query.cptQuery;
    var dataQuery = query.dataQuery;
    return check2(cptQuery, model, "mainType") && check2(cptQuery, model, "subType") && check2(cptQuery, model, "index", "componentIndex") && check2(cptQuery, model, "name") && check2(cptQuery, model, "id") && check2(dataQuery, packedEvent, "name") && check2(dataQuery, packedEvent, "dataIndex") && check2(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check2(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  };
  ECEventProcessor2.prototype.afterTrigger = function() {
    this.eventInfo = null;
  };
  return ECEventProcessor2;
}();
var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data5 = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data5.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;
    for (var i2 = 0; i2 < SYMBOL_PROPS_WITH_CB.length; i2++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i2];
      var val2 = seriesModel.get(symbolPropName);
      if (isFunction$h(val2)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val2;
      } else {
        symbolOptions[symbolPropName] = val2;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data5.setVisual(extend$1({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var symbolPropsCb = keys$d(symbolOptionsCb);
    function dataEach(data6, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);
      for (var i3 = 0; i3 < symbolPropsCb.length; i3++) {
        var symbolPropName2 = symbolPropsCb[i3];
        data6.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
      }
    }
    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data5 = seriesModel.getData();
    function dataEach(data6, idx) {
      var itemModel = data6.getItemModel(idx);
      for (var i2 = 0; i2 < SYMBOL_PROPS.length; i2++) {
        var symbolPropName = SYMBOL_PROPS[i2];
        var val2 = itemModel.getShallow(symbolPropName, true);
        if (val2 != null) {
          data6.setItemVisual(idx, symbolPropName, val2);
        }
      }
    }
    return {
      dataEach: data5.hasItemOption ? dataEach : null
    };
  }
};
function getItemVisualFromData(data5, dataIndex, key) {
  switch (key) {
    case "color":
      var style = data5.getItemVisual(dataIndex, "style");
      return style[data5.getVisual("drawType")];
    case "opacity":
      return data5.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data5.getItemVisual(dataIndex, key);
  }
}
function getVisualFromData(data5, key) {
  switch (key) {
    case "color":
      var style = data5.getVisual("style");
      return style[data5.getVisual("drawType")];
    case "opacity":
      return data5.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data5.getVisual(key);
  }
}
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each$q([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
      payload = extend$1({}, payload);
      api.dispatchAction(extend$1(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type2, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type2 + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;
      for (var i2 = 0; i2 < selected.length; i2++) {
        if (selected[i2].seriesIndex === seriesIndex) {
          var data5 = seriesModel.getData();
          var dataIndex = queryDataIndex(data5, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray$x(dataIndex) ? data5.getName(dataIndex[0]) : data5.getName(dataIndex),
            selected: isString$d(selectedMap) ? selectedMap : extend$1({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on("selectchanged", function(params) {
    var ecModel = api.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}
function findEventDispatcher(target, det, returnFirstMatch) {
  var found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap$2 = function() {
  function WeakMap2() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  WeakMap2.prototype.get = function(key) {
    return this._guard(key)[this._id];
  };
  WeakMap2.prototype.set = function(key, value) {
    var target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  };
  WeakMap2.prototype["delete"] = function(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  };
  WeakMap2.prototype.has = function(key) {
    return !!this._guard(key)[this._id];
  };
  WeakMap2.prototype._guard = function(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  };
  return WeakMap2;
}();
var WeakMap$3 = WeakMap$2;
var Triangle = Path$2.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width2 = shape.width / 2;
    var height2 = shape.height / 2;
    path.moveTo(cx, cy - height2);
    path.lineTo(cx + width2, cy + height2);
    path.lineTo(cx - width2, cy + height2);
    path.closePath();
  }
});
var Diamond = Path$2.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width2 = shape.width / 2;
    var height2 = shape.height / 2;
    path.moveTo(cx, cy - height2);
    path.lineTo(cx + width2, cy);
    path.lineTo(cx, cy + height2);
    path.lineTo(cx - width2, cy);
    path.closePath();
  }
});
var Pin = Path$2.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var x2 = shape.x;
    var y2 = shape.y;
    var w2 = shape.width / 5 * 3;
    var h2 = Math.max(w2, shape.height);
    var r2 = w2 / 2;
    var dy = r2 * r2 / (h2 - r2);
    var cy = y2 - h2 + r2 + dy;
    var angle = Math.asin(dy / r2);
    var dx = Math.cos(angle) * r2;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r2 * 0.6;
    var cpLen2 = r2 * 0.7;
    path.moveTo(x2 - dx, cy + dy);
    path.arc(x2, cy, r2, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x2 + dx - tanX * cpLen, cy + dy + tanY * cpLen, x2, y2 - cpLen2, x2, y2);
    path.bezierCurveTo(x2, y2 - cpLen2, x2 - dx + tanX * cpLen, cy + dy + tanY * cpLen, x2 - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path$2.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var height2 = shape.height;
    var width2 = shape.width;
    var x2 = shape.x;
    var y2 = shape.y;
    var dx = width2 / 3 * 2;
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 + dx, y2 + height2);
    ctx.lineTo(x2, y2 + height2 / 4 * 3);
    ctx.lineTo(x2 - dx, y2 + height2);
    ctx.lineTo(x2, y2);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line$1,
  rect: Rect$2,
  roundRect: Rect$2,
  square: Rect$2,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x2, y2, w2, h2, shape) {
    shape.x1 = x2;
    shape.y1 = y2 + h2 / 2;
    shape.x2 = x2 + w2;
    shape.y2 = y2 + h2 / 2;
  },
  rect: function(x2, y2, w2, h2, shape) {
    shape.x = x2;
    shape.y = y2;
    shape.width = w2;
    shape.height = h2;
  },
  roundRect: function(x2, y2, w2, h2, shape) {
    shape.x = x2;
    shape.y = y2;
    shape.width = w2;
    shape.height = h2;
    shape.r = Math.min(w2, h2) / 4;
  },
  square: function(x2, y2, w2, h2, shape) {
    var size = Math.min(w2, h2);
    shape.x = x2;
    shape.y = y2;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x2, y2, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y2 + h2 / 2;
    shape.r = Math.min(w2, h2) / 2;
  },
  diamond: function(x2, y2, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y2 + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  pin: function(x2, y2, w2, h2, shape) {
    shape.x = x2 + w2 / 2;
    shape.y = y2 + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  arrow: function(x2, y2, w2, h2, shape) {
    shape.x = x2 + w2 / 2;
    shape.y = y2 + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  },
  triangle: function(x2, y2, w2, h2, shape) {
    shape.cx = x2 + w2 / 2;
    shape.cy = y2 + h2 / 2;
    shape.width = w2;
    shape.height = h2;
  }
};
var symbolBuildProxies = {};
each$q(symbolCtors, function(Ctor, name2) {
  symbolBuildProxies[name2] = new Ctor();
});
var SymbolClz$1 = Path$2.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(out2, config2, rect) {
    var res = calculateTextPosition(out2, config2, rect);
    var shape = this.shape;
    if (shape && shape.symbolType === "pin" && config2.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath: function(ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    if (symbolType !== "none") {
      var proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color2, innerColor2) {
  if (this.type !== "image") {
    var symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color2;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color2;
    } else {
      symbolStyle.fill = color2;
    }
    this.markRedraw();
  }
}
function createSymbol(symbolType, x2, y2, w2, h2, color2, keepAspect) {
  var isEmpty2 = symbolType.indexOf("empty") === 0;
  if (isEmpty2) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  var symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect$1(x2, y2, w2, h2), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect$1(x2, y2, w2, h2), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz$1({
      shape: {
        symbolType,
        x: x2,
        y: y2,
        width: w2,
        height: h2
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty2;
  symbolPath.setColor = symbolPathSetColor;
  if (color2) {
    symbolPath.setColor(color2);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray$x(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray$x(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [parsePercent(symbolOffset[0], symbolSize[0]) || 0, parsePercent(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}
function isSafeNum(num) {
  return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
  var x2 = obj.x == null ? 0 : obj.x;
  var x22 = obj.x2 == null ? 1 : obj.x2;
  var y2 = obj.y == null ? 0 : obj.y;
  var y22 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x2 = x2 * rect.width + rect.x;
    x22 = x22 * rect.width + rect.x;
    y2 = y2 * rect.height + rect.y;
    y22 = y22 * rect.height + rect.y;
  }
  x2 = isSafeNum(x2) ? x2 : 0;
  x22 = isSafeNum(x22) ? x22 : 1;
  y2 = isSafeNum(y2) ? y2 : 0;
  y22 = isSafeNum(y22) ? y22 : 0;
  var canvasGradient = ctx.createLinearGradient(x2, y2, x22, y22);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width2 = rect.width;
  var height2 = rect.height;
  var min3 = Math.min(width2, height2);
  var x2 = obj.x == null ? 0.5 : obj.x;
  var y2 = obj.y == null ? 0.5 : obj.y;
  var r2 = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x2 = x2 * width2 + rect.x;
    y2 = y2 * height2 + rect.y;
    r2 = r2 * min3;
  }
  x2 = isSafeNum(x2) ? x2 : 0.5;
  y2 = isSafeNum(y2) ? y2 : 0.5;
  r2 = r2 >= 0 && isSafeNum(r2) ? r2 : 0.5;
  var canvasGradient = ctx.createRadialGradient(x2, y2, 0, x2, y2, r2);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  var colorStops = obj.colorStops;
  for (var i2 = 0; i2 < colorStops.length; i2++) {
    canvasGradient.addColorStop(colorStops[i2].offset, colorStops[i2].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i2 = 0; i2 < clipPaths.length; i2++) {
    if (clipPaths[i2] !== prevClipPaths[i2]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val2) {
  return parseInt(val2, 10);
}
function getSize$3(root2, whIdx, opts) {
  var wh2 = ["width", "height"][whIdx];
  var cwh = ["clientWidth", "clientHeight"][whIdx];
  var plt = ["paddingLeft", "paddingTop"][whIdx];
  var prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh2] != null && opts[wh2] !== "auto") {
    return parseFloat(opts[wh2]);
  }
  var stl = document.defaultView.getComputedStyle(root2);
  return (root2[cwh] || parseInt10(stl[wh2]) || parseInt10(root2.style[wh2])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber$c(lineType) ? [lineType] : isArray$x(lineType) ? lineType : null;
}
function getLineDash(el2) {
  var style = el2.style;
  var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  var lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    var lineScale_1 = style.strokeNoScale && el2.getLineScale ? el2.getLineScale() : 1;
    if (lineScale_1 && lineScale_1 !== 1) {
      lineDash = map$9(lineDash, function(rawVal) {
        return rawVal / lineScale_1;
      });
      lineDashOffset /= lineScale_1;
    }
  }
  return [lineDash, lineDashOffset];
}
var pathProxyForDraw = new PathProxy$1(true);
function styleHasStroke(style) {
  var stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el2) {
  var image = createOrUpdateImage(pattern.image, pattern.__image, el2);
  if (isImageReady(image)) {
    var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      var matrix2 = new DOMMatrix();
      matrix2.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix2.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix2.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix2);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el2, style, inBatch) {
  var _a2;
  var hasStroke = styleHasStroke(style);
  var hasFill = styleHasFill(style);
  var strokePercent = style.strokePercent;
  var strokePart = strokePercent < 1;
  var firstDraw = !el2.path;
  if ((!el2.silent || strokePart) && firstDraw) {
    el2.createPathProxy();
  }
  var path = el2.path || pathProxyForDraw;
  var dirtyFlag = el2.__dirty;
  if (!inBatch) {
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    var fillGradient = void 0;
    var strokeGradient = void 0;
    var fillPattern = void 0;
    var strokePattern = void 0;
    var rect = void 0;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el2.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el2.__canvasFillGradient;
      el2.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el2.__canvasStrokeGradient;
      el2.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el2.__canvasFillPattern ? createCanvasPattern(ctx, fill, el2) : el2.__canvasFillPattern;
      el2.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el2.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el2) : el2.__canvasStrokePattern;
      el2.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  var scale2 = el2.getGlobalScale();
  path.setScale(scale2[0], scale2[1], el2.segmentIgnoreThreshold);
  var lineDash;
  var lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    _a2 = getLineDash(el2), lineDash = _a2[0], lineDashOffset = _a2[1];
  }
  var needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el2.buildPath(path, el2.shape, inBatch);
    path.toStatic();
    el2.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el2, style) {
  var image = el2.__image = createOrUpdateImage(style.image, el2.__image, el2, el2.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  var x2 = style.x || 0;
  var y2 = style.y || 0;
  var width2 = el2.getWidth();
  var height2 = el2.getHeight();
  var aspect = image.width / image.height;
  if (width2 == null && height2 != null) {
    width2 = height2 * aspect;
  } else if (height2 == null && width2 != null) {
    height2 = width2 / aspect;
  } else if (width2 == null && height2 == null) {
    width2 = image.width;
    height2 = image.height;
  }
  if (style.sWidth && style.sHeight) {
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x2, y2, width2, height2);
  } else if (style.sx && style.sy) {
    var sx = style.sx;
    var sy = style.sy;
    var sWidth = width2 - sx;
    var sHeight = height2 - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x2, y2, width2, height2);
  } else {
    ctx.drawImage(image, x2, y2, width2, height2);
  }
}
function brushText(ctx, el2, style) {
  var _a2;
  var text2 = style.text;
  text2 != null && (text2 += "");
  if (text2) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    var lineDash = void 0;
    var lineDashOffset = void 0;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el2), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text2, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text2, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text2, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text2, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  var styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    var opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (var i2 = 0; i2 < SHADOW_NUMBER_PROPS.length; i2++) {
    var propName = SHADOW_NUMBER_PROPS[i2];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el2, prevEl, forceSetAll, scope) {
  var style = getStyle(el2, scope.inHover);
  var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el2.hasStroke()) {
    var lineWidth = style.lineWidth;
    var newLineWidth = lineWidth / (style.strokeNoScale && el2.getLineScale ? el2.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (var i2 = 0; i2 < STROKE_PROPS.length; i2++) {
    var prop = STROKE_PROPS[i2];
    var propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el2, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el2, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el2) {
  var m2 = el2.transform;
  var dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  var allClipped = false;
  for (var i2 = 0; i2 < clipPaths.length; i2++) {
    var clipPath = clipPaths[i2];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  var hasFill = styleHasFill(style);
  var hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el2, inHover) {
  return inHover ? el2.__hoverStyle || el2.style : el2.style;
}
function brushSingle(ctx, el2) {
  brush(ctx, el2, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush(ctx, el2, scope, isLast) {
  var m2 = el2.transform;
  if (!el2.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el2.__dirty &= ~REDRAW_BIT;
    el2.__isRendered = false;
    return;
  }
  var clipPaths = el2.__clipPaths;
  var prevElClipPaths = scope.prevElClipPaths;
  var forceSetTransform = false;
  var forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el2.__isRendered = false;
    return;
  }
  el2.beforeBrush && el2.beforeBrush();
  el2.innerBeforeBrush();
  var prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  var canBatchPath = el2 instanceof Path$2 && el2.autoBatch && canPathBatch(el2.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el2);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  var style = getStyle(el2, scope.inHover);
  if (el2 instanceof Path$2) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el2, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el2, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el2 instanceof TSpan$1) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el2, prevEl, forceSetStyle, scope);
      brushText(ctx, el2, style);
    } else if (el2 instanceof ZRImage$1) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el2, prevEl, forceSetStyle, scope);
      brushImage(ctx, el2, style);
    } else if (el2.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el2, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el2.innerAfterBrush();
  el2.afterBrush && el2.afterBrush();
  scope.prevEl = el2;
  el2.__dirty = 0;
  el2.__isRendered = true;
}
function brushIncremental(ctx, el2, scope) {
  var displayables = el2.getDisplayables();
  var temporalDisplayables = el2.getTemporalDisplayables();
  ctx.save();
  var innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  var i2;
  var len2;
  for (i2 = el2.getCursor(), len2 = displayables.length; i2 < len2; i2++) {
    var displayable = displayables[i2];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i2 === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
    var displayable = temporalDisplayables[i_1];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el2.clearTemporalDisplayables();
  el2.notClear = true;
  ctx.restore();
}
var decalMap = new WeakMap$3();
var decalCache = new LRU$1(100);
var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === "none") {
    return null;
  }
  var dpr2 = api.getDevicePixelRatio();
  var zr2 = api.getZr();
  var isSVG = zr2.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }
  var oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  var decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  var pattern = {
    repeat: "repeat"
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    var keys2 = [dpr2];
    var isValidKey = true;
    for (var i2 = 0; i2 < decalKeys.length; ++i2) {
      var value = decalOpt[decalKeys[i2]];
      if (value != null && !isArray$x(value) && !isString$d(value) && !isNumber$c(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value);
    }
    var cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      var cache2 = decalCache.get(cacheKey);
      if (cache2) {
        isSVG ? pattern2.svgElement = cache2 : pattern2.image = cache2;
      }
    }
    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    var pSize = getPatternSize();
    var ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      var width2 = 1;
      for (var i3 = 0, xlen = lineBlockLengthsX.length; i3 < xlen; ++i3) {
        width2 = getLeastCommonMultiple(width2, lineBlockLengthsX[i3]);
      }
      var symbolRepeats = 1;
      for (var i3 = 0, xlen = symbolArray.length; i3 < xlen; ++i3) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i3].length);
      }
      width2 *= symbolRepeats;
      var height2 = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      return {
        width: Math.max(1, Math.min(width2, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height2, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      var ySum = 0;
      for (var i3 = 0; i3 < dashArrayY.length; ++i3) {
        ySum += dashArrayY[i3];
      }
      if (ySum <= 0) {
        return;
      }
      var y2 = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;
      while (y2 < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x2 = 0;
          var xId1 = 0;
          var xId1Total = 0;
          while (x2 < pSize.width * 2) {
            var xSum = 0;
            for (var i3 = 0; i3 < dashArrayX[xId0].length; ++i3) {
              xSum += dashArrayX[xId0][i3];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              var size = (1 - decalOpt.symbolSize) * 0.5;
              var left = x2 + dashArrayX[xId0][xId1] * size;
              var top_1 = y2 + dashArrayY[yId] * size;
              var width2 = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height2 = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top_1, width2, height2, symbolArray[symbolYId][symbolXId]);
            }
            x2 += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y2 += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x3, y3, width3, height3, symbolType) {
        var scale2 = isSVG ? 1 : dpr2;
        var symbol = createSymbol(symbolType, x3 * scale2, y3 * scale2, width3 * scale2, height3 * scale2, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          var symbolVNode = zr2.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString$d(symbol)) {
    return [[symbol]];
  }
  var isAllString = true;
  for (var i2 = 0; i2 < symbol.length; ++i2) {
    if (!isString$d(symbol[i2])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  var result = [];
  for (var i2 = 0; i2 < symbol.length; ++i2) {
    if (isString$d(symbol[i2])) {
      result.push([symbol[i2]]);
    } else {
      result.push(symbol[i2]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber$c(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  var isAllNumber = true;
  for (var i2 = 0; i2 < dash.length; ++i2) {
    if (!isNumber$c(dash[i2])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  var result = [];
  for (var i2 = 0; i2 < dash.length; ++i2) {
    if (isNumber$c(dash[i2])) {
      var dashValue = Math.ceil(dash[i2]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map$9(dash[i2], function(n2) {
        return Math.ceil(n2);
      });
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber$c(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }
  var dashValue = map$9(dash, function(n2) {
    return Math.ceil(n2);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map$9(dash, function(line) {
    return getLineBlockLengthY(line);
  });
}
function getLineBlockLengthY(dash) {
  var blockLength = 0;
  for (var i2 = 0; i2 < dash.length; ++i2) {
    blockLength += dash[i2];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}
function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function(seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data5 = seriesModel.getData();
    if (data5.hasItemVisual()) {
      data5.each(function(idx) {
        var decal2 = data5.getItemVisual(idx, "decal");
        if (decal2) {
          var itemStyle = data5.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
        }
      });
    }
    var decal = data5.getVisual("decal");
    if (decal) {
      var style = data5.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}
var lifecycle = new Eventful$1();
var lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(name2, impl) {
  implsStore[name2] = impl;
}
function getImpl(name2) {
  return implsStore[name2];
}
var hasWindow = typeof window !== "undefined";
var version = "5.3.3";
var dependencies = {
  zrender: "5.3.2"
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful$1.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
  __extends(MessageCenter2, _super);
  function MessageCenter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return MessageCenter2;
}(Eventful$1);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render$1;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = function(_super) {
  __extends(ECharts2, _super);
  function ECharts2(dom, theme2, opts) {
    var _this = _super.call(this, new ECEventProcessor()) || this;
    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {};
    _this._pendingActions = [];
    opts = opts || {};
    if (isString$d(theme2)) {
      theme2 = themeStorage[theme2];
    }
    _this._dom = dom;
    var defaultRenderer = "canvas";
    var defaultUseDirtyRect = false;
    var zr2 = _this._zr = init$2(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
    });
    _this._ssr = opts.ssr;
    _this._throttledZrFlush = throttle$4(bind$3(zr2.flush, zr2), 17);
    theme2 = clone$8(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    _this._theme = theme2;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem();
    var api = _this._api = createExtensionAPI(_this);
    function prioritySortFunc(a2, b2) {
      return a2.__prio - b2.__prio;
    }
    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler$1(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter();
    _this._initEvents();
    _this.resize = bind$3(_this.resize, _this);
    zr2.animation.on("frame", _this._onframe, _this);
    bindRenderedEvent(zr2, _this);
    bindMouseEvent(zr2, _this);
    setAsPrimitive(_this);
    return _this;
  }
  ECharts2.prototype._onframe = function() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    var scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e3) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e3;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  ECharts2.prototype.getDom = function() {
    return this._dom;
  };
  ECharts2.prototype.getId = function() {
    return this.id;
  };
  ECharts2.prototype.getZr = function() {
    return this._zr;
  };
  ECharts2.prototype.isSSR = function() {
    return this._ssr;
  };
  ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    var replaceMerge;
    var transitionOpt;
    if (isObject$f(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager$1(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new GlobalModel$1();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {
      replaceMerge
    }, optionPreprocessorFuncs);
    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e3) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e3;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  ECharts2.prototype.setTheme = function() {
  };
  ECharts2.prototype.getModel = function() {
    return this._model;
  };
  ECharts2.prototype.getOption = function() {
    return this._model && this._model.getOption();
  };
  ECharts2.prototype.getWidth = function() {
    return this._zr.getWidth();
  };
  ECharts2.prototype.getHeight = function() {
    return this._zr.getHeight();
  };
  ECharts2.prototype.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;
  };
  ECharts2.prototype.getRenderedCanvas = function(opts) {
    return this.renderToCanvas(opts);
  };
  ECharts2.prototype.renderToCanvas = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };
  ECharts2.prototype.renderToSVGString = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  ECharts2.prototype.getSvgDataURL = function() {
    if (!env$1.svgSupported) {
      return;
    }
    var zr2 = this._zr;
    var list = zr2.storage.getDisplayList();
    each$q(list, function(el2) {
      el2.stopAnimation(null, true);
    });
    return zr2.painter.toDataURL();
  };
  ECharts2.prototype.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each$q(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        var view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each$q(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  };
  ECharts2.prototype.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin2 = Math.min;
    var mathMax2 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each$q(instances$1, function(chart, id2) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$8(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin2(boundingRect.left, left_1);
          top_1 = mathMin2(boundingRect.top, top_1);
          right_1 = mathMax2(boundingRect.right, right_1);
          bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width2 = right_1 - left_1;
      var height2 = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init$2(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr_1.resize({
        width: width2,
        height: height2
      });
      if (isSvg) {
        var content_1 = "";
        each$q(canvasList_1, function(item) {
          var x2 = item.left - left_1;
          var y2 = item.top - top_1;
          content_1 += '<g transform="translate(' + x2 + "," + y2 + ')">' + item.dom + "</g>";
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;
        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect$2({
            shape: {
              x: 0,
              y: 0,
              width: width2,
              height: height2
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each$q(canvasList_1, function(item) {
          var img = new ZRImage$1({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  ECharts2.prototype.convertToPixel = function(finder, value) {
    return doConvertPixel(this, "convertToPixel", finder, value);
  };
  ECharts2.prototype.convertFromPixel = function(finder, value) {
    return doConvertPixel(this, "convertFromPixel", finder, value);
  };
  ECharts2.prototype.containPixel = function(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    var findResult = parseFinder(ecModel, finder);
    each$q(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each$q(models, function(model) {
        var coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          var view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          }
        } else
          ;
      }, this);
    }, this);
    return !!result;
  };
  ECharts2.prototype.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = parsedFinder.seriesModel;
    var data5 = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data5.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data5, dataIndexInside, visualType) : getVisualFromData(data5, visualType);
  };
  ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  ECharts2.prototype._initEvents = function() {
    var _this = this;
    each$q(MOUSE_EVENT_NAMES, function(eveName) {
      var handler3 = function(e3) {
        var ecModel = _this.getModel();
        var el2 = e3.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el2 && findEventDispatcher(el2, function(parent2) {
            var ecData = getECData(parent2);
            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend$1({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          params.event = e3;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el2,
            packedEvent: params,
            model,
            view
          };
          _this.trigger(eveName, params);
        }
      };
      handler3.zrEventfulCallAtLast = true;
      _this._zr.on(eveName, handler3, _this);
    });
    each$q(eventActionMap, function(actionType, eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    each$q(["selectchanged"], function(eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };
  ECharts2.prototype.isDisposed = function() {
    return this._disposed;
  };
  ECharts2.prototype.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  ECharts2.prototype.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    var dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each$q(chart._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each$q(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances$1[chart.id];
  };
  ECharts2.prototype.resize = function(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var needPrepare = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend$1({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e3) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e3;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.showLoading = function(name2, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject$f(name2)) {
      cfg = name2;
      name2 = "";
    }
    name2 = name2 || "default";
    this.hideLoading();
    if (!loadingEffects[name2]) {
      return;
    }
    var el2 = loadingEffects[name2](this._api, cfg);
    var zr2 = this._zr;
    this._loadingFX = el2;
    zr2.add(el2);
  };
  ECharts2.prototype.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  ECharts2.prototype.makeActionFromEvent = function(eventObj) {
    var payload = extend$1({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  ECharts2.prototype.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject$f(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env$1.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.updateLabelLayout = function() {
    lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  };
  ECharts2.prototype.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  };
  ECharts2.internalField = function() {
    prepare = function(ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    prepareView = function(ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr2 = ecIns._zr;
      var api = ecIns._api;
      for (var i2 = 0; i2 < viewList.length; i2++) {
        viewList[i2].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var requireNewView = model.__requireNewView;
        model.__requireNewView = false;
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = !requireNewView && viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView$1.getClass(classType.main, classType.sub) : ChartView$1.getClass(classType.sub);
          view2 = new Clazz();
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr2.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i2 = 0; i2 < viewList.length; ) {
        var view = viewList[i2];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr2.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i2, 1);
          if (viewMap[view.__id] === view) {
            delete viewMap[view.__id];
          }
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i2++;
        }
      }
    };
    updateDirectly = function(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload);
      if (!mainType) {
        each$q([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;
      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each$q(normalizeToArray(excludeSeriesId), function(id2) {
          var modelId = convertOptionIdName(id2, null);
          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        if (isHighDownPayload(payload)) {
          if (model instanceof SeriesModel$1) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            }
            if (dispatchers) {
              each$q(dispatchers, function(dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          if (model instanceof SeriesModel$1) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    };
    updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          optionChanged: payload.newOption != null
        });
      },
      update: function(payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr2 = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render$1(this, ecModel, api, payload, updateParams);
        var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
        var darkMode = ecModel.get("darkMode");
        zr2.setBackgroundColor(backgroundColor2);
        if (darkMode != null && darkMode !== "auto") {
          zr2.setDarkMode(darkMode);
        }
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateTransform: function(payload) {
        var _this = this;
        var ecModel = this._model;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType === "series") {
            return;
          }
          var componentView = _this.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ChartView$1.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render$1(this, ecModel, this._api, payload, {});
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateVisual: function(payload) {
        var _this = this;
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.getData().clearAllVisual();
        });
        ChartView$1.markUpdateMethod(payload, "updateVisual");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: "visual",
          setDirty: true
        });
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType !== "series") {
            var componentView = _this.getViewOfComponentModel(componentModel);
            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    doConvertPixel = function(ecIns, methodName, finder, value) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }
      var ecModel = ecIns._model;
      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
      var result;
      var parsedFinder = parseFinder(ecModel, finder);
      for (var i2 = 0; i2 < coordSysList.length; i2++) {
        var coordSys = coordSysList[i2];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
          return result;
        }
      }
    };
    updateStreamModes = function(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };
    doDispatchAction = function(payload, silent) {
      var _this = this;
      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo.update || "update").split(":");
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = map$9(payload.batch, function(item) {
          item = defaults(extend$1({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload);
      if (isHighDown) {
        allLeaveBlur(this._api);
      }
      each$q(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
        eventObj = eventObj || extend$1({}, batchItem);
        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          updateDirectly(_this, updateMethod, batchItem, "series");
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });
      if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
        try {
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e3) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e3;
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj);
        if (isSelectChange) {
          var newObj = {
            type: "selectchanged",
            escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };
    flushPendingActions = function(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };
    triggerUpdatedEvent = function(silent) {
      !silent && this.trigger("updated");
    };
    bindRenderedEvent = function(zr2, ecIns) {
      zr2.on("rendered", function(params) {
        ecIns.trigger("rendered", params);
        if (zr2.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    };
    bindMouseEvent = function(zr2, ecIns) {
      zr2.on("mouseover", function(e3) {
        var el2 = e3.target;
        var dispatcher = findEventDispatcher(el2, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e3, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("mouseout", function(e3) {
        var el2 = e3.target;
        var dispatcher = findEventDispatcher(el2, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e3, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("click", function(e3) {
        var el2 = e3.target;
        var dispatcher = findEventDispatcher(el2, function(target) {
          return getECData(target).dataIndex != null;
        }, true);
        if (dispatcher) {
          var actionType = dispatcher.selected ? "unselect" : "select";
          var ecData = getECData(dispatcher);
          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeperateZLevel = false;
      ecModel.eachComponent(function(componentType, componentModel) {
        var zlevel = componentModel.get("zlevel") || 0;
        var z2 = componentModel.get("z") || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
        (componentType === "series" ? seriesZLevels : componentZLevels).push({
          zlevel,
          z: z2,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });
      if (hasSeperateZLevel) {
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort(zLevels, function(a2, b2) {
          if (a2.zlevel === b2.zlevel) {
            return a2.z - b2.z;
          }
          return a2.zlevel - b2.zlevel;
        });
        each$q(zLevels, function(item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key = item.key;
          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }
          if (key) {
            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
              zlevel++;
            }
            lastSeriesKey_1 = key;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }
            lastSeriesKey_1 = "";
          }
          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }
    render$1 = function(ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each$q(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams);
      each$q(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };
    renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each$q(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      var scheduler = ecIns._scheduler;
      updateParams = extend$1(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      });
      lifecycle$1.trigger("series:beforeupdate", ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        clearStates(seriesModel, chartView);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }
        chartView.group.silent = !!seriesModel.get("silent");
        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle$1.trigger("series:layoutlabels", ecModel, api, updateParams);
      lifecycle$1.trigger("series:transition", ecModel, api, updateParams);
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        updateZ(seriesModel, chartView);
        updateStates(seriesModel, chartView);
      });
      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle$1.trigger("series:afterupdate", ecModel, api, updateParams);
    };
    markStatusToUpdate = function(ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
      ecIns.getZr().wakeUp();
    };
    applyChangedStates = function(ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }
      ecIns.getZr().storage.traverse(function(el2) {
        if (isElementRemoved(el2)) {
          return;
        }
        applyElementStates(el2);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };
    function applyElementStates(el2) {
      var newStates = [];
      var oldStates = el2.currentStates;
      for (var i2 = 0; i2 < oldStates.length; i2++) {
        var stateName = oldStates[i2];
        if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
          newStates.push(stateName);
        }
      }
      if (el2.selected && el2.states.select) {
        newStates.push("select");
      }
      if (el2.hoverState === HOVER_STATE_EMPHASIS && el2.states.emphasis) {
        newStates.push("emphasis");
      } else if (el2.hoverState === HOVER_STATE_BLUR && el2.states.blur) {
        newStates.push("blur");
      }
      el2.useStates(newStates);
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr2 = ecIns._zr;
      var storage = zr2.storage;
      var elCount = 0;
      storage.traverse(function(el2) {
        if (!el2.isGroup) {
          elCount++;
        }
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env$1.node && !env$1.worker) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.eachRendered(function(el2) {
              if (el2.states.emphasis) {
                el2.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.eachRendered(function(el2) {
        if (!el2.isGroup) {
          el2.style.blend = blendMode;
        }
      });
    }
    function updateZ(model, view) {
      if (model.preventAutoZ) {
        return;
      }
      var z2 = model.get("z") || 0;
      var zlevel = model.get("zlevel") || 0;
      view.eachRendered(function(el2) {
        doUpdateZ(el2, z2, zlevel, -Infinity);
        return true;
      });
    }
    function doUpdateZ(el2, z2, zlevel, maxZ2) {
      var label = el2.getTextContent();
      var labelLine = el2.getTextGuideLine();
      var isGroup = el2.isGroup;
      if (isGroup) {
        var children2 = el2.childrenRef();
        for (var i2 = 0; i2 < children2.length; i2++) {
          maxZ2 = Math.max(doUpdateZ(children2[i2], z2, zlevel, maxZ2), maxZ2);
        }
      } else {
        el2.z = z2;
        el2.zlevel = zlevel;
        maxZ2 = Math.max(el2.z2, maxZ2);
      }
      if (label) {
        label.z = z2;
        label.zlevel = zlevel;
        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }
      if (labelLine) {
        var textGuideLineConfig = el2.textGuideLineConfig;
        labelLine.z = z2;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }
      return maxZ2;
    }
    function clearStates(model, view) {
      view.eachRendered(function(el2) {
        if (isElementRemoved(el2)) {
          return;
        }
        var textContent = el2.getTextContent();
        var textGuide = el2.getTextGuideLine();
        if (el2.stateTransition) {
          el2.stateTransition = null;
        }
        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }
        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        }
        if (el2.hasState()) {
          el2.prevStates = el2.currentStates;
          el2.clearStates();
        } else if (el2.prevStates) {
          el2.prevStates = null;
        }
      });
    }
    function updateStates(model, view) {
      var stateAnimationModel = model.getModel("stateAnimation");
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get("duration");
      var stateTransition = duration > 0 ? {
        duration,
        delay: stateAnimationModel.get("delay"),
        easing: stateAnimationModel.get("easing")
      } : null;
      view.eachRendered(function(el2) {
        if (el2.states && el2.states.emphasis) {
          if (isElementRemoved(el2)) {
            return;
          }
          if (el2 instanceof Path$2) {
            savePathStates(el2);
          }
          if (el2.__dirty) {
            var prevStates = el2.prevStates;
            if (prevStates) {
              el2.useStates(prevStates);
            }
          }
          if (enableAnimation) {
            el2.stateTransition = stateTransition;
            var textContent = el2.getTextContent();
            var textGuide = el2.getTextGuideLine();
            if (textContent) {
              textContent.stateTransition = stateTransition;
            }
            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          }
          if (el2.__dirty) {
            applyElementStates(el2);
          }
        }
      });
    }
    createExtensionAPI = function(ecIns) {
      return new (function(_super2) {
        __extends(class_1, _super2);
        function class_1() {
          return _super2 !== null && _super2.apply(this, arguments) || this;
        }
        class_1.prototype.getCoordinateSystems = function() {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };
        class_1.prototype.getComponentByElement = function(el2) {
          while (el2) {
            var modelInfo = el2.__ecComponentInfo;
            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el2 = el2.parent;
          }
        };
        class_1.prototype.enterEmphasis = function(el2, highlightDigit) {
          enterEmphasis(el2, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveEmphasis = function(el2, highlightDigit) {
          leaveEmphasis(el2, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterBlur = function(el2) {
          enterBlur(el2);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveBlur = function(el2) {
          leaveBlur(el2);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterSelect = function(el2) {
          enterSelect(el2);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveSelect = function(el2) {
          leaveSelect(el2);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.getModel = function() {
          return ecIns.getModel();
        };
        class_1.prototype.getViewOfComponentModel = function(componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };
        class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };
        return class_1;
      }(ExtensionAPI$1))(ecIns);
    };
    enableConnect = function(chart) {
      function updateConnectedChartsStatus(charts, status) {
        for (var i2 = 0; i2 < charts.length; i2++) {
          var otherChart = charts[i2];
          otherChart[CONNECT_STATUS_KEY] = status;
        }
      }
      each$q(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action_1 = chart.makeActionFromEvent(event);
            var otherCharts_1 = [];
            each$q(instances$1, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts_1.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
            each$q(otherCharts_1, function(otherChart) {
              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                otherChart.dispatchAction(action_1);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
          }
        });
      });
    };
  }();
  return ECharts2;
}(Eventful$1);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  var self2 = this;
  function wrapped() {
    var args2 = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args2[_i2] = arguments[_i2];
    }
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(id2) {
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances$1 = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var groupIdBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init$1(dom, theme2, opts) {
  var isClient2 = !(opts && opts.ssr);
  if (isClient2) {
    var existInstance = getInstanceByDom(dom);
    if (existInstance) {
      return existInstance;
    }
  }
  var chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances$1[chart.id] = chart;
  isClient2 && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle$1.trigger("afterinit", chart);
  return chart;
}
function connect(groupId) {
  if (isArray$x(groupId)) {
    var charts = groupId;
    groupId = null;
    each$q(charts, function(chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || "g_" + groupIdBase++;
    each$q(charts, function(chart) {
      chart.group = groupId;
    });
  }
  connectedGroups[groupId] = true;
  return groupId;
}
function disConnect(groupId) {
  connectedGroups[groupId] = false;
}
var disconnect = disConnect;
function dispose(chart) {
  if (isString$d(chart)) {
    chart = instances$1[chart];
  } else if (!(chart instanceof ECharts)) {
    chart = getInstanceByDom(chart);
  }
  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
function getInstanceByDom(dom) {
  return instances$1[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key) {
  return instances$1[key];
}
function registerTheme(name2, theme2) {
  themeStorage[name2] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf$2(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name2, cb) {
  lifecycle$1.on(name2, cb);
}
function registerAction(actionInfo, eventName, action) {
  if (isFunction$h(eventName)) {
    action = eventName;
    eventName = "";
  }
  var actionType = isObject$f(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
    event: eventName
  }][0];
  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
  eventName = actionInfo.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {
      action,
      actionInfo
    };
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type2, coordSysCreator) {
  CoordinateSystem.register(type2, coordSysCreator);
}
function getCoordinateSystemDimensions(type2) {
  var coordSysCreator = CoordinateSystem.get(type2);
  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn2, defaultPriority, visualType) {
  if (isFunction$h(priority) || isObject$f(priority)) {
    fn2 = priority;
    priority = defaultPriority;
  }
  if (indexOf$2(registeredTasks, fn2) >= 0) {
    return;
  }
  registeredTasks.push(fn2);
  var stageHandler = Scheduler$1.wrapStageHandler(fn2, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn2;
  targetList.push(stageHandler);
}
function registerLoading(name2, loadingFx) {
  loadingEffects[name2] = loadingFx;
}
function setCanvasCreator(creator) {
  setPlatformAPI({
    createCanvas: creator
  });
}
function registerMap(mapName, geoJson, specialAreas) {
  var registerMap2 = getImpl("registerMap");
  registerMap2 && registerMap2(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  var getMap2 = getImpl("getMap");
  return getMap2 && getMap2(mapName);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop$3);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop$3);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop$3);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop$3);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop$3);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var dataTool = {};
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = function() {
  function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  DataDiffer2.prototype.add = function(func) {
    this._add = func;
    return this;
  };
  DataDiffer2.prototype.update = function(func) {
    this._update = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToOne = function(func) {
    this._updateManyToOne = func;
    return this;
  };
  DataDiffer2.prototype.updateOneToMany = function(func) {
    this._updateOneToMany = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToMany = function(func) {
    this._updateManyToMany = func;
    return this;
  };
  DataDiffer2.prototype.remove = function(func) {
    this._remove = func;
    return this;
  };
  DataDiffer2.prototype.execute = function() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  };
  DataDiffer2.prototype._executeOneToOne = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i2 = 0; i2 < oldArr.length; i2++) {
      var oldKey = oldDataKeyArr[i2];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        var newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i2);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i2);
      } else {
        this._remove && this._remove(i2);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._executeMultiple = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i2 = 0; i2 < oldDataKeyArr.length; i2++) {
      var oldKey = oldDataKeyArr[i2];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
    for (var i2 = 0; i2 < newDataKeyArr.length; i2++) {
      var newKey = newDataKeyArr[i2];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (var j2 = 0; j2 < idxMapValLen; j2++) {
          this._add && this._add(newIdxMapVal[j2]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  };
  DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;
    for (var i2 = 0; i2 < arr.length; i2++) {
      var key = "_ec_" + this[keyGetterName](arr[i2], i2);
      if (!cbModeMultiple) {
        keyArr[i2] = key;
      }
      if (!map2) {
        continue;
      }
      var idxMapVal = map2[key];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map2[key] = i2;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map2[key] = [idxMapVal, i2];
      } else {
        idxMapVal.push(i2);
      }
    }
  };
  return DataDiffer2;
}();
var DataDiffer$1 = DataDiffer;
var DimensionUserOuput = function() {
  function DimensionUserOuput2(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }
  DimensionUserOuput2.prototype.get = function() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  DimensionUserOuput2.prototype._getFullDimensionNames = function() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  };
  return DimensionUserOuput2;
}();
function summarizeDimensions(data5, schema) {
  var summary = {};
  var encode = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each$q(data5.dimensions, function(dimName) {
    var dimItem = data5.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;
    if (coordDim) {
      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data5.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v2, otherDim) {
      var encodeArr = getOrCreateEncodeArr(encode, otherDim);
      var dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v2, coordDim) {
    var dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map$9(dataDimsOnCoord, function(dimName) {
    return data5.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  var encodeTooltip = encode.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }
  return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}
var SeriesDimensionDefine = function() {
  function SeriesDimensionDefine2(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend$1(this, opt);
    }
  }
  return SeriesDimensionDefine2;
}();
var SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$6 = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = function() {
  function SeriesDataSchema2(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  SeriesDataSchema2.prototype.isDimensionOmitted = function() {
    return this._dimOmitted;
  };
  SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };
  SeriesDataSchema2.prototype.makeStoreSchema = function() {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    var dimHash = "";
    var dims = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      var property2 = void 0;
      var type2 = void 0;
      var ordinalMeta = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property2 = willRetrieveDataByName ? seriesDimDef.name : null;
        type2 = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property2 = willRetrieveDataByName ? sourceDimDef.name : null;
          type2 = sourceDimDef.type;
        }
      }
      dims.push({
        property: property2,
        type: type2,
        ordinalMeta
      });
      if (willRetrieveDataByName && property2 != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property2.replace(/\`/g, "`1").replace(/\$/g, "`2") : property2;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type2] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    var source = this.source;
    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
    return {
      dimensions: dims,
      hash
    };
  };
  SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
    var result = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }
      result.push(name_1);
    }
    return result;
  };
  SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  };
  return SeriesDataSchema2;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();
  for (var i2 = 0; i2 < (dimsDef || []).length; i2++) {
    var dimDefItemRaw = dimsDef[i2];
    var userDimName = isObject$f(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i2);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  var innerSource = inner$6(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}
var isObject$d = isObject$f;
var map$8 = map$9;
var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
  function SeriesData2(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
    var dimensions;
    var assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};
    for (var i2 = 0; i2 < dimensions.length; i2++) {
      var dimInfoInput = dimensions[i2];
      var dimensionInfo = isString$d(dimInfoInput) ? new SeriesDimensionDefine$1({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine$1) ? new SeriesDimensionDefine$1(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i2;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i2;
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i2;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each$q(dimensionNames, function(dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  SeriesData2.prototype.getDimension = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    var dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    var sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  SeriesData2.prototype.getDimensionIndex = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    var dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  SeriesData2.prototype._recognizeDimIndex = function(dim) {
    if (isNumber$c(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };
  SeriesData2.prototype._getStoreDimIndex = function(dim) {
    var dimIdx = this.getDimensionIndex(dim);
    return dimIdx;
  };
  SeriesData2.prototype.getDimensionInfo = function(dim) {
    return this._getDimInfo(this.getDimension(dim));
  };
  SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function(dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
    } : function(dimName) {
      return dimensionInfos[dimName];
    };
  };
  SeriesData2.prototype.getDimensionsOnCoord = function() {
    return this._dimSummary.dataDimsOnCoord.slice();
  };
  SeriesData2.prototype.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };
  SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };
  SeriesData2.prototype.getStore = function() {
    return this._store;
  };
  SeriesData2.prototype.initData = function(data5, nameList, dimValueGetter) {
    var _this = this;
    var store;
    if (data5 instanceof DataStore) {
      store = data5;
    }
    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data5) || isArrayLike$2(data5) ? new DefaultDataProvider(data5, dimensions.length) : data5;
      store = new DataStore();
      var dimensionInfos = map$8(dimensions, function(dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  SeriesData2.prototype.appendData = function(data5) {
    var range2 = this._store.appendData(data5);
    this._doInit(range2[0], range2[1]);
  };
  SeriesData2.prototype.appendValues = function(values2, names) {
    var _a2 = this._store.appendValues(values2, names.length), start2 = _a2.start, end2 = _a2.end;
    var shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (var idx = start2; idx < end2; idx++) {
        var sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };
  SeriesData2.prototype._updateOrdinalMeta = function() {
    var store = this._store;
    var dimensions = this.dimensions;
    for (var i2 = 0; i2 < dimensions.length; i2++) {
      var dimInfo = this._dimInfos[dimensions[i2]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };
  SeriesData2.prototype._shouldMakeIdFromName = function() {
    var provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };
  SeriesData2.prototype._doInit = function(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    var store = this._store;
    var provider = store.getProvider();
    this._updateOrdinalMeta();
    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        var dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          var itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          var itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (var idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  };
  SeriesData2.prototype.getApproximateExtent = function(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  };
  SeriesData2.prototype.getCalculationInfo = function(key) {
    return this._calculationInfo[key];
  };
  SeriesData2.prototype.setCalculationInfo = function(key, value) {
    isObject$d(key) ? extend$1(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  SeriesData2.prototype.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    var name2 = this._nameList[rawIndex];
    if (name2 == null && this._nameDimIdx != null) {
      name2 = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name2 == null) {
      name2 = "";
    }
    return name2;
  };
  SeriesData2.prototype._getCategory = function(dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);
    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  };
  SeriesData2.prototype.getId = function(idx) {
    return getId(this, this.getRawIndex(idx));
  };
  SeriesData2.prototype.count = function() {
    return this._store.count();
  };
  SeriesData2.prototype.get = function(dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };
  SeriesData2.prototype.getIndices = function() {
    return this._store.getIndices();
  };
  SeriesData2.prototype.getDataExtent = function(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getSum = function(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getMedian = function(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getValues = function(dimensions, idx) {
    var _this = this;
    var store = this._store;
    return isArray$x(dimensions) ? store.getValues(map$8(dimensions, function(dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  SeriesData2.prototype.hasValue = function(idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (var i2 = 0, len2 = dataDimIndicesOnCoord.length; i2 < len2; i2++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i2], idx))) {
        return false;
      }
    }
    return true;
  };
  SeriesData2.prototype.indexOfName = function(name2) {
    for (var i2 = 0, len2 = this._store.count(); i2 < len2; i2++) {
      if (this.getName(i2) === name2) {
        return i2;
      }
    }
    return -1;
  };
  SeriesData2.prototype.getRawIndex = function(idx) {
    return this._store.getRawIndex(idx);
  };
  SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  SeriesData2.prototype.rawIndexOf = function(dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    var rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  };
  SeriesData2.prototype.each = function(dims, cb, ctx) {
    if (isFunction$h(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map$8(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind$3(cb, fCtx) : cb);
  };
  SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
    if (isFunction$h(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map$8(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind$3(cb, fCtx) : cb);
    return this;
  };
  SeriesData2.prototype.selectRange = function(range2) {
    var _this = this;
    var innerRange = {};
    var dims = keys$d(range2);
    each$q(dims, function(dim) {
      var dimIdx = _this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range2[dim];
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
    if (isFunction$h(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    var result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };
  SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map$8(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind$3(cb, fCtx) : cb);
    return list;
  };
  SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map$8(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind$3(cb, fCtx) : cb);
  };
  SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  };
  SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };
  SeriesData2.prototype.getRawDataItem = function(idx) {
    return this._store.getRawDataItem(idx);
  };
  SeriesData2.prototype.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model$1(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  SeriesData2.prototype.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer$1(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  };
  SeriesData2.prototype.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  SeriesData2.prototype.setVisual = function(kvObj, val2) {
    this._visual = this._visual || {};
    if (isObject$d(kvObj)) {
      extend$1(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val2;
    }
  };
  SeriesData2.prototype.getItemVisual = function(idx, key) {
    var itemVisual = this._itemVisuals[idx];
    var val2 = itemVisual && itemVisual[key];
    if (val2 == null) {
      return this.getVisual(key);
    }
    return val2;
  };
  SeriesData2.prototype.hasItemVisual = function() {
    return this._itemVisuals.length > 0;
  };
  SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    var val2 = itemVisual[key];
    if (val2 == null) {
      val2 = this.getVisual(key);
      if (isArray$x(val2)) {
        val2 = val2.slice();
      } else if (isObject$d(val2)) {
        val2 = extend$1({}, val2);
      }
      itemVisual[key] = val2;
    }
    return val2;
  };
  SeriesData2.prototype.setItemVisual = function(idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject$d(key)) {
      extend$1(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  };
  SeriesData2.prototype.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  SeriesData2.prototype.setLayout = function(key, val2) {
    isObject$d(key) ? extend$1(this._layout, key) : this._layout[key] = val2;
  };
  SeriesData2.prototype.getLayout = function(key) {
    return this._layout[key];
  };
  SeriesData2.prototype.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  SeriesData2.prototype.setItemLayout = function(idx, layout2, merge2) {
    this._itemLayouts[idx] = merge2 ? extend$1(this._itemLayouts[idx] || {}, layout2) : layout2;
  };
  SeriesData2.prototype.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  SeriesData2.prototype.setItemGraphicEl = function(idx, el2) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el2);
    this._graphicEls[idx] = el2;
  };
  SeriesData2.prototype.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
    each$q(this._graphicEls, function(el2, idx) {
      if (el2) {
        cb && cb.call(context, el2, idx);
      }
    });
  };
  SeriesData2.prototype.cloneShallow = function(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map$8(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  };
  SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (!isFunction$h(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice$8(arguments)));
    };
  };
  SeriesData2.internalField = function() {
    prepareInvertedIndex = function(data5) {
      var invertedIndicesMap = data5._invertedIndicesMap;
      each$q(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = data5._dimInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data5._store;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i2 = 0; i2 < invertedIndices.length; i2++) {
            invertedIndices[i2] = INDEX_NOT_FOUND;
          }
          for (var i2 = 0; i2 < store.count(); i2++) {
            invertedIndices[store.get(dimInfo.storeDimIndex, i2)] = i2;
          }
        }
      });
    };
    getIdNameFromStore = function(data5, dimIdx, idx) {
      return convertOptionIdName(data5._getCategory(dimIdx, idx), null);
    };
    getId = function(data5, rawIndex) {
      var id2 = data5._idList[rawIndex];
      if (id2 == null && data5._idDimIdx != null) {
        id2 = getIdNameFromStore(data5, data5._idDimIdx, rawIndex);
      }
      if (id2 == null) {
        id2 = ID_PREFIX + rawIndex;
      }
      return id2;
    };
    normalizeDimensions = function(dimensions) {
      if (!isArray$x(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }
      return dimensions;
    };
    cloneListForMapAndSample = function(original) {
      var list = new SeriesData2(original._schema ? original._schema : map$8(original.dimensions, original._getDimInfo, original), original.hostModel);
      transferProperties(list, original);
      return list;
    };
    transferProperties = function(target, source) {
      each$q(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      each$q(CLONE_PROPERTIES, function(propName) {
        target[propName] = clone$8(source[propName]);
      });
      target._calculationInfo = extend$1({}, source._calculationInfo);
    };
    makeIdFromName = function(data5, idx) {
      var nameList = data5._nameList;
      var idList = data5._idList;
      var nameDimIdx = data5._nameDimIdx;
      var idDimIdx = data5._idDimIdx;
      var name2 = nameList[idx];
      var id2 = idList[idx];
      if (name2 == null && nameDimIdx != null) {
        nameList[idx] = name2 = getIdNameFromStore(data5, nameDimIdx, idx);
      }
      if (id2 == null && idDimIdx != null) {
        idList[idx] = id2 = getIdNameFromStore(data5, idDimIdx, idx);
      }
      if (id2 == null && name2 != null) {
        var nameRepeatCount = data5._nameRepeatCount;
        var nmCnt = nameRepeatCount[name2] = (nameRepeatCount[name2] || 0) + 1;
        id2 = name2;
        if (nmCnt > 1) {
          id2 += "__ec__" + nmCnt;
        }
        idList[idx] = id2;
      }
    };
  }();
  return SeriesData2;
}();
var SeriesData$1 = SeriesData;
function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array$1(dimCount);
  for (var i2 = 0; i2 < indicesMap.length; i2++) {
    indicesMap[i2] = -1;
  }
  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];
    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject$f(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem2 = new SeriesDimensionDefine$1();
      var userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem2.name = resultItem2.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem2.storeDimIndex = dimIdx;
      resultList.push(resultItem2);
      return resultItem2;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (var i2 = 0; i2 < dimCount; i2++) {
      getResultItem(i2);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim2) {
    var dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString$d(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim2, false);
      return;
    }
    var validDataDims = encodeDefMap.set(coordDim2, []);
    each$q(dataDims, function(resultDimIdxOrName, idx) {
      var resultDimIdx2 = isString$d(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
        validDataDims[idx] = resultDimIdx2;
        applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
      }
    });
  });
  var availDimIdx = 0;
  each$q(sysDims, function(sysDimItemRaw) {
    var coordDim2;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;
    if (isString$d(sysDimItemRaw)) {
      coordDim2 = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim2 = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend$1({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    var dataDims = encodeDefMap.get(coordDim2);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (var i3 = 0; i3 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i3++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each$q(dataDims, function(resultDimIdx2, coordDimIndex) {
      var resultItem2 = getResultItem(resultDimIdx2);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem2.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
      if (resultItem2.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject$f(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
        resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem2, coordDim2, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
      resultItem2.otherDims[coordDim2] = coordDimIndex;
    } else {
      resultItem2.coordDim = coordDim2;
      resultItem2.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim2, true);
    }
  }
  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem2) {
    if (resultItem2.name == null) {
      resultItem2.name = resultItem2.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each$q(resultList, function(resultItem2) {
      ifNoNameFillWithCoordName(resultItem2);
    });
    resultList.sort(function(item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  var duplicationMap = createHashMap();
  for (var i2 = 0; i2 < result.length; i2++) {
    var dim = result[i2];
    var dimOriginalName = dim.name;
    var count = duplicationMap.get(dimOriginalName) || 0;
    if (count > 0) {
      dim.name = dimOriginalName + (count - 1);
    }
    count++;
    duplicationMap.set(dimOriginalName, count);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each$q(sysDims, function(sysDimItem) {
    var sysDimItemDimsDef;
    if (isObject$f(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name2, map2, fromZero) {
  var mapData = map2.data;
  if (fromZero || mapData.hasOwnProperty(name2)) {
    var i2 = 0;
    while (mapData.hasOwnProperty(name2 + i2)) {
      i2++;
    }
    name2 += i2;
  }
  map2.set(name2, true);
  return name2;
}
var CoordSysInfo = function() {
  function CoordSysInfo2(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
  return CoordSysInfo2;
}();
function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var result = new CoordSysInfo(coordSysName);
  var fetch3 = fetchers[coordSysName];
  if (fetch3) {
    fetch3(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    var angleAxisModel = polarModel.findAxisModel("angleAxis");
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each$q(parallelModel.parallelAxisIndex, function(axisIndex, index) {
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  var mayStack = !!(seriesModel && seriesModel.get("stack"));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each$q(dimensionDefineList, function(dimensionInfo, index) {
    if (isString$d(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each$q(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data5, stackedDim) {
  return !!stackedDim && stackedDim === data5.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data5, targetDim) {
  return isDimensionStacked(data5, targetDim) ? data5.getCalculationInfo("stackResultDimension") : targetDim;
}
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map$9(coordSysInfo.coordSysDims, function(dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        var axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each$q(dimInfoList, function(dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source;
  var isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction$h(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema,
    store
  });
  var data5 = new SeriesData$1(schema, seriesModel);
  data5.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data5.hasItemOption = false;
  data5.initData(
    isOriginalSource ? source : store,
    null,
    dimValueGetter
  );
  return data5;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return !isArray$x(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  var i2 = 0;
  while (i2 < arr.length && arr[i2] == null) {
    i2++;
  }
  return arr[i2];
}
var Scale = function() {
  function Scale2(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }
  Scale2.prototype.getSetting = function(name2) {
    return this._setting[name2];
  };
  Scale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  };
  Scale2.prototype.unionExtentFromData = function(data5, dim) {
    this.unionExtent(data5.getApproximateExtent(dim));
  };
  Scale2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  };
  Scale2.prototype.isInExtentRange = function(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  Scale2.prototype.isBlank = function() {
    return this._isBlank;
  };
  Scale2.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  return Scale2;
}();
enableClassManagement(Scale);
var Scale$1 = Scale;
var uidBase = 0;
var OrdinalMeta = function() {
  function OrdinalMeta2(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  OrdinalMeta2.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data5 = option.data;
    var categories = data5 && map$9(data5, getName$2);
    return new OrdinalMeta2({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  };
  OrdinalMeta2.prototype.getOrdinal = function(category) {
    return this._getOrCreateMap().get(category);
  };
  OrdinalMeta2.prototype.parseAndCollect = function(category) {
    var index;
    var needCollect = this._needCollect;
    if (!isString$d(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }
    var map2 = this._getOrCreateMap();
    index = map2.get(category);
    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map2.set(category, index);
      } else {
        index = NaN;
      }
    }
    return index;
  };
  OrdinalMeta2.prototype._getOrCreateMap = function() {
    return this._map || (this._map = createHashMap(this.categories));
  };
  return OrdinalMeta2;
}();
function getName$2(obj) {
  if (isObject$f(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta$1 = OrdinalMeta;
function isIntervalOrLogScale(scale2) {
  return scale2.type === "interval" || scale2.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent3[1] - extent3[0];
  var interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  var precision = result.intervalPrecision = getIntervalPrecision(interval);
  var niceTickExtent = result.niceTickExtent = [round$5(Math.ceil(extent3[0] / interval) * interval, precision), round$5(Math.floor(extent3[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval));
  var f2 = interval / exp10;
  if (!f2) {
    f2 = 1;
  } else if (f2 === 2) {
    f2 = 3;
  } else if (f2 === 3) {
    f2 = 5;
  } else {
    f2 *= 2;
  }
  return round$5(f2 * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp(niceTickExtent, 0, extent3);
  clamp(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain$1(val2, extent3) {
  return val2 >= extent3[0] && val2 <= extent3[1];
}
function normalize(val2, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val2 - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale(val2, extent3) {
  return val2 * (extent3[1] - extent3[0]) + extent3[0];
}
var OrdinalScale = function(_super) {
  __extends(OrdinalScale2, _super);
  function OrdinalScale2(setting) {
    var _this = _super.call(this, setting) || this;
    _this.type = "ordinal";
    var ordinalMeta = _this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta$1({});
    }
    if (isArray$x(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta$1({
        categories: map$9(ordinalMeta, function(item) {
          return isObject$f(item) ? item.value : item;
        })
      });
    }
    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
    return _this;
  }
  OrdinalScale2.prototype.parse = function(val2) {
    if (val2 == null) {
      return NaN;
    }
    return isString$d(val2) ? this._ordinalMeta.getOrdinal(val2) : Math.round(val2);
  };
  OrdinalScale2.prototype.contain = function(rank) {
    rank = this.parse(rank);
    return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  };
  OrdinalScale2.prototype.normalize = function(val2) {
    val2 = this._getTickNumber(this.parse(val2));
    return normalize(val2, this._extent);
  };
  OrdinalScale2.prototype.scale = function(val2) {
    val2 = Math.round(scale(val2, this._extent));
    return this.getRawOrdinalNumber(val2);
  };
  OrdinalScale2.prototype.getTicks = function() {
    var ticks = [];
    var extent3 = this._extent;
    var rank = extent3[0];
    while (rank <= extent3[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  };
  OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
    return;
  };
  OrdinalScale2.prototype.setSortInfo = function(info2) {
    if (info2 == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    var infoOrdinalNumbers = info2.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = [];
    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;
    for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    var unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };
  OrdinalScale2.prototype._getTickNumber = function(ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  OrdinalScale2.prototype.getLabel = function(tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  };
  OrdinalScale2.prototype.count = function() {
    return this._extent[1] - this._extent[0] + 1;
  };
  OrdinalScale2.prototype.unionExtentFromData = function(data5, dim) {
    this.unionExtent(data5.getApproximateExtent(dim));
  };
  OrdinalScale2.prototype.isInExtentRange = function(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  OrdinalScale2.prototype.getOrdinalMeta = function() {
    return this._ordinalMeta;
  };
  OrdinalScale2.prototype.calcNiceTicks = function() {
  };
  OrdinalScale2.prototype.calcNiceExtent = function() {
  };
  OrdinalScale2.type = "ordinal";
  return OrdinalScale2;
}(Scale$1);
Scale$1.registerClass(OrdinalScale);
var OrdinalScale$1 = OrdinalScale;
var roundNumber = round$5;
var IntervalScale = function(_super) {
  __extends(IntervalScale2, _super);
  function IntervalScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "interval";
    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }
  IntervalScale2.prototype.parse = function(val2) {
    return val2;
  };
  IntervalScale2.prototype.contain = function(val2) {
    return contain$1(val2, this._extent);
  };
  IntervalScale2.prototype.normalize = function(val2) {
    return normalize(val2, this._extent);
  };
  IntervalScale2.prototype.scale = function(val2) {
    return scale(val2, this._extent);
  };
  IntervalScale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  };
  IntervalScale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  };
  IntervalScale2.prototype.getInterval = function() {
    return this._interval;
  };
  IntervalScale2.prototype.setInterval = function(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
    var interval = this._interval;
    var extent3 = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    var safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    var tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  };
  IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent3 = this.getExtent();
    for (var i2 = 1; i2 < ticks.length; i2++) {
      var nextTick2 = ticks[i2];
      var prevTick = ticks[i2 - 1];
      var count = 0;
      var minorTicksGroup = [];
      var interval = nextTick2.value - prevTick.value;
      var minorInterval = interval / splitNumber;
      while (count < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  };
  IntervalScale2.prototype.getLabel = function(data5, opt) {
    if (data5 == null) {
      return "";
    }
    var precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data5.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    var dataNum = roundNumber(data5.value, precision, true);
    return addCommas(dataNum);
  };
  IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };
  IntervalScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        var expandSize = extent3[0];
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    var interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  };
  IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
    this._niceExtent = [min3, max3];
  };
  IntervalScale2.type = "interval";
  return IntervalScale2;
}(Scale$1);
Scale$1.registerClass(IntervalScale);
var IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray$x(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey(axis) {
  return axis.dim + axis.index;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  var axisValues = {};
  each$q(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    var data5 = seriesModel.getData();
    var key2 = baseAxis.dim + "_" + baseAxis.index;
    var dimIdx = data5.getDimensionIndex(data5.mapDimension(baseAxis.dim));
    var store = data5.getStore();
    for (var i2 = 0, cnt = store.count(); i2 < cnt; ++i2) {
      var value = store.get(dimIdx, i2);
      if (!axisValues[key2]) {
        axisValues[key2] = [value];
      } else {
        axisValues[key2].push(value);
      }
    }
  });
  var axisMinGaps = {};
  for (var key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      var valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a2, b2) {
          return a2 - b2;
        });
        var min3 = null;
        for (var j2 = 1; j2 < valuesInAxis.length; ++j2) {
          var delta = valuesInAxis[j2] - valuesInAxis[j2 - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each$q(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      var key = baseAxis.dim + "_" + baseAxis.index;
      var minGap = axisMinGaps[key];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale2 = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale2[1] - scale2[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      var data5 = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data5.count();
    }
    var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
    var barMinWidth = parsePercent(
      seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1),
      bandWidth
    );
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  var columnsMap = {};
  each$q(seriesInfoList, function(seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$q(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      var columnCount = keys$d(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    var categoryGap = parsePercent(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$q(stacks, function(column2) {
      var maxWidth = column2.maxWidth;
      var minWidth = column2.minWidth;
      if (!column2.width) {
        var finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column2.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        var finalWidth = column2.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column2.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$q(stacks, function(column2, idx) {
      if (!column2.width) {
        column2.width = autoWidth;
      }
      lastColumn = column2;
      widthSum += column2.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset2 = -widthSum / 2;
    each$q(stacks, function(column2, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset: offset2,
        width: column2.width
      };
      offset2 += column2.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId(seriesModel)];
    }
    return result;
  }
}
function layout$1(seriesType2, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each$q(seriesModels, function(seriesModel) {
    var data5 = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data5.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      var data5 = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis2 = cartesian.getOtherAxis(baseAxis);
      var valueDimIdx = data5.getDimensionIndex(data5.mapDimension(valueAxis2.dim));
      var baseDimIdx = data5.getDimensionIndex(data5.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get("showBackground", true);
      var valueDim = data5.mapDimension(valueAxis2.dim);
      var stackResultDim = data5.getCalculationInfo("stackResultDimension");
      var stacked = isDimensionStacked(data5, valueDim) && !!data5.getCalculationInfo("stackedOnSeries");
      var isValueAxisH = valueAxis2.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var stackedDimIdx = stackResultDim && data5.getDimensionIndex(stackResultDim);
      var columnWidth = data5.getLayout("size");
      var columnOffset = data5.getLayout("offset");
      return {
        progress: function(params, data6) {
          var count = params.count;
          var largePoints = isLarge && createFloat32Array(count * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3);
          var largeDataIndices = isLarge && createFloat32Array(count);
          var coordLayout = cartesian.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data6.getStore();
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var startValue = void 0;
            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }
            var x2 = void 0;
            var y2 = void 0;
            var width2 = void 0;
            var height2 = void 0;
            if (isValueAxisH) {
              var coord = cartesian.dataToPoint([value, baseValue]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x2 = baseCoord;
              y2 = coord[1] + columnOffset;
              width2 = coord[0] - baseCoord;
              height2 = columnWidth;
              if (Math.abs(width2) < barMinHeight) {
                width2 = (width2 < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian.dataToPoint([baseValue, value]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }
              x2 = coord[0] + columnOffset;
              y2 = baseCoord;
              width2 = columnWidth;
              height2 = coord[1] - baseCoord;
              if (Math.abs(height2) < barMinHeight) {
                height2 = (height2 <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data6.setItemLayout(dataIndex, {
                x: x2,
                y: y2,
                width: width2,
                height: height2
              });
            } else {
              largePoints[idxOffset] = x2;
              largePoints[idxOffset + 1] = y2;
              largePoints[idxOffset + 2] = isValueAxisH ? width2 : height2;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x2;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y2 : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data6.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
}
var bisect = function(a2, x2, lo2, hi2) {
  while (lo2 < hi2) {
    var mid = lo2 + hi2 >>> 1;
    if (a2[mid][1] < x2) {
      lo2 = mid + 1;
    } else {
      hi2 = mid;
    }
  }
  return lo2;
};
var TimeScale = function(_super) {
  __extends(TimeScale2, _super);
  function TimeScale2(settings) {
    var _this = _super.call(this, settings) || this;
    _this.type = "time";
    return _this;
  }
  TimeScale2.prototype.getLabel = function(tick) {
    var useUTC = this.getSetting("useUTC");
    return format$1(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  };
  TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
    var isUTC = this.getSetting("useUTC");
    var lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  TimeScale2.prototype.getTicks = function() {
    var interval = this._interval;
    var extent3 = this._extent;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    var useUTC = this.getSetting("useUTC");
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  };
  TimeScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      var d3 = new Date();
      extent3[1] = +new Date(d3.getFullYear(), d3.getMonth(), d3.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };
  TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };
  TimeScale2.prototype.parse = function(val2) {
    return isNumber$c(val2) ? val2 : +parseDate$1(val2);
  };
  TimeScale2.prototype.contain = function(val2) {
    return contain$1(this.parse(val2), this._extent);
  };
  TimeScale2.prototype.normalize = function(val2) {
    return normalize(this.parse(val2), this._extent);
  };
  TimeScale2.prototype.scale = function(val2) {
    return scale(val2, this._extent);
  };
  TimeScale2.type = "time";
  return TimeScale2;
}(IntervalScale$1);
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate$1(valueA);
  var dateB = parseDate$1(valueB);
  var isSame = function(unit2) {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  var isSameYear = function() {
    return isSame("year");
  };
  var isSameMonth = function() {
    return isSameYear() && isSame("month");
  };
  var isSameDay = function() {
    return isSameMonth() && isSame("day");
  };
  var isSameHour = function() {
    return isSameDay() && isSame("hour");
  };
  var isSameMinute = function() {
    return isSameHour() && isSame("minute");
  };
  var isSameSecond = function() {
    return isSameMinute() && isSame("second");
  };
  var isSameMilliSecond = function() {
    return isSameSecond() && isSame("millisecond");
  };
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  var safeLimit = 1e4;
  var unitNames = timeUnits;
  var iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate2, out2) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d3 = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d3 += interval;
      date[setMethodName](d3);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (var i3 = 0; i3 < lastLevelTicks.length - 1; i3++) {
      var startTick = lastLevelTicks[i3].value;
      var endTick = lastLevelTicks[i3 + 1].value;
      if (startTick === endTick) {
        continue;
      }
      var interval = void 0;
      var getterName = void 0;
      var setterName = void 0;
      var isDate2 = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate2 = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate2, newAddedTicks);
      if (unitName === "year" && levelTicks2.length > 1 && i3 === 0) {
        levelTicks2.unshift({
          value: levelTicks2[0].value - interval
        });
      }
    }
    for (var i3 = 0; i3 < newAddedTicks.length; i3++) {
      levelTicks2.push(newAddedTicks[i3]);
    }
    return newAddedTicks;
  }
  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;
  for (var i2 = 0; i2 < unitNames.length && iter++ < safeLimit; ++i2) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i2]);
    if (!isPrimaryTimeUnit(unitNames[i2])) {
      continue;
    }
    addLevelTicks(unitNames[i2], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i2 + 1] ? getPrimaryTimeUnit(unitNames[i2 + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort(function(a2, b2) {
          return a2.value - b2.value;
        });
        var levelTicksRemoveDuplicated = [];
        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;
          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i2]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  var levelsTicksInExtent = filter$3(map$9(levelsTicks, function(levelTicks2) {
    return filter$3(levelTicks2, function(tick) {
      return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
    });
  }), function(levelTicks2) {
    return levelTicks2.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;
  for (var i2 = 0; i2 < levelsTicksInExtent.length; ++i2) {
    var levelTicks = levelsTicksInExtent[i2];
    for (var k2 = 0; k2 < levelTicks.length; ++k2) {
      ticks.push({
        value: levelTicks[k2].value,
        level: maxLevel - i2
      });
    }
  }
  ticks.sort(function(a2, b2) {
    return a2.value - b2.value;
  });
  var result = [];
  for (var i2 = 0; i2 < ticks.length; ++i2) {
    if (i2 === 0 || ticks[i2].value !== ticks[i2 - 1].value) {
      result.push(ticks[i2]);
    }
  }
  return result;
}
Scale$1.registerClass(TimeScale);
var TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype;
var intervalScaleProto = IntervalScale$1.prototype;
var roundingErrorFix = round$5;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow = Math.pow;
var mathLog$1 = Math.log;
var LogScale = function(_super) {
  __extends(LogScale2, _super);
  function LogScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    _this.base = 10;
    _this._originalScale = new IntervalScale$1();
    _this._interval = 0;
    return _this;
  }
  LogScale2.prototype.getTicks = function(expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent3 = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map$9(ticks, function(tick) {
      var val2 = tick.value;
      var powVal = round$5(mathPow(this.base, val2));
      powVal = val2 === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val2 === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };
  LogScale2.prototype.setExtent = function(start2, end2) {
    var base2 = this.base;
    start2 = mathLog$1(start2) / mathLog$1(base2);
    end2 = mathLog$1(end2) / mathLog$1(base2);
    intervalScaleProto.setExtent.call(this, start2, end2);
  };
  LogScale2.prototype.getExtent = function() {
    var base2 = this.base;
    var extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow(base2, extent3[0]);
    extent3[1] = mathPow(base2, extent3[1]);
    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  };
  LogScale2.prototype.unionExtent = function(extent3) {
    this._originalScale.unionExtent(extent3);
    var base2 = this.base;
    extent3[0] = mathLog$1(extent3[0]) / mathLog$1(base2);
    extent3[1] = mathLog$1(extent3[1]) / mathLog$1(base2);
    scaleProto.unionExtent.call(this, extent3);
  };
  LogScale2.prototype.unionExtentFromData = function(data5, dim) {
    this.unionExtent(data5.getApproximateExtent(dim));
  };
  LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    var interval = quantity(span);
    var err2 = approxTickNum / span * interval;
    if (err2 <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    var niceExtent = [round$5(mathCeil(extent3[0] / interval) * interval), round$5(mathFloor(extent3[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };
  LogScale2.prototype.calcNiceExtent = function(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };
  LogScale2.prototype.parse = function(val2) {
    return val2;
  };
  LogScale2.prototype.contain = function(val2) {
    val2 = mathLog$1(val2) / mathLog$1(this.base);
    return contain$1(val2, this._extent);
  };
  LogScale2.prototype.normalize = function(val2) {
    val2 = mathLog$1(val2) / mathLog$1(this.base);
    return normalize(val2, this._extent);
  };
  LogScale2.prototype.scale = function(val2) {
    val2 = scale(val2, this._extent);
    return mathPow(this.base, val2);
  };
  LogScale2.type = "log";
  return LogScale2;
}(Scale$1);
var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val2, originalVal) {
  return roundingErrorFix(val2, getPrecision(originalVal));
}
Scale$1.registerClass(LogScale);
var LogScale$1 = LogScale;
var ScaleRawExtentInfo = function() {
  function ScaleRawExtentInfo2(scale2, model, originalExtent) {
    this._prepareParams(scale2, model, originalExtent);
  }
  ScaleRawExtentInfo2.prototype._prepareParams = function(scale2, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale2.type === "ordinal";
    this._needCrossZero = scale2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    var modelMinRaw = this._modelMinRaw = model.get("min", true);
    if (isFunction$h(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw);
    }
    var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction$h(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get("boundaryGap");
      var boundaryGapArr = isArray$x(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent$1(boundaryGapArr[0], 1), parsePercent$1(boundaryGapArr[1], 1)];
      }
    }
  };
  ScaleRawExtentInfo2.prototype.calculate = function() {
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    var minFixed = min3 != null;
    var maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  };
  ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val2) {
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val2;
  };
  ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val2) {
    var attr2 = DETERMINED_MIN_MAX_ATTR[minMaxName];
    this[attr2] = val2;
  };
  ScaleRawExtentInfo2.prototype.freeze = function() {
    this.frozen = true;
  };
  return ScaleRawExtentInfo2;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(scale2, model, originalExtent) {
  var rawExtentInfo = scale2.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale2, model, originalExtent);
  scale2.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale2, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale2.parse(minMax);
}
function getScaleExtent(scale2, model) {
  var scaleType = scale2.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale2, model, scale2.getExtent()).calculate();
  scale2.setBlank(rawExtentResult.isBlank);
  var min3 = rawExtentResult.min;
  var max3 = rawExtentResult.max;
  var ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each$q(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries_1) {
      var barWidthAndOffset = makeColumnLayout(barSeriesModels);
      var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0];
  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {
      min: min3,
      max: max3
    };
  }
  var minOverflow = Infinity;
  each$q(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each$q(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow;
  var oldRange = max3 - min3;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min3,
    max: max3
  };
}
function niceScaleExtent(scale2, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale2, model);
  var extent3 = extentInfo.extent;
  var splitNumber = model.get("splitNumber");
  if (scale2 instanceof LogScale$1) {
    scale2.base = model.get("logBase");
  }
  var scaleType = scale2.type;
  var interval = model.get("interval");
  var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale2.setExtent(extent3[0], extent3[1]);
  scale2.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale2.setInterval && scale2.setInterval(interval);
  }
}
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(axisType) || IntervalScale$1)();
    }
  }
}
function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min3 = dataExtent[0];
  var max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get("formatter");
  var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString$d(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text2 = tpl.replace("{value}", label != null ? label : "");
        return text2;
      };
    }(labelFormatter);
  } else if (isFunction$h(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale2 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale2.isBlank()) {
    return;
  }
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale2.getExtent();
  if (scale2 instanceof OrdinalScale$1) {
    tickCount = scale2.count();
  } else {
    realNumberScaleTicks = scale2.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (var i2 = 0; i2 < tickCount; i2 += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i2] : {
      value: categoryScaleExtent[0] + i2
    };
    var label = labelFormatter(tick, i2);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  var rotateRadians = rotate2 * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  var rotatedRect = new BoundingRect$1(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  var interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data5, axisDim) {
  var dataDimMap = {};
  each$q(data5.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data5, dataDim)] = true;
  });
  return keys$d(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data5, axisDim) {
  if (data5) {
    each$q(getDataDimensionsOnAxis(data5, axisDim), function(dim) {
      var seriesExtent = data5.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}
var AxisModelCommonMixin = function() {
  function AxisModelCommonMixin2() {
  }
  AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
    var option = this.option;
    return !option.scale;
  };
  AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
    return;
  };
  return AxisModelCommonMixin2;
}();
function createList(seriesModel) {
  return createSeriesData(null, seriesModel);
}
var dataStack = {
  isDimensionStacked,
  enableDataStack,
  getStackedDimension
};
function createScale(dataExtent, option) {
  var axisModel = option;
  if (!(option instanceof Model$1)) {
    axisModel = new Model$1(option);
  }
  var scale2 = createScaleByModel(axisModel);
  scale2.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale2, axisModel);
  return scale2;
}
function mixinAxisModelCommonMethods(Model2) {
  mixin$1(Model2, AxisModelCommonMixin);
}
function createTextStyle(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle$1(textStyleModel, null, null, opts.state !== "normal");
}
var helper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createList,
  getLayoutRect,
  dataStack,
  createScale,
  mixinAxisModelCommonMethods,
  getECData,
  createTextStyle,
  createDimensions,
  createSymbol,
  enableHoverEmphasis
}, Symbol.toStringTag, { value: "Module" }));
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  registerComponentModel: function(ComponentModelClass) {
    ComponentModel$1.registerClass(ComponentModelClass);
  },
  registerComponentView: function(ComponentViewClass) {
    ComponentView$1.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function(SeriesModelClass) {
    SeriesModel$1.registerClass(SeriesModelClass);
  },
  registerChartView: function(ChartViewClass) {
    ChartView$1.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function(componentType, defaulter) {
    ComponentModel$1.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use$1(ext) {
  if (isArray$x(ext)) {
    each$q(ext, function(singleExt) {
      use$1(singleExt);
    });
    return;
  }
  if (indexOf$2(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction$h(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}
var EPSILON = 1e-8;
function isAroundEqual(a2, b2) {
  return Math.abs(a2 - b2) < EPSILON;
}
function contain(points2, x2, y2) {
  var w2 = 0;
  var p2 = points2[0];
  if (!p2) {
    return false;
  }
  for (var i2 = 1; i2 < points2.length; i2++) {
    var p22 = points2[i2];
    w2 += windingLine(p2[0], p2[1], p22[0], p22[1], x2, y2);
    p2 = p22;
  }
  var p0 = points2[0];
  if (!isAroundEqual(p2[0], p0[0]) || !isAroundEqual(p2[1], p0[1])) {
    w2 += windingLine(p2[0], p2[1], p0[0], p0[1], x2, y2);
  }
  return w2 !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(points2, transform) {
  for (var p2 = 0; p2 < points2.length; p2++) {
    applyTransform$1(points2[p2], points2[p2], transform);
  }
}
function updateBBoxFromPoints(points2, min3, max3, projection) {
  for (var i2 = 0; i2 < points2.length; i2++) {
    var p2 = points2[i2];
    if (projection) {
      p2 = projection.project(p2);
    }
    if (p2 && isFinite(p2[0]) && isFinite(p2[1])) {
      min$3(min3, min3, p2);
      max$4(max3, max3, p2);
    }
  }
}
function centroid$1(points2) {
  var signedArea = 0;
  var cx = 0;
  var cy = 0;
  var len2 = points2.length;
  var x0 = points2[len2 - 1][0];
  var y0 = points2[len2 - 1][1];
  for (var i2 = 0; i2 < len2; i2++) {
    var x1 = points2[i2][0];
    var y1 = points2[i2][1];
    var a2 = x0 * y1 - x1 * y0;
    signedArea += a2;
    cx += (x0 + x1) * a2;
    cy += (y0 + y1) * a2;
    x0 = x1;
    y0 = y1;
  }
  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points2[0][0] || 0, points2[0][1] || 0];
}
var Region = function() {
  function Region2(name2) {
    this.name = name2;
  }
  Region2.prototype.setCenter = function(center2) {
    this._center = center2;
  };
  Region2.prototype.getCenter = function() {
    var center2 = this._center;
    if (!center2) {
      center2 = this._center = this.calcCenter();
    }
    return center2;
  };
  return Region2;
}();
var GeoJSONPolygonGeometry = function() {
  function GeoJSONPolygonGeometry2(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
  return GeoJSONPolygonGeometry2;
}();
var GeoJSONLineStringGeometry = function() {
  function GeoJSONLineStringGeometry2(points2) {
    this.type = "linestring";
    this.points = points2;
  }
  return GeoJSONLineStringGeometry2;
}();
var GeoJSONRegion = function(_super) {
  __extends(GeoJSONRegion2, _super);
  function GeoJSONRegion2(name2, geometries, cp2) {
    var _this = _super.call(this, name2) || this;
    _this.type = "geoJSON";
    _this.geometries = geometries;
    _this._center = cp2 && [cp2[0], cp2[1]];
    return _this;
  }
  GeoJSONRegion2.prototype.calcCenter = function() {
    var geometries = this.geometries;
    var largestGeo;
    var largestGeoSize = 0;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geo = geometries[i2];
      var exterior = geo.exterior;
      var size = exterior && exterior.length;
      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }
    if (largestGeo) {
      return centroid$1(largestGeo.exterior);
    }
    var rect = this.getBoundingRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.getBoundingRect = function(projection) {
    var rect = this._rect;
    if (rect && !projection) {
      return rect;
    }
    var min3 = [Infinity, Infinity];
    var max3 = [-Infinity, -Infinity];
    var geometries = this.geometries;
    each$q(geometries, function(geo) {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min3, max3, projection);
      } else {
        each$q(geo.points, function(points2) {
          updateBBoxFromPoints(points2, min3, max3, projection);
        });
      }
    });
    if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
      min3[0] = min3[1] = max3[0] = max3[1] = 0;
    }
    rect = new BoundingRect$1(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    if (!projection) {
      this._rect = rect;
    }
    return rect;
  };
  GeoJSONRegion2.prototype.contain = function(coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (var i2 = 0, len2 = geometries.length; i2 < len2; i2++) {
        var geo = geometries[i2];
        if (geo.type !== "polygon") {
          continue;
        }
        var exterior = geo.exterior;
        var interiors = geo.interiors;
        if (contain(exterior, coord[0], coord[1])) {
          for (var k2 = 0; k2 < (interiors ? interiors.length : 0); k2++) {
            if (contain(interiors[k2], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  };
  GeoJSONRegion2.prototype.transformTo = function(x2, y2, width2, height2) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;
    if (!width2) {
      width2 = aspect * height2;
    } else if (!height2) {
      height2 = width2 / aspect;
    }
    var target = new BoundingRect$1(x2, y2, width2, height2);
    var transform = rect.calculateTransform(target);
    var geometries = this.geometries;
    for (var i2 = 0; i2 < geometries.length; i2++) {
      var geo = geometries[i2];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform);
        each$q(geo.interiors, function(interior) {
          transformPoints(interior, transform);
        });
      } else {
        each$q(geo.points, function(points2) {
          transformPoints(points2, transform);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.cloneShallow = function(name2) {
    name2 == null && (name2 = this.name);
    var newRegion = new GeoJSONRegion2(name2, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  };
  return GeoJSONRegion2;
}(Region);
(function(_super) {
  __extends(GeoSVGRegion, _super);
  function GeoSVGRegion(name2, elOnlyForCalculate) {
    var _this = _super.call(this, name2) || this;
    _this.type = "geoSVG";
    _this._elOnlyForCalculate = elOnlyForCalculate;
    return _this;
  }
  GeoSVGRegion.prototype.calcCenter = function() {
    var el2 = this._elOnlyForCalculate;
    var rect = el2.getBoundingRect();
    var center2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    var mat = identity$2(TMP_TRANSFORM);
    var target = el2;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform$1(center2, center2, mat);
    return center2;
  };
  return GeoSVGRegion;
})(Region);
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  var jsonCompressed = json;
  var encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  var features = jsonCompressed.features;
  each$q(features, function(feature) {
    var geometry = feature.geometry;
    var encodeOffsets = geometry.encodeOffsets;
    var coordinates = geometry.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry.type) {
      case "LineString":
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each$q(coordinates, function(rings, idx) {
          return decodeRings(rings, encodeOffsets[idx], encodeScale);
        });
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (var c2 = 0; c2 < rings.length; c2++) {
    rings[c2] = decodeRing(rings[c2], encodeOffsets[c2], encodeScale);
  }
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];
  for (var i2 = 0; i2 < coordinate.length; i2 += 2) {
    var x2 = coordinate.charCodeAt(i2) - 64;
    var y2 = coordinate.charCodeAt(i2 + 1) - 64;
    x2 = x2 >> 1 ^ -(x2 & 1);
    y2 = y2 >> 1 ^ -(y2 & 1);
    x2 += prevX;
    y2 += prevY;
    prevX = x2;
    prevY = y2;
    result.push([x2 / encodeScale, y2 / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map$9(filter$3(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var geometries = [];
    switch (geo.type) {
      case "Polygon":
        var coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each$q(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}
var number = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  linearMap,
  round: round$5,
  asc: asc$1,
  getPrecision,
  getPrecisionSafe,
  getPixelPrecision,
  getPercentWithPrecision,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2,
  remRadian,
  isRadianAroundZero,
  parseDate: parseDate$1,
  quantity,
  quantityExponent,
  nice,
  quantile,
  reformIntervals,
  isNumeric,
  numericToNumber
}, Symbol.toStringTag, { value: "Module" }));
var time = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parse: parseDate$1,
  format: format$1
}, Symbol.toStringTag, { value: "Module" }));
var graphic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  extendShape,
  extendPath,
  makePath,
  makeImage,
  mergePath,
  resizePath,
  createIcon,
  updateProps: updateProps$2,
  initProps,
  getTransform,
  clipPointsByRect,
  clipRectByRect,
  registerShape,
  getShapeClass,
  Group: Group$3,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$1,
  Rect: Rect$2,
  Line: Line$1,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1
}, Symbol.toStringTag, { value: "Module" }));
var format = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCommas,
  toCamelCase: toCamelCase$1,
  normalizeCssArray,
  encodeHTML,
  formatTpl,
  getTooltipMarker,
  formatTime,
  capitalFirst,
  truncateText,
  getTextRect
}, Symbol.toStringTag, { value: "Module" }));
var util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  map: map$9,
  each: each$q,
  indexOf: indexOf$2,
  inherits,
  reduce: reduce$2,
  filter: filter$3,
  bind: bind$3,
  curry: curry$1,
  isArray: isArray$x,
  isString: isString$d,
  isObject: isObject$f,
  isFunction: isFunction$h,
  extend: extend$1,
  defaults,
  clone: clone$8,
  merge: merge$2
}, Symbol.toStringTag, { value: "Module" }));
var inner$5 = makeInner();
function createAxisLabels(axis) {
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
    ticks: map$9(axis.scale.getTicks(), function(tick) {
      return tick.value;
    })
  };
}
function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, "labels");
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet$1(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  var labels;
  var numericLabelInterval;
  if (isFunction$h(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet$1(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, "ticks");
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet$1(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  var ticks;
  var tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction$h(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map$9(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet$1(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map$9(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner$5(axis)[prop] || (inner$5(axis)[prop] = []);
}
function listCacheGet$1(cache2, key) {
  for (var i2 = 0; i2 < cache2.length; i2++) {
    if (cache2[i2].key === key) {
      return cache2[i2].value;
    }
  }
}
function listCacheSet$1(cache2, key, value) {
  cache2.push({
    key,
    value
  });
  return value;
}
function makeAutoCategoryInterval(axis) {
  var result = inner$5(axis).autoInterval;
  return result != null ? result : inner$5(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  var step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width2 = 0;
    var height2 = 0;
    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, "center", "top");
    width2 = rect.width * 1.3;
    height2 = rect.height * 1.3;
    maxW = Math.max(maxW, width2, 7);
    maxH = Math.max(maxH, height2, 7);
  }
  var dw = maxW / unitW;
  var dh2 = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh2) && (dh2 = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh2)));
  var cache2 = inner$5(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache2.lastAutoInterval;
  var lastTickCount = cache2.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache2.axisExtent0 === axisExtent[0] && cache2.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache2.lastTickCount = tickCount;
    cache2.lastAutoInterval = interval;
    cache2.axisExtent0 = axisExtent[0];
    cache2.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = [];
  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  var tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    var tickObj = {
      value: tickValue2
    };
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each$q(ordinalScale.getTicks(), function(tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}
var NORMALIZED_EXTENT = [0, 1];
var Axis = function() {
  function Axis2(dim, scale2, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale2;
    this._extent = extent3 || [0, 0];
  }
  Axis2.prototype.contain = function(coord) {
    var extent3 = this._extent;
    var min3 = Math.min(extent3[0], extent3[1]);
    var max3 = Math.max(extent3[0], extent3[1]);
    return coord >= min3 && coord <= max3;
  };
  Axis2.prototype.containData = function(data5) {
    return this.scale.contain(data5);
  };
  Axis2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Axis2.prototype.getPixelPrecision = function(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  Axis2.prototype.setExtent = function(start2, end2) {
    var extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  };
  Axis2.prototype.dataToCoord = function(data5, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    data5 = scale2.normalize(data5);
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    return linearMap(data5, NORMALIZED_EXTENT, extent3, clamp2);
  };
  Axis2.prototype.coordToData = function(coord, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    var t2 = linearMap(coord, extent3, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t2);
  };
  Axis2.prototype.pointToData = function(point, clamp2) {
    return;
  };
  Axis2.prototype.getTicksCoords = function(opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map$9(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };
  Axis2.prototype.getMinorTicksCoords = function() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    var minorTickModel = this.model.getModel("minorTick");
    var splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map$9(minorTicks, function(minorTicksGroup) {
      return map$9(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };
  Axis2.prototype.getViewLabels = function() {
    return createAxisLabels(this).labels;
  };
  Axis2.prototype.getLabelModel = function() {
    return this.model.getModel("axisLabel");
  };
  Axis2.prototype.getTickModel = function() {
    return this.model.getModel("axisTick");
  };
  Axis2.prototype.getBandWidth = function() {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  };
  Axis2.prototype.calculateCategoryInterval = function() {
    return calculateCategoryInterval(this);
  };
  return Axis2;
}();
function fixExtentWithBands(extent3, nTick) {
  var size = extent3[1] - extent3[0];
  var len2 = nTick;
  var margin = size / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  var ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  var axisExtent = axis.getExtent();
  var last2;
  var diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last2 = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each$q(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last2 = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
    };
    ticksCoords.push(last2);
  }
  var inverse = axisExtent[0] > axisExtent[1];
  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }
  if (littleThan(axisExtent[1], last2.coord)) {
    clamp2 ? last2.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan(last2.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }
  function littleThan(a2, b2) {
    a2 = round$5(a2);
    b2 = round$5(b2);
    return inverse ? a2 > b2 : a2 < b2;
  }
}
var Axis$1 = Axis;
function extendComponentModel(proto2) {
  var Model2 = ComponentModel$1.extend(proto2);
  ComponentModel$1.registerClass(Model2);
  return Model2;
}
function extendComponentView(proto2) {
  var View = ComponentView$1.extend(proto2);
  ComponentView$1.registerClass(View);
  return View;
}
function extendSeriesModel(proto2) {
  var Model2 = SeriesModel$1.extend(proto2);
  SeriesModel$1.registerClass(Model2);
  return Model2;
}
function extendChartView(proto2) {
  var View = ChartView$1.extend(proto2);
  ChartView$1.registerClass(View);
  return View;
}
var PI2$1 = Math.PI * 2;
var CMD$1 = PathProxy$1.CMD;
var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
  var width2 = rect.width;
  var height2 = rect.height;
  switch (pos) {
    case "top":
      outPt.set(rect.x + width2 / 2, rect.y - distance2);
      outDir.set(0, -1);
      break;
    case "bottom":
      outPt.set(rect.x + width2 / 2, rect.y + height2 + distance2);
      outDir.set(0, 1);
      break;
    case "left":
      outPt.set(rect.x - distance2, rect.y + height2 / 2);
      outDir.set(-1, 0);
      break;
    case "right":
      outPt.set(rect.x + width2 + distance2, rect.y + height2 / 2);
      outDir.set(1, 0);
      break;
  }
}
function projectPointToArc(cx, cy, r2, startAngle, endAngle, anticlockwise, x2, y2, out2) {
  x2 -= cx;
  y2 -= cy;
  var d3 = Math.sqrt(x2 * x2 + y2 * y2);
  x2 /= d3;
  y2 /= d3;
  var ox = x2 * r2 + cx;
  var oy = y2 * r2 + cy;
  if (Math.abs(startAngle - endAngle) % PI2$1 < 1e-4) {
    out2[0] = ox;
    out2[1] = oy;
    return d3 - r2;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$1;
  }
  var angle = Math.atan2(y2, x2);
  if (angle < 0) {
    angle += PI2$1;
  }
  if (angle >= startAngle && angle <= endAngle || angle + PI2$1 >= startAngle && angle + PI2$1 <= endAngle) {
    out2[0] = ox;
    out2[1] = oy;
    return d3 - r2;
  }
  var x1 = r2 * Math.cos(startAngle) + cx;
  var y1 = r2 * Math.sin(startAngle) + cy;
  var x22 = r2 * Math.cos(endAngle) + cx;
  var y22 = r2 * Math.sin(endAngle) + cy;
  var d1 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
  var d22 = (x22 - x2) * (x22 - x2) + (y22 - y2) * (y22 - y2);
  if (d1 < d22) {
    out2[0] = x1;
    out2[1] = y1;
    return Math.sqrt(d1);
  } else {
    out2[0] = x22;
    out2[1] = y22;
    return Math.sqrt(d22);
  }
}
function projectPointToLine(x1, y1, x2, y2, x3, y3, out2, limitToEnds) {
  var dx = x3 - x1;
  var dy = y3 - y1;
  var dx1 = x2 - x1;
  var dy1 = y2 - y1;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  var projectedLen = dx * dx1 + dy * dy1;
  var t2 = projectedLen / lineLen;
  if (limitToEnds) {
    t2 = Math.min(Math.max(t2, 0), 1);
  }
  t2 *= lineLen;
  var ox = out2[0] = x1 + t2 * dx1;
  var oy = out2[1] = y1 + t2 * dy1;
  return Math.sqrt((ox - x3) * (ox - x3) + (oy - y3) * (oy - y3));
}
function projectPointToRect(x1, y1, width2, height2, x2, y2, out2) {
  if (width2 < 0) {
    x1 = x1 + width2;
    width2 = -width2;
  }
  if (height2 < 0) {
    y1 = y1 + height2;
    height2 = -height2;
  }
  var x22 = x1 + width2;
  var y22 = y1 + height2;
  var ox = out2[0] = Math.min(Math.max(x2, x1), x22);
  var oy = out2[1] = Math.min(Math.max(y2, y1), y22);
  return Math.sqrt((ox - x2) * (ox - x2) + (oy - y2) * (oy - y2));
}
var tmpPt = [];
function nearestPointOnRect(pt3, rect, out2) {
  var dist2 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt3.x, pt3.y, tmpPt);
  out2.set(tmpPt[0], tmpPt[1]);
  return dist2;
}
function nearestPointOnPath(pt3, path, out2) {
  var xi2 = 0;
  var yi2 = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  var minDist = Infinity;
  var data5 = path.data;
  var x2 = pt3.x;
  var y2 = pt3.y;
  for (var i2 = 0; i2 < data5.length; ) {
    var cmd = data5[i2++];
    if (i2 === 1) {
      xi2 = data5[i2];
      yi2 = data5[i2 + 1];
      x0 = xi2;
      y0 = yi2;
    }
    var d3 = minDist;
    switch (cmd) {
      case CMD$1.M:
        x0 = data5[i2++];
        y0 = data5[i2++];
        xi2 = x0;
        yi2 = y0;
        break;
      case CMD$1.L:
        d3 = projectPointToLine(xi2, yi2, data5[i2], data5[i2 + 1], x2, y2, tmpPt, true);
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$1.C:
        d3 = cubicProjectPoint(xi2, yi2, data5[i2++], data5[i2++], data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], x2, y2, tmpPt);
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$1.Q:
        d3 = quadraticProjectPoint(xi2, yi2, data5[i2++], data5[i2++], data5[i2], data5[i2 + 1], x2, y2, tmpPt);
        xi2 = data5[i2++];
        yi2 = data5[i2++];
        break;
      case CMD$1.A:
        var cx = data5[i2++];
        var cy = data5[i2++];
        var rx = data5[i2++];
        var ry = data5[i2++];
        var theta = data5[i2++];
        var dTheta = data5[i2++];
        i2 += 1;
        var anticlockwise = !!(1 - data5[i2++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (i2 <= 1) {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x2 - cx) * ry / rx + cx;
        d3 = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y2, tmpPt);
        xi2 = Math.cos(theta + dTheta) * rx + cx;
        yi2 = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$1.R:
        x0 = xi2 = data5[i2++];
        y0 = yi2 = data5[i2++];
        var width2 = data5[i2++];
        var height2 = data5[i2++];
        d3 = projectPointToRect(x0, y0, width2, height2, x2, y2, tmpPt);
        break;
      case CMD$1.Z:
        d3 = projectPointToLine(xi2, yi2, x0, y0, x2, y2, tmpPt, true);
        xi2 = x0;
        yi2 = y0;
        break;
    }
    if (d3 < minDist) {
      minDist = d3;
      out2.set(tmpPt[0], tmpPt[1]);
    }
  }
  return minDist;
}
var pt0 = new Point$2();
var pt1 = new Point$2();
var pt2 = new Point$2();
var dir = new Point$2();
var dir2 = new Point$2();
function updateLabelLinePoints(target, labelLineModel) {
  if (!target) {
    return;
  }
  var labelLine = target.getTextGuideLine();
  var label = target.getTextContent();
  if (!(label && labelLine)) {
    return;
  }
  var labelGuideConfig = target.textGuideLineConfig || {};
  var points2 = [[0, 0], [0, 0], [0, 0]];
  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
  var labelRect = label.getBoundingRect().clone();
  labelRect.applyTransform(label.getComputedTransform());
  var minDist = Infinity;
  var anchorPoint = labelGuideConfig.anchor;
  var targetTransform = target.getComputedTransform();
  var targetInversedTransform = targetTransform && invert([], targetTransform);
  var len2 = labelLineModel.get("length2") || 0;
  if (anchorPoint) {
    pt2.copy(anchorPoint);
  }
  for (var i2 = 0; i2 < searchSpace.length; i2++) {
    var candidate = searchSpace[i2];
    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
    Point$2.scaleAndAdd(pt1, pt0, dir, len2);
    pt1.transform(targetInversedTransform);
    var boundingRect = target.getBoundingRect();
    var dist2 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path$2 ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
    if (dist2 < minDist) {
      minDist = dist2;
      pt1.transform(targetTransform);
      pt2.transform(targetTransform);
      pt2.toArray(points2[0]);
      pt1.toArray(points2[1]);
      pt0.toArray(points2[2]);
    }
  }
  limitTurnAngle(points2, labelLineModel.get("minTurnAngle"));
  labelLine.setShape({
    points: points2
  });
}
var tmpArr = [];
var tmpProjPoint = new Point$2();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$2.sub(dir, pt0, pt1);
  Point$2.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    var d3 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d3 / Math.tan(Math.PI - minTurnAngle));
    var t2 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t2)) {
      return;
    }
    if (t2 < 0) {
      Point$2.copy(tmpProjPoint, pt1);
    } else if (t2 > 1) {
      Point$2.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$2.sub(dir, pt1, pt0);
  Point$2.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    var d3 = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle2 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point$2.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d3 / Math.tan(Math.PI / 2 - newAngle));
      var t2 = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t2)) {
        return;
      }
      if (t2 < 0) {
        Point$2.copy(tmpProjPoint, pt1);
      } else if (t2 > 1) {
        Point$2.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === "normal";
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  var smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  var styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (!points2) {
    return;
  }
  path.moveTo(points2[0][0], points2[0][1]);
  if (smooth > 0 && points2.length >= 3) {
    var len1 = dist$1(points2[0], points2[1]);
    var len2 = dist$1(points2[1], points2[2]);
    if (!len1 || !len2) {
      path.lineTo(points2[1][0], points2[1][1]);
      path.lineTo(points2[2][0], points2[2][1]);
      return;
    }
    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp$1([], points2[1], points2[0], moveLen / len1);
    var midPoint2 = lerp$1([], points2[1], points2[2], moveLen / len2);
    var midPoint1 = lerp$1([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points2[2][0], points2[2][1]);
  } else {
    for (var i2 = 1; i2 < points2.length; i2++) {
      path.lineTo(points2[i2][0], points2[i2][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  var normalModel = statesModels.normal;
  var showNormal = normalModel.get("show");
  var labelIgnoreNormal = label.ignore;
  for (var i2 = 0; i2 < DISPLAY_STATES.length; i2++) {
    var stateName = DISPLAY_STATES[i2];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === "normal";
    if (stateModel) {
      var stateShow = stateModel.get("show");
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline$1();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    var showAbove = normalModel.get("showAbove");
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
    var stateName = SPECIAL_STATES[i2];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}
function prepareLayoutList(input4) {
  var list = [];
  for (var i2 = 0; i2 < input4.length; i2++) {
    var rawItem = input4[i2];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    var label = rawItem.label;
    var transform = label.getComputedTransform();
    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect$1(localRect, transform) : null;
    list.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform
    });
  }
  return list;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a2, b2) {
    return a2.rect[xyDim] - b2.rect[xyDim];
  });
  var lastPos = 0;
  var delta;
  var adjusted = false;
  var totalShifts = 0;
  for (var i2 = 0; i2 < len2; i2++) {
    var item = list[i2];
    var rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    var shift = Math.max(-delta, 0);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  var first2 = list[0];
  var last2 = list[len2 - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first2.rect[xyDim] - minBound;
    maxGap = maxBound - last2.rect[xyDim] - last2.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        var remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (var i3 = start2; i3 < end2; i3++) {
      var item2 = list[i3];
      var rect2 = item2.rect;
      rect2[xyDim] += delta2;
      item2.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;
    for (var i3 = 1; i3 < len2; i3++) {
      var prevItemRect = list[i3 - 1].rect;
      var gap = Math.max(list[i3].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (var i3 = 0; i3 < len2 - 1; i3++) {
        var movement = gaps[i3] * squeezePercent;
        shiftList(movement, 0, i3 + 1);
      }
    } else {
      for (var i3 = len2 - 1; i3 > 0; i3--) {
        var movement = gaps[i3 - 1] * squeezePercent;
        shiftList(-movement, i3, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    var dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (var i3 = 0; i3 < len2 - 1; i3++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i3 + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i3 - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
  return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = [];
  labelList.sort(function(a2, b2) {
    return b2.priority - a2.priority;
  });
  var globalRect = new BoundingRect$1(0, 0, 0, 0);
  function hideEl(el2) {
    if (!el2.ignore) {
      var emphasisState = el2.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el2.ignore = true;
  }
  for (var i2 = 0; i2 < labelList.length; i2++) {
    var labelItem = labelList[i2];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;
    for (var j2 = 0; j2 < displayedLabels.length; j2++) {
      var existsTextCfg = displayedLabels[j2];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect$1(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect$1(localRect, transform);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}
function cloneArr(points2) {
  if (points2) {
    var newPoints = [];
    for (var i2 = 0; i2 < points2.length; i2++) {
      newPoints.push(points2[i2].slice());
    }
    return newPoints;
  }
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
  var label = labelItem.label;
  var labelLine = hostEl && hostEl.getTextGuideLine();
  return {
    dataIndex: labelItem.dataIndex,
    dataType: labelItem.dataType,
    seriesIndex: labelItem.seriesModel.seriesIndex,
    text: labelItem.label.style.text,
    rect: labelItem.hostRect,
    labelRect: labelItem.rect,
    align: label.style.align,
    verticalAlign: label.style.verticalAlign,
    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
var dummyTransformable = new Transformable$1();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source, keys2) {
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var key = keys2[i2];
    if (source[key] != null) {
      target[key] = source[key];
    }
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
var LabelManager = function() {
  function LabelManager2() {
    this._labelList = [];
    this._chartViewList = [];
  }
  LabelManager2.prototype.clearLabels = function() {
    this._labelList = [];
    this._chartViewList = [];
  };
  LabelManager2.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOption) {
    var labelStyle = label.style;
    var hostEl = label.__hostTarget;
    var textConfig = hostEl.textConfig || {};
    var labelTransform = label.getComputedTransform();
    var labelRect = label.getBoundingRect().plain();
    BoundingRect$1.applyTransform(labelRect, labelRect, labelTransform);
    if (labelTransform) {
      dummyTransformable.setLocalTransform(labelTransform);
    } else {
      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
    }
    var host = label.__hostTarget;
    var hostRect;
    if (host) {
      hostRect = host.getBoundingRect().plain();
      var transform = host.getComputedTransform();
      BoundingRect$1.applyTransform(hostRect, hostRect, transform);
    }
    var labelGuide = hostRect && host.getTextGuideLine();
    this._labelList.push({
      label,
      labelLine: labelGuide,
      seriesModel,
      dataIndex,
      dataType,
      layoutOption,
      computedLayoutOption: null,
      rect: labelRect,
      hostRect,
      priority: hostRect ? hostRect.width * hostRect.height : 0,
      defaultAttr: {
        ignore: label.ignore,
        labelGuideIgnore: labelGuide && labelGuide.ignore,
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY,
        rotation: dummyTransformable.rotation,
        style: {
          x: labelStyle.x,
          y: labelStyle.y,
          align: labelStyle.align,
          verticalAlign: labelStyle.verticalAlign,
          width: labelStyle.width,
          height: labelStyle.height,
          fontSize: labelStyle.fontSize
        },
        cursor: label.cursor,
        attachedPos: textConfig.position,
        attachedRot: textConfig.rotation
      }
    });
  };
  LabelManager2.prototype.addLabelsOfSeries = function(chartView) {
    var _this = this;
    this._chartViewList.push(chartView);
    var seriesModel = chartView.__model;
    var layoutOption = seriesModel.get("labelLayout");
    if (!(isFunction$h(layoutOption) || keys$d(layoutOption).length)) {
      return;
    }
    chartView.group.traverse(function(child) {
      if (child.ignore) {
        return true;
      }
      var textEl = child.getTextContent();
      var ecData = getECData(child);
      if (textEl && !textEl.disableLabelLayout) {
        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
      }
    });
  };
  LabelManager2.prototype.updateLayoutConfig = function(api) {
    var width2 = api.getWidth();
    var height2 = api.getHeight();
    function createDragHandler(el2, labelLineModel) {
      return function() {
        updateLabelLinePoints(el2, labelLineModel);
      };
    }
    for (var i2 = 0; i2 < this._labelList.length; i2++) {
      var labelItem = this._labelList[i2];
      var label = labelItem.label;
      var hostEl = label.__hostTarget;
      var defaultLabelAttr = labelItem.defaultAttr;
      var layoutOption = void 0;
      if (isFunction$h(labelItem.layoutOption)) {
        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
      } else {
        layoutOption = labelItem.layoutOption;
      }
      layoutOption = layoutOption || {};
      labelItem.computedLayoutOption = layoutOption;
      var degreeToRadian = Math.PI / 180;
      if (hostEl) {
        hostEl.setTextConfig({
          local: false,
          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
        });
      }
      var needsUpdateLabelLine = false;
      if (layoutOption.x != null) {
        label.x = parsePercent(layoutOption.x, width2);
        label.setStyle("x", 0);
        needsUpdateLabelLine = true;
      } else {
        label.x = defaultLabelAttr.x;
        label.setStyle("x", defaultLabelAttr.style.x);
      }
      if (layoutOption.y != null) {
        label.y = parsePercent(layoutOption.y, height2);
        label.setStyle("y", 0);
        needsUpdateLabelLine = true;
      } else {
        label.y = defaultLabelAttr.y;
        label.setStyle("y", defaultLabelAttr.style.y);
      }
      if (layoutOption.labelLinePoints) {
        var guideLine = hostEl.getTextGuideLine();
        if (guideLine) {
          guideLine.setShape({
            points: layoutOption.labelLinePoints
          });
          needsUpdateLabelLine = false;
        }
      }
      var labelLayoutStore = labelLayoutInnerStore(label);
      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
      label.scaleX = defaultLabelAttr.scaleX;
      label.scaleY = defaultLabelAttr.scaleY;
      for (var k2 = 0; k2 < LABEL_OPTION_TO_STYLE_KEYS.length; k2++) {
        var key = LABEL_OPTION_TO_STYLE_KEYS[k2];
        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
      }
      if (layoutOption.draggable) {
        label.draggable = true;
        label.cursor = "move";
        if (hostEl) {
          var hostModel = labelItem.seriesModel;
          if (labelItem.dataIndex != null) {
            var data5 = labelItem.seriesModel.getData(labelItem.dataType);
            hostModel = data5.getItemModel(labelItem.dataIndex);
          }
          label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
        }
      } else {
        label.off("drag");
        label.cursor = defaultLabelAttr.cursor;
      }
    }
  };
  LabelManager2.prototype.layout = function(api) {
    var width2 = api.getWidth();
    var height2 = api.getHeight();
    var labelList = prepareLayoutList(this._labelList);
    var labelsNeedsAdjustOnX = filter$3(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftX";
    });
    var labelsNeedsAdjustOnY = filter$3(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftY";
    });
    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width2);
    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height2);
    var labelsNeedsHideOverlap = filter$3(labelList, function(item) {
      return item.layoutOption.hideOverlap;
    });
    hideOverlap(labelsNeedsHideOverlap);
  };
  LabelManager2.prototype.processLabelsOverall = function() {
    var _this = this;
    each$q(this._chartViewList, function(chartView) {
      var seriesModel = chartView.__model;
      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
      var animationEnabled = seriesModel.isAnimationEnabled();
      chartView.group.traverse(function(child) {
        if (child.ignore && !child.forceLabelAnimation) {
          return true;
        }
        var needsUpdateLabelLine = !ignoreLabelLineUpdate;
        var label = child.getTextContent();
        if (!needsUpdateLabelLine && label) {
          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
        }
        if (needsUpdateLabelLine) {
          _this._updateLabelLine(child, seriesModel);
        }
        if (animationEnabled) {
          _this._animateLabels(child, seriesModel);
        }
      });
    });
  };
  LabelManager2.prototype._updateLabelLine = function(el2, seriesModel) {
    var textEl = el2.getTextContent();
    var ecData = getECData(el2);
    var dataIndex = ecData.dataIndex;
    if (textEl && dataIndex != null) {
      var data5 = seriesModel.getData(ecData.dataType);
      var itemModel = data5.getItemModel(dataIndex);
      var defaultStyle = {};
      var visualStyle = data5.getItemVisual(dataIndex, "style");
      var visualType = data5.getVisual("drawType");
      defaultStyle.stroke = visualStyle[visualType];
      var labelLineModel = itemModel.getModel("labelLine");
      setLabelLineStyle(el2, getLabelLineStatesModels(itemModel), defaultStyle);
      updateLabelLinePoints(el2, labelLineModel);
    }
  };
  LabelManager2.prototype._animateLabels = function(el2, seriesModel) {
    var textEl = el2.getTextContent();
    var guideLine = el2.getTextGuideLine();
    if (textEl && (el2.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el2.disableLabelAnimation && !isElementRemoved(el2))) {
      var layoutStore = labelLayoutInnerStore(textEl);
      var oldLayout = layoutStore.oldLayout;
      var ecData = getECData(el2);
      var dataIndex = ecData.dataIndex;
      var newProps = {
        x: textEl.x,
        y: textEl.y,
        rotation: textEl.rotation
      };
      var data5 = seriesModel.getData(ecData.dataType);
      if (!oldLayout) {
        textEl.attr(newProps);
        if (!labelInner(textEl).valueAnimation) {
          var oldOpacity = retrieve2(textEl.style.opacity, 1);
          textEl.style.opacity = 0;
          initProps(textEl, {
            style: {
              opacity: oldOpacity
            }
          }, seriesModel, dataIndex);
        }
      } else {
        textEl.attr(oldLayout);
        var prevStates = el2.prevStates;
        if (prevStates) {
          if (indexOf$2(prevStates, "select") >= 0) {
            textEl.attr(layoutStore.oldLayoutSelect);
          }
          if (indexOf$2(prevStates, "emphasis") >= 0) {
            textEl.attr(layoutStore.oldLayoutEmphasis);
          }
        }
        updateProps$2(textEl, newProps, seriesModel, dataIndex);
      }
      layoutStore.oldLayout = newProps;
      if (textEl.states.select) {
        var layoutSelect = layoutStore.oldLayoutSelect = {};
        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
      }
      if (textEl.states.emphasis) {
        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
      }
      animateLabelValue(textEl, dataIndex, data5, seriesModel, seriesModel);
    }
    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
      var layoutStore = labelLineAnimationStore(guideLine);
      var oldLayout = layoutStore.oldLayout;
      var newLayout = {
        points: guideLine.shape.points
      };
      if (!oldLayout) {
        guideLine.setShape(newLayout);
        guideLine.style.strokePercent = 0;
        initProps(guideLine, {
          style: {
            strokePercent: 1
          }
        }, seriesModel);
      } else {
        guideLine.attr({
          shape: oldLayout
        });
        updateProps$2(guideLine, {
          shape: newLayout
        }, seriesModel);
      }
      layoutStore.oldLayout = newLayout;
    }
  };
  return LabelManager2;
}();
var LabelManager$1 = LabelManager;
var getLabelManager = makeInner();
function installLabelLayout(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    if (!labelManager) {
      labelManager = getLabelManager(api).labelManager = new LabelManager$1();
    }
    labelManager.clearLabels();
  });
  registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    params.updatedSeries.forEach(function(series) {
      labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));
    });
    labelManager.updateLayoutConfig(api);
    labelManager.layout(api);
    labelManager.processLabelsOverall();
  });
}
var echarts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  registerLocale,
  version,
  dependencies,
  PRIORITY,
  init: init$1,
  connect,
  disConnect,
  disconnect,
  dispose,
  getInstanceByDom,
  getInstanceById,
  registerTheme,
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  getCoordinateSystemDimensions,
  registerLayout,
  registerVisual,
  registerLoading,
  setCanvasCreator,
  registerMap,
  getMap,
  registerTransform,
  dataTool,
  throttle: throttle$4,
  use: use$1,
  setPlatformAPI,
  parseGeoJSON,
  parseGeoJson: parseGeoJSON,
  env: env$1,
  Model: Model$1,
  Axis: Axis$1,
  innerDrawElementOnCanvas: brushSingle,
  zrender,
  matrix,
  vector,
  zrUtil: util$1,
  color,
  helper,
  number,
  time,
  graphic,
  format,
  util,
  List: SeriesData$1,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  extendComponentModel,
  extendComponentView,
  extendSeriesModel,
  extendChartView
}, Symbol.toStringTag, { value: "Module" }));
var LineSeriesModel = function(_super) {
  __extends(LineSeriesModel2, _super);
  function LineSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LineSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  LineSeriesModel2.prototype.getInitialData = function(option) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  LineSeriesModel2.prototype.getLegendIcon = function(opt) {
    var group = new Group$3();
    var line = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual("symbol");
    var visualRotate = this.getData().getVisual("symbolRotate");
    var symbolType = visualType === "none" ? "circle" : visualType;
    var size = opt.itemHeight * 0.8;
    var symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  };
  LineSeriesModel2.type = "series.line";
  LineSeriesModel2.dependencies = ["grid", "polar"];
  LineSeriesModel2.defaultOption = {
    z: 3,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    clip: true,
    label: {
      position: "top"
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: "solid"
    },
    emphasis: {
      scale: true
    },
    step: false,
    smooth: false,
    smoothMonotone: null,
    symbol: "emptyCircle",
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    showAllSymbol: "auto",
    connectNulls: false,
    sampling: "none",
    animationEasing: "linear",
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: "clone"
    },
    triggerLineEvent: false
  };
  return LineSeriesModel2;
}(SeriesModel$1);
var LineSeries = LineSeriesModel;
function getDefaultLabel(data5, dataIndex) {
  var labelDims = data5.mapDimensionsAll("defaultedLabel");
  var len2 = labelDims.length;
  if (len2 === 1) {
    var rawVal = retrieveRawValue(data5, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    var vals = [];
    for (var i2 = 0; i2 < labelDims.length; i2++) {
      vals.push(retrieveRawValue(data5, dataIndex, labelDims[i2]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data5, interpolatedValue) {
  var labelDims = data5.mapDimensionsAll("defaultedLabel");
  if (!isArray$x(interpolatedValue)) {
    return interpolatedValue + "";
  }
  var vals = [];
  for (var i2 = 0; i2 < labelDims.length; i2++) {
    var dimIndex = data5.getDimensionIndex(labelDims[i2]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}
var Symbol$5 = function(_super) {
  __extends(Symbol2, _super);
  function Symbol2(data5, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;
    _this.updateData(data5, idx, seriesScope, opts);
    return _this;
  }
  Symbol2.prototype._createSymbol = function(symbolType, data5, idx, symbolSize, keepAspect) {
    this.removeAll();
    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  Symbol2.prototype.getSymbolType = function() {
    return this._symbolType;
  };
  Symbol2.prototype.getSymbolPath = function() {
    return this.childAt(0);
  };
  Symbol2.prototype.highlight = function() {
    enterEmphasis(this.childAt(0));
  };
  Symbol2.prototype.downplay = function() {
    leaveEmphasis(this.childAt(0));
  };
  Symbol2.prototype.setZ = function(zlevel, z2) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z2;
  };
  Symbol2.prototype.setDraggable = function(draggable, hasCursorOption) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
  };
  Symbol2.prototype.updateData = function(data5, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data5.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data5.hostModel;
    var symbolSize = Symbol2.getSymbolSize(data5, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      var keepAspect = data5.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data5, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps$2(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data5, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      var symbolPath = this.childAt(0);
      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  };
  Symbol2.prototype._updateCommon = function(data5, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data5.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus2;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus2 = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data5.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data5.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus2 = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    var symbolRotate = data5.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data5.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    var symbolStyle = data5.getItemVisual(idx, "style");
    var visualColor = symbolStyle.fill;
    if (symbolPath instanceof ZRImage$1) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend$1({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend$1({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    var liftZ = data5.getItemVisual(idx, "liftZ");
    var z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data5.getName(idx2) : getDefaultLabel(data5, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    if (hoverScale) {
      var scaleRatio = Math.max(isNumber$c(hoverScale) ? hoverScale : 1.1, 3 / this._sizeY);
      emphasisState.scaleX = this._sizeX * scaleRatio;
      emphasisState.scaleY = this._sizeY * scaleRatio;
    }
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus2, blurScope, emphasisDisabled);
  };
  Symbol2.prototype.setSymbolScale = function(scale2) {
    this.scaleX = this.scaleY = scale2;
  };
  Symbol2.prototype.fadeOut = function(cb, seriesModel, opt) {
    var symbolPath = this.childAt(0);
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb: function() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex,
      cb,
      removeOpt: animationOpt
    });
  };
  Symbol2.getSymbolSize = function(data5, idx) {
    return normalizeSymbolSize(data5.getItemVisual(idx, "symbolSize"));
  };
  return Symbol2;
}(Group$3);
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var SymbolClz = Symbol$5;
function symbolNeedsDraw(data5, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data5.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject$f(opt)) {
    opt = {
      isIgnore: opt
    };
  }
  return opt || {};
}
function makeSeriesScope(data5) {
  var seriesModel = data5.hostModel;
  var emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = function() {
  function SymbolDraw2(SymbolCtor) {
    this.group = new Group$3();
    this._SymbolCtor = SymbolCtor || SymbolClz;
  }
  SymbolDraw2.prototype.updateData = function(data5, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data5.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope(data5);
    var symbolUpdateOpt = {
      disableAnimation
    };
    var getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data5.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data5.diff(oldData).add(function(newIdx) {
      var point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw(data5, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data5, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data5.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw(data5, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      var newSymbolType = data5.getItemVisual(newIdx, "symbol") || "circle";
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data5, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data5, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps$2(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data5.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el2 = oldData.getItemGraphicEl(oldIdx);
      el2 && el2.fadeOut(function() {
        group.remove(el2);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data5;
  };
  SymbolDraw2.prototype.updateLayout = function() {
    var _this = this;
    var data5 = this._data;
    if (data5) {
      data5.eachItemGraphicEl(function(el2, idx) {
        var point = _this._getSymbolPoint(idx);
        el2.setPosition(point);
        el2.markRedraw();
      });
    }
  };
  SymbolDraw2.prototype.incrementalPrepareUpdate = function(data5) {
    this._seriesScope = makeSeriesScope(data5);
    this._data = null;
    this.group.removeAll();
  };
  SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data5, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el3) {
      if (!el3.isGroup) {
        el3.incremental = true;
        el3.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data5.getItemLayout(idx);
      if (symbolNeedsDraw(data5, point, idx, opt)) {
        var el2 = new this._SymbolCtor(data5, idx, this._seriesScope);
        el2.traverse(updateIncrementalAndHover);
        el2.setPosition(point);
        this.group.add(el2);
        data5.setItemGraphicEl(idx, el2);
        this._progressiveEls.push(el2);
      }
    }
  };
  SymbolDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  SymbolDraw2.prototype.remove = function(enableAnimation) {
    var group = this.group;
    var data5 = this._data;
    if (data5 && enableAnimation) {
      data5.eachItemGraphicEl(function(el2) {
        el2.fadeOut(function() {
          group.remove(el2);
        }, data5.hostModel);
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw2;
}();
var SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(coordSys, data5, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis2 = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis2, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis2.dim;
  var valueDim = data5.mapDimension(valueAxisDim);
  var baseDim = data5.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  var dims = map$9(coordSys.dimensions, function(coordDim) {
    return data5.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data5.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(
    data5,
    dims[0]
  )) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(
    data5,
    dims[1]
  )) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data5.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  var valueStart = 0;
  var extent3 = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else if (isNumber$c(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data5, idx) {
  var value = NaN;
  if (dataCoordInfo.stacked) {
    value = data5.get(data5.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data5.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({
      cmd: "+",
      idx
    });
  }).update(function(newIdx, oldIdx) {
    diffResult.push({
      cmd: "=",
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function(idx) {
    diffResult.push({
      cmd: "-",
      idx
    });
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData);
  var currPoints = [];
  var nextPoints = [];
  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldPoints = oldData.getLayout("points") || [];
  var newPoints = newData.getLayout("points") || [];
  for (var i2 = 0; i2 < diff.length; i2++) {
    var diffItem = diff[i2];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a2, b2) {
    return rawIndices[a2] - rawIndices[b2];
  });
  var len2 = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len2);
  var sortedNextPoints = createFloat32Array(len2);
  var sortedCurrStackedPoints = createFloat32Array(len2);
  var sortedNextStackedPoints = createFloat32Array(len2);
  var sortedStatus = [];
  for (var i2 = 0; i2 < sortedIndices.length; i2++) {
    var idx = sortedIndices[i2];
    var i22 = i2 * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i22] = currPoints[idx2];
    sortedCurrPoints[i22 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i22] = nextPoints[idx2];
    sortedNextPoints[i22 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i22] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i22 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i22] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i22 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i2] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
function isPointNull$1(x2, y2) {
  return isNaN(x2) || isNaN(y2);
}
function drawSegment(ctx, points2, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start2;
  var k2 = 0;
  for (; k2 < segLen; k2++) {
    var x2 = points2[idx * 2];
    var y2 = points2[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull$1(x2, y2)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x2, y2);
      cpx0 = x2;
      cpy0 = y2;
    } else {
      var dx = x2 - prevX;
      var dy = y2 - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        var nextIdx = idx + dir3;
        var nextX = points2[nextIdx * 2];
        var nextY = points2[nextIdx * 2 + 1];
        while (nextX === x2 && nextY === y2 && k2 < segLen) {
          k2++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points2[nextIdx * 2];
          nextY = points2[nextIdx * 2 + 1];
          x2 = points2[idx * 2];
          y2 = points2[idx * 2 + 1];
          dx = x2 - prevX;
          dy = y2 - prevY;
        }
        var tmpK = k2 + 1;
        if (connectNulls) {
          while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
          }
        }
        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0;
        if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
          cpx1 = x2;
          cpy1 = y2;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x2 - prevX;
          var dx1 = nextX - x2;
          var dy0 = y2 - prevY;
          var dy1 = nextY - y2;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x2 - dir_1 * lenPrevSeg * smooth;
            cpy1 = y2;
            nextCpx0 = x2 + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y2;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x2;
            cpy1 = y2 - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x2;
            nextCpy0 = y2 + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x2 - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y2 - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x2 + vx * smooth * ratioNextSeg;
            nextCpy0 = y2 + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin$1(nextCpx0, mathMax$1(nextX, x2));
            nextCpy0 = mathMin$1(nextCpy0, mathMax$1(nextY, y2));
            nextCpx0 = mathMax$1(nextCpx0, mathMin$1(nextX, x2));
            nextCpy0 = mathMax$1(nextCpy0, mathMin$1(nextY, y2));
            vx = nextCpx0 - x2;
            vy = nextCpy0 - y2;
            cpx1 = x2 - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y2 - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin$1(cpx1, mathMax$1(prevX, x2));
            cpy1 = mathMin$1(cpy1, mathMax$1(prevY, y2));
            cpx1 = mathMax$1(cpx1, mathMin$1(prevX, x2));
            cpy1 = mathMax$1(cpy1, mathMin$1(prevY, y2));
            vx = x2 - cpx1;
            vy = y2 - cpy1;
            nextCpx0 = x2 + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y2 + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x2, y2);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x2, y2);
      }
    }
    prevX = x2;
    prevY = y2;
    idx += dir3;
  }
  return k2;
}
var ECPolylineShape = function() {
  function ECPolylineShape2() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
  return ECPolylineShape2;
}();
var ECPolyline = function(_super) {
  __extends(ECPolyline2, _super);
  function ECPolyline2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polyline";
    return _this;
  }
  ECPolyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECPolyline2.prototype.getDefaultShape = function() {
    return new ECPolylineShape();
  };
  ECPolyline2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var i2 = 0;
    var len2 = points2.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i2 < len2; i2++) {
        if (!isPointNull$1(points2[i2 * 2], points2[i2 * 2 + 1])) {
          break;
        }
      }
    }
    while (i2 < len2) {
      i2 += drawSegment(ctx, points2, i2, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };
  ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    var path = this.path;
    var data5 = path.data;
    var CMD2 = PathProxy$1.CMD;
    var x0;
    var y0;
    var isDimX = dim === "x";
    var roots2 = [];
    for (var i2 = 0; i2 < data5.length; ) {
      var cmd = data5[i2++];
      var x2 = void 0;
      var y2 = void 0;
      var x22 = void 0;
      var y22 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t2 = void 0;
      switch (cmd) {
        case CMD2.M:
          x0 = data5[i2++];
          y0 = data5[i2++];
          break;
        case CMD2.L:
          x2 = data5[i2++];
          y2 = data5[i2++];
          t2 = isDimX ? (xOrY - x0) / (x2 - x0) : (xOrY - y0) / (y2 - y0);
          if (t2 <= 1 && t2 >= 0) {
            var val2 = isDimX ? (y2 - y0) * t2 + y0 : (x2 - x0) * t2 + x0;
            return isDimX ? [xOrY, val2] : [val2, xOrY];
          }
          x0 = x2;
          y0 = y2;
          break;
        case CMD2.C:
          x2 = data5[i2++];
          y2 = data5[i2++];
          x22 = data5[i2++];
          y22 = data5[i2++];
          x3 = data5[i2++];
          y3 = data5[i2++];
          var nRoot = isDimX ? cubicRootAt(x0, x2, x22, x3, xOrY, roots2) : cubicRootAt(y0, y2, y22, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots2[i_1];
              if (t_1 <= 1 && t_1 >= 0) {
                var val2 = isDimX ? cubicAt(y0, y2, y22, y3, t_1) : cubicAt(x0, x2, x22, x3, t_1);
                return isDimX ? [xOrY, val2] : [val2, xOrY];
              }
            }
          }
          x0 = x3;
          y0 = y3;
          break;
      }
    }
  };
  return ECPolyline2;
}(Path$2);
var ECPolygonShape = function(_super) {
  __extends(ECPolygonShape2, _super);
  function ECPolygonShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ECPolygonShape2;
}(ECPolylineShape);
var ECPolygon = function(_super) {
  __extends(ECPolygon2, _super);
  function ECPolygon2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polygon";
    return _this;
  }
  ECPolygon2.prototype.getDefaultShape = function() {
    return new ECPolygonShape();
  };
  ECPolygon2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i2 = 0;
    var len2 = points2.length / 2;
    var smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i2 < len2; i2++) {
        if (!isPointNull$1(points2[i2 * 2], points2[i2 * 2 + 1])) {
          break;
        }
      }
    }
    while (i2 < len2) {
      var k2 = drawSegment(ctx, points2, i2, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i2 + k2 - 1, k2, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i2 += k2 + 1;
      ctx.closePath();
    }
  };
  return ECPolygon2;
}(Path$2);
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x2 = rect.x;
  var y2 = rect.y;
  var width2 = rect.width;
  var height2 = rect.height;
  var lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
  x2 -= lineWidth / 2;
  y2 -= lineWidth / 2;
  width2 += lineWidth;
  height2 += lineWidth;
  x2 = Math.floor(x2);
  width2 = Math.round(width2);
  var clipPath = new Rect$2({
    shape: {
      x: x2,
      y: y2,
      width: width2,
      height: height2
    }
  });
  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width2;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height2;
      }
      clipPath.shape.height = 0;
    }
    var duringCb = isFunction$h(during) ? function(percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width: width2,
        height: height2,
        x: x2,
        y: y2
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea();
  var r0 = round$5(sectorArea.r0, 1);
  var r2 = round$5(sectorArea.r, 1);
  var clipPath = new Sector$1({
    shape: {
      cx: round$5(polar.cx, 1),
      cy: round$5(polar.cy, 1),
      r0,
      r: r2,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r: r2
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}
function isCoordinateSystemType(coordSys, type2) {
  return coordSys.type === type2;
}
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }
  for (var i2 = 0; i2 < points1.length; i2++) {
    if (points1[i2] !== points2[i2]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points2) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  for (var i2 = 0; i2 < points2.length; ) {
    var x2 = points2[i2++];
    var y2 = points2[i2++];
    if (!isNaN(x2)) {
      minX = Math.min(x2, minX);
      maxX = Math.max(x2, maxX);
    }
    if (!isNaN(y2)) {
      minY = Math.min(y2, minY);
      maxY = Math.max(y2, maxY);
    }
  }
  return [[minX, minY], [maxX, maxY]];
}
function getBoundingDiff(points1, points2) {
  var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
  var _b2 = bboxFromPoints(points2), min22 = _b2[0], max22 = _b2[1];
  return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
}
function getSmooth(smooth) {
  return isNumber$c(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data5, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  var len2 = data5.count();
  var points2 = createFloat32Array(len2 * 2);
  for (var idx = 0; idx < len2; idx++) {
    var pt3 = getStackedOnPoint(dataCoordInfo, coordSys, data5, idx);
    points2[idx * 2] = pt3[0];
    points2[idx * 2 + 1] = pt3[1];
  }
  return points2;
}
function turnPointsIntoStep(points2, coordSys, stepTurnAt, connectNulls) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  var stepPoints = [];
  var i2 = 0;
  var stepPt = [];
  var pt3 = [];
  var nextPt = [];
  var filteredPoints = [];
  if (connectNulls) {
    for (i2 = 0; i2 < points2.length; i2 += 2) {
      if (!isNaN(points2[i2]) && !isNaN(points2[i2 + 1])) {
        filteredPoints.push(points2[i2], points2[i2 + 1]);
      }
    }
    points2 = filteredPoints;
  }
  for (i2 = 0; i2 < points2.length - 2; i2 += 2) {
    nextPt[0] = points2[i2 + 2];
    nextPt[1] = points2[i2 + 3];
    pt3[0] = points2[i2];
    pt3[1] = points2[i2 + 1];
    stepPoints.push(pt3[0], pt3[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt3[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        var middle = (pt3[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt3[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt3[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points2[i2++], points2[i2++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len2 = colorStops.length;
  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    var coord0 = stop0.coord;
    var p2 = (clippedCoord - coord0) / (stop1.coord - coord0);
    var color2 = lerp(p2, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color: color2
    };
  }
  for (var i2 = 0; i2 < len2; i2++) {
    var stop_1 = colorStops[i2];
    var coord = stop_1.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }
  return newColorStops;
}
function getVisualGradient(data5, coordSys, api) {
  var visualMetaList = data5.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data5.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    return;
  }
  var coordDim;
  var visualMeta;
  for (var i2 = visualMetaList.length - 1; i2 >= 0; i2--) {
    var dimInfo = data5.getDimensionInfo(visualMetaList[i2].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i2];
      break;
    }
  }
  if (!visualMeta) {
    return;
  }
  var axis = coordSys.getAxis(coordDim);
  var colorStops = map$9(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  var tinyExtent = 10;
  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each$q(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  var gradient = new LinearGradient$1(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data5, coordSys) {
  var showAllSymbol = seriesModel.get("showAllSymbol");
  var isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data5)) {
    return;
  }
  var categoryDataDim = data5.mapDimension(categoryAxis2.dim);
  var labelMap = {};
  each$q(categoryAxis2.getViewLabels(), function(labelItem) {
    var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data5.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data5) {
  var axisExtent = categoryAxis2.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  var dataLen = data5.count();
  var step = Math.max(1, Math.round(dataLen / 5));
  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(
      data5,
      dataIndex
    )[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull(x2, y2) {
  return isNaN(x2) || isNaN(y2);
}
function getLastIndexNotNull(points2) {
  var len2 = points2.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points2, idx) {
  return [points2[idx * 2], points2[idx * 2 + 1]];
}
function getIndexRange(points2, xOrY, dim) {
  var len2 = points2.length / 2;
  var dimIdx = dim === "x" ? 0 : 1;
  var a2;
  var b2;
  var prevIndex = 0;
  var nextIndex = -1;
  for (var i2 = 0; i2 < len2; i2++) {
    b2 = points2[i2 * 2 + dimIdx];
    if (isNaN(b2) || isNaN(points2[i2 * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i2 === 0) {
      a2 = b2;
      continue;
    }
    if (a2 <= xOrY && b2 >= xOrY || a2 >= xOrY && b2 <= xOrY) {
      nextIndex = i2;
      break;
    }
    prevIndex = i2;
    a2 = b2;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a2) / (b2 - a2)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (var i2 = 0; i2 < SPECIAL_STATES.length; i2++) {
    if (seriesModel.get([SPECIAL_STATES[i2], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    var endLabelModel_1 = seriesModel.getModel("endLabel");
    var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
      var endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = function(_super) {
  __extends(LineView2, _super);
  function LineView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineView2.prototype.init = function() {
    var lineGroup = new Group$3();
    var symbolDraw = new SymbolDraw$1();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };
  LineView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data5 = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel("lineStyle");
    var areaStyleModel = seriesModel.getModel("areaStyle");
    var points2 = data5.getLayout("points") || [];
    var isCoordSysPolar = coordSys.type === "polar";
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get("animation");
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get("origin");
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data5, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data5, dataCoordInfo);
    var showSymbol = seriesModel.get("showSymbol");
    var connectNulls = seriesModel.get("connectNulls");
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data5, coordSys);
    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el2, idx) {
      if (el2.__temp) {
        group.remove(el2);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    var step = !isCoordSysPolar ? seriesModel.get("step") : false;
    var clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data5, coordSys, api) || data5.getVisual("style")[data5.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data5, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data5, coordSys, clipShapeForSymbol);
      if (step) {
        points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
        }
      }
      polyline = this._newPolyline(points2);
      if (isAreaChart) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      var oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data5, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data5, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            points2 = turnPointsIntoStep(points2, coordSys, step, connectNulls);
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
            }
          }
          polyline.setShape({
            points: points2
          });
          polygon && polygon.setShape({
            points: points2,
            stackedOnPoints
          });
        }
      }
    }
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus2 = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(
      lineStyleModel.getLineStyle(),
      {
        fill: "none",
        stroke: visualColor,
        lineJoin: "bevel"
      }
    ));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      var emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus2, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get("smooth"));
    var smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      var stackedOnSeries = data5.getCalculationInfo("stackedOnSeries");
      var stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data5.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus2, blurScope, emphasisDisabled);
    }
    var changePolyState = function(toState) {
      _this._changePolyState(toState);
    };
    data5.eachItemGraphicEl(function(el2) {
      el2 && (el2.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data5;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points2;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  };
  LineView2.prototype.packEventData = function(seriesModel, el2) {
    getECData(el2).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  };
  LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data5 = seriesModel.getData();
    var dataIndex = queryDataIndex(data5, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points2 = data5.getLayout("points");
      var symbol = data5.getItemGraphicEl(dataIndex);
      if (!symbol) {
        var x2 = points2[dataIndex * 2];
        var y2 = points2[dataIndex * 2 + 1];
        if (isNaN(x2) || isNaN(y2)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x2, y2)) {
          return;
        }
        var zlevel = seriesModel.get("zlevel");
        var z2 = seriesModel.get("z");
        symbol = new SymbolClz(data5, dataIndex);
        symbol.x = x2;
        symbol.y = y2;
        symbol.setZ(zlevel, z2);
        var symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z2;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data5.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      ChartView$1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data5 = seriesModel.getData();
    var dataIndex = queryDataIndex(data5, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data5.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data5.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      ChartView$1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype._changePolyState = function(toState) {
    var polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  };
  LineView2.prototype._newPolyline = function(points2) {
    var polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points2
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  };
  LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
    var polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points2,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  };
  LineView2.prototype._initSymbolLabelAnimation = function(data5, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    var seriesModel = data5.hostModel;
    var seriesDuration = seriesModel.get("animationDuration");
    if (isFunction$h(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    var seriesDalay = seriesModel.get("animationDelay") || 0;
    var seriesDalayValue = isFunction$h(seriesDalay) ? seriesDalay(null) : seriesDalay;
    data5.eachItemGraphicEl(function(symbol, idx) {
      var el2 = symbol;
      if (el2) {
        var point = [symbol.x, symbol.y];
        var start2 = void 0;
        var end2 = void 0;
        var current = void 0;
        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        var delay2 = isFunction$h(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el2.getSymbolPath();
        var text2 = symbolPath.getTextContent();
        el2.attr({
          scaleX: 0,
          scaleY: 0
        });
        el2.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay: delay2
        });
        if (text2) {
          text2.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: delay2
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  };
  LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var points2 = data_2.getLayout("points");
      if (!points2) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      var endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new ZRText$1({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      var dataIndex = getLastIndexNotNull(points2);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  };
  LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data5, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      var points2 = data5.getLayout("points");
      var seriesModel = data5.hostModel;
      var connectNulls = seriesModel.get("connectNulls");
      var precision = endLabelModel.get("precision");
      var distance2 = endLabelModel.get("distance") || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? "x" : "y";
      var dataIndexRange = getIndexRange(points2, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value = void 0;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          var pt3 = getPointAtIndex(points2, indices[0]);
          endLabel.attr({
            x: pt3[0] + distanceX,
            y: pt3[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt3 = polyline.getPointOn(xOrY, dim);
          pt3 && endLabel.attr({
            x: pt3[0] + distanceX,
            y: pt3[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data5, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt3 = getPointAtIndex(points2, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt3[0] + distanceX,
          y: pt3[1] + distanceY
        });
      }
      if (valueAnimation) {
        labelInner(endLabel).setLabelText(value);
      }
    }
  };
  LineView2.prototype._doUpdateAnimation = function(data5, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data5.hostModel;
    var diff = lineAnimationDiff(this._data, data5, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;
    if (step) {
      current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);
      next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps$2(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps$2(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    var updatedDataInfo = [];
    var diffStatus = diff.status;
    for (var i2 = 0; i2 < diffStatus.length; i2++) {
      var cmd = diffStatus[i2].cmd;
      if (cmd === "=") {
        var el2 = data5.getItemGraphicEl(diffStatus[i2].idx1);
        if (el2) {
          updatedDataInfo.push({
            el: el2,
            ptIdx: i2
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        var points2 = polyline.shape.__points;
        for (var i3 = 0; i3 < updatedDataInfo.length; i3++) {
          var el3 = updatedDataInfo[i3].el;
          var offset2 = updatedDataInfo[i3].ptIdx * 2;
          el3.x = points2[offset2];
          el3.y = points2[offset2 + 1];
          el3.markRedraw();
        }
      });
    }
  };
  LineView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el2, idx) {
      if (el2.__temp) {
        group.remove(el2);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };
  LineView2.type = "line";
  return LineView2;
}(ChartView$1);
var LineView$1 = LineView;
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data5 = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map$9(coordSys.dimensions, function(dim) {
        return data5.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data5.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data5, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data5, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data5.getStore();
      var dimIdx0 = data5.getDimensionIndex(dims[0]);
      var dimIdx1 = data5.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data6) {
          var segCount = params.end - params.start;
          var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i2 = params.start, offset2 = 0; i2 < params.end; i2++) {
            var point = void 0;
            if (dimLen === 1) {
              var x2 = store.get(dimIdx0, i2);
              point = coordSys.dataToPoint(x2, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i2);
              tmpIn[1] = store.get(dimIdx1, i2);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points2[offset2++] = point[0];
              points2[offset2++] = point[1];
            } else {
              data6.setItemLayout(i2, point.slice());
            }
          }
          useTypedArray && data6.setLayout("points", points2);
        }
      };
    }
  };
}
var samplers = {
  average: function(frame) {
    var sum3 = 0;
    var count = 0;
    for (var i2 = 0; i2 < frame.length; i2++) {
      if (!isNaN(frame[i2])) {
        sum3 += frame[i2];
        count++;
      }
    }
    return count === 0 ? NaN : sum3 / count;
  },
  sum: function(frame) {
    var sum3 = 0;
    for (var i2 = 0; i2 < frame.length; i2++) {
      sum3 += frame[i2] || 0;
    }
    return sum3;
  },
  max: function(frame) {
    var max3 = -Infinity;
    for (var i2 = 0; i2 < frame.length; i2++) {
      frame[i2] > max3 && (max3 = frame[i2]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    var min3 = Infinity;
    for (var i2 = 0; i2 < frame.length; i2++) {
      frame[i2] < min3 && (min3 = frame[i2]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api) {
      var data5 = seriesModel.getData();
      var sampling = seriesModel.get("sampling");
      var coordSys = seriesModel.coordinateSystem;
      var count = data5.count();
      if (count > 10 && coordSys.type === "cartesian2d" && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var extent3 = baseAxis.getExtent();
        var dpr2 = api.getDevicePixelRatio();
        var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        var rate = Math.round(count / size);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data5.lttbDownSample(data5.mapDimension(valueAxis2.dim), 1 / rate));
          }
          var sampler = void 0;
          if (isString$d(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction$h(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data5.downSample(data5.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}
function install$e(registers) {
  registers.registerChartView(LineView$1);
  registers.registerSeriesModel(LineSeries);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      var data5 = seriesModel.getData();
      var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data5.getVisual("style").fill;
      }
      data5.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = function(_super) {
  __extends(BaseBarSeriesModel2, _super);
  function BaseBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BaseBarSeriesModel2.type;
    return _this;
  }
  BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  BaseBarSeriesModel2.prototype.getMarkerPosition = function(value) {
    var coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      var pt3 = coordSys.dataToPoint(coordSys.clampData(value));
      var data5 = this.getData();
      var offset2 = data5.getLayout("offset");
      var size = data5.getLayout("size");
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt3[offsetIndex] += offset2 + size / 2;
      return pt3;
    }
    return [NaN, NaN];
  };
  BaseBarSeriesModel2.type = "series.__base_bar__";
  BaseBarSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    barMinHeight: 0,
    barMinAngle: 0,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: "mod"
  };
  return BaseBarSeriesModel2;
}(SeriesModel$1);
SeriesModel$1.registerClass(BaseBarSeriesModel);
var BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = function(_super) {
  __extends(BarSeriesModel2, _super);
  function BarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BarSeriesModel2.type;
    return _this;
  }
  BarSeriesModel2.prototype.getInitialData = function() {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  };
  BarSeriesModel2.prototype.getProgressive = function() {
    return this.get("large") ? this.get("progressive") : false;
  };
  BarSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.get("progressiveThreshold");
    var largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  };
  BarSeriesModel2.prototype.brushSelector = function(dataIndex, data5, selectors) {
    return selectors.rect(data5.getItemLayout(dataIndex));
  };
  BarSeriesModel2.type = "series.bar";
  BarSeriesModel2.dependencies = ["grid", "polar"];
  BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: "rgba(180, 180, 180, 0.2)",
      borderColor: null,
      borderWidth: 0,
      borderType: "solid",
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel2;
}(BaseBarSeriesModel$1);
var BarSeries = BarSeriesModel;
var SausageShape = function() {
  function SausageShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return SausageShape2;
}();
var SausagePath = function(_super) {
  __extends(SausagePath2, _super);
  function SausagePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "sausage";
    return _this;
  }
  SausagePath2.prototype.getDefaultShape = function() {
    return new SausageShape();
  };
  SausagePath2.prototype.buildPath = function(ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r2 = Math.max(shape.r, 0);
    var dr2 = (r2 - r0) * 0.5;
    var rCenter = r0 + dr2;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI22 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI22 : startAngle - endAngle < PI22;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI22 : -PI22);
    }
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr2, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r2 + cx, unitStartY * r2 + cy);
    }
    ctx.arc(cx, cy, r2, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr2, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  };
  return SausagePath2;
}(Path$2);
var Sausage = SausagePath;
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    var textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    var mappedSectorPosition = positionMapping(textPosition);
    var distance2 = opts2.distance != null ? opts2.distance : 5;
    var sector = this.shape;
    var cx = sector.cx;
    var cy = sector.cy;
    var r2 = sector.r;
    var r0 = sector.r0;
    var middleR = (r2 + r0) / 2;
    var startAngle = sector.startAngle;
    var endAngle = sector.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r2 - r0) / 2 : 0;
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var x2 = cx + r2 * mathCos2(startAngle);
    var y2 = cy + r2 * mathSin2(startAngle);
    var textAlign = "left";
    var textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x2 = cx + (r0 - distance2) * mathCos2(middleAngle);
        y2 = cy + (r0 - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x2 = cx + (r0 + distance2) * mathCos2(middleAngle);
        y2 = cy + (r0 + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x2 = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y2 = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x2 = cx + middleR * mathCos2(middleAngle);
        y2 = cy + middleR * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x2 = cx + (r2 + distance2) * mathCos2(middleAngle);
        y2 = cy + (r2 + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x2 = cx + (r2 - distance2) * mathCos2(middleAngle);
        y2 = cy + (r2 - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x2 = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y2 = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x2;
    out2.y = y2;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber$c(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray$x(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  var shape = sector.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  var rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}
var mathMax = Math.max;
var mathMin = Math.min;
function getClipArea(coord, data5) {
  var coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      var expandWidth = data5.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView = function(_super) {
  __extends(BarView2, _super);
  function BarView2() {
    var _this = _super.call(this) || this;
    _this.type = BarView2.type;
    _this._isFirstFrame = true;
    return _this;
  }
  BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api);
    this._updateDrawMode(seriesModel);
    var coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    }
  };
  BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype.incrementalRender = function(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  };
  BarView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  BarView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data5 = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data5, api);
    }
    var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data5);
    group.removeClipPath();
    var roundCap = seriesModel.get("roundCap", true);
    var drawBackground = seriesModel.get("showBackground", true);
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var barBorderRadius = backgroundModel.get("borderRadius") || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data5, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data5.diff(oldData).add(function(dataIndex) {
      var itemModel = data5.getItemModel(dataIndex);
      var layout2 = getLayout[coord.type](data5, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data5.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
      }
      var el2 = elementCreator[coord.type](seriesModel, data5, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el2.forceLabelAnimation = true;
      }
      updateStyle$1(el2, data5, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el2.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el2, layout2, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el2, {
          shape: layout2
        }, seriesModel, dataIndex);
      }
      data5.setItemGraphicEl(dataIndex, el2);
      group.add(el2);
      el2.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      var itemModel = data5.getItemModel(newIndex);
      var layout2 = getLayout[coord.type](data5, newIndex, itemModel);
      if (drawBackground) {
        var bgEl = void 0;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        var bgLayout = getLayout[coord.type](data5, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps$2(bgEl, {
          shape
        }, animationModel, newIndex);
      }
      var el2 = oldData.getItemGraphicEl(oldIndex);
      if (!data5.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
        group.remove(el2);
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
        if (isClipped) {
          group.remove(el2);
        }
      }
      if (!el2) {
        el2 = elementCreator[coord.type](seriesModel, data5, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el2, roundCap);
      } else {
        saveOldStyle(el2);
      }
      if (realtimeSortCfg) {
        el2.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        var textEl = el2.getTextContent();
        if (textEl) {
          var labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle$1(el2, data5, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el2.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el2, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps$2(el2, {
          shape: layout2
        }, seriesModel, newIndex, null);
      }
      data5.setItemGraphicEl(newIndex, el2);
      el2.ignore = isClipped;
      group.add(el2);
    }).remove(function(dataIndex) {
      var el2 = oldData.getItemGraphicEl(dataIndex);
      el2 && removeElementWithFadeOut(el2, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$3());
    bgGroup.removeAll();
    for (var i2 = 0; i2 < bgEls.length; ++i2) {
      bgGroup.add(bgEls[i2]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data5;
  };
  BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
    this._clear();
    createLarge(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    this._removeBackground();
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };
  BarView2.prototype._updateLargeClip = function(seriesModel) {
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };
  BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data5, api) {
    var _this = this;
    if (!data5.count()) {
      return;
    }
    var baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data5, realtimeSortCfg, api);
      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function(idx) {
        var el2 = data5.getItemGraphicEl(idx);
        var shape = el2 && el2.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = function() {
        _this._updateSortWithinSameData(data5, orderMapping_1, baseAxis, api);
      };
      api.getZr().on("rendered", this._onRendered);
    }
  };
  BarView2.prototype._dataSort = function(data5, baseAxis, orderMapping) {
    var info2 = [];
    data5.each(data5.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info2.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info2.sort(function(a2, b2) {
      return b2.mappedValue - a2.mappedValue;
    });
    return {
      ordinalNumbers: map$9(info2, function(item) {
        return item.ordinalNumber;
      })
    };
  };
  BarView2.prototype._isOrderChangedWithinSameData = function(data5, orderMapping, baseAxis) {
    var scale2 = baseAxis.scale;
    var ordinalDataDim = data5.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;
    for (var tickNum = 0, len2 = scale2.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      var rawIdx = data5.rawIndexOf(ordinalDataDim, scale2.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data5.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  };
  BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
    var scale2 = baseAxis.scale;
    var extent3 = scale2.getExtent();
    var tickNum = Math.max(0, extent3[0]);
    var tickMax = Math.min(extent3[1], scale2.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale2.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };
  BarView2.prototype._updateSortWithinSameData = function(data5, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data5, orderMapping, baseAxis)) {
      return;
    }
    var sortInfo = this._dataSort(data5, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  };
  BarView2.prototype._dispatchInitSort = function(data5, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;
    var sortResult = this._dataSort(data5, baseAxis, function(dataIdx) {
      return data5.get(data5.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });
    api.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };
  BarView2.prototype.remove = function(ecModel, api) {
    this._clear(this._model);
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype.dispose = function(ecModel, api) {
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype._removeOnRenderedListener = function(api) {
    if (this._onRendered) {
      api.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  };
  BarView2.prototype._clear = function(model) {
    var group = this.group;
    var data5 = this._data;
    if (model && model.isAnimationEnabled() && data5 && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data5.eachItemGraphicEl(function(el2) {
        removeElementWithFadeOut(el2, model, getECData(el2).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  };
  BarView2.prototype._removeBackground = function() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };
  BarView2.type = "bar";
  return BarView2;
}(ChartView$1);
var clip = {
  cartesian2d: function(coordSysBoundingRect, layout2) {
    var signWidth = layout2.width < 0 ? -1 : 1;
    var signHeight = layout2.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x2 = mathMax(layout2.x, coordSysBoundingRect.x);
    var x22 = mathMin(layout2.x + layout2.width, coordSysX2);
    var y2 = mathMax(layout2.y, coordSysBoundingRect.y);
    var y22 = mathMin(layout2.y + layout2.height, coordSysY2);
    var xClipped = x22 < x2;
    var yClipped = y22 < y2;
    layout2.x = xClipped && x2 > coordSysX2 ? x22 : x2;
    layout2.y = yClipped && y2 > coordSysY2 ? y22 : y2;
    layout2.width = xClipped ? 0 : x22 - x2;
    layout2.height = yClipped ? 0 : y22 - y2;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    return xClipped || yClipped;
  },
  polar: function(coordSysClipArea, layout2) {
    var signR = layout2.r0 <= layout2.r ? 1 : -1;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    var r2 = mathMin(layout2.r, coordSysClipArea.r);
    var r0 = mathMax(layout2.r0, coordSysClipArea.r0);
    layout2.r = r2;
    layout2.r0 = r0;
    var clipped = r2 - r0 < 0;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function(seriesModel, data5, newIndex, layout2, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect$2({
      shape: extend$1({}, layout2),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar: function(seriesModel, data5, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? Sausage : Sector$1;
    var sector = new ShapeClass({
      shape: layout2,
      z2: 1
    });
    sector.name = "item";
    var positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === Sausage
    });
    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? "r" : "endAngle";
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout2.startAngle;
      animateTarget[animateProperty] = layout2[animateProperty];
      (isUpdate ? updateProps$2 : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get("realtimeSort", true);
  var baseAxis = coordSys.getBaseAxis();
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el2, layout2, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout2.x,
      width: layout2.width
    };
    seriesTarget = {
      y: layout2.y,
      height: layout2.height
    };
  } else {
    axisTarget = {
      y: layout2.y,
      height: layout2.height
    };
    seriesTarget = {
      x: layout2.x,
      width: layout2.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps$2 : initProps)(el2, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps$2 : initProps)(el2, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    if (!isFinite(obj[props[i2]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d: function(layout2) {
    return !checkPropertiesNotValid(layout2, rectPropties);
  },
  polar: function(layout2) {
    return !checkPropertiesNotValid(layout2, polarPropties);
  }
};
var getLayout = {
  cartesian2d: function(data5, dataIndex, itemModel) {
    var layout2 = data5.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
    var signX = layout2.width > 0 ? 1 : -1;
    var signY = layout2.height > 0 ? 1 : -1;
    return {
      x: layout2.x + signX * fixedLineWidth / 2,
      y: layout2.y + signY * fixedLineWidth / 2,
      width: layout2.width - signX * fixedLineWidth,
      height: layout2.height - signY * fixedLineWidth
    };
  },
  polar: function(data5, dataIndex, itemModel) {
    var layout2 = data5.getItemLayout(dataIndex);
    return {
      cx: layout2.cx,
      cy: layout2.cy,
      r0: layout2.r0,
      r: layout2.r,
      startAngle: layout2.startAngle,
      endAngle: layout2.endAngle,
      clockwise: layout2.clockwise
    };
  }
};
function isZeroOnPolar(layout2) {
  return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return function(isRadial2) {
    var arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return function(position) {
      switch (position) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position + arcOrAngle;
        default:
          return position;
      }
    };
  }(isRadial);
}
function updateStyle$1(el2, data5, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data5.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    el2.setShape("r", itemModel.get(["itemStyle", "borderRadius"]) || 0);
  }
  el2.useStyle(style);
  var cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el2.attr("cursor", cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el2, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el2.getTextContent();
  if (isPolar && label) {
    var position = itemModel.get(["label", "position"]);
    el2.textConfig.inside = position === "middle" ? true : null;
    setSectorTextRotation(el2, position === "outside" ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
    return getDefaultInterpolatedLabel(data5, value);
  });
  var emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el2, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el2, itemModel);
  if (isZeroOnPolar(layout2)) {
    el2.style.fill = "none";
    el2.style.stroke = "none";
    each$q(el2.states, function(state) {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  var borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  var width2 = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height2 = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width2, height2);
}
var LagePathShape = function() {
  function LagePathShape2() {
  }
  return LagePathShape2;
}();
var LargePath = function(_super) {
  __extends(LargePath2, _super);
  function LargePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeBar";
    return _this;
  }
  LargePath2.prototype.getDefaultShape = function() {
    return new LagePathShape();
  };
  LargePath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size = [];
    var barWidth = this.barWidth;
    for (var i2 = 0; i2 < points2.length; i2 += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points2[i2 + 2];
      startPoint[baseDimIdx] = points2[i2 + baseDimIdx];
      startPoint[valueDimIdx] = points2[i2 + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  };
  return LargePath2;
}(Path$2);
function createLarge(seriesModel, group, progressiveEls, incremental) {
  var data5 = seriesModel.getData();
  var baseDimIdx = data5.getLayout("valueAxisHorizontal") ? 1 : 0;
  var largeDataIndices = data5.getLayout("largeDataIndices");
  var barWidth = data5.getLayout("size");
  var backgroundModel = seriesModel.getModel("backgroundStyle");
  var bgPoints = data5.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  var el2 = new LargePath({
    shape: {
      points: data5.getLayout("largePoints")
    },
    incremental: !!incremental,
    z2: 1
  });
  el2.baseDimIdx = baseDimIdx;
  el2.largeDataIndices = largeDataIndices;
  el2.barWidth = barWidth;
  group.add(el2);
  el2.useStyle(data5.getVisual("style"));
  getECData(el2).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el2.on("mousedown", largePathUpdateDataIndex);
    el2.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el2);
}
var largePathUpdateDataIndex = throttle$4(function(event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x2, y2) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points2 = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size = [];
  var barWidth = largePath.barWidth;
  for (var i2 = 0, len2 = points2.length / 3; i2 < len2; i2++) {
    var ii2 = i2 * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points2[ii2 + 2];
    startPoint[baseDimIdx] = points2[ii2 + baseDimIdx];
    startPoint[valueDimIdx] = points2[ii2 + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x2 >= startPoint[0] && x2 <= startPoint[0] + size[0] && y2 >= startPoint[1] && y2 <= startPoint[1] + size[1]) {
      return largeDataIndices[i2];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var rectShape = layout2;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout2;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
  var ElementClz = coord.type === "polar" ? Sector$1 : Rect$2;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
    silent: true,
    z2: 0
  });
}
var BarView$1 = BarView;
function install$d(registers) {
  registers.registerChartView(BarView$1);
  registers.registerSeriesModel(BarSeries);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$1, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}
var PI2 = Math.PI * 2;
var RADIAN$1 = Math.PI / 180;
function getViewRect(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api) {
  var viewRect2 = getViewRect(seriesModel, api);
  var center2 = seriesModel.get("center");
  var radius = seriesModel.get("radius");
  if (!isArray$x(radius)) {
    radius = [0, radius];
  }
  if (!isArray$x(center2)) {
    center2 = [center2, center2];
  }
  var width2 = parsePercent(viewRect2.width, api.getWidth());
  var height2 = parsePercent(viewRect2.height, api.getHeight());
  var size = Math.min(width2, height2);
  var cx = parsePercent(center2[0], width2) + viewRect2.x;
  var cy = parsePercent(center2[1], height2) + viewRect2.y;
  var r0 = parsePercent(radius[0], size / 2);
  var r2 = parsePercent(radius[1], size / 2);
  return {
    cx,
    cy,
    r0,
    r: r2
  };
}
function pieLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var data5 = seriesModel.getData();
    var valueDim = data5.mapDimension("value");
    var viewRect2 = getViewRect(seriesModel, api);
    var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r2 = _a2.r, r0 = _a2.r0;
    var startAngle = -seriesModel.get("startAngle") * RADIAN$1;
    var minAngle = seriesModel.get("minAngle") * RADIAN$1;
    var validDataCount = 0;
    data5.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    var sum3 = data5.getSum(valueDim);
    var unitRadian = Math.PI / (sum3 || validDataCount) * 2;
    var clockwise = seriesModel.get("clockwise");
    var roseType = seriesModel.get("roseType");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var extent3 = data5.getDataExtent(valueDim);
    extent3[0] = 0;
    var restAngle = PI2;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir3 = clockwise ? 1 : -1;
    data5.setLayout({
      viewRect: viewRect2,
      r: r2
    });
    data5.each(valueDim, function(value, idx) {
      var angle;
      if (isNaN(value)) {
        data5.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r2
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum3 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = PI2 / validDataCount;
      }
      if (angle < minAngle) {
        angle = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      var endAngle = currentAngle + dir3 * angle;
      data5.setItemLayout(idx, {
        angle,
        startAngle: currentAngle,
        endAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap(value, extent3, [r0, r2]) : r2
      });
      currentAngle = endAngle;
    });
    if (restAngle < PI2 && validDataCount) {
      if (restAngle <= 1e-3) {
        var angle_1 = PI2 / validDataCount;
        data5.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data5.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir3 * idx * angle_1;
            layout_1.endAngle = startAngle + dir3 * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data5.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data5.getItemLayout(idx);
            var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir3 * angle;
            currentAngle += dir3 * angle;
          }
        });
      }
    }
  });
}
function dataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      var data5 = seriesModel.getData();
      data5.filterSelf(function(idx) {
        var name2 = data5.getName(idx);
        for (var i2 = 0; i2 < legendModels.length; i2++) {
          if (!legendModels[i2].isSelected(name2)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}
var RADIAN = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r2, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;
    for (var i3 = 0; i3 < semi.list.length; i3++) {
      var item = semi.list[i3];
      var dy = Math.abs(item.label.y - cy);
      var rA = r2 + item.len;
      var rA2 = rA * rA;
      var dx2 = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      var newX = cx + (dx2 + item.len2) * dir3;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };
    for (var i3 = 0; i3 < items.length; i3++) {
      if (items[i3].labelAlignTo !== "none") {
        continue;
      }
      var item = items[i3];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        var dx2 = item.label.x - cx - item.len2 * dir3;
        var rA = r2 + item.len;
        var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  var len2 = list.length;
  for (var i2 = 0; i2 < len2; i2++) {
    if (list[i2].position === "outer" && list[i2].labelAlignTo === "labelLine") {
      var dx = list[i2].label.x - farthestX;
      list[i2].linePoints[1][0] += dx;
      list[i2].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r2, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;
  for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
    var label = labelLayoutList[i2].label;
    if (isPositionCenter(labelLayoutList[i2])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i2]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i2]);
    }
  }
  for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
    var layout2 = labelLayoutList[i2];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      if (layout2.labelStyleWidth != null) {
        continue;
      }
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var targetTextWidth = void 0;
      if (layout2.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
        }
      } else if (layout2.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
        }
      }
      layout2.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout2, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r2, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r2, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
    var layout2 = labelLayoutList[i2];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var isAlignToEdge = layout2.labelAlignTo === "edge";
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0;
      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout2.rect.width + extraPaddingH;
      var dist2 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout2.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout2.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist2;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
  if (forceRecalculate === void 0) {
    forceRecalculate = false;
  }
  if (layout2.labelStyleWidth != null) {
    return;
  }
  var label = layout2.label;
  var style = label.style;
  var textRect = layout2.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow;
  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      var innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  var data5 = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
  var viewRect2 = data5.getLayout("viewRect");
  var r2 = data5.getLayout("r");
  var viewWidth = viewRect2.width;
  var viewLeft = viewRect2.x;
  var viewTop = viewRect2.y;
  var viewHeight = viewRect2.height;
  function setNotShow(el2) {
    el2.ignore = true;
  }
  function isLabelShown(label2) {
    if (!label2.ignore) {
      return true;
    }
    for (var key in label2.states) {
      if (label2.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data5.each(function(idx) {
    var sector = data5.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label2 = sector.getTextContent();
    var labelLine2 = sector.getTextGuideLine();
    var itemModel = data5.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    var labelDistance = labelModel.get("distanceToLabelLine");
    var labelAlignTo = labelModel.get("alignTo");
    var edgeDistance = parsePercent(labelModel.get("edgeDistance"), viewWidth);
    var bleedMargin = labelModel.get("bleedMargin");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each$q(label2.states, setNotShow);
      label2.ignore = true;
      return;
    }
    if (!isLabelShown(label2)) {
      return;
    }
    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints2;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        var x2 = x1 + nx * (labelLineLen + r2 - sectorShape.r);
        var y2 = y1 + ny * (labelLineLen + r2 - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints2 = [[x1, y1], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    var PI3 = Math.PI;
    var labelRotate = 0;
    var rotate2 = labelModel.get("rotate");
    if (isNumber$c(rotate2)) {
      labelRotate = rotate2 * (PI3 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      var radialAngle = nx < 0 ? -midAngle + PI3 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      var rad = Math.atan2(nx, ny);
      if (rad < 0) {
        rad = PI3 * 2 + rad;
      }
      var isDown = ny > 0;
      if (isDown) {
        rad = PI3 + rad;
      }
      labelRotate = rad - PI3;
    }
    hasLabelRotate = !!labelRotate;
    label2.x = textX;
    label2.y = textY;
    label2.rotation = labelRotate;
    label2.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      var textRect = label2.getBoundingRect().clone();
      textRect.applyTransform(label2.getComputedTransform());
      var margin = (label2.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label2,
        labelLine: labelLine2,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point$2(nx, ny),
        linePoints: linePoints2,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label2.style.width
      });
    } else {
      label2.setStyle({
        align: textAlign
      });
      var selectState2 = label2.states.select;
      if (selectState2) {
        selectState2.x += label2.x;
        selectState2.y += label2.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r2, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (var i2 = 0; i2 < labelLayoutList.length; i2++) {
    var layout2 = labelLayoutList[i2];
    var label = layout2.label;
    var labelLine = layout2.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout2.textAlign
      });
      if (notShowLabel) {
        each$q(label.states, setNotShow);
        label.ignore = true;
      }
      var selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      var linePoints = layout2.linePoints;
      if (notShowLabel || !linePoints) {
        each$q(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout2.minTurnAngle);
        limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        });
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point$2(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}
function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }
  if (!isArray$x(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  var dr2 = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map$9(cornerRadius, function(cr2) {
      return parsePercent$1(cr2, dr2);
    })
  };
}
var PiePiece = function(_super) {
  __extends(PiePiece2, _super);
  function PiePiece2(data5, idx, startAngle) {
    var _this = _super.call(this) || this;
    _this.z2 = 2;
    var text2 = new ZRText$1();
    _this.setTextContent(text2);
    _this.updateData(data5, idx, startAngle, true);
    return _this;
  }
  PiePiece2.prototype.updateData = function(data5, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data5.hostModel;
    var itemModel = data5.getItemModel(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = data5.getItemLayout(idx);
    var sectorShape = extend$1(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout2.r0;
        initProps(sector, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({
            startAngle,
            endAngle: startAngle
          });
          initProps(sector, {
            shape: {
              startAngle: layout2.startAngle,
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout2.startAngle;
          updateProps$2(sector, {
            shape: {
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps$2(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data5.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var offset2 = seriesModel.get("selectedOffset");
    var dx = Math.cos(midAngle) * offset2;
    var dy = Math.sin(midAngle) * offset2;
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data5, idx);
    sector.ensureState("emphasis").shape = extend$1({
      r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
    extend$1(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
    });
    extend$1(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && extend$1(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend$1(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  PiePiece2.prototype._updateLabel = function(seriesModel, data5, idx) {
    var sector = this;
    var itemModel = data5.getItemModel(idx);
    var labelLineModel = itemModel.getModel("labelLine");
    var style = data5.getItemVisual(idx, "style");
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data5.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data5.getName(idx)
    });
    var labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline$1();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  };
  return PiePiece2;
}(Sector$1);
var PieView = function(_super) {
  __extends(PieView2, _super);
  function PieView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var data5 = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle;
    if (!oldData && data5.count() > 0) {
      var shape = data5.getItemLayout(0);
      for (var s2 = 1; isNaN(shape && shape.startAngle) && s2 < data5.count(); ++s2) {
        shape = data5.getItemLayout(s2);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data5.count() === 0 && seriesModel.get("showEmptyCircle")) {
      var sector = new Sector$1({
        shape: getBasicPieLayout(seriesModel, api)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data5.diff(oldData).add(function(idx) {
      var piePiece = new PiePiece(data5, idx, startAngle);
      data5.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data5, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data5.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data5;
    }
  };
  PieView2.prototype.dispose = function() {
  };
  PieView2.prototype.containPoint = function(point, seriesModel) {
    var data5 = seriesModel.getData();
    var itemLayout = data5.getItemLayout(0);
    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  PieView2.type = "pie";
  return PieView2;
}(ChartView$1);
var PieView$1 = PieView;
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray$x(opt) && {
    coordDimensions: opt
  } || extend$1({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
  var list = new SeriesData$1(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}
var LegendVisualProvider = function() {
  function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  LegendVisualProvider2.prototype.getAllNames = function() {
    var rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  };
  LegendVisualProvider2.prototype.containName = function(name2) {
    var rawData = this._getRawData();
    return rawData.indexOfName(name2) >= 0;
  };
  LegendVisualProvider2.prototype.indexOfName = function(name2) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name2);
  };
  LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };
  return LegendVisualProvider2;
}();
var LegendVisualProvider$1 = LegendVisualProvider;
var PieSeriesModel = function(_super) {
  __extends(PieSeriesModel2, _super);
  function PieSeriesModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$3(this.getData, this), bind$3(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  PieSeriesModel2.prototype.mergeOption = function() {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  PieSeriesModel2.prototype.getInitialData = function() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
  };
  PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data5 = this.getData();
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    var valueList = [];
    data5.each(data5.mapDimension("value"), function(value) {
      valueList.push(value);
    });
    params.percent = getPercentWithPrecision(valueList, dataIndex, data5.hostModel.get("percentPrecision"));
    params.$vars.push("percent");
    return params;
  };
  PieSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  PieSeriesModel2.type = "series.pie";
  PieSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    minShowLabelAngle: 0,
    selectedOffset: 10,
    percentPrecision: 2,
    stillShowZeroSum: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      rotate: 0,
      show: true,
      overflow: "truncate",
      position: "outer",
      alignTo: "none",
      edgeDistance: "25%",
      bleedMargin: 10,
      distanceToLabelLine: 5
    },
    labelLine: {
      show: true,
      length: 15,
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: "round"
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: "lightgray",
      opacity: 1
    },
    labelLayout: {
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    avoidLabelOverlap: true,
    animationType: "expansion",
    animationDuration: 1e3,
    animationTypeUpdate: "transition",
    animationEasingUpdate: "cubicInOut",
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut"
  };
  return PieSeriesModel2;
}(SeriesModel$1);
var PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var data5 = seriesModel.getData();
      data5.filterSelf(function(idx) {
        var valueDim = data5.mapDimension("value");
        var curValue = data5.get(valueDim, idx);
        if (isNumber$c(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}
function install$c(registers) {
  registers.registerChartView(PieView$1);
  registers.registerSeriesModel(PieSeriesModel$1);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry$1(pieLayout, "pie"));
  registers.registerProcessor(dataFilter("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}
var GridModel = function(_super) {
  __extends(GridModel2, _super);
  function GridModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridModel2.type = "grid";
  GridModel2.dependencies = ["xAxis", "yAxis"];
  GridModel2.layoutMode = "box";
  GridModel2.defaultOption = {
    show: false,
    z: 0,
    left: "10%",
    top: 60,
    right: "10%",
    bottom: 70,
    containLabel: false,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 1,
    borderColor: "#ccc"
  };
  return GridModel2;
}(ComponentModel$1);
var GridModel$1 = GridModel;
var CartesianAxisModel = function(_super) {
  __extends(CartesianAxisModel2, _super);
  function CartesianAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  };
  CartesianAxisModel2.type = "cartesian2dAxis";
  return CartesianAxisModel2;
}(ComponentModel$1);
mixin$1(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis = merge$2({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption);
var valueAxis = merge$2({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption);
var timeAxis = merge$2({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};
var AXIS_TYPES = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each$q(AXIS_TYPES, function(v2, axisType) {
    var defaultOption2 = merge$2(merge$2({}, axisDefault[axisType], true), extraDefaultOption, true);
    var AxisModel = function(_super) {
      __extends(AxisModel2, _super);
      function AxisModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = axisName + "Axis." + axisType;
        return _this;
      }
      AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge$2(option, themeModel.get(axisType + "Axis"));
        merge$2(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      AxisModel2.prototype.optionUpdated = function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      };
      AxisModel2.prototype.getCategories = function(rawData) {
        var option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      };
      AxisModel2.prototype.getOrdinalMeta = function() {
        return this.__ordinalMeta;
      };
      AxisModel2.type = axisName + "Axis." + axisType;
      AxisModel2.defaultOption = defaultOption2;
      return AxisModel2;
    }(BaseAxisModelClass);
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}
var Cartesian = function() {
  function Cartesian2(name2) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name2 || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map$9(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter$3(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale2) {
  return scale2.type === "interval" || scale2.type === "time";
}
var Cartesian2D = function(_super) {
  __extends(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end2[0] - start2[0]) / xScaleSpan;
    var scaleY = (end2[1] - start2[1]) / yScaleSpan;
    var translateX = start2[0] - xScaleExtent[0] * scaleX;
    var translateY = start2[1] - yScaleExtent[0] * scaleY;
    var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };
  Cartesian2D2.prototype.containData = function(data5) {
    return this.getAxis("x").containData(data5[0]) && this.getAxis("y").containData(data5[1]);
  };
  Cartesian2D2.prototype.containZone = function(data1, data22) {
    var zoneDiag1 = this.dataToPoint(data1);
    var zoneDiag2 = this.dataToPoint(data22);
    var area = this.getArea();
    var zone = new BoundingRect$1(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  };
  Cartesian2D2.prototype.dataToPoint = function(data5, clamp2, out2) {
    out2 = out2 || [];
    var xVal = data5[0];
    var yVal = data5[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform$1(out2, data5, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  };
  Cartesian2D2.prototype.clampData = function(data5, out2) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x2 = xScale.parse(data5[0]);
    var y2 = yScale.parse(data5[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x2), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y2), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  };
  Cartesian2D2.prototype.pointToData = function(point, clamp2) {
    var out2 = [];
    if (this._invTransform) {
      return applyTransform$1(out2, point, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function() {
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x2 = Math.min(xExtent[0], xExtent[1]);
    var y2 = Math.min(yExtent[0], yExtent[1]);
    var width2 = Math.max(xExtent[0], xExtent[1]) - x2;
    var height2 = Math.max(yExtent[0], yExtent[1]) - y2;
    return new BoundingRect$1(x2, y2, width2, height2);
  };
  return Cartesian2D2;
}(Cartesian$1);
var Axis2D = function(_super) {
  __extends(Axis2D2, _super);
  function Axis2D2(dim, scale2, coordExtent, axisType, position) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position = this.position;
    return position === "top" || position === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc2) {
    var ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc2 && ret[0] > ret[1] && ret.reverse();
    return ret;
  };
  Axis2D2.prototype.pointToData = function(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info2) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info2;
    this.scale.setSortInfo(info2);
  };
  return Axis2D2;
}(Axis$1);
var Axis2D$1 = Axis2D;
function layout(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get("offset") || 0;
  var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
  layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
  layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout2.z2 = 1;
  return layout2;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each$q(axisModelMap, function(v2, key) {
    var axisType = key.replace(/Model$/, "");
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}
var mathLog = Math.log;
function alignScaleTicks(scale2, axisModel, alignToScale) {
  var intervalScaleProto2 = IntervalScale$1.prototype;
  var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale2, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale2.type === "log") {
    var logBase = mathLog(scale2.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }
  scale2.setExtent(rawExtent[0], rawExtent[1]);
  scale2.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent3 = intervalScaleProto2.getExtent.call(scale2);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  var interval = intervalScaleProto2.getInterval.call(scale2);
  var min3 = rawExtent[0];
  var max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale2.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range2 = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round$5(max3 - range2);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round$5(range2);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round$5(range2);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale2, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto2.setInterval.call(scale2, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale2, min3 + interval, max3 - interval);
  }
}
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys$d(axes);
      var len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i2 = len2 - 1; i2 >= 0; i2--) {
        var idx = +axesIndices[i2];
        var axis = axes[idx];
        var model = axis.model;
        var scale2 = axis.scale;
        if (isIntervalOrLogScale(scale2) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale2, model);
          if (isIntervalOrLogScale(scale2)) {
            alignTo = axis;
          }
        }
      }
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each$q(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each$q(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each$q(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each$q(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each$q(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each$q(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject$f(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i2 = 0, coordList = this._coordsList; i2 < coordList.length; i2++) {
      if (coordList[i2].getAxis("x").index === xAxisIndex || coordList[i2].getAxis("y").index === yAxisIndex) {
        return coordList[i2];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf$2(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each$q(axesMap.x, function(xAxis, xAxisIndex) {
      each$q(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;
        _this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D$1(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each$q(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data5 = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        unionExtent(data5, xAxis);
        unionExtent(data5, yAxis);
      }
    }, this);
    function unionExtent(data5, axis) {
      each$q(getDataDimensionsOnAxis(data5, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data5, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$q(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf$2(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf$2(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid = new Grid2(gridModel, ecModel, api);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid$1 = Grid;
var PI = Math.PI;
var AxisBuilder = function() {
  function AxisBuilder2(axisModel, opt) {
    this.group = new Group$3();
    this.opt = opt;
    this.axisModel = axisModel;
    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function() {
        return true;
      }
    });
    var transformGroup = new Group$3({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  AxisBuilder2.prototype.hasBuilder = function(name2) {
    return !!builders[name2];
  };
  AxisBuilder2.prototype.add = function(name2) {
    builders[name2](this.opt, this.axisModel, this.group, this._transformGroup);
  };
  AxisBuilder2.prototype.getGroup = function() {
    return this.group;
  };
  AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  AxisBuilder2.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  return AxisBuilder2;
}();
var builders = {
  axisLine: function(opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    var extent3 = axisModel.axis.getExtent();
    var matrix2 = transformGroup.transform;
    var pt12 = [extent3[0], 0];
    var pt22 = [extent3[1], 0];
    if (matrix2) {
      applyTransform$1(pt12, pt12, matrix2);
      applyTransform$1(pt22, pt22, matrix2);
    }
    var lineStyle = extend$1({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    var line = new Line$1({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    line.anid = "line";
    group.add(line);
    var arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString$d(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString$d(arrowSize) || isNumber$c(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each$q([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index) {
        if (arrows[index] !== "none" && arrows[index] != null) {
          var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
          var r2 = point.r + point.offset;
          symbol.attr({
            rotation: point.rotate,
            x: pt12[0] + r2 * Math.cos(opt.rotation),
            y: pt12[1] - r2 * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function(opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      var labelList = prepareLayoutList(map$9(labelEls, function(label) {
        return {
          label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function(opt, axisModel, group, transformGroup) {
    var name2 = retrieve(opt.axisName, axisModel.get("name"));
    if (!name2) {
      return;
    }
    var nameLocation = axisModel.get("nameLocation");
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel("nameTextStyle");
    var gap = axisModel.get("nameGap") || 0;
    var extent3 = axisModel.axis.getExtent();
    var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    var pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    var labelLayout;
    var nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI / 180;
    }
    var axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout = AxisBuilder.innerTextLayout(
        opt.rotation,
        nameRotation != null ? nameRotation : opt.rotation,
        nameDirection
      );
    } else {
      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get("nameTruncate", true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new ZRText$1({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle$1(textStyleModel, {
        text: name2,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name2
    });
    textEl.__fullText = name2;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name2;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent3[0] > extent3[1];
  var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick2 = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick2);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el2) {
  el2 && (el2.ignore = true);
}
function isTwoLabelOverlapped(current, next) {
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  var mRotationBack = identity$2([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt12 = [];
  var pt22 = [];
  for (var i2 = 0; i2 < ticksCoords.length; i2++) {
    var tickCoord = ticksCoords[i2].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform$1(pt12, pt12, tickTransform);
      applyTransform$1(pt22, pt22, tickTransform);
    }
    var tickEl = new Line$1({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    tickEl.anid = anidPrefix + "_" + ticksCoords[i2].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel("axisTick");
  var shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  var lineStyleModel = tickModel.getModel("lineStyle");
  var tickEndCoord = opt.tickDirection * tickModel.get("length");
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (var i2 = 0; i2 < ticksEls.length; i2++) {
    group.add(ticksEls[i2]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  var minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  var lineStyleModel = minorTickModel.getModel("lineStyle");
  var tickEndCoord = tickDirection * minorTickModel.get("length");
  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (var i2 = 0; i2 < minorTicksCoords.length; i2++) {
    var minorTicksEls = createTicks(minorTicksCoords[i2], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i2);
    for (var k2 = 0; k2 < minorTicksEls.length; k2++) {
      group.add(minorTicksEls[k2]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show2 = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show2 || axis.scale.isBlank()) {
    return;
  }
  var labelModel = axisModel.getModel("axisLabel");
  var labelMargin = labelModel.get("margin");
  var labels = axis.getViewLabels();
  var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI / 180;
  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent2 = axisModel.get("triggerEvent");
  each$q(labels, function(labelItem, index) {
    var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];
      if (isObject$f(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model$1(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new ZRText$1({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle$1(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow("align", true) || labelLayout.textAlign,
        verticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign,
        fill: isFunction$h(textColor) ? textColor(
          axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
          index
        ) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    if (triggerEvent2) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index;
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder$1 = AxisBuilder;
function collect(ecModel, api) {
  var result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent("tooltip");
  var globalAxisPointerModel = ecModel.getComponent("axisPointer");
  var linksOption = globalAxisPointerModel.get("link", true) || [];
  var linkGroups = [];
  each$q(api.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each$q(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      var triggerAxis = baseTooltipModel.get("trigger") === "axis";
      var cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross) {
        each$q(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
      }
      if (cross) {
        each$q(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get("snap");
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === "category";
      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
  var volatileOption = {};
  each$q(fields, function(field) {
    volatileOption[field] = clone$8(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  var labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model$1(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each$q(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      var axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;
  for (var i2 = 0; i2 < linksOption.length; i2++) {
    var linkOption = linksOption[i2] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i2;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray$x(linkPropValue) && indexOf$2(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  if (!axisInfo) {
    return;
  }
  var axisPointerModel = axisInfo.axisPointerModel;
  var scale2 = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get("status");
  var value = axisPointerModel.get("value");
  if (value != null) {
    value = scale2.parse(value);
  }
  var useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  var extent3 = scale2.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value == null || value > extent3[1]) {
    value = extent3[1];
  }
  if (value < extent3[0]) {
    value = extent3[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}
var axisPointerClazz = {};
var AxisView = function(_super) {
  __extends(AxisView2, _super);
  function AxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisView2.type;
    return _this;
  }
  AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.axisPointerClass && fixValue(axisModel);
    _super.prototype.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  AxisView2.prototype.remove = function(ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  AxisView2.prototype.dispose = function(ecModel, api) {
    this._disposeAxisPointer(api);
    _super.prototype.dispose.apply(this, arguments);
  };
  AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
    var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };
  AxisView2.prototype._disposeAxisPointer = function(api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };
  AxisView2.registerAxisPointerClass = function(type2, clazz) {
    axisPointerClazz[type2] = clazz;
  };
  AxisView2.getAxisPointerClass = function(type2) {
    return type2 && axisPointerClazz[type2];
  };
  AxisView2.type = "axis";
  return AxisView2;
}(ComponentView$1);
var AxisView$1 = AxisView;
var inner$4 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  var splitAreaModel = axisModel.getModel("splitArea");
  var areaStyleModel = splitAreaModel.getModel("areaStyle");
  var areaColors = areaStyleModel.get("color");
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner$4(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;
  if (lastSplitAreaColors) {
    for (var i2 = 0; i2 < ticksCoords.length; i2++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i2].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i2) % areaColorsLen;
        break;
      }
    }
  }
  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray$x(areaColors) ? areaColors : [areaColors];
  for (var i2 = 1; i2 < ticksCoords.length; i2++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i2].coord);
    var x2 = void 0;
    var y2 = void 0;
    var width2 = void 0;
    var height2 = void 0;
    if (axis.isHorizontal()) {
      x2 = prev;
      y2 = gridRect.y;
      width2 = tickCoord - x2;
      height2 = gridRect.height;
      prev = x2 + width2;
    } else {
      x2 = gridRect.x;
      y2 = prev;
      width2 = gridRect.width;
      height2 = tickCoord - y2;
      prev = y2 + height2;
    }
    var tickValue = ticksCoords[i2 - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect$2({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x: x2,
        y: y2,
        width: width2,
        height: height2
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner$4(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner$4(axisView).splitAreaColors = null;
}
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
var CartesianAxisView = function(_super) {
  __extends(CartesianAxisView2, _super);
  function CartesianAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianAxisView2.type;
    _this.axisPointerClass = "CartesianAxisPointer";
    return _this;
  }
  CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$3();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var gridModel = axisModel.getCoordSysModel();
    var layout$12 = layout(gridModel, axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, extend$1({
      handleAutoShown: function(elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();
        for (var i2 = 0; i2 < cartesians.length; i2++) {
          if (isIntervalOrLogScale(cartesians[i2].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout$12));
    each$q(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each$q(selfBuilderAttrs, function(name2) {
      if (axisModel.get([name2, "show"])) {
        axisElementBuilders[name2](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  CartesianAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  CartesianAxisView2.type = "cartesianAxis";
  return CartesianAxisView2;
}(AxisView$1);
var axisElementBuilders = {
  splitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = isArray$x(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i2 = 0; i2 < ticksCoords.length; i2++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i2].coord);
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i2].tickValue;
      axisGroup.add(new Line$1({
        anid: tickValue != null ? "line_" + ticksCoords[i2].tickValue : null,
        subPixelOptimize: true,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      }));
    }
  },
  minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var p1 = [];
    var p2 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i2 = 0; i2 < minorTicksCoords.length; i2++) {
      for (var k2 = 0; k2 < minorTicksCoords[i2].length; k2++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i2][k2].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        axisGroup.add(new Line$1({
          anid: "minor_line_" + minorTicksCoords[i2][k2].tickValue,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        }));
      }
    }
  },
  splitArea: function(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView = function(_super) {
  __extends(CartesianXAxisView2, _super);
  function CartesianXAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView2.type;
    return _this;
  }
  CartesianXAxisView2.type = "xAxis";
  return CartesianXAxisView2;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
  __extends(CartesianYAxisView2, _super);
  function CartesianYAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView.type;
    return _this;
  }
  CartesianYAxisView2.type = "yAxis";
  return CartesianYAxisView2;
}(CartesianAxisView);
var GridView = function(_super) {
  __extends(GridView2, _super);
  function GridView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    return _this;
  }
  GridView2.prototype.render = function(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect$2({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };
  GridView2.type = "grid";
  return GridView2;
}(ComponentView$1);
var extraOption = {
  offset: 0
};
function install$b(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel$1);
  registers.registerCoordinateSystem("cartesian2d", Grid$1);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}
var ATTR = "\0_ec_interaction_mutex";
function isTaken(zr2, resourceKey) {
  return !!getStore(zr2)[resourceKey];
}
function getStore(zr2) {
  return zr2[ATTR] || (zr2[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop$3);
var RoamController = function(_super) {
  __extends(RoamController2, _super);
  function RoamController2(zr2) {
    var _this = _super.call(this) || this;
    _this._zr = zr2;
    var mousedownHandler = bind$3(_this._mousedownHandler, _this);
    var mousemoveHandler = bind$3(_this._mousemoveHandler, _this);
    var mouseupHandler = bind$3(_this._mouseupHandler, _this);
    var mousewheelHandler = bind$3(_this._mousewheelHandler, _this);
    var pinchHandler = bind$3(_this._pinchHandler, _this);
    _this.enable = function(controlType, opt) {
      this.disable();
      this._opt = defaults(clone$8(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || controlType === "move" || controlType === "pan") {
        zr2.on("mousedown", mousedownHandler);
        zr2.on("mousemove", mousemoveHandler);
        zr2.on("mouseup", mouseupHandler);
      }
      if (controlType === true || controlType === "scale" || controlType === "zoom") {
        zr2.on("mousewheel", mousewheelHandler);
        zr2.on("pinch", pinchHandler);
      }
    };
    _this.disable = function() {
      zr2.off("mousedown", mousedownHandler);
      zr2.off("mousemove", mousemoveHandler);
      zr2.off("mouseup", mouseupHandler);
      zr2.off("mousewheel", mousewheelHandler);
      zr2.off("pinch", pinchHandler);
    };
    return _this;
  }
  RoamController2.prototype.isDragging = function() {
    return this._dragging;
  };
  RoamController2.prototype.isPinching = function() {
    return this._pinching;
  };
  RoamController2.prototype.setPointerChecker = function(pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  RoamController2.prototype.dispose = function() {
    this.disable();
  };
  RoamController2.prototype._mousedownHandler = function(e3) {
    if (isMiddleOrRightButtonOnMouseUpDown(e3) || e3.target && e3.target.draggable) {
      return;
    }
    var x2 = e3.offsetX;
    var y2 = e3.offsetY;
    if (this.pointerChecker && this.pointerChecker(e3, x2, y2)) {
      this._x = x2;
      this._y = y2;
      this._dragging = true;
    }
  };
  RoamController2.prototype._mousemoveHandler = function(e3) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e3, this._opt) || e3.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
      return;
    }
    var x2 = e3.offsetX;
    var y2 = e3.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x2 - oldX;
    var dy = y2 - oldY;
    this._x = x2;
    this._y = y2;
    this._opt.preventDefaultMouseMove && stop(e3.event);
    trigger(this, "pan", "moveOnMouseMove", e3, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x2,
      newY: y2,
      isAvailableBehavior: null
    });
  };
  RoamController2.prototype._mouseupHandler = function(e3) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e3)) {
      this._dragging = false;
    }
  };
  RoamController2.prototype._mousewheelHandler = function(e3) {
    var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e3, this._opt);
    var shouldMove = isAvailableBehavior("moveOnMouseWheel", e3, this._opt);
    var wheelDelta = e3.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e3.offsetX;
    var originY = e3.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale2 = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e3, {
        scale: scale2,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      var absDelta = Math.abs(wheelDelta);
      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e3, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  };
  RoamController2.prototype._pinchHandler = function(e3) {
    if (isTaken(this._zr, "globalPan")) {
      return;
    }
    var scale2 = e3.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e3, {
      scale: scale2,
      originX: e3.pinchX,
      originY: e3.pinchY,
      isAvailableBehavior: null
    });
  };
  return RoamController2;
}(Eventful$1);
function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e3, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e3, contollerEvent.originX, contollerEvent.originY)) {
    stop(e3.event);
    trigger(controller, eventName, behaviorToCheck, e3, contollerEvent);
  }
}
function trigger(controller, eventName, behaviorToCheck, e3, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind$3(isAvailableBehavior, null, behaviorToCheck, e3);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e3, settings) {
  var setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString$d(setting) || e3.event[setting + "Key"]);
}
var RoamController$1 = RoamController;
function sliderMove(delta, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  var extentSpan = extent3[1] - extent3[0];
  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict(handleEnds[0], extent3);
  handleEnds[1] = restrict(handleEnds[1], extent3);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta;
  var extentMinSpan = minSpan || 0;
  var realExtent = extent3.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  var dist2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {
    span: Math.abs(dist2),
    sign: dist2 > 0 ? -1 : dist2 < 0 ? 1 : handleIndex ? -1 : 1
  };
}
function restrict(value, extend2) {
  return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
}
var inner$3 = makeInner();
var clone$5 = clone$8;
var bind$2 = bind$3;
var BaseAxisPointer = function() {
  function BaseAxisPointer2() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get("value");
    var status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
    var graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }
    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group$3();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry$1(updateProps$1, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  };
  BaseAxisPointer2.prototype.remove = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.dispose = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
    var animation = axisPointerModel.get("animation");
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === "category";
    var useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      var animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  };
  BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
  };
  BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;
    if (pointerOption) {
      var pointerEl = inner$3(group).pointerEl = new graphic$1[pointerOption.type](clone$5(elOption.pointer));
      group.add(pointerEl);
    }
  };
  BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner$3(group).labelEl = new ZRText$1(clone$5(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
    var pointerEl = inner$3(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps2(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
    var labelEl = inner$3(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps2(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype._renderHandle = function(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    var axisPointerModel = this._axisPointerModel;
    var zr2 = this._api.getZr();
    var handle = this._handle;
    var handleModel = axisPointerModel.getModel("handle");
    var status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr2.remove(handle);
      this._handle = null;
      return;
    }
    var isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove: function(e3) {
          stop(e3.event);
        },
        onmousedown: bind$2(this._onHandleDragMove, this, 0, 0),
        drift: bind$2(this._onHandleDragMove, this),
        ondragend: bind$2(this._onHandleDragEnd, this)
      });
      zr2.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
    var handleSize = handleModel.get("size");
    if (!isArray$x(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  };
  BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
    updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };
  BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner$3(handle).lastProp = null;
    this._doDispatchAxisPointer();
  };
  BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };
  BaseAxisPointer2.prototype._onHandleDragEnd = function() {
    this._dragging = false;
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  };
  BaseAxisPointer2.prototype.clear = function(api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr2 = api.getZr();
    var group = this._group;
    var handle = this._handle;
    if (zr2 && group) {
      this._lastGraphicKey = null;
      group && zr2.remove(group);
      handle && zr2.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear$3(this, "_doDispatchAxisPointer");
  };
  BaseAxisPointer2.prototype.doClear = function() {
  };
  BaseAxisPointer2.prototype.buildLabel = function(xy, wh2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh2[xDimIndex],
      height: wh2[1 - xDimIndex]
    };
  };
  return BaseAxisPointer2;
}();
function updateProps$1(animationModel, moveAnimation, el2, props) {
  if (!propsEqual(inner$3(el2).lastProp, props)) {
    inner$3(el2).lastProp = props;
    moveAnimation ? updateProps$2(el2, props, animationModel) : (el2.stopAnimation(), el2.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject$f(lastProps) && isObject$f(newProps)) {
    var equals_1 = true;
    each$q(newProps, function(item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  var z2 = axisPointerModel.get("z");
  var zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el2) {
    if (el2.type !== "group") {
      z2 != null && (el2.z = z2);
      zlevel != null && (el2.zlevel = zlevel);
      el2.silent = silent;
    }
  });
}
var BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get("type");
  var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  var style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get("value");
  var text2 = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  var labelModel = axisPointerModel.getModel("label");
  var paddings = normalizeCssArray(labelModel.get("padding") || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text2, font);
  var position = labelPos.position;
  var width2 = textRect.width + paddings[1] + paddings[3];
  var height2 = textRect.height + paddings[0] + paddings[2];
  var align = labelPos.align;
  align === "right" && (position[0] -= width2);
  align === "center" && (position[0] -= width2 / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position[1] -= height2);
  verticalAlign === "middle" && (position[1] -= height2 / 2);
  confineInContainer(position, width2, height2, api);
  var bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position[0],
    y: position[1],
    style: createTextStyle$1(labelModel, {
      text: text2,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position, width2, height2, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position[0] = Math.min(position[0] + width2, viewWidth) - width2;
  position[1] = Math.min(position[1] + height2, viewHeight) - height2;
  position[0] = Math.max(position[0], 0);
  position[1] = Math.max(position[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text2 = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  var formatter = opt.formatter;
  if (formatter) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each$q(seriesDataIndices, function(idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });
    if (isString$d(formatter)) {
      text2 = formatter.replace("{value}", text2);
    } else if (isFunction$h(formatter)) {
      text2 = formatter(params_1);
    }
  }
  return text2;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform = create();
  rotate(transform, transform, layoutInfo.rotation);
  translate$1(transform, transform, layoutInfo.position);
  return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder$1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh2[xDimIndex],
    height: wh2[1 - xDimIndex]
  };
}
var CartesianAxisPointer = function(_super) {
  __extends(CartesianAxisPointer2, _super);
  function CartesianAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get("type");
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout(grid.model, axisModel);
    buildCartesianSingleLabelElOption(
      value,
      elOption,
      layoutInfo,
      axisModel,
      axisPointerModel,
      api
    );
  };
  CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  CartesianAxisPointer2.prototype.updateHandleTransform = function(transform, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === "x" ? 0 : 1;
    var currPosition = [transform.x, transform.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    var tooltipOptions = [{
      verticalAlign: "middle"
    }, {
      align: "center"
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };
  return CartesianAxisPointer2;
}(BaseAxisPointer$1);
function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = function(_super) {
  __extends(AxisPointerModel2, _super);
  function AxisPointerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerModel2.type;
    return _this;
  }
  AxisPointerModel2.type = "axisPointer";
  AxisPointerModel2.defaultOption = {
    show: "auto",
    z: 50,
    type: "line",
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: "#B9BEC9",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(210,219,238,0.2)"
    },
    label: {
      show: true,
      formatter: null,
      precision: "auto",
      margin: 3,
      color: "#fff",
      padding: [5, 7, 5, 7],
      backgroundColor: "auto",
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
      size: 45,
      margin: 50,
      color: "#333",
      shadowBlur: 3,
      shadowColor: "#aaa",
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      throttle: 40
    }
  };
  return AxisPointerModel2;
}(ComponentModel$1);
var AxisPointerModel$1 = AxisPointerModel;
var inner$2 = makeInner();
var each$n = each$q;
function register(key, api, handler3) {
  if (env$1.node) {
    return;
  }
  var zr2 = api.getZr();
  inner$2(zr2).records || (inner$2(zr2).records = {});
  initGlobalListeners(zr2, api);
  var record = inner$2(zr2).records[key] || (inner$2(zr2).records[key] = {});
  record.handler = handler3;
}
function initGlobalListeners(zr2, api) {
  if (inner$2(zr2).initialized) {
    return;
  }
  inner$2(zr2).initialized = true;
  useHandler("click", curry$1(doEnter, "click"));
  useHandler("mousemove", curry$1(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr2.on(eventType, function(e3) {
      var dis = makeDispatchAction$1(api);
      each$n(inner$2(zr2).records, function(record) {
        record && cb(record, e3, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}
function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e3, dispatchAction2) {
  record.handler("leave", null, dispatchAction2);
}
function doEnter(currTrigger, record, e3, dispatchAction2) {
  record.handler(currTrigger, e3, dispatchAction2);
}
function makeDispatchAction$1(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  };
  var dispatchAction2 = function(payload) {
    var pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction2;
      api.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction2,
    pendings
  };
}
function unregister(key, api) {
  if (env$1.node) {
    return;
  }
  var zr2 = api.getZr();
  var record = (inner$2(zr2).records || {})[key];
  if (record) {
    inner$2(zr2).records[key] = null;
  }
}
var AxisPointerView = function(_super) {
  __extends(AxisPointerView2, _super);
  function AxisPointerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerView2.type;
    return _this;
  }
  AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
    register("axisPointer", api, function(currTrigger, e3, dispatchAction2) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction2({
          type: "updateAxisPointer",
          currTrigger,
          x: e3 && e3.offsetX,
          y: e3 && e3.offsetY
        });
      }
    });
  };
  AxisPointerView2.prototype.remove = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.prototype.dispose = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.type = "axisPointer";
  return AxisPointerView2;
}(ComponentView$1);
var AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  var data5 = seriesModel.getData();
  var dataIndex = queryDataIndex(data5, finder);
  if (dataIndex == null || dataIndex < 0 || isArray$x(dataIndex)) {
    return {
      point: []
    };
  }
  var el2 = data5.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis2 = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis2.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var baseDim = data5.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data5.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data5.get(data5.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data5.getValues(map$9(coordSys.dimensions, function(dim) {
        return data5.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el2) {
    var rect = el2.getBoundingRect().clone();
    rect.applyTransform(el2.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
  return {
    point,
    el: el2
  };
}
var inner$1 = makeInner();
function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction2 = payload.dispatchAction || bind$3(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  var isIllegalPoint = illegalPoint(point);
  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === "leave" || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry$1(showPointer, showValueMap),
    showTooltip: curry$1(showTooltip, dataByCoordSys)
  };
  each$q(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each$q(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val2 = inputAxisInfo && inputAxisInfo.value;
        if (val2 == null && !isIllegalPoint) {
          val2 = axis.pointToData(point);
        }
        val2 != null && processOnAxis(axisInfo, val2, updaters, false, outputPayload);
      }
    });
  });
  var linkTriggers = {};
  each$q(axesInfo, function(tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each$q(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val2 = srcValItem.value;
          linkGroup.mapper && (val2 = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val2, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val2;
        }
      });
    }
  });
  each$q(linkTriggers, function(val2, tarKey) {
    processOnAxis(axesInfo[tarKey], val2, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2);
  dispatchHighDownActually(axesInfo, dispatchAction2, api);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend$1(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each$q(axisInfo.seriesModels, function(series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;
    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(
        dataDim[0],
        value,
        axis.type === "category" ? 0.5 : null
      );
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    var diff = value - seriesNestestValue;
    var dist2 = Math.abs(diff);
    if (dist2 <= minDist) {
      if (dist2 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist2;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each$q(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = [];
  each$q(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction2({
      type: "hideTip"
    });
    return;
  }
  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction2({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction2, api) {
  var zr2 = api.getZr();
  var highDownKey = "axisPointerLastHighlights";
  var lastHighlights = inner$1(zr2)[highDownKey] || {};
  var newHighlights = inner$1(zr2)[highDownKey] = {};
  each$q(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === "show" && each$q(option.seriesDataIndices, function(batchItem) {
      var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  var toHighlight = [];
  var toDownplay = [];
  each$q(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each$q(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i2 = 0; i2 < (inputAxesInfo || []).length; i2++) {
    var inputAxisInfo = inputAxesInfo[i2];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}
function install$a(registers) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1);
  registers.registerComponentModel(AxisPointerModel$1);
  registers.registerComponentView(AxisPointerView$1);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link2 = option.axisPointer.link;
      if (link2 && !isArray$x(link2)) {
        option.axisPointer.link = [link2];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$9(registers) {
  use$1(install$b);
  use$1(install$a);
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  var coordType = seriesModel.get("coordinateSystem");
  return indexOf$2(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  var axisRecords = createHashMap();
  var effectedModels = [];
  var effectedModelMap = createHashMap();
  ecModel.eachComponent({
    mainType: "dataZoom",
    query: payload
  }, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  var foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    var isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  var ecModel = dataZoomModel.ecModel;
  var coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    var coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    var coordSysUid = coordSysModel.uid;
    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {
        model: coordSysModel,
        axisModels: []
      };
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}
var DataZoomAxisInfo = function() {
  function DataZoomAxisInfo2() {
    this.indexList = [];
    this.indexMap = [];
  }
  DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  };
  return DataZoomAxisInfo2;
}();
var DataZoomModel = function(_super) {
  __extends(DataZoomModel2, _super);
  function DataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomModel2.type;
    _this._autoThrottle = true;
    _this._noTarget = true;
    _this._rangePropMode = ["percent", "percent"];
    return _this;
  }
  DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype.mergeOption = function(newOption) {
    var inputRawOption = retrieveRawOption(newOption);
    merge$2(this.option, newOption, true);
    merge$2(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype._doInit = function(inputRawOption) {
    var thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    var settledOption = this.settledOption;
    each$q([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      if (this._rangePropMode[index] === "value") {
        thisOption[names[0]] = settledOption[names[0]] = null;
      }
    }, this);
    this._resetTarget();
  };
  DataZoomModel2.prototype._resetTarget = function() {
    var optionOrient = this.get("orient", true);
    var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  };
  DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
    var hasAxisSpecified = false;
    each$q(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      var axisInfo = new DataZoomAxisInfo();
      each$q(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  };
  DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
    var ecModel = this.ecModel;
    var needAuto = true;
    if (needAuto) {
      var axisDim = orient === "vertical" ? "y" : "x";
      var axisModels = ecModel.findComponents({
        mainType: axisDim + "Axis"
      });
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      var axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: function(axisModel) {
          return axisModel.get("orient", true) === orient;
        }
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels2, axisDim2) {
      var axisModel = axisModels2[0];
      if (!axisModel) {
        return;
      }
      var axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim2, axisInfo);
      needAuto = false;
      if (axisDim2 === "x" || axisDim2 === "y") {
        var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel_1 && each$q(axisModels2, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each$q(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
        if (!needAuto) {
          return;
        }
        var axisModels2 = ecModel.findComponents({
          mainType: getAxisMainType(axisDim2),
          filter: function(axisModel) {
            return axisModel.get("type", true) === "category";
          }
        });
        if (axisModels2[0]) {
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels2[0].componentIndex);
          targetAxisIndexMap.set(axisDim2, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  };
  DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
    var dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  };
  DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  };
  DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
    var rangePropMode = this._rangePropMode;
    var rangeModeInOption = this.get("rangeMode");
    each$q([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      var percentSpecified = inputRawOption[names[0]] != null;
      var valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index] = rangeModeInOption[index];
      } else if (percentSpecified) {
        rangePropMode[index] = "percent";
      }
    });
  };
  DataZoomModel2.prototype.noTarget = function() {
    return this._noTarget;
  };
  DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
    var firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  };
  DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each$q(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  };
  DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
    var axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  };
  DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
    var axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  };
  DataZoomModel2.prototype.setRawRange = function(opt) {
    var thisOption = this.option;
    var settledOption = this.settledOption;
    each$q([["start", "startValue"], ["end", "endValue"]], function(names) {
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  };
  DataZoomModel2.prototype.setCalculatedRange = function(opt) {
    var option = this.option;
    each$q(["start", "startValue", "end", "endValue"], function(name2) {
      option[name2] = opt[name2];
    });
  };
  DataZoomModel2.prototype.getPercentRange = function() {
    var axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  };
  DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  };
  DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    var firstProxy;
    var axisDimList = this._targetAxisInfoMap.keys();
    for (var i2 = 0; i2 < axisDimList.length; i2++) {
      var axisDim = axisDimList[i2];
      var axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (var j2 = 0; j2 < axisInfo.indexList.length; j2++) {
        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j2]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  };
  DataZoomModel2.prototype.getRangePropMode = function() {
    return this._rangePropMode.slice();
  };
  DataZoomModel2.prototype.getOrient = function() {
    return this._orient;
  };
  DataZoomModel2.type = "dataZoom";
  DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
  DataZoomModel2.defaultOption = {
    z: 4,
    filterMode: "filter",
    start: 0,
    end: 100
  };
  return DataZoomModel2;
}(ComponentModel$1);
function retrieveRawOption(option) {
  var ret = {};
  each$q(["start", "end", "startValue", "endValue", "throttle"], function(name2) {
    option.hasOwnProperty(name2) && (ret[name2] = option[name2]);
  });
  return ret;
}
var DataZoomModel$1 = DataZoomModel;
var DataZoomView = function(_super) {
  __extends(DataZoomView2, _super);
  function DataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomView2.type;
    return _this;
  }
  DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  };
  DataZoomView2.type = "dataZoom";
  return DataZoomView2;
}(ComponentView$1);
var DataZoomView$1 = DataZoomView;
var each$m = each$q;
var asc = asc$1;
var AxisProxy = function() {
  function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  };
  AxisProxy2.prototype.getDataValueWindow = function() {
    return this._valueWindow.slice();
  };
  AxisProxy2.prototype.getDataPercentWindow = function() {
    return this._percentWindow.slice();
  };
  AxisProxy2.prototype.getTargetSeriesModels = function() {
    var seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        var axisMainType = getAxisMainType(this._dimName);
        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  };
  AxisProxy2.prototype.getAxisModel = function() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  };
  AxisProxy2.prototype.getMinMaxSpan = function() {
    return clone$8(this._minMaxSpan);
  };
  AxisProxy2.prototype.calculateDataWindow = function(opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale2 = axisModel.axis.scale;
    var rangePropMode = this._dataZoomModel.getRangePropMode();
    var percentExtent = [0, 100];
    var percentWindow = [];
    var valueWindow = [];
    var hasPropModeValue;
    each$m(["start", "end"], function(prop, idx) {
      var boundPercent = opt[prop];
      var boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale2.parse(linearMap(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale2.parse(boundValue);
        boundPercent = linearMap(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    asc(valueWindow);
    asc(percentWindow);
    var spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue2) {
      var suffix = toValue2 ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (var i2 = 0; i2 < 2; i2++) {
        toWindow[i2] = linearMap(fromWindow[i2], fromExtent, toExtent, true);
        toValue2 && (toWindow[i2] = scale2.parse(toWindow[i2]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  };
  AxisProxy2.prototype.reset = function(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  };
  AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get("filterMode");
    var valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each$m(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        var store_1 = seriesData.getStore();
        var dataDimIndices_1 = map$9(dataDims, function(dim) {
          return seriesData.getDimensionIndex(dim);
        }, seriesData);
        seriesData.filterSelf(function(dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;
          for (var i2 = 0; i2 < dataDims.length; i2++) {
            var value = store_1.get(dataDimIndices_1[i2], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each$m(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range2 = {};
            range2[dim] = valueWindow;
            seriesData.selectRange(range2);
          }
        });
      }
      each$m(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  };
  AxisProxy2.prototype._updateMinMaxSpan = function() {
    var minMaxSpan = this._minMaxSpan = {};
    var dataZoomModel = this._dataZoomModel;
    var dataExtent = this._dataExtent;
    each$m(["min", "max"], function(minMax) {
      var percentSpan = dataZoomModel.get(minMax + "Span");
      var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  };
  AxisProxy2.prototype._setAxisModel = function() {
    var axisModel = this.getAxisModel();
    var percentWindow = this._percentWindow;
    var valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    var precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  };
  return AxisProxy2;
}();
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each$m(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  var axisModel = axisProxy.getAxisModel();
  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  getTargetSeries: function(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    var proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy$1(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    var seriesModelMap = createHashMap();
    each$q(proxyList, function(axisProxy) {
      each$q(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset: function(ecModel, api) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    var effectedModels = findEffectedDataZooms(ecModel, payload);
    each$q(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}
function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray(componentModel.get("padding"));
  var style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect$2({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}
var TooltipModel = function(_super) {
  __extends(TooltipModel2, _super);
  function TooltipModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipModel2.type;
    return _this;
  }
  TooltipModel2.type = "tooltip";
  TooltipModel2.dependencies = ["axisPointer"];
  TooltipModel2.defaultOption = {
    z: 60,
    show: true,
    showContent: true,
    trigger: "item",
    triggerOn: "mousemove|click",
    alwaysShowContent: false,
    displayMode: "single",
    renderMode: "auto",
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: "#fff",
    shadowBlur: 10,
    shadowColor: "rgba(0, 0, 0, .2)",
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    borderRadius: 4,
    borderWidth: 1,
    padding: null,
    extraCssText: "",
    axisPointer: {
      type: "line",
      axis: "auto",
      animation: "auto",
      animationDurationUpdate: 200,
      animationEasingUpdate: "exponentialOut",
      crossStyle: {
        color: "#999",
        width: 1,
        type: "dashed",
        textStyle: {}
      }
    },
    textStyle: {
      color: "#666",
      fontSize: 14
    }
  };
  return TooltipModel2;
}(ComponentModel$1);
var TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env$1.domSupported) {
    return;
  }
  var style = document.documentElement.style;
  for (var i2 = 0, len2 = styleProps.length; i2 < len2; i2++) {
    if (styleProps[i2] in style) {
      return styleProps[i2];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase$1(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle$1(el2, style) {
  var stl = el2.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el2);
  return stl ? style ? stl[style] : stl : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString$d(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = "";
  var transformStyle = CSS_TRANSFORM_VENDOR + ":";
  var rotateDeg;
  if (indexOf$2(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
  } else {
    positionStyle += "left:50%";
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
  }
  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
  return '<div style="' + styleCss.join("") + '"></div>';
}
function assembleTransition(duration, onlyFade) {
  var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x2, y2, toString2) {
  var x0 = x2.toFixed(0) + "px";
  var y0 = y2.toFixed(0) + "px";
  if (!env$1.transformSupported) {
    return toString2 ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
  }
  var is3d = env$1.transform3dSupported;
  var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
  return toString2 ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get("fontSize");
  var color2 = textStyleModel.getTextColor();
  color2 && cssText.push("color:" + color2);
  cssText.push("font:" + textStyleModel.getFont());
  fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
  var shadowColor = textStyleModel.get("textShadowColor");
  var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each$q(["decoration", "align"], function(name2) {
    var val2 = textStyleModel.get(name2);
    val2 && cssText.push("text-" + name2 + ":" + val2);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get("transitionDuration");
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var shadowBlur = tooltipModel.get("shadowBlur");
  var shadowColor = tooltipModel.get("shadowColor");
  var shadowOffsetX = tooltipModel.get("shadowOffsetX");
  var shadowOffsetY = tooltipModel.get("shadowOffsetY");
  var textStyleModel = tooltipModel.getModel("textStyle");
  var padding = getPaddingFromTooltipModel(tooltipModel, "html");
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each$q(["width", "color", "radius"], function(name2) {
    var borderName = "border-" + name2;
    var camelCase2 = toCamelCase$1(borderName);
    var val2 = tooltipModel.get(camelCase2);
    val2 != null && cssText.push(borderName + ":" + val2 + (name2 === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord$1(out2, zr2, appendToBody, zrX, zrY) {
  var zrPainter = zr2 && zr2.painter;
  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr2.getWidth();
  out2[3] = out2[1] / zr2.getHeight();
}
var TooltipHTMLContent = function() {
  function TooltipHTMLContent2(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;
    if (env$1.wxa) {
      return null;
    }
    var el2 = document.createElement("div");
    el2.domBelongToZr = true;
    this.el = el2;
    var zr2 = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord$1(this._styleCoord, zr2, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
    if (appendToBody) {
      document.body.appendChild(el2);
    } else {
      container.appendChild(el2);
    }
    this._container = container;
    var self2 = this;
    el2.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el2.onmousemove = function(e3) {
      e3 = e3 || window.event;
      if (!self2._enterable) {
        var handler3 = zr2.handler;
        var zrViewportRoot = zr2.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e3, true);
        handler3.dispatch("mousemove", e3);
      }
    };
    el2.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  TooltipHTMLContent2.prototype.update = function(tooltipModel) {
    var container = this._container;
    var position = getComputedStyle$1(container, "position");
    var domStyle = container.style;
    if (domStyle.position !== "absolute" && position !== "absolute") {
      domStyle.position = "relative";
    }
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this.el.className = tooltipModel.get("className") || "";
  };
  TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el2 = this.el;
    var style = el2.style;
    var styleCoord = this._styleCoord;
    if (!el2.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };
  TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
    var el2 = this.el;
    if (content == null) {
      el2.innerHTML = "";
      return;
    }
    var arrow = "";
    if (isString$d(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString$d(content)) {
      el2.innerHTML = content + arrow;
    } else if (content) {
      el2.innerHTML = "";
      if (!isArray$x(content)) {
        content = [content];
      }
      for (var i2 = 0; i2 < content.length; i2++) {
        if (isDom(content[i2]) && content[i2].parentNode !== el2) {
          el2.appendChild(content[i2]);
        }
      }
      if (arrow && el2.childNodes.length) {
        var arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el2.appendChild(arrowEl);
      }
    }
  };
  TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipHTMLContent2.prototype.getSize = function() {
    var el2 = this.el;
    return [el2.offsetWidth, el2.offsetHeight];
  };
  TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord$1(styleCoord, this._zr, this._appendToBody, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each$q(transforms, function(transform) {
        style_1[transform[0]] = transform[1];
      });
    }
  };
  TooltipHTMLContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipHTMLContent2.prototype.hide = function() {
    var _this = this;
    var style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env$1.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(function() {
      return _this._longHide = true;
    }, 500);
  };
  TooltipHTMLContent2.prototype.hideLater = function(time2) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time2) {
        this._hideDelay = time2;
        this._show = false;
        this._hideTimeout = setTimeout(bind$3(this.hide, this), time2);
      } else {
        this.hide();
      }
    }
  };
  TooltipHTMLContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipHTMLContent2.prototype.dispose = function() {
    this.el.parentNode.removeChild(this.el);
  };
  return TooltipHTMLContent2;
}();
var TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = function() {
  function TooltipRichContent2(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  TooltipRichContent2.prototype.update = function(tooltipModel) {
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
  };
  TooltipRichContent2.prototype.show = function() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  };
  TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;
    if (isObject$f(content)) {
      throwError("");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    var textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new ZRText$1({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each$q(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each$q(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    var self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  };
  TooltipRichContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipRichContent2.prototype.getSize = function() {
    var el2 = this.el;
    var bounding = this.el.getBoundingRect();
    var shadowOuterSize = calcShadowOuterSize(el2.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };
  TooltipRichContent2.prototype.moveTo = function(x2, y2) {
    var el2 = this.el;
    if (el2) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x2, y2);
      x2 = styleCoord[0];
      y2 = styleCoord[1];
      var style = el2.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style);
      el2.x = x2 + borderWidth + shadowOuterSize.left;
      el2.y = y2 + borderWidth + shadowOuterSize.top;
      el2.markRedraw();
    }
  };
  TooltipRichContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipRichContent2.prototype.hide = function() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  };
  TooltipRichContent2.prototype.hideLater = function(time2) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time2) {
        this._hideDelay = time2;
        this._show = false;
        this._hideTimeout = setTimeout(bind$3(this.hide, this), time2);
      } else {
        this.hide();
      }
    }
  };
  TooltipRichContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipRichContent2.prototype.dispose = function() {
    this._zr.remove(this.el);
  };
  return TooltipRichContent2;
}();
function mathMaxWith0(val2) {
  return Math.max(0, val2);
}
function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord(out2, zr2, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr2.getWidth();
  out2[3] = out2[1] / zr2.getHeight();
}
var TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$2({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});
var TooltipView = function(_super) {
  __extends(TooltipView2, _super);
  function TooltipView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipView2.type;
    return _this;
  }
  TooltipView2.prototype.init = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    var tooltipModel = ecModel.getComponent("tooltip");
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent$1(api) : new TooltipHTMLContent$1(api.getDom(), api, {
      appendToBody: tooltipModel.get("appendToBody", true)
    });
  };
  TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear$3(this, "_updatePosition");
    }
  };
  TooltipView2.prototype._initGlobalListener = function() {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind$3(function(currTrigger, e3, dispatchAction2) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e3, dispatchAction2);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction2);
        }
      }
    }, this));
  };
  TooltipView2.prototype._keepShow = function() {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    var triggerOn = tooltipModel.get("triggerOn");
    if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env$1.node || !api.getDom()) {
      return;
    }
    var dispatchAction2 = makeDispatchAction(payload, api);
    this._ticket = "";
    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);
    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction2);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el2 = proxyRect;
      el2.x = payload.x;
      el2.y = payload.y;
      el2.update();
      getECData(el2).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el2
      }, dispatchAction2);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction2);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }
      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction2);
      }
    } else if (payload.x != null && payload.y != null) {
      api.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction2);
    }
  };
  TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;
    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  };
  TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    var data5 = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data5.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  };
  TooltipView2.prototype._tryShow = function(e3, dispatchAction2) {
    var el2 = e3.target;
    var tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e3.offsetX;
    this._lastY = e3.offsetY;
    var dataByCoordSys = e3.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e3);
    } else if (el2) {
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el2, function(target) {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);
      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e3, seriesDispatcher_1, dispatchAction2);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e3, cmptDispatcher_1, dispatchAction2);
      } else {
        this._hide(dispatchAction2);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction2);
    }
  };
  TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
    var delay2 = tooltipModel.get("showDelay");
    cb = bind$3(cb, this);
    clearTimeout(this._showTimout);
    delay2 > 0 ? this._showTimout = setTimeout(cb, delay2) : cb();
  };
  TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e3) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e3.offsetX, e3.offsetY];
    var singleTooltipModel = buildTooltipModel([e3.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    each$q(dataByCoordSys, function(itemCoordSys) {
      each$q(itemCoordSys.dataByAxis, function(axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        var axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim$3(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each$q(axisItem.seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;
          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend$1({
              valueFormatter
            }, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e3.position;
    var orderMode = singleTooltipModel.get("order");
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    var allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  };
  TooltipView2.prototype._showSeriesItemTooltip = function(e3, dispatcher, dispatchAction2) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher);
    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data5 = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e3.positionDefault;
    var tooltipModel = buildTooltipModel([data5.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get("order");
    var valueFormatter = tooltipModel.get("valueFormatter");
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend$1({
      valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e3.offsetX, e3.offsetY, e3.position, e3.target, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data5.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  };
  TooltipView2.prototype._showComponentItemTooltip = function(e3, el2, dispatchAction2) {
    var ecData = getECData(el2);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};
    if (isString$d(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
    }
    var tooltipModelCascade = [tooltipOpt];
    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e3.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get("content");
    var asyncTicket = Math.random() + "";
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      var formatterParams = clone$8(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e3.offsetX, e3.offsetY, e3.position, el2, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      from: this.uid
    });
  };
  TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x2, y2, positionExpr, el2, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    var tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    var formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    var html2 = defaultHtml;
    var nearPoint = this._getNearestPoint([x2, y2], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    var nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString$d(formatter)) {
        var useUTC = tooltipModel.ecModel.get("useUTC");
        var params0 = isArray$x(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html2 = formatter;
        if (isTimeAxis) {
          html2 = format$1(params0.axisValue, html2, useUTC);
        }
        html2 = formatTpl(html2, params, true);
      } else if (isFunction$h(formatter)) {
        var callback = bind$3(function(cbTicket, html3) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html3, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params, el2);
          }
        }, this);
        this._ticket = asyncTicket;
        html2 = formatter(params, asyncTicket, callback);
      } else {
        html2 = formatter;
      }
    }
    tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x2, y2, tooltipContent, params, el2);
  };
  TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger2, borderColor) {
    if (trigger2 === "axis" || isArray$x(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray$x(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };
  TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x2, y2, content, params, el2) {
    var viewWidth = this._api.getWidth();
    var viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    var contentSize = content.getSize();
    var align = tooltipModel.get("align");
    var vAlign = tooltipModel.get("verticalAlign");
    var rect = el2 && el2.getBoundingRect().clone();
    el2 && rect.applyTransform(el2.transform);
    if (isFunction$h(positionExpr)) {
      positionExpr = positionExpr([x2, y2], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray$x(positionExpr)) {
      x2 = parsePercent(positionExpr[0], viewWidth);
      y2 = parsePercent(positionExpr[1], viewHeight);
    } else if (isObject$f(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x2 = layoutRect.x;
      y2 = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString$d(positionExpr) && el2) {
      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x2 = pos[0];
      y2 = pos[1];
    } else {
      var pos = refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x2 = pos[0];
      y2 = pos[1];
    }
    align && (x2 -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y2 -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x2, y2, content, viewWidth, viewHeight);
      x2 = pos[0];
      y2 = pos[1];
    }
    content.moveTo(x2, y2);
  };
  TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each$q(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each$q(lastDataByAxis, function(lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each$q(lastIndices, function(lastIdxItem, j2) {
          var newIdxItem = newIndices[j2];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each$q(lastItem.seriesDataIndices, function(idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };
  TooltipView2.prototype._hide = function(dispatchAction2) {
    this._lastDataByCoordSys = null;
    dispatchAction2({
      type: "hideTip",
      from: this.uid
    });
  };
  TooltipView2.prototype.dispose = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    clear$3(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api);
  };
  TooltipView2.type = "tooltip";
  return TooltipView2;
}(ComponentView$1);
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model$1(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model$1(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (var i2 = modelCascade.length - 1; i2 >= 0; i2--) {
    var tooltipOpt = modelCascade[i2];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model$1) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString$d(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model$1(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction(payload, api) {
  return payload.dispatchAction || bind$3(api.dispatchAction, api);
}
function refixTooltipPosition(x2, y2, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getSize();
  var width2 = size[0];
  var height2 = size[1];
  if (gapH != null) {
    if (x2 + width2 + gapH + 2 > viewWidth) {
      x2 -= width2 + gapH;
    } else {
      x2 += gapH;
    }
  }
  if (gapV != null) {
    if (y2 + height2 + gapV > viewHeight) {
      y2 -= height2 + gapV;
    } else {
      y2 += gapV;
    }
  }
  return [x2, y2];
}
function confineTooltipPosition(x2, y2, content, viewWidth, viewHeight) {
  var size = content.getSize();
  var width2 = size[0];
  var height2 = size[1];
  x2 = Math.min(x2 + width2, viewWidth) - width2;
  y2 = Math.min(y2 + height2, viewHeight) - height2;
  x2 = Math.max(x2, 0);
  y2 = Math.max(y2, 0);
  return [x2, y2];
}
function calcTooltipPosition(position, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset2 = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x2 = 0;
  var y2 = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  switch (position) {
    case "inside":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y - domHeight - offset2;
      break;
    case "bottom":
      x2 = rect.x + rectWidth / 2 - domWidth / 2;
      y2 = rect.y + rectHeight + offset2;
      break;
    case "left":
      x2 = rect.x - domWidth - offset2;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x2 = rect.x + rectWidth + offset2;
      y2 = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x2, y2];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];
  if (!model) {
    return;
  }
  var view = api.getViewOfComponentModel(model);
  var el2;
  view.group.traverse(function(subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el2 = subEl;
      return true;
    }
  });
  if (el2) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el: el2
    };
  }
}
var TooltipView$1 = TooltipView;
function install$8(registers) {
  use$1(install$a);
  registers.registerComponentModel(TooltipModel$1);
  registers.registerComponentView(TooltipView$1);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop$3);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop$3);
}
var TitleModel = function(_super) {
  __extends(TitleModel2, _super);
  function TitleModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  TitleModel2.type = "title";
  TitleModel2.defaultOption = {
    z: 6,
    show: true,
    text: "",
    target: "blank",
    subtext: "",
    subtarget: "blank",
    left: 0,
    top: 0,
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: "bold",
      color: "#464646"
    },
    subtextStyle: {
      fontSize: 12,
      color: "#6E7079"
    }
  };
  return TitleModel2;
}(ComponentModel$1);
var TitleView = function(_super) {
  __extends(TitleView2, _super);
  function TitleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleView2.type;
    return _this;
  }
  TitleView2.prototype.render = function(titleModel, ecModel, api) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    var group = this.group;
    var textStyleModel = titleModel.getModel("textStyle");
    var subtextStyleModel = titleModel.getModel("subtextStyle");
    var textAlign = titleModel.get("textAlign");
    var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    var textEl = new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get("subtext");
    var subTextEl = new ZRText$1({
      style: createTextStyle$1(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link2 = titleModel.get("link");
    var sublink = titleModel.get("sublink");
    var triggerEvent2 = titleModel.get("triggerEvent", true);
    textEl.silent = !link2 && !triggerEvent2;
    subTextEl.silent = !sublink && !triggerEvent2;
    if (link2) {
      textEl.on("click", function() {
        windowOpen(link2, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent2 ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    var rect = new Rect$2({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };
  TitleView2.type = "title";
  return TitleView2;
}(ComponentView$1);
function install$7(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}
var getDefaultSelectorOptions = function(ecModel, type2) {
  if (type2 === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type2 === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel = function(_super) {
  __extends(LegendModel2, _super);
  function LegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  LegendModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  };
  LegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    this._updateSelector(option);
  };
  LegendModel2.prototype._updateSelector = function(option) {
    var selector = option.selector;
    var ecModel = this.ecModel;
    if (selector === true) {
      selector = option.selector = ["all", "inverse"];
    }
    if (isArray$x(selector)) {
      each$q(selector, function(item, index) {
        isString$d(item) && (item = {
          type: item
        });
        selector[index] = merge$2(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };
  LegendModel2.prototype.optionUpdated = function() {
    this._updateData(this.ecModel);
    var legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      var hasSelected = false;
      for (var i2 = 0; i2 < legendData.length; i2++) {
        var name_1 = legendData[i2].get("name");
        if (this.isSelected(name_1)) {
          this.select(name_1);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  };
  LegendModel2.prototype._updateData = function(ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;
      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    var rawData = this.get("data") || potentialData;
    var legendData = map$9(rawData, function(dataItem) {
      if (isString$d(dataItem) || isNumber$c(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      return new Model$1(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
  };
  LegendModel2.prototype.getData = function() {
    return this._data;
  };
  LegendModel2.prototype.select = function(name2) {
    var selected = this.option.selected;
    var selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      var data5 = this._data;
      each$q(data5, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name2] = true;
  };
  LegendModel2.prototype.unSelect = function(name2) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name2] = false;
    }
  };
  LegendModel2.prototype.toggleSelected = function(name2) {
    var selected = this.option.selected;
    if (!selected.hasOwnProperty(name2)) {
      selected[name2] = true;
    }
    this[selected[name2] ? "unSelect" : "select"](name2);
  };
  LegendModel2.prototype.allSelect = function() {
    var data5 = this._data;
    var selected = this.option.selected;
    each$q(data5, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  };
  LegendModel2.prototype.inverseSelect = function() {
    var data5 = this._data;
    var selected = this.option.selected;
    each$q(data5, function(dataItem) {
      var name2 = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name2)) {
        selected[name2] = true;
      }
      selected[name2] = !selected[name2];
    });
  };
  LegendModel2.prototype.isSelected = function(name2) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name2) && !selected[name2]) && indexOf$2(this._availableNames, name2) >= 0;
  };
  LegendModel2.prototype.getOrient = function() {
    return this.get("orient") === "vertical" ? {
      index: 1,
      name: "vertical"
    } : {
      index: 0,
      name: "horizontal"
    };
  };
  LegendModel2.type = "legend.plain";
  LegendModel2.dependencies = ["series"];
  LegendModel2.defaultOption = {
    z: 4,
    show: true,
    orient: "horizontal",
    left: "center",
    top: 0,
    align: "auto",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: "inherit",
    symbolKeepAspect: true,
    inactiveColor: "#ccc",
    inactiveBorderColor: "#ccc",
    inactiveBorderWidth: "auto",
    itemStyle: {
      color: "inherit",
      opacity: "inherit",
      borderColor: "inherit",
      borderWidth: "auto",
      borderCap: "inherit",
      borderJoin: "inherit",
      borderDashOffset: "inherit",
      borderMiterLimit: "inherit"
    },
    lineStyle: {
      width: "auto",
      color: "inherit",
      inactiveColor: "#ccc",
      inactiveWidth: 2,
      opacity: "inherit",
      type: "inherit",
      cap: "inherit",
      join: "inherit",
      dashOffset: "inherit",
      miterLimit: "inherit"
    },
    textStyle: {
      color: "#333"
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: "sans-serif",
      color: "#666",
      borderWidth: 1,
      borderColor: "#666"
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: "#eee",
        backgroundColor: "#666"
      }
    },
    selectorPosition: "auto",
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel2;
}(ComponentModel$1);
var LegendModel$1 = LegendModel;
var curry = curry$1;
var each$l = each$q;
var Group$1 = Group$3;
var LegendView = function(_super) {
  __extends(LegendView2, _super);
  function LegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendView2.type;
    _this.newlineDisabled = false;
    return _this;
  }
  LegendView2.prototype.init = function() {
    this.group.add(this._contentGroup = new Group$1());
    this.group.add(this._selectorGroup = new Group$1());
    this._isFirstRender = true;
  };
  LegendView2.prototype.getContentGroup = function() {
    return this._contentGroup;
  };
  LegendView2.prototype.getSelectorGroup = function() {
    return this._selectorGroup;
  };
  LegendView2.prototype.render = function(legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    var itemAlign = legendModel.get("align");
    var orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    var selector = legendModel.get("selector", true);
    var selectorPosition = legendModel.get("selectorPosition", true);
    if (selector && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get("padding");
    var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
    var layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };
  LegendView2.prototype.resetInner = function() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };
  LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get("selectedMode");
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each$l(legendModel.getData(), function(legendItemModel, dataIndex) {
      var name2 = legendItemModel.get("name");
      if (!this.newlineDisabled && (name2 === "" || name2 === "\n")) {
        var g2 = new Group$1();
        g2.newline = true;
        contentGroup.add(g2);
        return;
      }
      var seriesModel = ecModel.getSeriesByName(name2)[0];
      if (legendDrawnMap.get(name2)) {
        return;
      }
      if (seriesModel) {
        var data5 = seriesModel.getData();
        var lineVisualStyle = data5.getVisual("legendLineStyle") || {};
        var legendIcon = data5.getVisual("legendIcon");
        var style = data5.getVisual("style");
        var itemGroup = this._createItem(seriesModel, name2, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api);
        itemGroup.on("click", curry(dispatchSelectAction, name2, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name2, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name2)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            var provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name2)) {
              return;
            }
            var idx = provider.indexOfName(name2);
            var style2 = provider.getItemVisual(idx, "style");
            var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
            var colorArr = parse(style2.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style2 = extend$1(extend$1({}, style2), {
                fill: stringify(colorArr, "rgba")
              });
            }
            var itemGroup2 = this._createItem(seriesModel2, name2, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode, api);
            itemGroup2.on("click", curry(dispatchSelectAction, null, name2, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name2, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name2, api, excludeSeriesId));
            legendDrawnMap.set(name2, true);
          }
        }, this);
      }
    }, this);
    if (selector) {
      this._createSelector(selector, legendModel, api, orient, selectorPosition);
    }
  };
  LegendView2.prototype._createSelector = function(selector, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each$l(selector, function createSelectorButton(selectorItem) {
      var type2 = selectorItem.type;
      var labelText = new ZRText$1({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick: function() {
          api.dispatchAction({
            type: type2 === "all" ? "legendAllSelect" : "legendInverseSelect"
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel("selectorLabel");
      var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };
  LegendView2.prototype._createItem = function(seriesModel, name2, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get("itemWidth");
    var itemHeight = legendModel.get("itemHeight");
    var isSelected = legendModel.isSelected(name2);
    var iconRotate = legendItemModel.get("symbolRotate");
    var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    var legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api);
    var itemGroup = new Group$1();
    var textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction$h(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    var textX = itemAlign === "left" ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get("formatter");
    var content = name2;
    if (isString$d(formatter) && formatter) {
      content = formatter.replace("{name}", name2 != null ? name2 : "");
    } else if (isFunction$h(formatter)) {
      content = formatter(name2);
    }
    var inactiveColor = legendItemModel.get("inactiveColor");
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: "middle"
      })
    }));
    var hitRect = new Rect$2({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });
    var tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name2,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };
  LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector) {
      box(
        "horizontal",
        selectorGroup,
        legendModel.get("selectorItemGap", true)
      );
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var orientIdx = legendModel.getOrient().index;
      var wh2 = orientIdx === 0 ? "width" : "height";
      var hw = orientIdx === 0 ? "height" : "width";
      var yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh2] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh2] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh2] = contentRect[wh2] + selectorButtonGap + selectorRect[wh2];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  LegendView2.prototype.remove = function() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };
  LegendView2.type = "legend.plain";
  return LegendView2;
}(ComponentView$1);
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each$l(style, function(propVal, propName) {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  var itemStyleModel = legendItemModel.getModel("itemStyle");
  var itemStyle = itemStyleModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  var decalStyle = itemStyleModel.getShallow("decal");
  itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api);
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  var legendLineModel = legendItemModel.getModel("lineStyle");
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    var borderWidth = legendItemModel.get("inactiveBorderWidth");
    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get("inactiveColor");
    itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {
    itemStyle,
    lineStyle
  };
}
function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || "roundRect";
  var icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i2 = 0;
  var len2 = list.length;
  while (i2 < len2 && !(emphasisState = list[i2].states.emphasis)) {
    i2++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView$1 = LegendView;
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (var i2 = 0; i2 < legendModels.length; i2++) {
        if (!legendModels[i2].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}
function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === "toggleSelected";
  var isSelected;
  ecModel.eachComponent("legend", function(legendModel) {
    if (isToggleSelect && isSelected != null) {
      legendModel[isSelected ? "select" : "unSelect"](payload.name);
    } else if (methodName === "allSelect" || methodName === "inverseSelect") {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }
    var legendData = legendModel.getData();
    each$q(legendData, function(model) {
      var name2 = model.get("name");
      if (name2 === "\n" || name2 === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name2);
      if (selectedMap.hasOwnProperty(name2)) {
        selectedMap[name2] = selectedMap[name2] && isItemSelected;
      } else {
        selectedMap[name2] = isItemSelected;
      }
    });
  });
  return methodName === "allSelect" || methodName === "inverseSelect" ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$6(registers) {
  registers.registerComponentModel(LegendModel$1);
  registers.registerComponentView(LegendView$1);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}
var ScrollableLegendModel = function(_super) {
  __extends(ScrollableLegendModel2, _super);
  function ScrollableLegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendModel2.type;
    return _this;
  }
  ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };
  ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.call(this, option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  };
  ScrollableLegendModel2.type = "legend.scroll";
  ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: "end",
    pageFormatter: "{current}/{total}",
    pageIcons: {
      horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
      vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
    },
    pageIconColor: "#2f4554",
    pageIconInactiveColor: "#aaa",
    pageIconSize: 15,
    pageTextStyle: {
      color: "#333"
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel2;
}(LegendModel$1);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$3;
var WH = ["width", "height"];
var XY = ["x", "y"];
var ScrollableLegendView = function(_super) {
  __extends(ScrollableLegendView2, _super);
  function ScrollableLegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendView2.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }
  ScrollableLegendView2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.group.add(this._containerGroup = new Group());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group());
  };
  ScrollableLegendView2.prototype.resetInner = function() {
    _super.prototype.resetInner.call(this);
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  };
  ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
    var self2 = this;
    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get("pageIconSize", true);
    var pageIconSizeArr = isArray$x(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    var pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new ZRText$1({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name2, iconIdx) {
      var pageDataIndexName = name2 + "DataIndex";
      var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind$3(self2._pageGo, self2, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name2;
      controllerGroup.add(icon);
    }
  };
  ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh2 = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector && box(
      "horizontal",
      selectorGroup,
      legendModel.get("selectorItemGap", true)
    );
    var selectorButtonGap = legendModel.get("selectorButtonGap", true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone$8(maxSize);
    selector && (processMaxSize[wh2] = maxSize[wh2] - selectorRect[wh2] - selectorButtonGap);
    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh2, hw, yx, xy);
    if (selector) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh2] + selectorButtonGap;
      } else {
        var offset2 = selectorRect[wh2] + selectorButtonGap;
        selectorPos[orientIdx] -= offset2;
        mainRect[xy] -= offset2;
      }
      mainRect[wh2] += selectorRect[wh2] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  };
  ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh2, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box(
      "horizontal",
      controllerGroup,
      legendModel.get("pageButtonItemGap", true)
    );
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh2] > maxSize[wh2];
    var contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      var pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh2] - controllerRect[wh2];
      } else {
        containerPos[orientIdx] += controllerRect[wh2] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    var mainRect = {
      x: 0,
      y: 0
    };
    mainRect[wh2] = showController ? maxSize[wh2] : contentRect[wh2];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh2];
    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh2] = Math.max(maxSize[wh2] - controllerRect[wh2] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect$2({
        shape: clipShape
      }));
      containerGroup.__rectSize = clipShape[wh2];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    var pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps$2(
      contentGroup,
      {
        x: pageInfo.contentPosition[0],
        y: pageInfo.contentPosition[1]
      },
      showController ? legendModel : null
    );
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  };
  ScrollableLegendView2.prototype._pageGo = function(to2, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to2];
    scrollDataIndex != null && api.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  };
  ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each$q(["pagePrev", "pageNext"], function(name2) {
      var key = name2 + "DataIndex";
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name2);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    var pageText = controllerGroup.childOfName("pageText");
    var pageFormatter = legendModel.get("pageFormatter");
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString$d(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
      current,
      total
    }));
  };
  ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
    var scrollDataIndex = legendModel.get("scrollDataIndex", true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh2 = WH[orientIdx];
    var xy = XY[orientIdx];
    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    var children2 = contentGroup.children();
    var targetItem = children2[targetItemIndex];
    var itemCount = children2.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (var i2 = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i2 <= itemCount; ++i2) {
      currItemInfo = getItemInfo(children2[i2]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (var i2 = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i2 >= -1; --i2) {
      currItemInfo = getItemInfo(children2[i2]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el2) {
      if (el2) {
        var itemRect = el2.getBoundingRect();
        var start2 = itemRect[xy] + el2[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh2],
          i: el2.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };
  ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    var index;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      var legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  };
  ScrollableLegendView2.type = "legend.scroll";
  return ScrollableLegendView2;
}(LegendView$1);
var ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}
function install$5(registers) {
  use$1(install$6);
  registers.registerComponentModel(ScrollableLegendModel$1);
  registers.registerComponentView(ScrollableLegendView$1);
  installScrollableLegendAction(registers);
}
function install$4(registers) {
  use$1(install$6);
  use$1(install$5);
}
var InsideZoomModel = function(_super) {
  __extends(InsideZoomModel2, _super);
  function InsideZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = InsideZoomModel2.type;
    return _this;
  }
  InsideZoomModel2.type = "dataZoom.inside";
  InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    disabled: false,
    zoomLock: false,
    zoomOnMouseWheel: true,
    moveOnMouseMove: true,
    moveOnMouseWheel: false,
    preventDefaultMouseMove: true
  });
  return InsideZoomModel2;
}(DataZoomModel$1);
var InsideZoomModel$1 = InsideZoomModel;
var inner = makeInner();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
  inner(api).coordSysRecordMap.each(function(coordSysRecord) {
    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
  var coordSysRecordMap = inner(api).coordSysRecordMap;
  var coordSysKeyArr = coordSysRecordMap.keys();
  for (var i2 = 0; i2 < coordSysKeyArr.length; i2++) {
    var coordSysKey = coordSysKeyArr[i2];
    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      var dzUid = dataZoomModel.uid;
      var dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    var controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api, coordSysModel) {
  var coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry$1(containsPoint, coordSysModel),
    dispatchAction: curry$1(dispatchAction, api),
    dataZoomInfoMap: null,
    controller: null
  };
  var controller = coordSysRecord.controller = new RoamController$1(api.getZr());
  each$q(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      var batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        var method = (dzInfo.getRange || {})[eventName];
        var range2 = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range2 && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range2[0],
          end: range2[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction(api, batch) {
  if (!api.isDisposed()) {
    api.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint(coordSysModel, e3, x2, y2) {
  return coordSysModel.coordinateSystem.containPoint([x2, y2]);
}
function mergeControllerParams(dataZoomInfoMap) {
  var controlType;
  var prefix = "type_";
  var typePriority = {
    "type_true": 2,
    "type_move": 1,
    "type_false": 0,
    "type_undefined": -1
  };
  var preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    var dataZoomModel = dataZoomInfo.model;
    var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
    var apiInner = inner(api);
    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(dataZoomModel) {
      var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each$q(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        var coordSysUid = dzCoordSysInfo.model.uid;
        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      var controller = coordSysRecord.controller;
      var firstDzInfo;
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      var controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}
var InsideZoomView = function(_super) {
  __extends(InsideZoomView2, _super);
  function InsideZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataZoom.inside";
    return _this;
  }
  InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
    _super.prototype.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api, dataZoomModel, {
      pan: bind$3(getRangeHandlers.pan, this),
      zoom: bind$3(getRangeHandlers.zoom, this),
      scrollMove: bind$3(getRangeHandlers.scrollMove, this)
    });
  };
  InsideZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  InsideZoomView2.prototype._clear = function() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  };
  InsideZoomView2.type = "dataZoom.inside";
  return InsideZoomView2;
}(DataZoomView$1);
var getRangeHandlers = {
  zoom: function(coordSysInfo, coordSysMainType, controller, e3) {
    var lastRange = this.range;
    var range2 = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo[coordSysMainType](null, [e3.originX, e3.originY], axisModel, controller, coordSysInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range2[1] - range2[0]) + range2[0];
    var scale2 = Math.max(1 / e3.scale, 0);
    range2[0] = (range2[0] - percentPoint) * scale2 + percentPoint;
    range2[1] = (range2[1] - percentPoint) * scale2 + percentPoint;
    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range2, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range2;
    if (lastRange[0] !== range2[0] || lastRange[1] !== range2[1]) {
      return range2;
    }
  },
  pan: makeMover(function(range2, axisModel, coordSysInfo, coordSysMainType, controller, e3) {
    var directionInfo = getDirectionInfo[coordSysMainType]([e3.oldX, e3.oldY], [e3.newX, e3.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range2[1] - range2[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range2, axisModel, coordSysInfo, coordSysMainType, controller, e3) {
    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e3.scrollDelta, e3.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range2[1] - range2[0]) * e3.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e3) {
    var lastRange = this.range;
    var range2 = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var percentDelta = getPercentDelta(range2, axisModel, coordSysInfo, coordSysMainType, controller, e3);
    sliderMove(percentDelta, range2, [0, 100], "all");
    this.range = range2;
    if (lastRange[0] !== range2[0] || lastRange[1] !== range2[1]) {
      return range2;
    }
  };
}
var getDirectionInfo = {
  grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret = {};
    var polar = coordSysInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    var ret = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
};
var InsideZoomView$1 = InsideZoomView;
function install$3(registers) {
  installCommon(registers);
  registers.registerComponentModel(InsideZoomModel$1);
  registers.registerComponentView(InsideZoomView$1);
  installDataZoomRoamProcessor(registers);
}
var SliderZoomModel = function(_super) {
  __extends(SliderZoomModel2, _super);
  function SliderZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomModel2.type;
    return _this;
  }
  SliderZoomModel2.type = "dataZoom.slider";
  SliderZoomModel2.layoutMode = "box";
  SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    show: true,
    right: "ph",
    top: "ph",
    width: "ph",
    height: "ph",
    left: null,
    bottom: null,
    borderColor: "#d2dbee",
    borderRadius: 3,
    backgroundColor: "rgba(47,69,84,0)",
    dataBackground: {
      lineStyle: {
        color: "#d2dbee",
        width: 0.5
      },
      areaStyle: {
        color: "#d2dbee",
        opacity: 0.2
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#8fb0f7",
        width: 0.5
      },
      areaStyle: {
        color: "#8fb0f7",
        opacity: 0.2
      }
    },
    fillerColor: "rgba(135,175,274,0.2)",
    handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
    handleSize: "100%",
    handleStyle: {
      color: "#fff",
      borderColor: "#ACB8D1"
    },
    moveHandleSize: 7,
    moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
    moveHandleStyle: {
      color: "#D2DBEE",
      opacity: 0.7
    },
    showDetail: true,
    showDataShadow: "auto",
    realtime: true,
    zoomLock: false,
    textStyle: {
      color: "#6E7079"
    },
    brushSelect: true,
    brushStyle: {
      color: "rgba(135,175,274,0.15)"
    },
    emphasis: {
      handleStyle: {
        borderColor: "#8FB0F7"
      },
      moveHandleStyle: {
        color: "#8FB0F7"
      }
    }
  });
  return SliderZoomModel2;
}(DataZoomModel$1);
var SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$2;
var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView = function(_super) {
  __extends(SliderZoomView2, _super);
  function SliderZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomView2.type;
    _this._displayables = {};
    return _this;
  }
  SliderZoomView2.prototype.init = function(ecModel, api) {
    this.api = api;
    this._onBrush = bind$3(this._onBrush, this);
    this._onBrushEnd = bind$3(this._onBrushEnd, this);
  };
  SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    _super.prototype.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  };
  SliderZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  SliderZoomView2.prototype._clear = function() {
    clear$3(this, "_dispatchZoomAction");
    var zr2 = this.api.getZr();
    zr2.off("mousemove", this._onBrush);
    zr2.off("mouseup", this._onBrushEnd);
  };
  SliderZoomView2.prototype._buildView = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    var barGroup = this._displayables.sliderGroup = new Group$3();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  };
  SliderZoomView2.prototype._resetLocation = function() {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var showMoveHandle = dataZoomModel.get("brushSelect");
    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    var coordRect = this._findCoordRect();
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var positionInfo = this._orient === HORIZONTAL ? {
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    var layoutParams = getLayoutParams(dataZoomModel.option);
    each$q(["right", "top", "width", "height"], function(name2) {
      if (layoutParams[name2] === "ph") {
        layoutParams[name2] = positionInfo[name2];
      }
    });
    var layoutRect = getLayoutRect(layoutParams, ecSize);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  };
  SliderZoomView2.prototype._positionGroup = function() {
    var thisGroup = this.group;
    var location2 = this._location;
    var orient = this._orient;
    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get("inverse");
    var sliderGroup = this._displayables.sliderGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: 1
    } : orient === HORIZONTAL && inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: -1
    } : orient === VERTICAL && !inverse ? {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: 1,
      rotation: Math.PI / 2
    } : {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: -1,
      rotation: Math.PI / 2
    });
    var rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location2.x - rect.x;
    thisGroup.y = location2.y - rect.y;
    thisGroup.markRedraw();
  };
  SliderZoomView2.prototype._getViewExtent = function() {
    return [0, this._size[0]];
  };
  SliderZoomView2.prototype._renderBackground = function() {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.sliderGroup;
    var brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    var clickPanel = new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind$3(this._onClickPanel, this)
    });
    var zr2 = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr2.on("mousemove", this._onBrush);
      zr2.on("mouseup", this._onBrushEnd);
    } else {
      zr2.off("mousemove", this._onBrush);
      zr2.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  };
  SliderZoomView2.prototype._renderDataShadow = function() {
    var info2 = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info2) {
      return;
    }
    var size = this._size;
    var oldSize = this._shadowSize || [];
    var seriesModel = info2.series;
    var data5 = seriesModel.getRawData();
    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info2.otherDim;
    if (otherDim == null) {
      return;
    }
    var polygonPts = this._shadowPolygonPts;
    var polylinePts = this._shadowPolylinePts;
    if (data5 !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      var otherDataExtent_1 = data5.getDataExtent(otherDim);
      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
      var otherShadowExtent_1 = [0, size[1]];
      var thisShadowExtent = [0, size[0]];
      var areaPoints_1 = [[size[0], 0], [0, 0]];
      var linePoints_1 = [];
      var step_1 = thisShadowExtent[1] / (data5.count() - 1);
      var thisCoord_1 = 0;
      var stride_1 = Math.round(data5.count() / size[0]);
      var lastIsEmpty_1;
      data5.each([otherDim], function(value, index) {
        if (stride_1 > 0 && index % stride_1) {
          thisCoord_1 += step_1;
          return;
        }
        var isEmpty2 = value == null || isNaN(value) || value === "";
        var otherCoord = isEmpty2 ? 0 : linearMap(value, otherDataExtent_1, otherShadowExtent_1, true);
        if (isEmpty2 && !lastIsEmpty_1 && index) {
          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
        } else if (!isEmpty2 && lastIsEmpty_1) {
          areaPoints_1.push([thisCoord_1, 0]);
          linePoints_1.push([thisCoord_1, 0]);
        }
        areaPoints_1.push([thisCoord_1, otherCoord]);
        linePoints_1.push([thisCoord_1, otherCoord]);
        thisCoord_1 += step_1;
        lastIsEmpty_1 = isEmpty2;
      });
      polygonPts = this._shadowPolygonPts = areaPoints_1;
      polylinePts = this._shadowPolylinePts = linePoints_1;
    }
    this._shadowData = data5;
    this._shadowDim = otherDim;
    this._shadowSize = [size[0], size[1]];
    var dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      var group2 = new Group$3();
      var polygon = new Polygon$1({
        shape: {
          points: polygonPts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      var polyline = new Polyline$1({
        shape: {
          points: polylinePts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group2.add(polygon);
      group2.add(polyline);
      return group2;
    }
    for (var i2 = 0; i2 < 3; i2++) {
      var group = createDataShadowGroup(i2 === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  };
  SliderZoomView2.prototype._prepareDataShadowInfo = function() {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each$q(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf$2(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        var otherDim = getOtherDim(axisDim);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;
        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  };
  SliderZoomView2.prototype._renderHandle = function() {
    var thisGroup = this.group;
    var displayables = this._displayables;
    var handles = displayables.handles = [null, null];
    var handleLabels = displayables.handleLabels = [null, null];
    var sliderGroup = this._displayables.sliderGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var borderRadius = dataZoomModel.get("borderRadius") || 0;
    var brushSelect = dataZoomModel.get("brushSelect");
    var filler = displayables.filler = new Rect({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: "rgba(0,0,0,0)"
      }
    }));
    each$q([0, 1], function(handleIndex) {
      var iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
      }
      var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind$3(this._onDragMove, this, handleIndex),
        ondragend: bind$3(this._onDragEnd, this),
        onmouseover: bind$3(this._showDataInfo, this, true),
        onmouseout: bind$3(this._showDataInfo, this, false),
        z2: 5
      });
      var bRect = path.getBoundingRect();
      var handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      var handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.getModel("textStyle");
      thisGroup.add(handleLabels[handleIndex] = new ZRText$1({
        silent: true,
        invisible: true,
        style: createTextStyle$1(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    var actualMoveZone = filler;
    if (brushSelect) {
      var moveHandleHeight = parsePercent(dataZoomModel.get("moveHandleSize"), size[1]);
      var moveHandle_1 = displayables.moveHandle = new Rect$2({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      var iconSize = moveHandleHeight * 0.8;
      var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect$2({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", function() {
        api.enterEmphasis(moveHandle_1);
      }).on("mouseout", function() {
        api.leaveEmphasis(moveHandle_1);
      });
      sliderGroup.add(moveHandle_1);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: bind$3(this._onDragMove, this, "all"),
      ondragstart: bind$3(this._showDataInfo, this, true),
      ondragend: bind$3(this._onDragEnd, this),
      onmouseover: bind$3(this._showDataInfo, this, true),
      onmouseout: bind$3(this._showDataInfo, this, false)
    });
  };
  SliderZoomView2.prototype._resetInterval = function() {
    var range2 = this._range = this.dataZoomModel.getPercentRange();
    var viewExtent = this._getViewExtent();
    this._handleEnds = [linearMap(range2[0], [0, 100], viewExtent, true), linearMap(range2[1], [0, 100], viewExtent, true)];
  };
  SliderZoomView2.prototype._updateInterval = function(handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;
    var viewExtend = this._getViewExtent();
    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range2 = this._range = asc$1([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range2[0] || lastRange[1] !== range2[1];
  };
  SliderZoomView2.prototype._updateView = function(nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc$1(handleEnds.slice());
    var size = this._size;
    each$q([0, 1], function(handleIndex) {
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    var viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    var dataShadowSegs = displaybles.dataShadowSegs;
    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
    for (var i2 = 0; i2 < dataShadowSegs.length; i2++) {
      var segGroup = dataShadowSegs[i2];
      var clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect$2();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i2],
        y: 0,
        width: segIntervals[i2 + 1] - segIntervals[i2],
        height: size[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  };
  SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range2 = this._range;
        var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range2[0],
          end: range2[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }
    var orderedHandleEnds = asc$1(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);
    function setLabel(handleIndex) {
      var barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);
      var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      var offset2 = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset2 : offset2), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? "middle" : direction,
        align: orient === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  };
  SliderZoomView2.prototype._formatLabel = function(value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get("labelFormatter");
    var labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction$h(labelFormatter) ? labelFormatter(value, valueStr) : isString$d(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  };
  SliderZoomView2.prototype._showDataInfo = function(showOrHide) {
    showOrHide = this._dragging || showOrHide;
    var displayables = this._displayables;
    var handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !showOrHide);
    handleLabels[1].attr("invisible", !showOrHide);
    displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  };
  SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    var barTransform = this._displayables.sliderGroup.getLocalTransform();
    var vertex = applyTransform([dx, dy], barTransform, true);
    var changed = this._updateInterval(handleIndex, vertex[0]);
    var realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  };
  SliderZoomView2.prototype._onDragEnd = function() {
    this._dragging = false;
    this._showDataInfo(false);
    var realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onClickPanel = function(e3) {
    var size = this._size;
    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e3.offsetX, e3.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }
    var handleEnds = this._handleEnds;
    var center2 = (handleEnds[0] + handleEnds[1]) / 2;
    var changed = this._updateInterval("all", localPoint[0] - center2);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrushStart = function(e3) {
    var x2 = e3.offsetX;
    var y2 = e3.offsetY;
    this._brushStart = new Point$2(x2, y2);
    this._brushing = true;
    this._brushStartTime = +new Date();
  };
  SliderZoomView2.prototype._onBrushEnd = function(e3) {
    if (!this._brushing) {
      return;
    }
    var brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    var brushShape = brushRect.shape;
    var brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    var viewExtend = this._getViewExtent();
    var percentExtent = [0, 100];
    this._range = asc$1([linearMap(brushShape.x, viewExtend, percentExtent, true), linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    this._updateView();
    this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrush = function(e3) {
    if (this._brushing) {
      stop(e3.event);
      this._updateBrushRect(e3.offsetX, e3.offsetY);
    }
  };
  SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
    var displayables = this._displayables;
    var dataZoomModel = this.dataZoomModel;
    var brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    var brushStart = this._brushStart;
    var sliderGroup = this._displayables.sliderGroup;
    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    var size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  };
  SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
    var range2 = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range2[0],
      end: range2[1]
    });
  };
  SliderZoomView2.prototype._findCoordRect = function() {
    var rect;
    var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      var coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      var width2 = this.api.getWidth();
      var height2 = this.api.getHeight();
      rect = {
        x: width2 * 0.2,
        y: height2 * 0.2,
        width: width2 * 0.6,
        height: height2 * 0.6
      };
    }
    return rect;
  };
  SliderZoomView2.type = "dataZoom.slider";
  return SliderZoomView2;
}(DataZoomView$1);
function getOtherDim(thisDim) {
  var map2 = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return map2[thisDim];
}
function getCursor(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView$1 = SliderZoomView;
function install$2(registers) {
  registers.registerComponentModel(SliderZoomModel$1);
  registers.registerComponentView(SliderZoomView$1);
  installCommon(registers);
}
function install$1(registers) {
  use$1(install$3);
  use$1(install$2);
}
var CMD = PathProxy$1.CMD;
function aroundEqual(a2, b2) {
  return Math.abs(a2 - b2) < 1e-5;
}
function pathToBezierCurves(path) {
  var data5 = path.data;
  var len2 = path.len();
  var bezierArrayGroups = [];
  var currentSubpath;
  var xi2 = 0;
  var yi2 = 0;
  var x0 = 0;
  var y0 = 0;
  function createNewSubpath(x3, y3) {
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    currentSubpath = [x3, y3];
  }
  function addLine(x02, y02, x12, y12) {
    if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
      currentSubpath.push(x02, y02, x12, y12, x12, y12);
    }
  }
  function addArc(startAngle2, endAngle2, cx2, cy2, rx2, ry2) {
    var delta = Math.abs(endAngle2 - startAngle2);
    var len3 = Math.tan(delta / 4) * 4 / 3;
    var dir3 = endAngle2 < startAngle2 ? -1 : 1;
    var c1 = Math.cos(startAngle2);
    var s1 = Math.sin(startAngle2);
    var c2 = Math.cos(endAngle2);
    var s2 = Math.sin(endAngle2);
    var x12 = c1 * rx2 + cx2;
    var y12 = s1 * ry2 + cy2;
    var x4 = c2 * rx2 + cx2;
    var y4 = s2 * ry2 + cy2;
    var hx = rx2 * len3 * dir3;
    var hy = ry2 * len3 * dir3;
    currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
  var x1;
  var y1;
  var x2;
  var y2;
  for (var i2 = 0; i2 < len2; ) {
    var cmd = data5[i2++];
    var isFirst = i2 === 1;
    if (isFirst) {
      xi2 = data5[i2];
      yi2 = data5[i2 + 1];
      x0 = xi2;
      y0 = yi2;
      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
        currentSubpath = [x0, y0];
      }
    }
    switch (cmd) {
      case CMD.M:
        xi2 = x0 = data5[i2++];
        yi2 = y0 = data5[i2++];
        createNewSubpath(x0, y0);
        break;
      case CMD.L:
        x1 = data5[i2++];
        y1 = data5[i2++];
        addLine(xi2, yi2, x1, y1);
        xi2 = x1;
        yi2 = y1;
        break;
      case CMD.C:
        currentSubpath.push(data5[i2++], data5[i2++], data5[i2++], data5[i2++], xi2 = data5[i2++], yi2 = data5[i2++]);
        break;
      case CMD.Q:
        x1 = data5[i2++];
        y1 = data5[i2++];
        x2 = data5[i2++];
        y2 = data5[i2++];
        currentSubpath.push(xi2 + 2 / 3 * (x1 - xi2), yi2 + 2 / 3 * (y1 - yi2), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
        xi2 = x2;
        yi2 = y2;
        break;
      case CMD.A:
        var cx = data5[i2++];
        var cy = data5[i2++];
        var rx = data5[i2++];
        var ry = data5[i2++];
        var startAngle = data5[i2++];
        var endAngle = data5[i2++] + startAngle;
        i2 += 1;
        var anticlockwise = !data5[i2++];
        x1 = Math.cos(startAngle) * rx + cx;
        y1 = Math.sin(startAngle) * ry + cy;
        if (isFirst) {
          x0 = x1;
          y0 = y1;
          createNewSubpath(x0, y0);
        } else {
          addLine(xi2, yi2, x1, y1);
        }
        xi2 = Math.cos(endAngle) * rx + cx;
        yi2 = Math.sin(endAngle) * ry + cy;
        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
          addArc(angle, nextAngle, cx, cy, rx, ry);
        }
        break;
      case CMD.R:
        x0 = xi2 = data5[i2++];
        y0 = yi2 = data5[i2++];
        x1 = x0 + data5[i2++];
        y1 = y0 + data5[i2++];
        createNewSubpath(x1, y0);
        addLine(x1, y0, x1, y1);
        addLine(x1, y1, x0, y1);
        addLine(x0, y1, x0, y0);
        addLine(x0, y0, x1, y0);
        break;
      case CMD.Z:
        currentSubpath && addLine(xi2, yi2, x0, y0);
        xi2 = x0;
        yi2 = y0;
        break;
    }
  }
  if (currentSubpath && currentSubpath.length > 2) {
    bezierArrayGroups.push(currentSubpath);
  }
  return bezierArrayGroups;
}
function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale2) {
  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
    out2.push(x3, y3);
    return;
  }
  var PIXEL_DISTANCE = 2 / scale2;
  var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
  var dx = x3 - x0;
  var dy = y3 - y0;
  var d3 = Math.sqrt(dx * dx + dy * dy);
  dx /= d3;
  dy /= d3;
  var dx1 = x1 - x0;
  var dy1 = y1 - y0;
  var dx2 = x2 - x3;
  var dy2 = y2 - y3;
  var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
  var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
    out2.push(x3, y3);
    return;
  }
  var projLen1 = dx * dx1 + dy * dy1;
  var projLen2 = -dx * dx2 - dy * dy2;
  var d1Sqr = cp1LenSqr - projLen1 * projLen1;
  var d2Sqr = cp2LenSqr - projLen2 * projLen2;
  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
    out2.push(x3, y3);
    return;
  }
  var tmpSegX = [];
  var tmpSegY = [];
  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale2);
  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale2);
}
function pathToPolygons(path, scale2) {
  var bezierArrayGroups = pathToBezierCurves(path);
  var polygons = [];
  scale2 = scale2 || 1;
  for (var i2 = 0; i2 < bezierArrayGroups.length; i2++) {
    var beziers = bezierArrayGroups[i2];
    var polygon = [];
    var x0 = beziers[0];
    var y0 = beziers[1];
    polygon.push(x0, y0);
    for (var k2 = 2; k2 < beziers.length; ) {
      var x1 = beziers[k2++];
      var y1 = beziers[k2++];
      var x2 = beziers[k2++];
      var y2 = beziers[k2++];
      var x3 = beziers[k2++];
      var y3 = beziers[k2++];
      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale2);
      x0 = x3;
      y0 = y3;
    }
    polygons.push(polygon);
  }
  return polygons;
}
function getDividingGrids(dimSize, rowDim, count) {
  var rowSize = dimSize[rowDim];
  var columnSize = dimSize[1 - rowDim];
  var ratio = Math.abs(rowSize / columnSize);
  var rowCount = Math.ceil(Math.sqrt(ratio * count));
  var columnCount = Math.floor(count / rowCount);
  if (columnCount === 0) {
    columnCount = 1;
    rowCount = count;
  }
  var grids = [];
  for (var i2 = 0; i2 < rowCount; i2++) {
    grids.push(columnCount);
  }
  var currentCount = rowCount * columnCount;
  var remained = count - currentCount;
  if (remained > 0) {
    for (var i2 = 0; i2 < remained; i2++) {
      grids[i2 % rowCount] += 1;
    }
  }
  return grids;
}
function divideSector(sectorShape, count, outShapes) {
  var r0 = sectorShape.r0;
  var r2 = sectorShape.r;
  var startAngle = sectorShape.startAngle;
  var endAngle = sectorShape.endAngle;
  var angle = Math.abs(endAngle - startAngle);
  var arcLen = angle * r2;
  var deltaR = r2 - r0;
  var isAngleRow = arcLen > Math.abs(deltaR);
  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);
  var rowSize = (isAngleRow ? angle : deltaR) / grids.length;
  for (var row2 = 0; row2 < grids.length; row2++) {
    var columnSize = (isAngleRow ? deltaR : angle) / grids[row2];
    for (var column2 = 0; column2 < grids[row2]; column2++) {
      var newShape = {};
      if (isAngleRow) {
        newShape.startAngle = startAngle + rowSize * row2;
        newShape.endAngle = startAngle + rowSize * (row2 + 1);
        newShape.r0 = r0 + columnSize * column2;
        newShape.r = r0 + columnSize * (column2 + 1);
      } else {
        newShape.startAngle = startAngle + columnSize * column2;
        newShape.endAngle = startAngle + columnSize * (column2 + 1);
        newShape.r0 = r0 + rowSize * row2;
        newShape.r = r0 + rowSize * (row2 + 1);
      }
      newShape.clockwise = sectorShape.clockwise;
      newShape.cx = sectorShape.cx;
      newShape.cy = sectorShape.cy;
      outShapes.push(newShape);
    }
  }
}
function divideRect(rectShape, count, outShapes) {
  var width2 = rectShape.width;
  var height2 = rectShape.height;
  var isHorizontalRow = width2 > height2;
  var grids = getDividingGrids([width2, height2], isHorizontalRow ? 0 : 1, count);
  var rowSizeDim = isHorizontalRow ? "width" : "height";
  var columnSizeDim = isHorizontalRow ? "height" : "width";
  var rowDim = isHorizontalRow ? "x" : "y";
  var columnDim = isHorizontalRow ? "y" : "x";
  var rowSize = rectShape[rowSizeDim] / grids.length;
  for (var row2 = 0; row2 < grids.length; row2++) {
    var columnSize = rectShape[columnSizeDim] / grids[row2];
    for (var column2 = 0; column2 < grids[row2]; column2++) {
      var newShape = {};
      newShape[rowDim] = row2 * rowSize;
      newShape[columnDim] = column2 * columnSize;
      newShape[rowSizeDim] = rowSize;
      newShape[columnSizeDim] = columnSize;
      newShape.x += rectShape.x;
      newShape.y += rectShape.y;
      outShapes.push(newShape);
    }
  }
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (Math.abs(nmCrossProduct) < 1e-6) {
    return null;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var p2 = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p2 < 0 || p2 > 1) {
    return null;
  }
  return new Point$2(p2 * mx + a1x, p2 * my + a1y);
}
function projPtOnLine(pt3, lineA, lineB) {
  var dir3 = new Point$2();
  Point$2.sub(dir3, lineB, lineA);
  dir3.normalize();
  var dir22 = new Point$2();
  Point$2.sub(dir22, pt3, lineA);
  var len2 = dir22.dot(dir3);
  return len2;
}
function addToPoly(poly, pt3) {
  var last2 = poly[poly.length - 1];
  if (last2 && last2[0] === pt3[0] && last2[1] === pt3[1]) {
    return;
  }
  poly.push(pt3);
}
function splitPolygonByLine(points2, lineA, lineB) {
  var len2 = points2.length;
  var intersections = [];
  for (var i2 = 0; i2 < len2; i2++) {
    var p0 = points2[i2];
    var p1 = points2[(i2 + 1) % len2];
    var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
    if (intersectionPt) {
      intersections.push({
        projPt: projPtOnLine(intersectionPt, lineA, lineB),
        pt: intersectionPt,
        idx: i2
      });
    }
  }
  if (intersections.length < 2) {
    return [{ points: points2 }, { points: points2 }];
  }
  intersections.sort(function(a2, b2) {
    return a2.projPt - b2.projPt;
  });
  var splitPt0 = intersections[0];
  var splitPt1 = intersections[intersections.length - 1];
  if (splitPt1.idx < splitPt0.idx) {
    var tmp = splitPt0;
    splitPt0 = splitPt1;
    splitPt1 = tmp;
  }
  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
  var newPolyA = [splitPt0Arr];
  var newPolyB = [splitPt1Arr];
  for (var i2 = splitPt0.idx + 1; i2 <= splitPt1.idx; i2++) {
    addToPoly(newPolyA, points2[i2].slice());
  }
  addToPoly(newPolyA, splitPt1Arr);
  addToPoly(newPolyA, splitPt0Arr);
  for (var i2 = splitPt1.idx + 1; i2 <= splitPt0.idx + len2; i2++) {
    addToPoly(newPolyB, points2[i2 % len2].slice());
  }
  addToPoly(newPolyB, splitPt0Arr);
  addToPoly(newPolyB, splitPt1Arr);
  return [{
    points: newPolyA
  }, {
    points: newPolyB
  }];
}
function binaryDividePolygon(polygonShape) {
  var points2 = polygonShape.points;
  var min3 = [];
  var max3 = [];
  fromPoints(points2, min3, max3);
  var boundingRect = new BoundingRect$1(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
  var width2 = boundingRect.width;
  var height2 = boundingRect.height;
  var x2 = boundingRect.x;
  var y2 = boundingRect.y;
  var pt02 = new Point$2();
  var pt12 = new Point$2();
  if (width2 > height2) {
    pt02.x = pt12.x = x2 + width2 / 2;
    pt02.y = y2;
    pt12.y = y2 + height2;
  } else {
    pt02.y = pt12.y = y2 + height2 / 2;
    pt02.x = x2;
    pt12.x = x2 + width2;
  }
  return splitPolygonByLine(points2, pt02, pt12);
}
function binaryDivideRecursive(divider, shape, count, out2) {
  if (count === 1) {
    out2.push(shape);
  } else {
    var mid = Math.floor(count / 2);
    var sub2 = divider(shape);
    binaryDivideRecursive(divider, sub2[0], mid, out2);
    binaryDivideRecursive(divider, sub2[1], count - mid, out2);
  }
  return out2;
}
function clone$4(path, count) {
  var paths = [];
  for (var i2 = 0; i2 < count; i2++) {
    paths.push(clonePath(path));
  }
  return paths;
}
function copyPathProps(source, target) {
  target.setStyle(source.style);
  target.z = source.z;
  target.z2 = source.z2;
  target.zlevel = source.zlevel;
}
function polygonConvert(points2) {
  var out2 = [];
  for (var i2 = 0; i2 < points2.length; ) {
    out2.push([points2[i2++], points2[i2++]]);
  }
  return out2;
}
function split(path, count) {
  var outShapes = [];
  var shape = path.shape;
  var OutShapeCtor;
  switch (path.type) {
    case "rect":
      divideRect(shape, count, outShapes);
      OutShapeCtor = Rect$2;
      break;
    case "sector":
      divideSector(shape, count, outShapes);
      OutShapeCtor = Sector$1;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: shape.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: shape.cx,
        cy: shape.cy
      }, count, outShapes);
      OutShapeCtor = Sector$1;
      break;
    default:
      var m2 = path.getComputedTransform();
      var scale2 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
      var polygons = map$9(pathToPolygons(path.getUpdatedPathProxy(), scale2), function(poly) {
        return polygonConvert(poly);
      });
      var polygonCount = polygons.length;
      if (polygonCount === 0) {
        binaryDivideRecursive(binaryDividePolygon, {
          points: polygons[0]
        }, count, outShapes);
      } else if (polygonCount === count) {
        for (var i2 = 0; i2 < polygonCount; i2++) {
          outShapes.push({
            points: polygons[i2]
          });
        }
      } else {
        var totalArea_1 = 0;
        var items = map$9(polygons, function(poly) {
          var min3 = [];
          var max3 = [];
          fromPoints(poly, min3, max3);
          var area = (max3[1] - min3[1]) * (max3[0] - min3[0]);
          totalArea_1 += area;
          return { poly, area };
        });
        items.sort(function(a2, b2) {
          return b2.area - a2.area;
        });
        var left = count;
        for (var i2 = 0; i2 < polygonCount; i2++) {
          var item = items[i2];
          if (left <= 0) {
            break;
          }
          var selfCount = i2 === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count);
          if (selfCount < 0) {
            continue;
          }
          binaryDivideRecursive(binaryDividePolygon, {
            points: item.poly
          }, selfCount, outShapes);
          left -= selfCount;
        }
      }
      OutShapeCtor = Polygon$1;
      break;
  }
  if (!OutShapeCtor) {
    return clone$4(path, count);
  }
  var out2 = [];
  for (var i2 = 0; i2 < outShapes.length; i2++) {
    var subPath = new OutShapeCtor();
    subPath.setShape(outShapes[i2]);
    copyPathProps(path, subPath);
    out2.push(subPath);
  }
  return out2;
}
function alignSubpath(subpath1, subpath2) {
  var len1 = subpath1.length;
  var len2 = subpath2.length;
  if (len1 === len2) {
    return [subpath1, subpath2];
  }
  var tmpSegX = [];
  var tmpSegY = [];
  var shorterPath = len1 < len2 ? subpath1 : subpath2;
  var shorterLen = Math.min(len1, len2);
  var diff = Math.abs(len2 - len1) / 6;
  var shorterBezierCount = (shorterLen - 2) / 6;
  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
  var newSubpath = [shorterPath[0], shorterPath[1]];
  var remained = diff;
  for (var i2 = 2; i2 < shorterLen; ) {
    var x0 = shorterPath[i2 - 2];
    var y0 = shorterPath[i2 - 1];
    var x1 = shorterPath[i2++];
    var y1 = shorterPath[i2++];
    var x2 = shorterPath[i2++];
    var y2 = shorterPath[i2++];
    var x3 = shorterPath[i2++];
    var y3 = shorterPath[i2++];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
    for (var k2 = 1; k2 <= actualSubDivCount; k2++) {
      var p2 = k2 / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p2, tmpSegX);
      cubicSubdivide(y0, y1, y2, y3, p2, tmpSegY);
      x0 = tmpSegX[3];
      y0 = tmpSegY[3];
      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
      x1 = tmpSegX[5];
      y1 = tmpSegY[5];
      x2 = tmpSegX[6];
      y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
  var len2 = lastSubpathSubpath.length;
  var lastX = lastSubpathSubpath[len2 - 2];
  var lastY = lastSubpathSubpath[len2 - 1];
  var newSubpath = [];
  for (var i2 = 0; i2 < otherSubpath.length; ) {
    newSubpath[i2++] = lastX;
    newSubpath[i2++] = lastY;
  }
  return newSubpath;
}
function alignBezierCurves(array1, array2) {
  var _a2;
  var lastSubpath1;
  var lastSubpath2;
  var newArray1 = [];
  var newArray2 = [];
  for (var i2 = 0; i2 < Math.max(array1.length, array2.length); i2++) {
    var subpath1 = array1[i2];
    var subpath2 = array2[i2];
    var newSubpath1 = void 0;
    var newSubpath2 = void 0;
    if (!subpath1) {
      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
      newSubpath2 = subpath2;
    } else if (!subpath2) {
      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
      newSubpath1 = subpath1;
    } else {
      _a2 = alignSubpath(subpath1, subpath2), newSubpath1 = _a2[0], newSubpath2 = _a2[1];
      lastSubpath1 = newSubpath1;
      lastSubpath2 = newSubpath2;
    }
    newArray1.push(newSubpath1);
    newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
function centroid(array2) {
  var signedArea = 0;
  var cx = 0;
  var cy = 0;
  var len2 = array2.length;
  for (var i2 = 0, j2 = len2 - 2; i2 < len2; j2 = i2, i2 += 2) {
    var x0 = array2[j2];
    var y0 = array2[j2 + 1];
    var x1 = array2[i2];
    var y1 = array2[i2 + 1];
    var a2 = x0 * y1 - x1 * y0;
    signedArea += a2;
    cx += (x0 + x1) * a2;
    cy += (y0 + y1) * a2;
  }
  if (signedArea === 0) {
    return [array2[0] || 0, array2[1] || 0];
  }
  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  var bezierCount = (fromSubBeziers.length - 2) / 6;
  var bestScore = Infinity;
  var bestOffset = 0;
  var len2 = fromSubBeziers.length;
  var len22 = len2 - 2;
  for (var offset2 = 0; offset2 < bezierCount; offset2++) {
    var cursorOffset = offset2 * 6;
    var score = 0;
    for (var k2 = 0; k2 < len2; k2 += 2) {
      var idx = k2 === 0 ? cursorOffset : (cursorOffset + k2 - 2) % len22 + 2;
      var x0 = fromSubBeziers[idx] - fromCp[0];
      var y0 = fromSubBeziers[idx + 1] - fromCp[1];
      var x1 = toSubBeziers[k2] - toCp[0];
      var y1 = toSubBeziers[k2 + 1] - toCp[1];
      var dx = x1 - x0;
      var dy = y1 - y0;
      score += dx * dx + dy * dy;
    }
    if (score < bestScore) {
      bestScore = score;
      bestOffset = offset2;
    }
  }
  return bestOffset;
}
function reverse(array2) {
  var newArr = [];
  var len2 = array2.length;
  for (var i2 = 0; i2 < len2; i2 += 2) {
    newArr[i2] = array2[len2 - i2 - 2];
    newArr[i2 + 1] = array2[len2 - i2 - 1];
  }
  return newArr;
}
function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
  var result = [];
  var fromNeedsReverse;
  for (var i2 = 0; i2 < fromArr.length; i2++) {
    var fromSubpathBezier = fromArr[i2];
    var toSubpathBezier = toArr2[i2];
    var fromCp = centroid(fromSubpathBezier);
    var toCp = centroid(toSubpathBezier);
    if (fromNeedsReverse == null) {
      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
    }
    var newFromSubpathBezier = [];
    var newToSubpathBezier = [];
    var bestAngle = 0;
    var bestScore = Infinity;
    var tmpArr2 = [];
    var len2 = fromSubpathBezier.length;
    if (fromNeedsReverse) {
      fromSubpathBezier = reverse(fromSubpathBezier);
    }
    var offset2 = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
    var len22 = len2 - 2;
    for (var k2 = 0; k2 < len22; k2 += 2) {
      var idx = (offset2 + k2) % len22 + 2;
      newFromSubpathBezier[k2 + 2] = fromSubpathBezier[idx] - fromCp[0];
      newFromSubpathBezier[k2 + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    newFromSubpathBezier[0] = fromSubpathBezier[offset2] - fromCp[0];
    newFromSubpathBezier[1] = fromSubpathBezier[offset2 + 1] - fromCp[1];
    if (searchAngleIteration > 0) {
      var step = searchAngleRange / searchAngleIteration;
      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
        var sa2 = Math.sin(angle);
        var ca2 = Math.cos(angle);
        var score = 0;
        for (var k2 = 0; k2 < fromSubpathBezier.length; k2 += 2) {
          var x0 = newFromSubpathBezier[k2];
          var y0 = newFromSubpathBezier[k2 + 1];
          var x1 = toSubpathBezier[k2] - toCp[0];
          var y1 = toSubpathBezier[k2 + 1] - toCp[1];
          var newX1 = x1 * ca2 - y1 * sa2;
          var newY1 = x1 * sa2 + y1 * ca2;
          tmpArr2[k2] = newX1;
          tmpArr2[k2 + 1] = newY1;
          var dx = newX1 - x0;
          var dy = newY1 - y0;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score;
          bestAngle = angle;
          for (var m2 = 0; m2 < tmpArr2.length; m2++) {
            newToSubpathBezier[m2] = tmpArr2[m2];
          }
        }
      }
    } else {
      for (var i_1 = 0; i_1 < len2; i_1 += 2) {
        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
      }
    }
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function isCombineMorphing(path) {
  return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  var originalMethod = obj[savedMethodName] || obj[methodName];
  if (!obj[savedMethodName]) {
    obj[savedMethodName] = obj[methodName];
  }
  var replace = modifiers.replace;
  var after2 = modifiers.after;
  var before2 = modifiers.before;
  obj[methodName] = function() {
    var args = arguments;
    var res;
    before2 && before2.apply(this, args);
    if (replace) {
      res = replace.apply(this, args);
    } else {
      res = originalMethod.apply(this, args);
    }
    after2 && after2.apply(this, args);
    return res;
  };
}
function restoreMethod(obj, methodName) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  if (obj[savedMethodName]) {
    obj[methodName] = obj[savedMethodName];
    obj[savedMethodName] = null;
  }
}
function applyTransformOnBeziers(bezierCurves, mm) {
  for (var i2 = 0; i2 < bezierCurves.length; i2++) {
    var subBeziers = bezierCurves[i2];
    for (var k2 = 0; k2 < subBeziers.length; ) {
      var x2 = subBeziers[k2];
      var y2 = subBeziers[k2 + 1];
      subBeziers[k2++] = mm[0] * x2 + mm[2] * y2 + mm[4];
      subBeziers[k2++] = mm[1] * x2 + mm[3] * y2 + mm[5];
    }
  }
}
function prepareMorphPath(fromPath, toPath) {
  var fromPathProxy = fromPath.getUpdatedPathProxy();
  var toPathProxy = toPath.getUpdatedPathProxy();
  var _a2 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a2[0], toBezierCurves = _a2[1];
  var fromPathTransform = fromPath.getComputedTransform();
  var toPathTransform = toPath.getComputedTransform();
  function updateIdentityTransform() {
    this.transform = null;
  }
  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
  saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
  toPath.transform = null;
  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
  var tmpArr2 = [];
  saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
    var t2 = toPath.__morphT;
    var onet = 1 - t2;
    var newCp = [];
    for (var i2 = 0; i2 < morphingData.length; i2++) {
      var item = morphingData[i2];
      var from = item.from;
      var to2 = item.to;
      var angle = item.rotation * t2;
      var fromCp = item.fromCp;
      var toCp = item.toCp;
      var sa2 = Math.sin(angle);
      var ca2 = Math.cos(angle);
      lerp$1(newCp, fromCp, toCp, t2);
      for (var m2 = 0; m2 < from.length; m2 += 2) {
        var x0_1 = from[m2];
        var y0_1 = from[m2 + 1];
        var x1 = to2[m2];
        var y1 = to2[m2 + 1];
        var x2 = x0_1 * onet + x1 * t2;
        var y2 = y0_1 * onet + y1 * t2;
        tmpArr2[m2] = x2 * ca2 - y2 * sa2 + newCp[0];
        tmpArr2[m2 + 1] = x2 * sa2 + y2 * ca2 + newCp[1];
      }
      var x0 = tmpArr2[0];
      var y0 = tmpArr2[1];
      path.moveTo(x0, y0);
      for (var m2 = 2; m2 < from.length; ) {
        var x1 = tmpArr2[m2++];
        var y1 = tmpArr2[m2++];
        var x22 = tmpArr2[m2++];
        var y22 = tmpArr2[m2++];
        var x3 = tmpArr2[m2++];
        var y3 = tmpArr2[m2++];
        if (x0 === x1 && y0 === y1 && x22 === x3 && y22 === y3) {
          path.lineTo(x3, y3);
        } else {
          path.bezierCurveTo(x1, y1, x22, y22, x3, y3);
        }
        x0 = x3;
        y0 = y3;
      }
    }
  } });
}
function morphPath(fromPath, toPath, animationOpts) {
  if (!fromPath || !toPath) {
    return toPath;
  }
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  prepareMorphPath(fromPath, toPath);
  toPath.__morphT = 0;
  function restoreToPath() {
    restoreMethod(toPath, "buildPath");
    restoreMethod(toPath, "updateTransform");
    toPath.__morphT = -1;
    toPath.createPathProxy();
    toPath.dirtyShape();
  }
  toPath.animateTo({
    __morphT: 1
  }, defaults({
    during: function(p2) {
      toPath.dirtyShape();
      oldDuring && oldDuring(p2);
    },
    done: function() {
      restoreToPath();
      oldDone && oldDone();
    }
  }, animationOpts));
  return toPath;
}
function hilbert(x2, y2, minX, minY, maxX, maxY) {
  var bits = 16;
  x2 = maxX === minX ? 0 : Math.round(32767 * (x2 - minX) / (maxX - minX));
  y2 = maxY === minY ? 0 : Math.round(32767 * (y2 - minY) / (maxY - minY));
  var d3 = 0;
  var tmp;
  for (var s2 = (1 << bits) / 2; s2 > 0; s2 /= 2) {
    var rx = 0;
    var ry = 0;
    if ((x2 & s2) > 0) {
      rx = 1;
    }
    if ((y2 & s2) > 0) {
      ry = 1;
    }
    d3 += s2 * s2 * (3 * rx ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x2 = s2 - 1 - x2;
        y2 = s2 - 1 - y2;
      }
      tmp = x2;
      x2 = y2;
      y2 = tmp;
    }
  }
  return d3;
}
function sortPaths(pathList) {
  var xMin = Infinity;
  var yMin = Infinity;
  var xMax = -Infinity;
  var yMax = -Infinity;
  var cps = map$9(pathList, function(path) {
    var rect = path.getBoundingRect();
    var m2 = path.getComputedTransform();
    var x2 = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
    var y2 = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
    xMin = Math.min(x2, xMin);
    yMin = Math.min(y2, yMin);
    xMax = Math.max(x2, xMax);
    yMax = Math.max(y2, yMax);
    return [x2, y2];
  });
  var items = map$9(cps, function(cp2, idx) {
    return {
      cp: cp2,
      z: hilbert(cp2[0], cp2[1], xMin, yMin, xMax, yMax),
      path: pathList[idx]
    };
  });
  return items.sort(function(a2, b2) {
    return a2.z - b2.z;
  }).map(function(item) {
    return item.path;
  });
}
function defaultDividePath(param) {
  return split(param.path, param.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(fromList, toPath, animationOpts) {
  var fromPathList = [];
  function addFromPath(fromList2) {
    for (var i3 = 0; i3 < fromList2.length; i3++) {
      var from2 = fromList2[i3];
      if (isCombineMorphing(from2)) {
        addFromPath(from2.childrenRef());
      } else if (from2 instanceof Path$2) {
        fromPathList.push(from2);
      }
    }
  }
  addFromPath(fromList);
  var separateCount = fromPathList.length;
  if (!separateCount) {
    return createEmptyReturn();
  }
  var dividePath = animationOpts.dividePath || defaultDividePath;
  var toSubPathList = dividePath({
    path: toPath,
    count: separateCount
  });
  if (toSubPathList.length !== separateCount) {
    console.error("Invalid morphing: unmatched splitted path");
    return createEmptyReturn();
  }
  fromPathList = sortPaths(fromPathList);
  toSubPathList = sortPaths(toSubPathList);
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  var individualDelay = animationOpts.individualDelay;
  var identityTransform = new Transformable$1();
  for (var i2 = 0; i2 < separateCount; i2++) {
    var from = fromPathList[i2];
    var to2 = toSubPathList[i2];
    to2.parent = toPath;
    to2.copyTransform(identityTransform);
    if (!individualDelay) {
      prepareMorphPath(from, to2);
    }
  }
  toPath.__isCombineMorphing = true;
  toPath.childrenRef = function() {
    return toSubPathList;
  };
  function addToSubPathListToZr(zr2) {
    for (var i3 = 0; i3 < toSubPathList.length; i3++) {
      toSubPathList[i3].addSelfToZr(zr2);
    }
  }
  saveAndModifyMethod(toPath, "addSelfToZr", {
    after: function(zr2) {
      addToSubPathListToZr(zr2);
    }
  });
  saveAndModifyMethod(toPath, "removeSelfFromZr", {
    after: function(zr2) {
      for (var i3 = 0; i3 < toSubPathList.length; i3++) {
        toSubPathList[i3].removeSelfFromZr(zr2);
      }
    }
  });
  function restoreToPath() {
    toPath.__isCombineMorphing = false;
    toPath.__morphT = -1;
    toPath.childrenRef = null;
    restoreMethod(toPath, "addSelfToZr");
    restoreMethod(toPath, "removeSelfFromZr");
  }
  var toLen = toSubPathList.length;
  if (individualDelay) {
    var animating_1 = toLen;
    var eachDone = function() {
      animating_1--;
      if (animating_1 === 0) {
        restoreToPath();
        oldDone && oldDone();
      }
    };
    for (var i2 = 0; i2 < toLen; i2++) {
      var indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i2, toLen, fromPathList[i2], toSubPathList[i2]),
        done: eachDone
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i2], toSubPathList[i2], indivdualAnimationOpts);
    }
  } else {
    toPath.__morphT = 0;
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during: function(p2) {
        for (var i3 = 0; i3 < toLen; i3++) {
          var child = toSubPathList[i3];
          child.__morphT = toPath.__morphT;
          child.dirtyShape();
        }
        oldDuring && oldDuring(p2);
      },
      done: function() {
        restoreToPath();
        for (var i3 = 0; i3 < fromList.length; i3++) {
          restoreMethod(fromList[i3], "updateTransform");
        }
        oldDone && oldDone();
      }
    }, animationOpts));
  }
  if (toPath.__zr) {
    addToSubPathListToZr(toPath.__zr);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toSubPathList,
    count: toLen
  };
}
function separateMorph(fromPath, toPathList, animationOpts) {
  var toLen = toPathList.length;
  var fromPathList = [];
  var dividePath = animationOpts.dividePath || defaultDividePath;
  function addFromPath(fromList) {
    for (var i3 = 0; i3 < fromList.length; i3++) {
      var from = fromList[i3];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path$2) {
        fromPathList.push(from);
      }
    }
  }
  if (isCombineMorphing(fromPath)) {
    addFromPath(fromPath.childrenRef());
    var fromLen = fromPathList.length;
    if (fromLen < toLen) {
      var k2 = 0;
      for (var i2 = fromLen; i2 < toLen; i2++) {
        fromPathList.push(clonePath(fromPathList[k2++ % fromLen]));
      }
    }
    fromPathList.length = toLen;
  } else {
    fromPathList = dividePath({ path: fromPath, count: toLen });
    var fromPathTransform = fromPath.getComputedTransform();
    for (var i2 = 0; i2 < fromPathList.length; i2++) {
      fromPathList[i2].setLocalTransform(fromPathTransform);
    }
    if (fromPathList.length !== toLen) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
  }
  fromPathList = sortPaths(fromPathList);
  toPathList = sortPaths(toPathList);
  var individualDelay = animationOpts.individualDelay;
  for (var i2 = 0; i2 < toLen; i2++) {
    var indivdualAnimationOpts = individualDelay ? defaults({
      delay: (animationOpts.delay || 0) + individualDelay(i2, toLen, fromPathList[i2], toPathList[i2])
    }, animationOpts) : animationOpts;
    morphPath(fromPathList[i2], toPathList[i2], indivdualAnimationOpts);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toPathList,
    count: toPathList.length
  };
}
function isMultiple(elements) {
  return isArray$x(elements[0]);
}
function prepareMorphBatches(one, many) {
  var batches = [];
  var batchCount = one.length;
  for (var i2 = 0; i2 < batchCount; i2++) {
    batches.push({
      one: one[i2],
      many: []
    });
  }
  for (var i2 = 0; i2 < many.length; i2++) {
    var len2 = many[i2].length;
    var k2 = void 0;
    for (k2 = 0; k2 < len2; k2++) {
      batches[k2 % batchCount].many.push(many[i2][k2]);
    }
  }
  var off2 = 0;
  for (var i2 = batchCount - 1; i2 >= 0; i2--) {
    if (!batches[i2].many.length) {
      var moveFrom = batches[off2].many;
      if (moveFrom.length <= 1) {
        if (off2) {
          off2 = 0;
        } else {
          return batches;
        }
      }
      var len2 = moveFrom.length;
      var mid = Math.ceil(len2 / 2);
      batches[i2].many = moveFrom.slice(mid, len2);
      batches[off2].many = moveFrom.slice(0, mid);
      off2++;
    }
  }
  return batches;
}
var pathDividers = {
  clone: function(params) {
    var ret = [];
    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
    for (var i2 = 0; i2 < params.count; i2++) {
      var cloned = clonePath(params.path);
      cloned.setStyle("opacity", approxOpacity);
      ret.push(cloned);
    }
    return ret;
  },
  split: null
};
function applyMorphAnimation(from, to2, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to2.length) {
    return;
  }
  var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }
  var animationDelay = seriesModel.getModel("universalTransition").get("delay");
  var animationCfg = Object.assign({
    setToFinal: true
  }, updateAnimationCfg);
  var many;
  var one;
  if (isMultiple(from)) {
    many = from;
    one = to2;
  }
  if (isMultiple(to2)) {
    many = to2;
    one = from;
  }
  function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
    var batchMany = batch.many;
    var batchOne = batch.one;
    if (batchMany.length === 1 && !forceManyOne) {
      var batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
      var batchTo = fromIsMany2 ? batchOne : batchMany[0];
      if (isCombineMorphing(batchFrom)) {
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex2, animateCount2, true);
      } else {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(animateIndex2, animateCount2)
        }, animationCfg) : animationCfg;
        morphPath(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      var separateAnimationCfg = defaults({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function(idx, count2, fromPath, toPath) {
          return animationDelay(idx + animateIndex2, animateCount2);
        }
      }, animationCfg);
      var _a2 = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a2.fromIndividuals, toIndividuals = _a2.toIndividuals;
      var count = fromIndividuals.length;
      for (var k2 = 0; k2 < count; k2++) {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(k2, count)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k2], toIndividuals[k2], fromIsMany2 ? batchMany[k2] : batch.one, fromIsMany2 ? batch.one : batchMany[k2], individualAnimationCfg);
      }
    }
  }
  var fromIsMany = many ? many === from : from.length > to2.length;
  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to2 : from, [fromIsMany ? from : to2]);
  var animateCount = 0;
  for (var i2 = 0; i2 < morphBatches.length; i2++) {
    animateCount += morphBatches[i2].many.length;
  }
  var animateIndex = 0;
  for (var i2 = 0; i2 < morphBatches.length; i2++) {
    morphOneBatch(morphBatches[i2], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i2].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }
  if (isArray$x(elements)) {
    var pathList_1 = [];
    for (var i2 = 0; i2 < elements.length; i2++) {
      pathList_1.push(getPathList(elements[i2]));
    }
    return pathList_1;
  }
  var pathList = [];
  elements.traverse(function(el2) {
    if (el2 instanceof Path$2 && !el2.disableMorphing && !el2.invisible && !el2.ignore) {
      pathList.push(el2);
    }
  });
  return pathList;
}
var DATA_COUNT_THRESHOLD = 1e4;
var getUniversalTransitionGlobalStore = makeInner();
function getGroupIdDimension(data5) {
  var dimensions = data5.dimensions;
  for (var i2 = 0; i2 < dimensions.length; i2++) {
    var dimInfo = data5.getDimensionInfo(dimensions[i2]);
    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
      return dimensions[i2];
    }
  }
}
function flattenDataDiffItems(list) {
  var items = [];
  each$q(list, function(seriesInfo) {
    var data5 = seriesInfo.data;
    if (data5.count() > DATA_COUNT_THRESHOLD) {
      return;
    }
    var indices = data5.getIndices();
    var groupDim = getGroupIdDimension(data5);
    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        data: data5,
        dim: seriesInfo.dim || groupDim,
        divide: seriesInfo.divide,
        dataIndex
      });
    }
  });
  return items;
}
function fadeInElement(newEl, newSeries, newIndex) {
  newEl.traverse(function(el2) {
    if (el2 instanceof Path$2) {
      initProps(el2, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}
function removeEl(el2) {
  if (el2.parent) {
    var computedTransform = el2.getComputedTransform();
    el2.setLocalTransform(computedTransform);
    el2.parent.remove(el2);
  }
}
function stopAnimation(el2) {
  el2.stopAnimation();
  if (el2.isGroup) {
    el2.traverse(function(child) {
      child.stopAnimation();
    });
  }
}
function animateElementStyles(el2, dataIndex, seriesModel) {
  var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
  animationConfig && el2.traverse(function(child) {
    if (child instanceof Displayable$1) {
      var oldStyle = getOldStyle(child);
      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}
function isAllIdSame(oldDiffItems, newDiffItems) {
  var len2 = oldDiffItems.length;
  if (len2 !== newDiffItems.length) {
    return false;
  }
  for (var i2 = 0; i2 < len2; i2++) {
    var oldItem = oldDiffItems[i2];
    var newItem = newDiffItems[i2];
    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }
  return true;
}
function transitionBetween(oldList, newList, api) {
  var oldDiffItems = flattenDataDiffItems(oldList);
  var newDiffItems = flattenDataDiffItems(newList);
  function updateMorphingPathProps(from, to2, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to2.animateFrom({
        style: rawFrom && rawFrom !== from ? extend$1(extend$1({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }
  function findKeyDim(items) {
    for (var i3 = 0; i3 < items.length; i3++) {
      if (items[i3].dim) {
        return items[i3].dim;
      }
    }
  }
  var oldKeyDim = findKeyDim(oldDiffItems);
  var newKeyDim = findKeyDim(newDiffItems);
  var hasMorphAnimation = false;
  function createKeyGetter(isOld, onlyGetId) {
    return function(diffItem) {
      var data5 = diffItem.data;
      var dataIndex = diffItem.dataIndex;
      if (onlyGetId) {
        return data5.getId(dataIndex);
      }
      var dataGroupId = data5.hostModel && data5.hostModel.get("dataGroupId");
      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;
      var dimInfo = keyDim && data5.getDimensionInfo(keyDim);
      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
      if (dimInfo) {
        var key = data5.get(dimInfo.name, dataIndex);
        if (dimOrdinalMeta) {
          return dimOrdinalMeta.categories[key] || key + "";
        }
        return key + "";
      }
      var itemVal = data5.getRawDataItem(dataIndex);
      if (itemVal && itemVal.groupId) {
        return itemVal.groupId + "";
      }
      return dataGroupId || data5.getId(dataIndex);
    };
  }
  var useId2 = isAllIdSame(oldDiffItems, newDiffItems);
  var isElementStillInChart = {};
  if (!useId2) {
    for (var i2 = 0; i2 < newDiffItems.length; i2++) {
      var newItem = newDiffItems[i2];
      var el2 = newItem.data.getItemGraphicEl(newItem.dataIndex);
      if (el2) {
        isElementStillInChart[el2.id] = true;
      }
    }
  }
  function updateOneToOne(newIndex, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var newItem2 = newDiffItems[newIndex];
    var newSeries = newItem2.data.hostModel;
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    var newEl = newItem2.data.getItemGraphicEl(newItem2.dataIndex);
    if (oldEl === newEl) {
      newEl && animateElementStyles(newEl, newItem2.dataIndex, newSeries);
      return;
    }
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    if (newEl) {
      stopAnimation(newEl);
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl, newSeries, newIndex);
      }
    }
  }
  new DataDiffer$1(oldDiffItems, newDiffItems, createKeyGetter(true, useId2), createKeyGetter(false, useId2), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
    var newItem2 = newDiffItems[newIndex];
    var newData = newItem2.data;
    var newSeries = newData.hostModel;
    var newEl = newData.getItemGraphicEl(newItem2.dataIndex);
    var oldElsList = filter$3(map$9(oldIndices, function(idx) {
      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
    }), function(oldEl) {
      return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id];
    });
    if (newEl) {
      stopAnimation(newEl);
      if (oldElsList.length) {
        each$q(oldElsList, function(oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
        });
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl, newSeries, newItem2.dataIndex);
      }
    }
  }).updateOneToMany(function(newIndices, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    var newElsList = filter$3(map$9(newIndices, function(idx) {
      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
    }), function(el3) {
      return el3 && el3 !== oldEl;
    });
    var newSeris = newDiffItems[newIndices[0]].data.hostModel;
    if (newElsList.length) {
      each$q(newElsList, function(newEl) {
        return stopAnimation(newEl);
      });
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(
          getPathList(oldEl),
          getPathList(newElsList),
          oldItem.divide,
          newSeris,
          newIndices[0],
          updateMorphingPathProps
        );
      } else {
        each$q(newElsList, function(newEl) {
          return fadeInElement(newEl, newSeris, newIndices[0]);
        });
      }
    }
  }).updateManyToMany(function(newIndices, oldIndices) {
    new DataDiffer$1(oldIndices, newIndices, function(rawIdx) {
      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
    }, function(rawIdx) {
      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
    }).update(function(newIndex, oldIndex) {
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();
  if (hasMorphAnimation) {
    each$q(newList, function(_a2) {
      var data5 = _a2.data;
      var seriesModel = data5.hostModel;
      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
      var animationCfg = getAnimationConfig("update", seriesModel, 0);
      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse(function(el3) {
          if (el3 instanceof Path$2 && !el3.animators.length) {
            el3.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}
function getSeriesTransitionKey(series) {
  var seriesKey = series.getModel("universalTransition").get("seriesKey");
  if (!seriesKey) {
    return series.id;
  }
  return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
  if (isArray$x(seriesKey)) {
    return seriesKey.sort().join(",");
  }
  return seriesKey;
}
function getDivideShapeFromData(data5) {
  if (data5.hostModel) {
    return data5.hostModel.getModel("universalTransition").get("divideShape");
  }
}
function findTransitionSeriesBatches(globalStore, params) {
  var updateBatches = createHashMap();
  var oldDataMap = createHashMap();
  var oldDataMapForSplit = createHashMap();
  each$q(globalStore.oldSeries, function(series, idx) {
    var oldData = globalStore.oldData[idx];
    var transitionKey = getSeriesTransitionKey(series);
    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, oldData);
    if (isArray$x(transitionKey)) {
      each$q(transitionKey, function(key) {
        oldDataMapForSplit.set(key, {
          data: oldData,
          key: transitionKeyStr
        });
      });
    }
  });
  each$q(params.updatedSeries, function(series) {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      var newData = series.getData();
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      var oldData = oldDataMap.get(transitionKeyStr);
      if (oldData) {
        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            divide: getDivideShapeFromData(oldData),
            data: oldData
          }],
          newSeries: [{
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        if (isArray$x(transitionKey)) {
          var oldSeries_1 = [];
          each$q(transitionKey, function(key) {
            var oldData2 = oldDataMap.get(key);
            if (oldData2) {
              oldSeries_1.push({
                divide: getDivideShapeFromData(oldData2),
                data: oldData2
              });
            }
          });
          if (oldSeries_1.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries: oldSeries_1,
              newSeries: [{
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          var oldData_1 = oldDataMapForSplit.get(transitionKey);
          if (oldData_1) {
            var batch = updateBatches.get(oldData_1.key);
            if (!batch) {
              batch = {
                oldSeries: [{
                  data: oldData_1.data,
                  divide: getDivideShapeFromData(oldData_1.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData_1.key, batch);
            }
            batch.newSeries.push({
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}
function querySeries(series, finder) {
  for (var i2 = 0; i2 < series.length; i2++) {
    var found = finder.seriesIndex != null && finder.seriesIndex === series[i2].seriesIndex || finder.seriesId != null && finder.seriesId === series[i2].id;
    if (found) {
      return i2;
    }
  }
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
  var from = [];
  var to2 = [];
  each$q(normalizeToArray(transitionOpt.from), function(finder) {
    var idx = querySeries(globalStore.oldSeries, finder);
    if (idx >= 0) {
      from.push({
        data: globalStore.oldData[idx],
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        dim: finder.dimension
      });
    }
  });
  each$q(normalizeToArray(transitionOpt.to), function(finder) {
    var idx = querySeries(params.updatedSeries, finder);
    if (idx >= 0) {
      var data5 = params.updatedSeries[idx].getData();
      to2.push({
        data: data5,
        divide: getDivideShapeFromData(data5),
        dim: finder.dimension
      });
    }
  });
  if (from.length > 0 && to2.length > 0) {
    transitionBetween(from, to2, api);
  }
}
function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api, params) {
    each$q(normalizeToArray(params.seriesTransition), function(transOpt) {
      each$q(normalizeToArray(transOpt.to), function(finder) {
        var series = params.updatedSeries;
        for (var i2 = 0; i2 < series.length; i2++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i2].seriesIndex || finder.seriesId != null && finder.seriesId === series[i2].id) {
            series[i2][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle("series:transition", function(ecModel, api, params) {
    var globalStore = getUniversalTransitionGlobalStore(api);
    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      var transitionOpt = params.seriesTransition;
      if (transitionOpt) {
        each$q(normalizeToArray(transitionOpt), function(opt) {
          transitionSeriesFromOpt(opt, globalStore, params, api);
        });
      } else {
        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
        each$q(updateBatches_1.keys(), function(key) {
          var batch = updateBatches_1.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api);
        });
      }
      each$q(params.updatedSeries, function(series) {
        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    }
    var allSeries = ecModel.getSeries();
    var savedSeries = globalStore.oldSeries = [];
    var savedData = globalStore.oldData = [];
    for (var i2 = 0; i2 < allSeries.length; i2++) {
      var data5 = allSeries[i2].getData();
      if (data5.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i2]);
        savedData.push(data5);
      }
    }
  });
}
function createDom(id2, painter, dpr2) {
  var newDom = platformApi.createCanvas();
  var width2 = painter.getWidth();
  var height2 = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width2 + "px";
    newDomStyle.height = height2 + "px";
    newDom.setAttribute("data-zr-dom-id", id2);
  }
  newDom.width = width2 * dpr2;
  newDom.height = height2 * dpr2;
  return newDom;
}
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id2, painter, dpr2) {
    var _this = _super.call(this) || this;
    _this.motionBlur = false;
    _this.lastFrameAlpha = 0.7;
    _this.dpr = 1;
    _this.virtual = false;
    _this.config = {};
    _this.incremental = false;
    _this.zlevel = 0;
    _this.maxRepaintRectCount = 5;
    _this.__dirty = true;
    _this.__firstTimePaint = true;
    _this.__used = false;
    _this.__drawIndex = 0;
    _this.__startIndex = 0;
    _this.__endIndex = 0;
    _this.__prevStartIndex = null;
    _this.__prevEndIndex = null;
    var dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id2 === "string") {
      dom = createDom(id2, painter, dpr2);
    } else if (isObject$f(id2)) {
      dom = id2;
      id2 = dom.id;
    }
    _this.id = id2;
    _this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = function() {
        return false;
      };
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    _this.painter = painter;
    _this.dpr = dpr2;
    return _this;
  }
  Layer2.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  };
  Layer2.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  };
  Layer2.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  };
  Layer2.prototype.setUnpainted = function() {
    this.__firstTimePaint = true;
  };
  Layer2.prototype.createBackBuffer = function() {
    var dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  };
  Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    var mergedRepaintRects = [];
    var maxRepaintRectCount = this.maxRepaintRectCount;
    var full = false;
    var pendingRect = new BoundingRect$1(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        var boundingRect = new BoundingRect$1(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        var isMerged = false;
        var minDeltaArea = Infinity;
        var bestRectToMergeIdx = 0;
        for (var i3 = 0; i3 < mergedRepaintRects.length; ++i3) {
          var mergedRect = mergedRepaintRects[i3];
          if (mergedRect.intersect(rect)) {
            var pendingRect_1 = new BoundingRect$1(0, 0, 0, 0);
            pendingRect_1.copy(mergedRect);
            pendingRect_1.union(rect);
            mergedRepaintRects[i3] = pendingRect_1;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            var aArea = rect.width * rect.height;
            var bArea = mergedRect.width * mergedRect.height;
            var pendingArea = pendingRect.width * pendingRect.height;
            var deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i3;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          var boundingRect = new BoundingRect$1(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (var i2 = this.__startIndex; i2 < this.__endIndex; ++i2) {
      var el2 = displayList[i2];
      if (el2) {
        var shouldPaint = el2.shouldBePainted(viewWidth, viewHeight, true, true);
        var prevRect = el2.__isRendered && (el2.__dirty & REDRAW_BIT || !shouldPaint) ? el2.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        var curRect = shouldPaint && (el2.__dirty & REDRAW_BIT || !el2.__isRendered) ? el2.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (var i2 = this.__prevStartIndex; i2 < this.__prevEndIndex; ++i2) {
      var el2 = prevList[i2];
      var shouldPaint = el2.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el2 && (!shouldPaint || !el2.__zr) && el2.__isRendered) {
        var prevRect = el2.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    var hasIntersections;
    do {
      hasIntersections = false;
      for (var i2 = 0; i2 < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i2].isZero()) {
          mergedRepaintRects.splice(i2, 1);
          continue;
        }
        for (var j2 = i2 + 1; j2 < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i2].intersect(mergedRepaintRects[j2])) {
            hasIntersections = true;
            mergedRepaintRects[i2].union(mergedRepaintRects[j2]);
            mergedRepaintRects.splice(j2, 1);
          } else {
            j2++;
          }
        }
        i2++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  };
  Layer2.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  };
  Layer2.prototype.resize = function(width2, height2) {
    var dpr2 = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width2 + "px";
      domStyle.height = height2 + "px";
    }
    dom.width = width2 * dpr2;
    dom.height = height2 * dpr2;
    if (domBack) {
      domBack.width = width2 * dpr2;
      domBack.height = height2 * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  };
  Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width2 = dom.width;
    var height2 = dom.height;
    clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr2 = this.dpr;
    var self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width2 / dpr2, height2 / dpr2);
    }
    var domBack = this.domBack;
    function doClear(x2, y2, width3, height3) {
      ctx.clearRect(x2, y2, width3, height3);
      if (clearColor && clearColor !== "transparent") {
        var clearColorGradientOrPattern = void 0;
        if (isGradientObject(clearColor)) {
          clearColorGradientOrPattern = clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width3,
            height: height3
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } else if (isImagePatternObject(clearColor)) {
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty: function() {
              self2.setUnpainted();
              self2.__painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x2, y2, width3, height3);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x2, y2, width3, height3);
        ctx.restore();
      }
    }
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width2, height2);
    } else if (repaintRects.length) {
      each$q(repaintRects, function(rect) {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  };
  return Layer2;
}(Eventful$1);
var Layer$1 = Layer;
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width2, height2) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width2 + "px",
    "height:" + height2 + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = function() {
  function CanvasPainter2(root2, storage, opts, id2) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    var singleCanvas = !root2.nodeName || root2.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend$1({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root2;
    var rootStyle = root2.style;
    if (rootStyle) {
      disableUserSelect(root2);
      root2.innerHTML = "";
    }
    this.storage = storage;
    var zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    var layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize$3(root2, 0, opts);
      this._height = getSize$3(root2, 1, opts);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root2.appendChild(domRoot);
    } else {
      var rootCanvas = root2;
      var width2 = rootCanvas.width;
      var height2 = rootCanvas.height;
      if (opts.width != null) {
        width2 = opts.width;
      }
      if (opts.height != null) {
        height2 = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width2 * this.dpr;
      rootCanvas.height = height2 * this.dpr;
      this._width = width2;
      this._height = height2;
      var mainLayer = new Layer$1(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root2;
    }
  }
  CanvasPainter2.prototype.getType = function() {
    return "canvas";
  };
  CanvasPainter2.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  };
  CanvasPainter2.prototype.getViewportRoot = function() {
    return this._domRoot;
  };
  CanvasPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  CanvasPainter2.prototype.refresh = function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var prevList = this._prevDisplayList;
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (var i2 = 0; i2 < zlevelList.length; i2++) {
      var z2 = zlevelList[i2];
      var layer = this._layers[z2];
      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i2 === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  };
  CanvasPainter2.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(false));
  };
  CanvasPainter2.prototype._paintHoverList = function(list) {
    var len2 = list.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    var scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    var ctx;
    for (var i2 = 0; i2 < len2; i2++) {
      var el2 = list[i2];
      if (el2.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush(ctx, el2, scope, i2 === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  };
  CanvasPainter2.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  };
  CanvasPainter2.prototype.paintOne = function(ctx, el2) {
    brushSingle(ctx, el2);
  };
  CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      var self_1 = this;
      requestAnimationFrame$1(function() {
        self_1._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer(function(layer) {
        layer.afterBrush && layer.afterBrush();
      });
    }
  };
  CanvasPainter2.prototype._compositeManually = function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width2 = this._domRoot.width;
    var height2 = this._domRoot.height;
    ctx.clearRect(0, 0, width2, height2);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width2, height2);
      }
    });
  };
  CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
    var _this = this;
    var layerList = [];
    var useDirtyRect = this._opts.useDirtyRect;
    for (var zi2 = 0; zi2 < this._zlevelList.length; zi2++) {
      var zlevel = this._zlevelList[zi2];
      var layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    var finished = true;
    var needsRefreshHover = false;
    var _loop_1 = function(k3) {
      var layer2 = layerList[k3];
      var ctx = layer2.ctx;
      var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
      var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
      var useTimer = !paintAll && layer2.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
      if (layer2.__startIndex === layer2.__endIndex) {
        layer2.clear(false, clearColor, repaintRects);
      } else if (start2 === layer2.__startIndex) {
        var firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer2.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer2.__startIndex;
      }
      var i2;
      var repaint = function(repaintRect) {
        var scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: _this._width,
          viewHeight: _this._height
        };
        for (i2 = start2; i2 < layer2.__endIndex; i2++) {
          var el2 = list[i2];
          if (el2.__inHover) {
            needsRefreshHover = true;
          }
          _this._doPaintEl(el2, layer2, useDirtyRect, repaintRect, scope, i2 === layer2.__endIndex - 1);
          if (useTimer) {
            var dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i2 = layer2.__endIndex;
        } else {
          var dpr2 = this_1.dpr;
          for (var r2 = 0; r2 < repaintRects.length; ++r2) {
            var rect = repaintRects[r2];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer2.__drawIndex = i2;
      if (layer2.__drawIndex < layer2.__endIndex) {
        finished = false;
      }
    };
    var this_1 = this;
    for (var k2 = 0; k2 < layerList.length; k2++) {
      _loop_1(k2);
    }
    if (env$1.wxa) {
      each$q(this._layers, function(layer2) {
        if (layer2 && layer2.ctx && layer2.ctx.draw) {
          layer2.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  };
  CanvasPainter2.prototype._doPaintEl = function(el2, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    var ctx = currentLayer.ctx;
    if (useDirtyRect) {
      var paintRect = el2.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush(ctx, el2, scope, isLast);
        el2.setPrevPaintRect(paintRect);
      }
    } else {
      brush(ctx, el2, scope, isLast);
    }
  };
  CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer$1("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge$2(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge$2(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  };
  CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len2 = zlevelList.length;
    var domRoot = this._domRoot;
    var prevLayer = null;
    var i2 = -1;
    if (layersMap[zlevel]) {
      return;
    }
    if (!isLayerValid(layer)) {
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i2 = 0; i2 < len2 - 1; i2++) {
        if (zlevelList[i2] < zlevel && zlevelList[i2 + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i2]];
    }
    zlevelList.splice(i2 + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.__painter = this;
  };
  CanvasPainter2.prototype.eachLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i2 = 0; i2 < zlevelList.length; i2++) {
      var z2 = zlevelList[i2];
      cb.call(context, this._layers[z2], z2);
    }
  };
  CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i2 = 0; i2 < zlevelList.length; i2++) {
      var z2 = zlevelList[i2];
      var layer = this._layers[z2];
      if (layer.__builtin__) {
        cb.call(context, layer, z2);
      }
    }
  };
  CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i2 = 0; i2 < zlevelList.length; i2++) {
      var z2 = zlevelList[i2];
      var layer = this._layers[z2];
      if (!layer.__builtin__) {
        cb.call(context, layer, z2);
      }
    }
  };
  CanvasPainter2.prototype.getLayers = function() {
    return this._layers;
  };
  CanvasPainter2.prototype._updateLayerStatus = function(list) {
    this.eachBuiltinLayer(function(layer2, z2) {
      layer2.__dirty = layer2.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i_1 = 1; i_1 < list.length; i_1++) {
        var el2 = list[i_1];
        if (el2.zlevel !== list[i_1 - 1].zlevel || el2.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    var i2;
    for (i2 = 0; i2 < list.length; i2++) {
      var el2 = list[i2];
      var zlevel = el2.zlevel;
      var layer = void 0;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el2.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i2) {
          layer.__dirty = true;
        }
        layer.__startIndex = i2;
        if (!layer.incremental) {
          layer.__drawIndex = i2;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i2);
        prevLayer = layer;
      }
      if (el2.__dirty & REDRAW_BIT && !el2.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i2;
        }
      }
    }
    updatePrevLayer(i2);
    this.eachBuiltinLayer(function(layer2, z2) {
      if (!layer2.__used && layer2.getElementCount() > 0) {
        layer2.__dirty = true;
        layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
      }
      if (layer2.__dirty && layer2.__drawIndex < 0) {
        layer2.__drawIndex = layer2.__startIndex;
      }
    });
  };
  CanvasPainter2.prototype.clear = function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  };
  CanvasPainter2.prototype._clearLayer = function(layer) {
    layer.clear();
  };
  CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each$q(this._layers, function(layer) {
      layer.setUnpainted();
    });
  };
  CanvasPainter2.prototype.configLayer = function(zlevel, config2) {
    if (config2) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config2;
      } else {
        merge$2(layerConfig[zlevel], config2, true);
      }
      for (var i2 = 0; i2 < this._zlevelList.length; i2++) {
        var _zlevel = this._zlevelList[i2];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          merge$2(layer, layerConfig[zlevel], true);
        }
      }
    }
  };
  CanvasPainter2.prototype.delLayer = function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf$2(zlevelList, zlevel), 1);
  };
  CanvasPainter2.prototype.resize = function(width2, height2) {
    if (!this._domRoot.style) {
      if (width2 == null || height2 == null) {
        return;
      }
      this._width = width2;
      this._height = height2;
      this.getLayer(CANVAS_ZLEVEL).resize(width2, height2);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      var root2 = this.root;
      width2 != null && (opts.width = width2);
      height2 != null && (opts.height = height2);
      width2 = getSize$3(root2, 0, opts);
      height2 = getSize$3(root2, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width2 || height2 !== this._height) {
        domRoot.style.width = width2 + "px";
        domRoot.style.height = height2 + "px";
        for (var id2 in this._layers) {
          if (this._layers.hasOwnProperty(id2)) {
            this._layers[id2].resize(width2, height2);
          }
        }
        this.refresh(true);
      }
      this._width = width2;
      this._height = height2;
    }
    return this;
  };
  CanvasPainter2.prototype.clearLayer = function(zlevel) {
    var layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  };
  CanvasPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  };
  CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer$1("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    var ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width_1 = imageLayer.dom.width;
      var height_1 = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      var scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var displayList = this.storage.getDisplayList(true);
      for (var i2 = 0, len2 = displayList.length; i2 < len2; i2++) {
        var el2 = displayList[i2];
        brush(ctx, el2, scope, i2 === len2 - 1);
      }
    }
    return imageLayer.dom;
  };
  CanvasPainter2.prototype.getWidth = function() {
    return this._width;
  };
  CanvasPainter2.prototype.getHeight = function() {
    return this._height;
  };
  return CanvasPainter2;
}();
var CanvasPainter$1 = CanvasPainter;
function install(registers) {
  registers.registerPainter("canvas", CanvasPainter$1);
}
use$1([
  install$7,
  install$8,
  install$9,
  install$4,
  install$d,
  install$e,
  install$c,
  installLabelLayout,
  installUniversalTransition,
  install,
  install$1
]);
function useBarEcharts(containerDom) {
  const barEchartsInstance = shallowRef$1();
  const state = reactive$1({
    barColors: [
      { startColor: "#ab66fd", endColor: "#f89aff" },
      { startColor: "#61abff", endColor: "#4081ff" },
      { startColor: "#fcee69", endColor: "#eed820" },
      { startColor: "#ffb64f", endColor: "#ffc384" },
      { startColor: "#00d0e5", endColor: "#00e6c1" },
      { startColor: "#e03047", endColor: "#fb6277" }
    ]
  });
  function initBarEchart(config2) {
    barEchartsInstance.value === void 0 && (barEchartsInstance.value = echarts.init(containerDom.value));
    setBarOptions(config2);
  }
  function setBarOptions(config2) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g;
    const legendPositon = (_a2 = config2.legend) == null ? void 0 : _a2.positon;
    const isShowLegend = (_b2 = config2.legend) == null ? void 0 : _b2.show;
    const legendLength = ((_d2 = (_c2 = config2.legend) == null ? void 0 : _c2.data) == null ? void 0 : _d2.length) || 0;
    const xAxisLength = ((_e2 = config2.xAxisNames) == null ? void 0 : _e2.length) || 0;
    const isStack = config2.isStack;
    const barWidth = 24;
    const barGap = 0.5;
    const viewWidth = Math.max((((_f2 = barEchartsInstance.value) == null ? void 0 : _f2.getWidth()) || 0) - 10 - 50, 0);
    const oneProjectWidth = isStack ? barWidth : legendLength * barWidth + Math.max(legendLength - 1, 0) * barWidth * barGap;
    const isOverflow = oneProjectWidth * xAxisLength > viewWidth;
    const isShowZoom = isOverflow || config2.isShowZoom;
    const _end = getDataZoomEnd(barWidth, barWidth * barGap, legendLength, xAxisLength, viewWidth, isStack);
    const series = (((_g = config2.legend) == null ? void 0 : _g.data) || []).map((item, index) => {
      const color2 = typeof item.color === "string" ? item.color : new echarts.graphic.LinearGradient(
        0,
        0,
        0,
        1,
        item.color ? item.color : [
          { offset: 0, color: state.barColors[index % 6].startColor },
          { offset: 1, color: state.barColors[index % 6].endColor }
        ]
      );
      const obj = {
        type: "bar",
        name: item.name,
        data: config2.data && config2.data[index] || [],
        stack: config2.isStack ? "total" : void 0,
        barWidth: "24px",
        barGap: "50%",
        itemStyle: {
          borderRadius: config2.hasBarRadius ? [40, 40, 0, 0] : [0, 0, 0, 0],
          color: color2
        }
      };
      return obj;
    });
    const option = {
      grid: {
        left: 0,
        right: 10,
        bottom: isShowLegend && legendPositon === "bottomCenter" ? isShowZoom ? 63 : 33 : isShowZoom ? 33 : 10,
        top: isShowLegend && legendPositon !== "bottomCenter" ? 55 : 20,
        containLabel: true
      },
      legend: {
        itemHeight: 8,
        itemWidth: 8,
        icon: "circle",
        textStyle: {
          fontFamily: "PingFangSC-Regular",
          color: "rgba(0, 0, 0, 0.45)"
        },
        show: isShowLegend,
        top: legendPositon === "bottomCenter" ? void 0 : "0",
        bottom: legendPositon === "bottomCenter" ? isShowZoom ? "30" : "0" : void 0,
        left: legendPositon === "topLeft" ? "0" : legendPositon === "topRight" ? void 0 : "center",
        right: legendPositon === "topRight" ? "10" : void 0
      },
      tooltip: {
        backgroundColor: "rgba(0, 0, 0, 0.6)",
        borderColor: "rgba(0, 0, 0, 0.6)",
        textStyle: {
          color: "#fff",
          fontSize: 12,
          fontWeight: "normal"
        }
      },
      xAxis: {
        type: "category",
        data: config2.xAxisNames,
        axisTick: {
          show: false
        },
        axisLabel: {
          margin: 9,
          lineHeight: 17,
          color: "rgba(0, 0, 0, 0.45)",
          fontFamily: "PingFangSC-Regular",
          interval: 0,
          formatter: function(name2) {
            const legendWith = legendLength * barWidth;
            const gapWith = Math.max(legendLength - 1, 0) * (barWidth * barGap);
            const _maxWidth = legendWith + gapWith - barWidth;
            const oneLineLength = Math.max(Math.floor(_maxWidth / 12), 3);
            if (name2 && name2.length > oneLineLength * 2) {
              return `${name2.substring(0, oneLineLength)}
${name2.substring(oneLineLength, oneLineLength * 2 - 1)}...`;
            } else if (name2.length > oneLineLength && name2.length <= oneLineLength * 2) {
              return `${name2.substring(0, oneLineLength)}
${name2.substring(oneLineLength, oneLineLength * 2)}`;
            } else {
              return name2;
            }
          }
        }
      },
      yAxis: {
        axisLabel: {
          color: "rgba(0, 0, 0, 0.45)",
          fontFamily: "PingFangSC-Regular",
          width: 50,
          overflow: "truncate"
        }
      },
      series,
      dataZoom: [
        {
          type: "inside",
          orient: "horizontal",
          zoomOnMouseWheel: false,
          moveOnMouseWheel: false,
          moveOnMouseMove: false,
          preventDefaultMouseMove: true,
          start: 0,
          endValue: _end,
          filterMode: "filter",
          rangeMode: ["value", "value"]
        },
        {
          type: "slider",
          show: isShowZoom,
          height: 18,
          showDataShadow: false,
          zoomLock: false,
          fillerColor: "#dae2f4",
          borderColor: "#dae2f4",
          handleIcon: "path://M571.076923 39.384615h-118.153846A137.846154 137.846154 0 0 0 315.076923 177.230769v669.538462A137.846154 137.846154 0 0 0 452.923077 984.615385h118.153846a137.846154 137.846154 0 0 0 137.846154-137.846154v-669.538462A137.846154 137.846154 0 0 0 571.076923 39.384615zM472.615385 728.615385a19.692308 19.692308 0 0 1-39.384616 0v-433.23077a19.692308 19.692308 0 0 1 39.384616 0z m118.153846 0a19.692308 19.692308 0 0 1-39.384616 0v-433.23077a19.692308 19.692308 0 0 1 39.384616 0z",
          brushSelect: false,
          bottom: 0
        }
      ]
    };
    barEchartsInstance.value && barEchartsInstance.value.setOption(option, true);
  }
  function getDataZoomEnd(barWidth, barGap, barNum, dataLength, viewWidth, isStack = false) {
    const oneProjectWidth = isStack ? barWidth + barGap : barWidth * barNum + barGap * (barNum - 1);
    if (oneProjectWidth * dataLength < viewWidth) {
      return dataLength - 1;
    } else {
      const maxProjectLength = Math.floor(viewWidth / oneProjectWidth);
      return Math.max(0, maxProjectLength - 1);
    }
  }
  return {
    initBarEchart,
    barEchartsInstance,
    setBarOptions
  };
}
function useLineEcharts(containerDom) {
  const lineEchartsInstance = shallowRef$1();
  const state = reactive$1({
    lineColors: ["#5b8ff9", "#5ad8a6", "#e8684a", "#6094ff", "#a17bf4", "#f6ae4f"]
  });
  function initLineEchart(config2) {
    lineEchartsInstance.value === void 0 && (lineEchartsInstance.value = echarts.init(containerDom.value));
    setLineOptions(config2);
  }
  function setLineOptions(config2) {
    var _a2, _b2, _c2, _d2, _e2;
    const legendPositon = (_a2 = config2.legend) == null ? void 0 : _a2.positon;
    const isShowLegend = (_b2 = config2.legend) == null ? void 0 : _b2.show;
    const xAxisLength = ((_c2 = config2.xAxisNames) == null ? void 0 : _c2.length) || 0;
    const viewWidth = Math.max((((_d2 = lineEchartsInstance.value) == null ? void 0 : _d2.getWidth()) || 0) - 10 - 50, 0);
    const isOverflow = 12 * 5 * xAxisLength > viewWidth;
    const isShowZoom = isOverflow || config2.isShowZoom;
    const _end = getDataZoomEnd(5, 12, xAxisLength, viewWidth);
    const series = (((_e2 = config2.legend) == null ? void 0 : _e2.data) || []).map((item, index) => {
      const color2 = typeof item.color === "object" ? new echarts.graphic.LinearGradient(
        0,
        0,
        0,
        1,
        item.color
      ) : item.color || state.lineColors[index % 6];
      const areaColor = typeof item.color === "object" ? item.color[0].color : item.color || state.lineColors[index % 6];
      const obj = {
        type: "line",
        name: item.name,
        data: config2.data && config2.data[index] || [],
        smooth: config2.isSmooth,
        lineStyle: {
          color: color2
        },
        itemStyle: {
          color: color2
        },
        areaStyle: config2.isShowArea ? {
          opacity: 0.25,
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{ offset: 0, color: areaColor }, { offset: 1, color: "#fff" }])
        } : void 0
      };
      return obj;
    });
    const option = {
      grid: {
        left: 0,
        right: 10,
        bottom: isShowLegend && legendPositon === "bottomCenter" ? isShowZoom ? 63 : 33 : isShowZoom ? 33 : 10,
        top: isShowLegend && legendPositon !== "bottomCenter" ? 55 : 20,
        containLabel: true
      },
      legend: {
        itemHeight: 8,
        itemWidth: 8,
        icon: "circle",
        textStyle: {
          fontFamily: "PingFangSC-Regular",
          color: "rgba(0, 0, 0, 0.45)"
        },
        show: isShowLegend,
        top: legendPositon === "bottomCenter" ? void 0 : "0",
        bottom: legendPositon === "bottomCenter" ? isShowZoom ? "30" : "0" : void 0,
        left: legendPositon === "topLeft" ? "0" : legendPositon === "topRight" ? void 0 : "center",
        right: legendPositon === "topRight" ? "10" : void 0
      },
      tooltip: {
        trigger: "axis",
        backgroundColor: "rgba(0, 0, 0, 0.6)",
        borderColor: "rgba(0, 0, 0, 0.6)",
        textStyle: {
          color: "#fff",
          fontSize: 12,
          fontWeight: "normal"
        }
      },
      xAxis: {
        type: "category",
        data: config2.xAxisNames,
        axisTick: {
          alignWithLabel: true
        },
        axisLabel: {
          margin: 9,
          lineHeight: 17,
          color: "rgba(0, 0, 0, 0.45)",
          fontFamily: "PingFangSC-Regular",
          interval: 0,
          formatter: function(name2) {
            if (name2 && name2.length > 10) {
              return `${name2.substring(0, 5)}
${name2.substring(5, 9)}...`;
            } else if (name2.length > 5 && name2.length <= 10) {
              return `${name2.substring(0, 5)}
${name2.substring(5, 10)}`;
            } else {
              return name2;
            }
          }
        }
      },
      yAxis: {
        axisLabel: {
          color: "rgba(0, 0, 0, 0.45)",
          fontFamily: "PingFangSC-Regular",
          width: 50,
          overflow: "truncate"
        }
      },
      series,
      dataZoom: [
        {
          type: "inside",
          orient: "horizontal",
          zoomOnMouseWheel: false,
          moveOnMouseWheel: false,
          moveOnMouseMove: false,
          preventDefaultMouseMove: true,
          start: 0,
          endValue: _end,
          filterMode: "filter",
          rangeMode: ["value", "value"]
        },
        {
          type: "slider",
          show: isShowZoom,
          height: 18,
          showDataShadow: false,
          zoomLock: false,
          fillerColor: "#dae2f4",
          borderColor: "#dae2f4",
          handleIcon: "path://M571.076923 39.384615h-118.153846A137.846154 137.846154 0 0 0 315.076923 177.230769v669.538462A137.846154 137.846154 0 0 0 452.923077 984.615385h118.153846a137.846154 137.846154 0 0 0 137.846154-137.846154v-669.538462A137.846154 137.846154 0 0 0 571.076923 39.384615zM472.615385 728.615385a19.692308 19.692308 0 0 1-39.384616 0v-433.23077a19.692308 19.692308 0 0 1 39.384616 0z m118.153846 0a19.692308 19.692308 0 0 1-39.384616 0v-433.23077a19.692308 19.692308 0 0 1 39.384616 0z",
          brushSelect: false,
          bottom: 0
        }
      ]
    };
    lineEchartsInstance.value && lineEchartsInstance.value.setOption(option, true);
  }
  function getDataZoomEnd(oneLineWords, fontSize, dataLength, viewWidth) {
    const oneProjectWidth = oneLineWords * fontSize;
    if (oneProjectWidth * dataLength < viewWidth) {
      return dataLength - 1;
    } else {
      const maxProjectLength = Math.floor(viewWidth / oneProjectWidth);
      return Math.max(0, maxProjectLength - 1);
    }
  }
  return {
    initLineEchart,
    lineEchartsInstance,
    setLineOptions
  };
}
function usePieEcharts(containerDom) {
  const pieEchartsInstance = shallowRef$1();
  const state = reactive$1({
    pieColors: ["rgba(91, 143, 249, 0.85)", "rgba(90, 216, 166, 0.85)", "#febe55", "#86c36e"]
  });
  function initPieEchart(config2) {
    pieEchartsInstance.value === void 0 && (pieEchartsInstance.value = echarts.init(containerDom.value));
    setPieOptions(config2);
    onChartMouseEvents();
  }
  function setSeries(charName, config2) {
    return {
      zlevel: charName === "upperChart" ? 1 : 0,
      name: charName,
      type: "pie",
      radius: ["40%", "70%"],
      label: {
        show: false,
        position: charName === "upperChart" ? "outside" : "center",
        color: "#303133",
        fontFamily: "MicrosoftYaHei",
        formatter(str) {
          return charName === "upperChart" ? str.percent + "%" : str.name.length > 7 ? str.name.slice(0, 7) + "..." : str.name;
        }
      },
      labelLine: {
        show: true
      },
      itemStyle: {
        borderRadius: config2.isHasGap ? 10 : 0,
        borderColor: "#fff",
        borderWidth: config2.isHasGap ? 4 : 0
      },
      emphasis: {
        label: {
          show: true,
          fontWeight: charName === "upperChart" ? "normal" : "bold",
          fontSize: charName === "upperChart" ? 12 : 18
        },
        labelLine: {
          show: true,
          lineStyle: {
            color: "#4382ff"
          }
        }
      },
      data: (config2.data || []).map((item, index) => {
        return Array.isArray(item) ? item : {
          name: item.name,
          value: item.value,
          itemStyle: {
            color: typeof item.color === "object" ? new echarts.graphic.LinearGradient(
              0,
              0,
              0,
              1,
              item.color
            ) : item.color || state.pieColors[index % 4]
          }
        };
      })
    };
  }
  function setPieOptions(config2) {
    var _a2;
    const isShowLegend = (_a2 = config2.legend) == null ? void 0 : _a2.show;
    const option = {
      grid: {
        left: 0,
        right: 10,
        bottom: 10,
        top: 20,
        containLabel: true
      },
      legend: {
        itemHeight: 8,
        itemWidth: 8,
        icon: "circle",
        textStyle: {
          fontFamily: "PingFangSC-Regular",
          color: "rgba(0, 0, 0, 0.45)"
        },
        show: isShowLegend,
        left: 0,
        top: "middle",
        orient: "vertical"
      },
      series: [
        setSeries("upperChart", config2),
        setSeries("lowerChart", config2)
      ]
    };
    pieEchartsInstance.value && pieEchartsInstance.value.setOption(option);
  }
  function onChartMouseEvents() {
    var _a2, _b2;
    (_a2 = pieEchartsInstance.value) == null ? void 0 : _a2.on("mouseover", { seriesName: "upperChart" }, (params) => {
      var _a3;
      (_a3 = pieEchartsInstance.value) == null ? void 0 : _a3.dispatchAction({
        type: "highlight",
        seriesName: "lowerChart",
        name: params.name
      });
    });
    (_b2 = pieEchartsInstance.value) == null ? void 0 : _b2.on("mouseout", { seriesName: "upperChart" }, () => {
      var _a3;
      (_a3 = pieEchartsInstance.value) == null ? void 0 : _a3.dispatchAction({
        type: "downplay",
        seriesName: "lowerChart"
      });
    });
  }
  return {
    initPieEchart,
    pieEchartsInstance
  };
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE2 = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag2 = "[object Arguments]", arrayTag = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart2 = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar2 = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange2 = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange2 + reComboHalfMarksRange + rsComboSymbolsRange2, rsDingbatRange2 = "\\u2700-\\u27bf", rsLowerRange2 = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange2 = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange2 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange2 = "\\u2000-\\u206f", rsSpaceRange2 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange2 = "\\ufe0e\\ufe0f", rsBreakRange2 = rsMathOpRange2 + rsNonCharRange2 + rsPunctuationRange2 + rsSpaceRange2;
    var rsApos2 = "['\u2019]", rsAstral2 = "[" + rsAstralRange2 + "]", rsBreak2 = "[" + rsBreakRange2 + "]", rsCombo2 = "[" + rsComboRange + "]", rsDigits2 = "\\d+", rsDingbat2 = "[" + rsDingbatRange2 + "]", rsLower2 = "[" + rsLowerRange2 + "]", rsMisc2 = "[^" + rsAstralRange2 + rsBreakRange2 + rsDigits2 + rsDingbatRange2 + rsLowerRange2 + rsUpperRange2 + "]", rsFitz2 = "\\ud83c[\\udffb-\\udfff]", rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")", rsNonAstral2 = "[^" + rsAstralRange2 + "]", rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper2 = "[" + rsUpperRange2 + "]", rsZWJ2 = "\\u200d";
    var rsMiscLower = "(?:" + rsLower2 + "|" + rsMisc2 + ")", rsMiscUpper = "(?:" + rsUpper2 + "|" + rsMisc2 + ")", rsOptContrLower = "(?:" + rsApos2 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos2 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod2 = rsModifier2 + "?", rsOptVar2 = "[" + rsVarRange2 + "]?", rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2, rsEmoji2 = "(?:" + [rsDingbat2, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2, rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
    var reApos2 = RegExp(rsApos2, "g");
    var reComboMark2 = RegExp(rsCombo2, "g");
    var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
    var reUnicodeWord2 = RegExp([
      rsUpper2 + "?" + rsLower2 + "+" + rsOptContrLower + "(?=" + [rsBreak2, rsUpper2, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak2, rsUpper2 + rsMiscLower, "$"].join("|") + ")",
      rsUpper2 + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper2 + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits2,
      rsEmoji2
    ].join("|"), "g");
    var reHasUnicode2 = RegExp("[" + rsZWJ2 + rsAstralRange2 + rsComboRange + rsVarRange2 + "]");
    var reHasUnicodeWord2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag2] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag2] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag2] = typedArrayTags[stringTag2] = typedArrayTags[weakMapTag2] = false;
    var cloneableTags = {};
    cloneableTags[argsTag2] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag2] = cloneableTags[numberTag] = cloneableTags[objectTag2] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
    var deburredLetters2 = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array2, setter, iteratee, accumulator) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        var value = array2[index];
        setter(accumulator, value, iteratee(value), array2);
      }
      return accumulator;
    }
    function arrayEach2(array2, iteratee) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (iteratee(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEachRight(array2, iteratee) {
      var length2 = array2 == null ? 0 : array2.length;
      while (length2--) {
        if (iteratee(array2[length2], length2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function arrayEvery(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (!predicate(array2[index], index, array2)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter2(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array2, value) {
      var length2 = array2 == null ? 0 : array2.length;
      return !!length2 && baseIndexOf(array2, value, 0) > -1;
    }
    function arrayIncludesWith(array2, value, comparator) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (comparator(value, array2[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap2(array2, iteratee) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index < length2) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    function arrayPush(array2, values2) {
      var index = -1, length2 = values2.length, offset2 = array2.length;
      while (++index < length2) {
        array2[offset2 + index] = values2[index];
      }
      return array2;
    }
    function arrayReduce2(array2, iteratee, accumulator, initAccum) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      if (initAccum && length2) {
        accumulator = array2[++index];
      }
      while (++index < length2) {
        accumulator = iteratee(accumulator, array2[index], index, array2);
      }
      return accumulator;
    }
    function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
      var length2 = array2 == null ? 0 : array2.length;
      if (initAccum && length2) {
        accumulator = array2[--length2];
      }
      while (length2--) {
        accumulator = iteratee(accumulator, array2[length2], length2, array2);
      }
      return accumulator;
    }
    function arraySome(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray2(string) {
      return string.split("");
    }
    function asciiWords2(string) {
      return string.match(reAsciiWord2) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length2 = array2.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length2) {
        if (predicate(array2[index], index, array2)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index = fromIndex - 1, length2 = array2.length;
      while (++index < length2) {
        if (comparator(array2[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array2, iteratee) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? baseSum(array2, iteratee) / length2 : NAN2;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf2(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array2, comparer) {
      var length2 = array2.length;
      array2.sort(comparer);
      while (length2--) {
        array2[length2] = array2[length2].value;
      }
      return array2;
    }
    function baseSum(array2, iteratee) {
      var result, index = -1, length2 = array2.length;
      while (++index < length2) {
        var current = iteratee(array2[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes2(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap2(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim2(string) {
      return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues2(object, props) {
      return arrayMap2(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length2 = strSymbols.length;
      while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array2, placeholder) {
      var length2 = array2.length, result = 0;
      while (length2--) {
        if (array2[length2] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter2 = basePropertyOf2(deburredLetters2);
    var escapeHtmlChar = basePropertyOf2(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode2(string) {
      return reHasUnicode2.test(string);
    }
    function hasUnicodeWord2(string) {
      return reHasUnicodeWord2.test(string);
    }
    function iteratorToArray2(iterator2) {
      var data5, result = [];
      while (!(data5 = iterator2.next()).done) {
        result.push(data5.value);
      }
      return result;
    }
    function mapToArray2(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array2, placeholder) {
      var index = -1, length2 = array2.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array2[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray2(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array2, value, fromIndex) {
      var index = fromIndex - 1, length2 = array2.length;
      while (++index < length2) {
        if (array2[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array2, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array2[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode2(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray2(string) {
      return hasUnicode2(string) ? unicodeToArray2(string) : asciiToArray2(string);
    }
    function trimmedEndIndex2(string) {
      var index = string.length;
      while (index-- && reWhitespace2.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf2(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode2.lastIndex = 0;
      while (reUnicode2.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray2(string) {
      return string.match(reUnicode2) || [];
    }
    function unicodeWords2(string) {
      return string.match(reUnicodeWord2) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function3 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function3.prototype, objectProto2 = Object2.prototype;
      var coreJsData2 = context["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString = funcToString2.call(Object2);
      var oldDash = root2._;
      var reIsNative2 = RegExp2(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg2(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto2) {
          if (!isObject2(proto2)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto2);
          }
          object.prototype = proto2;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray2(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray2(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray2(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array2 = this.__wrapped__.value(), dir3 = this.__dir__, isArr = isArray2(array2), isRight = dir3 < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length2 = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length2, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
          return baseWrapperValue(array2, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length2-- && resIndex < takeCount) {
            index += dir3;
            var iterIndex = -1, value = array2[index];
            while (++iterIndex < iterLength) {
              var data5 = iteratees[iterIndex], iteratee2 = data5.iteratee, type2 = data5.type, computed2 = iteratee2(value);
              if (type2 == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type2 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries2) {
        var index = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length2) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet2(key) {
        var data5 = this.__data__;
        if (nativeCreate2) {
          var result2 = data5[key];
          return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data5, key) ? data5[key] : undefined$1;
      }
      function hashHas2(key) {
        var data5 = this.__data__;
        return nativeCreate2 ? data5[key] !== undefined$1 : hasOwnProperty2.call(data5, key);
      }
      function hashSet2(key, value) {
        var data5 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data5[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries2) {
        var index = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length2) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key) {
        var data5 = this.__data__, index = assocIndexOf2(data5, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data5.length - 1;
        if (index == lastIndex) {
          data5.pop();
        } else {
          splice2.call(data5, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data5 = this.__data__, index = assocIndexOf2(data5, key);
        return index < 0 ? undefined$1 : data5[index][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data5 = this.__data__, index = assocIndexOf2(data5, key);
        if (index < 0) {
          ++this.size;
          data5.push([key, value]);
        } else {
          data5[index][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries2) {
        var index = -1, length2 = entries2 == null ? 0 : entries2.length;
        this.clear();
        while (++index < length2) {
          var entry = entries2[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        var result2 = getMapData2(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        var data5 = getMapData2(this, key), size2 = data5.size;
        data5.set(key, value);
        this.size += data5.size == size2 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache(values3) {
        var index = -1, length2 = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache2();
        while (++index < length2) {
          this.add(values3[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries2) {
        var data5 = this.__data__ = new ListCache2(entries2);
        this.size = data5.size;
      }
      function stackClear() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete(key) {
        var data5 = this.__data__, result2 = data5["delete"](key);
        this.size = data5.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data5 = this.__data__;
        if (data5 instanceof ListCache2) {
          var pairs = data5.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data5.size;
            return this;
          }
          data5 = this.__data__ = new MapCache2(pairs);
        }
        data5.set(key, value);
        this.size = data5.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length2 = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length2)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array2) {
        var length2 = array2.length;
        return length2 ? array2[baseRandom(0, length2 - 1)] : undefined$1;
      }
      function arraySampleSize(array2, n2) {
        return shuffleSelf(copyArray2(array2), baseClamp(n2, 0, array2.length));
      }
      function arrayShuffle(array2) {
        return shuffleSelf(copyArray2(array2));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf2(array2, key) {
        var length2 = array2.length;
        while (length2--) {
          if (eq2(array2[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach2(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
        while (++index < length2) {
          result2[index] = skip ? undefined$1 : get3(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number2, lower2, upper2) {
        if (number2 === number2) {
          if (upper2 !== undefined$1) {
            number2 = number2 <= upper2 ? number2 : upper2;
          }
          if (lower2 !== undefined$1) {
            number2 = number2 >= lower2 ? number2 : lower2;
          }
        }
        return number2;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray2(value, result2);
          }
        } else {
          var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach2(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length2 = props.length;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (length2--) {
          var key = props[length2], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array2, values3, iteratee2, comparator) {
        var index = -1, includes3 = arrayIncludes, isCommon = true, length2 = array2.length, result2 = [], valuesLength = values3.length;
        if (!length2) {
          return result2;
        }
        if (iteratee2) {
          values3 = arrayMap2(values3, baseUnary(iteratee2));
        }
        if (comparator) {
          includes3 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes3 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index < length2) {
            var value = array2[index], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values3, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach2 = createBaseEach2(baseForOwn2);
      var baseEachRight = createBaseEach2(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach2(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array2, iteratee2, comparator) {
        var index = -1, length2 = array2.length;
        while (++index < length2) {
          var value = array2[index], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array2, value, start2, end2) {
        var length2 = array2.length;
        start2 = toInteger2(start2);
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 === undefined$1 || end2 > length2 ? length2 : toInteger2(end2);
        if (end2 < 0) {
          end2 += length2;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array2[start2++] = value;
        }
        return array2;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach2(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array2, depth, predicate, isStrict, result2) {
        var index = -1, length2 = array2.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length2) {
          var value = array2[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor2 = createBaseFor2();
      var baseForRight = createBaseFor2(true);
      function baseForOwn2(object, iteratee2) {
        return object && baseFor2(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter2(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet2(object, path) {
        path = castPath2(path, object);
        var index = 0, length2 = path.length;
        while (object != null && index < length2) {
          object = object[toKey2(path[index++])];
        }
        return index && index == length2 ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number2, start2, end2) {
        return number2 >= nativeMin2(start2, end2) && number2 < nativeMax2(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array2 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array2 = arrayMap2(array2, baseUnary(iteratee2));
          }
          maxLength = nativeMin2(array2.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
        }
        array2 = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length2 && result2.length < maxLength) {
            var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes3(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes3(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn2(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath2(path, object);
        object = parent2(object, path);
        var func = object == null ? object : object[toKey2(last2(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag2(value) == mapTag2;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length2 = index, noCustomizer = !customizer;
        if (object == null) {
          return !length2;
        }
        object = Object2(object);
        while (index--) {
          var data5 = matchData[index];
          if (noCustomizer && data5[2] ? data5[1] !== object[data5[0]] : !(data5[0] in object)) {
            return false;
          }
        }
        while (++index < length2) {
          data5 = matchData[index];
          var key = data5[0], objValue = object[key], srcValue = data5[1];
          if (noCustomizer && data5[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag2(value) == setTag2;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property2(value);
      }
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype2(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey2(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey2(path), srcValue);
        }
        return function(object) {
          var objValue = get3(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor2(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject2(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array2, n2) {
        var length2 = array2.length;
        if (!length2) {
          return;
        }
        n2 += n2 < 0 ? length2 : 0;
        return isIndex2(n2, length2) ? array2[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap2(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index = -1;
        iteratees = arrayMap2(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap2(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length2 = paths.length, result2 = {};
        while (++index < length2) {
          var path = paths[index], value = baseGet2(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath2(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet2(object, path);
        };
      }
      function basePullAll(array2, values3, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values3.length, seen = array2;
        if (array2 === values3) {
          values3 = copyArray2(values3);
        }
        if (iteratee2) {
          seen = arrayMap2(array2, baseUnary(iteratee2));
        }
        while (++index < length2) {
          var fromIndex = 0, value = values3[index], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array2) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array2, fromIndex, 1);
          }
        }
        return array2;
      }
      function basePullAt(array2, indexes) {
        var length2 = array2 ? indexes.length : 0, lastIndex = length2 - 1;
        while (length2--) {
          var index = indexes[length2];
          if (length2 == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex2(index)) {
              splice2.call(array2, index, 1);
            } else {
              baseUnset(array2, index);
            }
          }
        }
        return array2;
      }
      function baseRandom(lower2, upper2) {
        return lower2 + nativeFloor(nativeRandom() * (upper2 - lower2 + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index = -1, length2 = nativeMax2(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length2);
        while (length2--) {
          result2[fromRight ? length2 : ++index] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n2) {
        var array2 = values2(collection);
        return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath2(path, object);
        var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
        while (nested != null && ++index < length2) {
          var key = toKey2(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data5) {
        metaMap.set(func, data5);
        return func;
      };
      var baseSetToString = !defineProperty ? identity2 : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice2(array2, start2, end2) {
        var index = -1, length2 = array2.length;
        if (start2 < 0) {
          start2 = -start2 > length2 ? 0 : length2 + start2;
        }
        end2 = end2 > length2 ? length2 : end2;
        if (end2 < 0) {
          end2 += length2;
        }
        length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length2);
        while (++index < length2) {
          result2[index] = array2[index + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach2(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array2, value, retHighest) {
        var low = 0, high = array2 == null ? low : array2.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array2[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array2, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
        var low = 0, high = array2 == null ? 0 : array2.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array2[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin2(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array2, iteratee2) {
        var index = -1, length2 = array2.length, resIndex = 0, result2 = [];
        while (++index < length2) {
          var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq2(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString2(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap2(value, baseToString2) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function baseUniq(array2, iteratee2, comparator) {
        var index = -1, includes3 = arrayIncludes, length2 = array2.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes3 = arrayIncludesWith;
        } else if (length2 >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array2);
          if (set3) {
            return setToArray2(set3);
          }
          isCommon = false;
          includes3 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length2) {
            var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes3(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath2(path, object);
        object = parent2(object, path);
        return object == null || delete object[toKey2(last2(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet2(object, path)), customizer);
      }
      function baseWhile(array2, predicate, isDrop, fromRight) {
        var length2 = array2.length, index = fromRight ? length2 : -1;
        while ((fromRight ? index-- : ++index < length2) && predicate(array2[index], index, array2)) {
        }
        return isDrop ? baseSlice2(array2, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice2(array2, fromRight ? index + 1 : 0, fromRight ? length2 : index);
      }
      function baseWrapperValue(value, actions2) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce2(actions2, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length2 = arrays.length;
        if (length2 < 2) {
          return length2 ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length2);
        while (++index < length2) {
          var array2 = arrays[index], othIndex = -1;
          while (++othIndex < length2) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index = -1, length2 = props.length, valsLength = values3.length, result2 = {};
        while (++index < length2) {
          var value = index < valsLength ? values3[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject2(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath2(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
      }
      var castRest = baseRest;
      function castSlice2(array2, start2, end2) {
        var length2 = array2.length;
        end2 = end2 === undefined$1 ? length2 : end2;
        return !start2 && end2 >= length2 ? array2 : baseSlice2(array2, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id2) {
        return root2.clearTimeout(id2);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp2) {
        var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        result2.lastIndex = regexp2.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
        while (++index < length2) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray2(source, array2) {
        var index = -1, length2 = source.length;
        array2 || (array2 = Array2(length2));
        while (++index < length2) {
          array2[index] = source[index];
        }
        return array2;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length2 = props.length;
        while (++index < length2) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length2 < 3 ? undefined$1 : customizer;
            length2 = 1;
          }
          object = Object2(object);
          while (++index < length2) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach2(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length2) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
          while (length2--) {
            var key = props[fromRight ? length2 : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst2(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode2(string) ? stringToArray2(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice2(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder2(callback) {
        return function(string) {
          return arrayReduce2(words2(deburr2(string).replace(reApos2, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length2 -= holders.length;
          if (length2 < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length2
            );
          }
          var fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length2;
          while (++index < length2) {
            func = funcs[index];
            var funcName = getFuncName(func), data5 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data5 && isLaziable(data5[0]) && data5[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data5[4].length && data5[9] == 1) {
              wrapper = wrapper[getFuncName(data5[0])].apply(wrapper, data5[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
            while (++index2 < length2) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length2 = arguments.length, args = Array2(length2), index = length2;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length2 -= holdersCount;
          if (isCurried && length2 < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length2
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length2 = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length2 > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length2) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString2(value);
              other = baseToString2(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap2(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length2, chars) {
        chars = chars === undefined$1 ? " " : baseToString2(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length2) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
        return hasUnicode2(chars) ? castSlice2(stringToArray2(result2), 0, length2).join("") : result2.slice(0, length2);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number2, precision) {
          number2 = toNumber2(number2);
          precision = precision == null ? 0 : nativeMin2(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number2)) {
            var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number2);
        };
      }
      var createSet = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values3) {
        return new Set2(values3);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag2(object);
          if (tag == mapTag2) {
            return mapToArray2(object);
          }
          if (tag == setTag2) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length2 = partials ? partials.length : 0;
        if (!length2) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger2(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger2(arity);
        length2 -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data5 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data5) {
          mergeData(newData, data5);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length2, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data5 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag2:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag2:
            return object == other + "";
          case mapTag2:
            var convert = mapToArray2;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag2:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten2), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array2 = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array2.length : 0;
        while (length2--) {
          var data5 = array2[length2], otherFunc = data5.func;
          if (otherFunc == null || otherFunc == func) {
            return data5.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData2(map3, key) {
        var data5 = map3.__data__;
        return isKeyable2(key) ? data5[typeof key == "string" ? "string" : "hash"] : data5.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length2 = result2.length;
        while (length2--) {
          var key = result2[length2], value = object[key];
          result2[length2] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e3) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter2(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable2.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms) {
        var index = -1, length2 = transforms.length;
        while (++index < length2) {
          var data5 = transforms[index], size2 = data5.size;
          switch (data5.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin2(end2, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax2(start2, end2 - size2);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath2(path, object);
        var index = -1, length2 = path.length, result2 = false;
        while (++index < length2) {
          var key = toKey2(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length2) {
          return result2;
        }
        length2 = object == null ? 0 : object.length;
        return !!length2 && isLength2(length2) && isIndex2(key, length2) && (isArray2(object) || isArguments2(object));
      }
      function initCloneArray(array2) {
        var length2 = array2.length, result2 = new array2.constructor(length2);
        if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
          result2.index = array2.index;
          result2.input = array2.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag2:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag:
          case stringTag2:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag2:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length2 = details.length;
        if (!length2) {
          return source;
        }
        var lastIndex = length2 - 1;
        details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length2 > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex2(value, length2) {
        var type2 = typeof value;
        length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
        return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type2 = typeof index;
        if (type2 == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type2 == "string" && index in object) {
          return eq2(object[index], value);
        }
        return false;
      }
      function isKey2(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type2 = typeof value;
        if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
      }
      function isKeyable2(value) {
        var type2 = typeof value;
        return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data5 = getData(other);
        return !!data5 && func === data5[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction2 : stubFalse;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto2;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped2(func) {
        var result2 = memoize2(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE2) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data5, source) {
        var bitmask = data5[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data5[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data5;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data5[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data5[3];
          data5[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data5[4] = partials ? replaceHolders(data5[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data5[5];
          data5[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data5[6] = partials ? replaceHolders(data5[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data5[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data5[8] = data5[8] == null ? source[8] : nativeMin2(data5[8], source[8]);
        }
        if (data5[9] == null) {
          data5[9] = source[9];
        }
        data5[0] = source[0];
        data5[1] = newBitmask;
        return data5;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest(func, start2, transform2) {
        start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length2 = nativeMax2(args.length - start2, 0), array2 = Array2(length2);
          while (++index < length2) {
            array2[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform2(array2);
          return apply(func, this, otherArgs);
        };
      }
      function parent2(object, path) {
        return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));
      }
      function reorder(array2, indexes) {
        var arrLength = array2.length, length2 = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array2);
        while (length2--) {
          var index = indexes[length2];
          array2[length2] = isIndex2(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array2;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array2, size2) {
        var index = -1, length2 = array2.length, lastIndex = length2 - 1;
        size2 = size2 === undefined$1 ? length2 : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array2[rand];
          array2[rand] = array2[index];
          array2[index] = value;
        }
        array2.length = size2;
        return array2;
      }
      var stringToPath2 = memoizeCapped2(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName2, function(match, number2, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number2 || match);
        });
        return result2;
      });
      function toKey2(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY2 ? "-0" : result2;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach2(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray2(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk2(array2, size2, guard) {
        if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax2(toInteger2(size2), 0);
        }
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2 || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
        while (index < length2) {
          result2[resIndex++] = baseSlice2(array2, index, index += size2);
        }
        return result2;
      }
      function compact(array2) {
        var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
        while (++index < length2) {
          var value = array2[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length2 = arguments.length;
        if (!length2) {
          return [];
        }
        var args = Array2(length2 - 1), array2 = arguments[0], index = length2;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array2) ? copyArray2(array2) : [array2], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array2, values3) {
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject2, true)) : [];
      });
      var differenceBy = baseRest(function(array2, values3) {
        var iteratee2 = last2(values3);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array2, values3) {
        var comparator = last2(values3);
        if (isArrayLikeObject2(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject2(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
      });
      function drop(array2, n2, guard) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice2(array2, n2 < 0 ? 0 : n2, length2);
      }
      function dropRight(array2, n2, guard) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length2 - n2;
        return baseSlice2(array2, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
      }
      function fill(array2, value, start2, end2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
          start2 = 0;
          end2 = length2;
        }
        return baseFill(array2, value, start2, end2);
      }
      function findIndex(array2, predicate, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax2(length2 + index, 0);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array2, predicate, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index = length2 - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger2(fromIndex);
          index = fromIndex < 0 ? nativeMax2(length2 + index, 0) : nativeMin2(index, length2 - 1);
        }
        return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
      }
      function flatten2(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseFlatten(array2, 1) : [];
      }
      function flattenDeep2(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseFlatten(array2, INFINITY2) : [];
      }
      function flattenDepth(array2, depth) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(array2, depth);
      }
      function fromPairs2(pairs) {
        var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length2) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array2) {
        return array2 && array2.length ? array2[0] : undefined$1;
      }
      function indexOf2(array2, value, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index < 0) {
          index = nativeMax2(length2 + index, 0);
        }
        return baseIndexOf(array2, value, index);
      }
      function initial(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseSlice2(array2, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap2(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        if (iteratee2 === last2(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last2(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array2, separator) {
        return array2 == null ? "" : nativeJoin.call(array2, separator);
      }
      function last2(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? array2[length2 - 1] : undefined$1;
      }
      function lastIndexOf2(array2, value, fromIndex) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return -1;
        }
        var index = length2;
        if (fromIndex !== undefined$1) {
          index = toInteger2(fromIndex);
          index = index < 0 ? nativeMax2(length2 + index, 0) : nativeMin2(index, length2 - 1);
        }
        return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
      }
      function nth(array2, n2) {
        return array2 && array2.length ? baseNth(array2, toInteger2(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array2, values3) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3) : array2;
      }
      function pullAllBy(array2, values3, iteratee2) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, getIteratee(iteratee2, 2)) : array2;
      }
      function pullAllWith(array2, values3, comparator) {
        return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, undefined$1, comparator) : array2;
      }
      var pullAt = flatRest(function(array2, indexes) {
        var length2 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
        basePullAt(array2, arrayMap2(indexes, function(index) {
          return isIndex2(index, length2) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array2, predicate) {
        var result2 = [];
        if (!(array2 && array2.length)) {
          return result2;
        }
        var index = -1, indexes = [], length2 = array2.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length2) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array2, indexes);
        return result2;
      }
      function reverse2(array2) {
        return array2 == null ? array2 : nativeReverse.call(array2);
      }
      function slice2(array2, start2, end2) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array2, start2, end2)) {
          start2 = 0;
          end2 = length2;
        } else {
          start2 = start2 == null ? 0 : toInteger2(start2);
          end2 = end2 === undefined$1 ? length2 : toInteger2(end2);
        }
        return baseSlice2(array2, start2, end2);
      }
      function sortedIndex(array2, value) {
        return baseSortedIndex(array2, value);
      }
      function sortedIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array2, value) {
        var length2 = array2 == null ? 0 : array2.length;
        if (length2) {
          var index = baseSortedIndex(array2, value);
          if (index < length2 && eq2(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array2, value) {
        return baseSortedIndex(array2, value, true);
      }
      function sortedLastIndexBy(array2, value, iteratee2) {
        return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array2, value) {
        var length2 = array2 == null ? 0 : array2.length;
        if (length2) {
          var index = baseSortedIndex(array2, value, true) - 1;
          if (eq2(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array2) {
        return array2 && array2.length ? baseSortedUniq(array2) : [];
      }
      function sortedUniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array2) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseSlice2(array2, 1, length2) : [];
      }
      function take(array2, n2, guard) {
        if (!(array2 && array2.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice2(array2, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array2, n2, guard) {
        var length2 = array2 == null ? 0 : array2.length;
        if (!length2) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length2 - n2;
        return baseSlice2(array2, n2 < 0 ? 0 : n2, length2);
      }
      function takeRightWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array2, predicate) {
        return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
      }
      var union2 = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
      });
      function uniq2(array2) {
        return array2 && array2.length ? baseUniq(array2) : [];
      }
      function uniqBy(array2, iteratee2) {
        return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array2, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
      }
      function unzip2(array2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var length2 = 0;
        array2 = arrayFilter2(array2, function(group) {
          if (isArrayLikeObject2(group)) {
            length2 = nativeMax2(group.length, length2);
            return true;
          }
        });
        return baseTimes2(length2, function(index) {
          return arrayMap2(array2, baseProperty(index));
        });
      }
      function unzipWith(array2, iteratee2) {
        if (!(array2 && array2.length)) {
          return [];
        }
        var result2 = unzip2(array2);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap2(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array2, values3) {
        return isArrayLikeObject2(array2) ? baseDifference(array2, values3) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last2(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last2(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$1, comparator);
      });
      var zip2 = baseRest(unzip2);
      function zipObject2(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor2) {
        interceptor2(value);
        return value;
      }
      function thru(value, interceptor2) {
        return interceptor2(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length2 = paths.length, start2 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor2 = function(object) {
          return baseAt(object, paths);
        };
        if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start2)) {
          return this.thru(interceptor2);
        }
        value = value.slice(start2, +start2 + (length2 ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor2],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array2) {
          if (length2 && !array2.length) {
            array2.push(undefined$1);
          }
          return array2;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent3 = this;
        while (parent3 instanceof baseLodash) {
          var clone3 = wrapperClone(parent3);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent3 = parent3.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse2],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse2);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy2 = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every2(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast2 = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY2);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach2 : baseEach2;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy2 = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes2(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length2 = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length2 + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach2(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap2 : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy2(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce2(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce2 : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter2 : baseFilter;
        return func(collection, negate2(getIteratee(predicate, 3)));
      }
      function sample2(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle2(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag2(collection);
        if (tag == mapTag2 || tag == setTag2) {
          return collection.size;
        }
        return baseKeys2(collection).length;
      }
      function some2(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy2 = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after2(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before2(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry2(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry2.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time2;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time2) : result2;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now2();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time2 = now2(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      function negate2(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once2(func) {
        return before2(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary(getIteratee())) : arrayMap2(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length2 = nativeMin2(args.length, funcsLength);
          while (++index < length2) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger2(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 == null ? 0 : nativeMax2(toInteger2(start2), 0);
        return baseRest(function(args) {
          var array2 = args[start2], otherArgs = castSlice2(args, 0, start2);
          if (array2) {
            arrayPush(otherArgs, array2);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag = getTag2(value);
        if (tag == mapTag2 || tag == setTag2) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys2(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith2(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError2(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
      }
      function isInteger2(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type2 = typeof value;
        return value != null && (type2 == "object" || type2 == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch2(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull2(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto2 = getPrototype(value);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger2(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap2(value) {
        return isObjectLike2(value) && getTag2(value) == weakMapTag2;
      }
      function isWeakSet2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray2(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray2(value[symIterator]());
        }
        var tag = getTag2(value), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values2;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY2 || value === -INFINITY2) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim2(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString2(value);
      }
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype2(source) || isArrayLike2(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length2 = sources.length;
        var guard = length2 > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length2 = 1;
        }
        while (++index < length2) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn2(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get3(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet2(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has3(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert2 = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke2 = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      function keysIn(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn2(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap2(paths, function(path) {
          path = castPath2(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length2 = paths.length;
        while (length2--) {
          baseUnset(result2, paths[length2]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate2(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap2(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath2(path, object);
        var index = -1, length2 = path.length;
        if (!length2) {
          length2 = 1;
          object = undefined$1;
        }
        while (++index < length2) {
          var value = object == null ? undefined$1 : object[toKey2(path[index])];
          if (value === undefined$1) {
            index = length2;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update5(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values2(object) {
        return object == null ? [] : baseValues2(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues2(object, keysIn(object));
      }
      function clamp2(number2, lower2, upper2) {
        if (upper2 === undefined$1) {
          upper2 = lower2;
          lower2 = undefined$1;
        }
        if (upper2 !== undefined$1) {
          upper2 = toNumber2(upper2);
          upper2 = upper2 === upper2 ? upper2 : 0;
        }
        if (lower2 !== undefined$1) {
          lower2 = toNumber2(lower2);
          lower2 = lower2 === lower2 ? lower2 : 0;
        }
        return baseClamp(toNumber2(number2), lower2, upper2);
      }
      function inRange(number2, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number2 = toNumber2(number2);
        return baseInRange(number2, start2, end2);
      }
      function random2(lower2, upper2, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper2, floating)) {
          upper2 = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper2 == "boolean") {
            floating = upper2;
            upper2 = undefined$1;
          } else if (typeof lower2 == "boolean") {
            floating = lower2;
            lower2 = undefined$1;
          }
        }
        if (lower2 === undefined$1 && upper2 === undefined$1) {
          lower2 = 0;
          upper2 = 1;
        } else {
          lower2 = toFinite(lower2);
          if (upper2 === undefined$1) {
            upper2 = lower2;
            lower2 = 0;
          } else {
            upper2 = toFinite(upper2);
          }
        }
        if (lower2 > upper2) {
          var temp = lower2;
          lower2 = upper2;
          upper2 = temp;
        }
        if (floating || lower2 % 1 || upper2 % 1) {
          var rand = nativeRandom();
          return nativeMin2(lower2 + rand * (upper2 - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper2);
        }
        return baseRandom(lower2, upper2);
      }
      var camelCase2 = createCompounder2(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst2(toString2(string).toLowerCase());
      }
      function deburr2(string) {
        string = toString2(string);
        return string && string.replace(reLatin2, deburrLetter2).replace(reComboMark2, "");
      }
      function endsWith2(string, target, position) {
        string = toString2(string);
        target = baseToString2(target);
        var length2 = string.length;
        position = position === undefined$1 ? length2 : baseClamp(toInteger2(position), 0, length2);
        var end2 = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end2) == target;
      }
      function escape2(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
      }
      var kebabCase2 = createCompounder2(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder2(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst2("toLowerCase");
      function pad2(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger2(length2);
        var strLength = length2 ? stringSize(string) : 0;
        if (!length2 || strLength >= length2) {
          return string;
        }
        var mid = (length2 - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd2(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger2(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
      }
      function padStart2(string, length2, chars) {
        string = toString2(string);
        length2 = toInteger2(length2);
        var strLength = length2 ? stringSize(string) : 0;
        return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart2, ""), radix || 0);
      }
      function repeat2(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        return baseRepeat(toString2(string), n2);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder2(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split2(string, separator, limit2) {
        if (limit2 && typeof limit2 != "number" && isIterateeCall(string, separator, limit2)) {
          separator = limit2 = undefined$1;
        }
        limit2 = limit2 === undefined$1 ? MAX_ARRAY_LENGTH : limit2 >>> 0;
        if (!limit2) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString2(separator);
          if (!separator && hasUnicode2(string)) {
            return castSlice2(stringToArray2(string), 0, limit2);
          }
        }
        return string.split(separator, limit2);
      }
      var startCase = createCompounder2(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst2(word);
      });
      function startsWith2(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString2(target);
        return string.slice(position, position + target.length) == target;
      }
      function template2(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues2(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset2 + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function3(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError2(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim2(string);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray2(string), chrSymbols = stringToArray2(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice2(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex2(string) + 1);
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray2(string), end2 = charsEndIndex(strSymbols, stringToArray2(chars)) + 1;
        return castSlice2(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart2, "");
        }
        if (!string || !(chars = baseToString2(chars))) {
          return string;
        }
        var strSymbols = stringToArray2(string), start2 = charsStartIndex(strSymbols, stringToArray2(chars));
        return castSlice2(strSymbols, start2).join("");
      }
      function truncate(string, options) {
        var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length2 = "length" in options ? toInteger2(options.length) : length2;
          omission = "omission" in options ? baseToString2(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode2(string)) {
          var strSymbols = stringToArray2(string);
          strLength = strSymbols.length;
        }
        if (length2 >= strLength) {
          return string;
        }
        var end2 = length2 - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice2(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end2).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString2(separator), end2) != end2) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder2(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst2 = createCaseFirst2("toUpperCase");
      function words2(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord2(string) ? unicodeWords2(string) : asciiWords2(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e3) {
          return isError2(e3) ? e3 : new Error2(e3);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach2(methodNames, function(key) {
          key = toKey2(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length2 ? [] : arrayMap2(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length2) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin2(object, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach2(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray2(this.__actions__);
                actions2.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger2(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap2);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property2(path) {
        return isKey2(path) ? baseProperty(toKey2(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet2(object, path);
        };
      }
      var range2 = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger2(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length2 = nativeMin2(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes2(length2, iteratee2);
        while (++index < n2) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap2(value, toKey2);
        }
        return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString2(value)));
      }
      function uniqueId2(prefix) {
        var id2 = ++idCounter;
        return toString2(prefix) + id2;
      }
      var add3 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil2 = createRound("ceil");
      var divide2 = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor2 = createRound("floor");
      function max3(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$1;
      }
      function maxBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean2(array2) {
        return baseMean(array2, identity2);
      }
      function meanBy(array2, iteratee2) {
        return baseMean(array2, getIteratee(iteratee2, 2));
      }
      function min3(array2) {
        return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined$1;
      }
      function minBy(array2, iteratee2) {
        return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply2 = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum3(array2) {
        return array2 && array2.length ? baseSum(array2, identity2) : 0;
      }
      function sumBy(array2, iteratee2) {
        return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after2;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before2;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk2;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy2;
      lodash2.create = create2;
      lodash2.curry = curry2;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten2;
      lodash2.flattenDeep = flattenDeep2;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs2;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy2;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert2;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize2;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin2;
      lodash2.negate = negate2;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once2;
      lodash2.orderBy = orderBy2;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property2;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range2;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse2;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle2;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy2;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split2;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union2;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq2;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip2;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update5;
      lodash2.updateWith = updateWith;
      lodash2.values = values2;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words2;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip2;
      lodash2.zipObject = zipObject2;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin2(lodash2, lodash2);
      lodash2.add = add3;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase2;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil2;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr2;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide2;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq2;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every2;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast2;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor2;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get3;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has3;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes2;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke2;
      lodash2.isArguments = isArguments2;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject2;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith2;
      lodash2.isError = isError2;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger2;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch2;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull2;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap2;
      lodash2.isWeakSet = isWeakSet2;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase2;
      lodash2.last = last2;
      lodash2.lastIndexOf = lastIndexOf2;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max3;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean2;
      lodash2.meanBy = meanBy;
      lodash2.min = min3;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply2;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd2;
      lodash2.padStart = padStart2;
      lodash2.parseInt = parseInt2;
      lodash2.random = random2;
      lodash2.reduce = reduce2;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat2;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample2;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some2;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith2;
      lodash2.subtract = subtract2;
      lodash2.sum = sum3;
      lodash2.sumBy = sumBy;
      lodash2.template = template2;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId2;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst2;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin2(lodash2, function() {
        var source = {};
        baseForOwn2(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach2(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax2(toInteger2(n2), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin2(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin2(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach2(["filter", "map", "takeWhile"], function(methodName, index) {
        var type2 = index + 1, isFilter = type2 == LAZY_FILTER_FLAG || type2 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type2
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach2(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach2(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate2(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger2(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger2(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor2 = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor2], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor2);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal$1);
})(lodash, lodash.exports);
var _$7 = lodash.exports;
var FitsEcharts_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "FitsEcharts",
  props: {
    config: { default: () => new FitsEchartsProps({}) }
  },
  setup(__props) {
    const props = __props;
    const { config: config2 } = toRefs$1(props);
    const fitsEcharts = ref();
    const { initBarEchart, barEchartsInstance, setBarOptions } = useBarEcharts(fitsEcharts);
    const { initLineEchart, lineEchartsInstance, setLineOptions } = useLineEcharts(fitsEcharts);
    const { initPieEchart, pieEchartsInstance } = usePieEcharts(fitsEcharts);
    const debounceFn = _$7.debounce(resizeEcharts, 300);
    onMounted$1(() => {
      window.addEventListener("resize", debounceFn);
    });
    onUnmounted(() => {
      window.removeEventListener("resize", debounceFn);
    });
    function resizeEcharts() {
      var _a2, _b2, _c2;
      switch (config2.value.type) {
        case "bar":
          (_a2 = barEchartsInstance.value) == null ? void 0 : _a2.resize();
          setBarOptions(config2.value);
          break;
        case "line":
          (_b2 = lineEchartsInstance.value) == null ? void 0 : _b2.resize();
          setLineOptions(config2.value);
          break;
        case "pie":
          (_c2 = pieEchartsInstance.value) == null ? void 0 : _c2.resize();
          break;
      }
    }
    watch$1(() => config2, async () => {
      await nextTick$1();
      switch (config2.value.type) {
        case "bar":
          initBarEchart(config2.value);
          break;
        case "line":
          initLineEchart(config2.value);
          break;
        case "pie":
          initPieEchart(config2.value);
          break;
      }
    }, { deep: true });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "fits-echarts",
        ref_key: "fitsEcharts",
        ref: fitsEcharts
      }, null, 512);
    };
  }
});
var FitsEcharts = /* @__PURE__ */ _export_sfc$2(_sfc_main$p, [["__scopeId", "data-v-670f603d"]]);
var FitsForm_vue_vue_type_style_index_0_lang = "";
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "FitsForm",
  props: {
    option: null
  },
  setup(__props, { expose }) {
    const props = __props;
    const fApi = ref(null);
    const formValue = ref({});
    expose({
      fApi
    });
    const { option } = toRefs(props);
    handleFormCreateOption();
    const formCreateOption = reactive({ form: { ...props.option.form }, ...props.option.btnProps });
    console.log(formCreateOption);
    function handleFormCreateOption() {
      var _a2, _b2, _c2, _d2;
      const resetBtn = (_a2 = props.option.btnProps) == null ? void 0 : _a2.resetBtn;
      if (((_b2 = props.option.btnProps) == null ? void 0 : _b2.resetBtn) && !((_d2 = (_c2 = props.option.btnProps) == null ? void 0 : _c2.resetBtn) == null ? void 0 : _d2.click)) {
        resetBtn.click = () => {
          var _a3;
          (_a3 = fApi.value) == null ? void 0 : _a3.resetFields();
        };
      }
    }
    return (_ctx, _cache) => {
      const _component_form_create = resolveComponent("form-create");
      return openBlock(), createBlock(_component_form_create, {
        rule: unref$1(option).formItem,
        api: fApi.value,
        "onUpdate:api": _cache[0] || (_cache[0] = ($event) => fApi.value = $event),
        class: "form-creat-wrap",
        modelValue: formValue.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => formValue.value = $event),
        option: formCreateOption
      }, null, 8, ["rule", "api", "modelValue", "option"]);
    };
  }
});
class FitsFormModel {
  constructor({
    form: form2,
    formItem,
    btnProps
  }) {
    __publicField(this, "form");
    __publicField(this, "formItem");
    __publicField(this, "btnProps");
    this.form = form2;
    this.formItem = formItem;
    this.btnProps = btnProps;
  }
}
var ListSeachBtnGroud_vue_vue_type_style_index_0_lang = "";
var ListSeachBtnGroud_vue_vue_type_style_index_1_scoped_true_lang = "";
const _hoisted_1$c = { class: "searchBtns" };
const _hoisted_2$6 = /* @__PURE__ */ createTextVNode("\u641C\u7D22");
const _hoisted_3$3 = /* @__PURE__ */ createTextVNode("\u91CD\u7F6E");
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "ListSeachBtnGroud",
  props: {
    isExpand: { type: Boolean, default: false }
  },
  emits: ["submit", "reset", "getOpenStatus"],
  setup(__props, { emit }) {
    const props = __props;
    const { isExpand } = toRefs(props);
    const submit = () => emit("submit");
    const reset = () => emit("reset");
    const handleExpand = () => {
      emit("getOpenStatus");
    };
    return (_ctx, _cache) => {
      const _component_el_button = resolveComponent("el-button");
      const _component_el_icon = resolveComponent("el-icon");
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createVNode(_component_el_button, {
          type: "primary",
          onClick: submit,
          class: "search",
          icon: unref$1(search)
        }, {
          default: withCtx(() => [
            _hoisted_2$6
          ]),
          _: 1
        }, 8, ["icon"]),
        createVNode(_component_el_button, {
          onClick: reset,
          class: "reset",
          icon: unref$1(refreshLeft)
        }, {
          default: withCtx(() => [
            _hoisted_3$3
          ]),
          _: 1
        }, 8, ["icon"]),
        createVNode(_component_el_button, {
          link: "",
          class: "expand",
          onClick: handleExpand
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(!unref$1(isExpand) ? "\u5C55\u5F00" : "\u6536\u8D77") + " ", 1),
            createVNode(_component_el_icon, { class: "expandicon" }, {
              default: withCtx(() => [
                !unref$1(isExpand) ? (openBlock(), createBlock(unref$1(arrowDown), { key: 0 })) : (openBlock(), createBlock(unref$1(arrowUp), { key: 1 }))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
});
var ListSeachBtnGroud = /* @__PURE__ */ _export_sfc$2(_sfc_main$n, [["__scopeId", "data-v-3f4a1de9"]]);
const menuText = "#bfcbd9";
const menuActiveText = "#409eff";
const subMenuActiveText = "#f4f4f5";
const menuBg = "#304156";
const menuHover = "#263445";
const subMenuBg = "#1f2d3d";
const subMenuHover = "#001528";
const sideBarWidth = "200px";
const headHeight = "50px";
const tagsViewHeight = "40px";
const footerHeight = "24px";
const basePadding = "16px";
const ListSearchFormItemWidth = "338px";
var variables = {
  menuText,
  menuActiveText,
  subMenuActiveText,
  menuBg,
  menuHover,
  subMenuBg,
  subMenuHover,
  sideBarWidth,
  headHeight,
  tagsViewHeight,
  footerHeight,
  basePadding,
  ListSearchFormItemWidth
};
var FitsListSeach_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "FitsListSeach",
  props: {
    formItem: null
  },
  emits: ["getFormData", "reset"],
  setup(__props, { emit }) {
    const props = __props;
    const fitsForm = ref();
    const { proxy } = getCurrentInstance();
    const option = reactive(new FitsFormModel({
      formItem: [],
      form: {
        inline: true
      },
      btnProps: {
        submitBtn: {
          show: false
        },
        resetBtn: {
          show: false
        }
      }
    }));
    const btnGroup = reactive({
      type: "ListSeachBtnGroud",
      field: "btn",
      component: shallowRef(ListSeachBtnGroud),
      props: {
        isExpand: false
      },
      on: {
        submit: () => {
          fitsForm.value.fApi.submit((formData3) => {
            let { btn, ...data5 } = formData3;
            emit("getFormData", data5);
          });
        },
        reset: () => {
          fitsForm.value.fApi.resetFields();
          const formData3 = fitsForm.value.fApi.formData();
          let { btn, ...data5 } = formData3;
          emit("reset", data5);
        },
        getOpenStatus: () => {
          const { props: _props } = btnGroup;
          _props.isExpand = !_props.isExpand;
          handleFormItemNumber(proxy == null ? void 0 : proxy.$el.clientWidth);
        }
      }
    });
    onMounted(() => {
      console.log(proxy == null ? void 0 : proxy.$el.clientWidth);
    });
    useResizeObserver(document.body, () => {
      handleFormItemNumber(proxy == null ? void 0 : proxy.$el.clientWidth);
    });
    function handleFormItemNumber(width2) {
      const formItemWidth = parseInt(variables.ListSearchFormItemWidth);
      const { props: _props } = btnGroup;
      if (_props.isExpand) {
        option.formItem = [...props.formItem, btnGroup];
      } else {
        option.formItem = [...props.formItem.slice(0, Math.floor(width2 / formItemWidth) - 1), btnGroup];
      }
    }
    return (_ctx, _cache) => {
      const _component_FitsForm = resolveComponent("FitsForm");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      return openBlock(), createBlock(_component_el_scrollbar, {
        ref: "scrollbarRef",
        "max-height": "200px",
        class: "list-search-wrap"
      }, {
        default: withCtx(() => [
          createVNode(_component_FitsForm, {
            ref_key: "fitsForm",
            ref: fitsForm,
            option,
            class: "fitsForm"
          }, null, 8, ["option"])
        ]),
        _: 1
      }, 512);
    };
  }
});
var FitsListSearch = /* @__PURE__ */ _export_sfc$2(_sfc_main$m, [["__scopeId", "data-v-2f7ed29a"]]);
var FitsNoData_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId$1 = (n2) => (pushScopeId("data-v-0b84498e"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$b = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "text" }, "\u6682\u65E0\u6570\u636E", -1));
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "FitsNoData",
  props: {
    height: { default: "300px" }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      const _component_SvgIcon = resolveComponent("SvgIcon");
      return openBlock(), createElementBlock("div", {
        class: "nodata",
        style: normalizeStyle$1({ height: props.height })
      }, [
        createVNode(_component_SvgIcon, { "icon-class": "nodata" }),
        _hoisted_1$b
      ], 4);
    };
  }
});
var FitsNoData = /* @__PURE__ */ _export_sfc$2(_sfc_main$l, [["__scopeId", "data-v-0b84498e"]]);
var setupDefaults$a = {
  cookies: {
    path: "/"
  },
  treeOptions: {
    parentKey: "parentId",
    key: "id",
    children: "children"
  },
  parseDateFormat: "yyyy-MM-dd HH:mm:ss",
  firstDayOfWeek: 1,
  dateDiffRules: [
    ["yyyy", 31536e6],
    ["MM", 2592e6],
    ["dd", 864e5],
    ["HH", 36e5],
    ["mm", 6e4],
    ["ss", 1e3],
    ["S", 0]
  ]
};
var setupDefaults_1 = setupDefaults$a;
function arrayEach$f(list, iterate, context) {
  if (list) {
    if (list.forEach) {
      list.forEach(iterate, context);
    } else {
      for (var index = 0, len2 = list.length; index < len2; index++) {
        iterate.call(context, list[index], index, list);
      }
    }
  }
}
var arrayEach_1 = arrayEach$f;
var objectToString$9 = Object.prototype.toString;
var staticObjectToString = objectToString$9;
var objectToString$8 = staticObjectToString;
function helperCreateInInObjectString$5(type2) {
  return function(obj) {
    return "[object " + type2 + "]" === objectToString$8.call(obj);
  };
}
var helperCreateInInObjectString_1 = helperCreateInInObjectString$5;
var helperCreateInInObjectString$4 = helperCreateInInObjectString_1;
var isArray$w = Array.isArray || helperCreateInInObjectString$4("Array");
var isArray_1 = isArray$w;
function hasOwnProp$a(obj, key) {
  return obj && obj.hasOwnProperty ? obj.hasOwnProperty(key) : false;
}
var hasOwnProp_1 = hasOwnProp$a;
var hasOwnProp$9 = hasOwnProp_1;
function objectEach$5(obj, iterate, context) {
  if (obj) {
    for (var key in obj) {
      if (hasOwnProp$9(obj, key)) {
        iterate.call(context, obj[key], key, obj);
      }
    }
  }
}
var objectEach_1 = objectEach$5;
var isArray$v = isArray_1;
var arrayEach$e = arrayEach_1;
var objectEach$4 = objectEach_1;
function each$k(obj, iterate, context) {
  if (obj) {
    return (isArray$v(obj) ? arrayEach$e : objectEach$4)(obj, iterate, context);
  }
  return obj;
}
var each_1 = each$k;
function helperCreateInTypeof$6(type2) {
  return function(obj) {
    return typeof obj === type2;
  };
}
var helperCreateInTypeof_1 = helperCreateInTypeof$6;
var helperCreateInTypeof$5 = helperCreateInTypeof_1;
var isFunction$g = helperCreateInTypeof$5("function");
var isFunction_1 = isFunction$g;
var each$j = each_1;
function helperCreateGetObjects$3(name2, getIndex) {
  var proMethod = Object[name2];
  return function(obj) {
    var result = [];
    if (obj) {
      if (proMethod) {
        return proMethod(obj);
      }
      each$j(obj, getIndex > 1 ? function(key) {
        result.push(["" + key, obj[key]]);
      } : function() {
        result.push(arguments[getIndex]);
      });
    }
    return result;
  };
}
var helperCreateGetObjects_1 = helperCreateGetObjects$3;
var helperCreateGetObjects$2 = helperCreateGetObjects_1;
var keys$c = helperCreateGetObjects$2("keys", 1);
var keys_1 = keys$c;
var objectToString$7 = staticObjectToString;
var objectEach$3 = objectEach_1;
var arrayEach$d = arrayEach_1;
function getCativeCtor(val2, args) {
  var Ctor = val2.__proto__.constructor;
  return args ? new Ctor(args) : new Ctor();
}
function handleValueClone(item, isDeep) {
  return isDeep ? copyValue(item, isDeep) : item;
}
function copyValue(val2, isDeep) {
  if (val2) {
    switch (objectToString$7.call(val2)) {
      case "[object Object]": {
        var restObj = Object.create(val2.__proto__);
        objectEach$3(val2, function(item, key) {
          restObj[key] = handleValueClone(item, isDeep);
        });
        return restObj;
      }
      case "[object Date]":
      case "[object RegExp]": {
        return getCativeCtor(val2, val2.valueOf());
      }
      case "[object Array]":
      case "[object Arguments]": {
        var restArr = [];
        arrayEach$d(val2, function(item) {
          restArr.push(handleValueClone(item, isDeep));
        });
        return restArr;
      }
      case "[object Set]": {
        var restSet = getCativeCtor(val2);
        restSet.forEach(function(item) {
          restSet.add(handleValueClone(item, isDeep));
        });
        return restSet;
      }
      case "[object Map]": {
        var restMap = getCativeCtor(val2);
        restMap.forEach(function(item, key) {
          restMap.set(handleValueClone(item, isDeep));
        });
        return restMap;
      }
    }
  }
  return val2;
}
function clone$3(obj, deep) {
  if (obj) {
    return copyValue(obj, deep);
  }
  return obj;
}
var clone_1 = clone$3;
var arrayEach$c = arrayEach_1;
var keys$b = keys_1;
var isArray$u = isArray_1;
var clone$2 = clone_1;
var objectAssignFns = Object.assign;
function handleAssign(destination, args, isClone) {
  var len2 = args.length;
  for (var source, index = 1; index < len2; index++) {
    source = args[index];
    arrayEach$c(keys$b(args[index]), isClone ? function(key) {
      destination[key] = clone$2(source[key], isClone);
    } : function(key) {
      destination[key] = source[key];
    });
  }
  return destination;
}
var assign$b = function(target) {
  if (target) {
    var args = arguments;
    if (target === true) {
      if (args.length > 1) {
        target = isArray$u(target[1]) ? [] : {};
        return handleAssign(target, args, true);
      }
    } else {
      return objectAssignFns ? objectAssignFns.apply(Object, args) : handleAssign(target, args);
    }
  }
  return target;
};
var assign_1 = assign$b;
var setupDefaults$9 = setupDefaults_1;
var arrayEach$b = arrayEach_1;
var each$i = each_1;
var isFunction$f = isFunction_1;
var assign$a = assign_1;
var XEUtils$1 = function() {
};
function mixin() {
  arrayEach$b(arguments, function(methods) {
    each$i(methods, function(fn2, name2) {
      XEUtils$1[name2] = isFunction$f(fn2) ? function() {
        var result = fn2.apply(XEUtils$1.$context, arguments);
        XEUtils$1.$context = null;
        return result;
      } : fn2;
    });
  });
}
function setup$1(options) {
  return assign$a(setupDefaults$9, options);
}
XEUtils$1.VERSION = "3.5.6";
XEUtils$1.mixin = mixin;
XEUtils$1.setup = setup$1;
var ctor = XEUtils$1;
function lastArrayEach$3(obj, iterate, context) {
  for (var len2 = obj.length - 1; len2 >= 0; len2--) {
    iterate.call(context, obj[len2], len2, obj);
  }
}
var lastArrayEach_1 = lastArrayEach$3;
var lastArrayEach$2 = lastArrayEach_1;
var keys$a = keys_1;
function lastObjectEach$2(obj, iterate, context) {
  lastArrayEach$2(keys$a(obj), function(key) {
    iterate.call(context, obj[key], key, obj);
  });
}
var lastObjectEach_1 = lastObjectEach$2;
function isNull$9(obj) {
  return obj === null;
}
var isNull_1 = isNull$9;
var isNull$8 = isNull_1;
function property$5(name2, defs) {
  return function(obj) {
    return isNull$8(obj) ? defs : obj[name2];
  };
}
var property_1 = property$5;
var each$h = each_1;
var isFunction$e = isFunction_1;
var property$4 = property_1;
function objectMap$1(obj, iterate, context) {
  var result = {};
  if (obj) {
    if (iterate) {
      if (!isFunction$e(iterate)) {
        iterate = property$4(iterate);
      }
      each$h(obj, function(val2, index) {
        result[index] = iterate.call(context, val2, index, obj);
      });
    } else {
      return obj;
    }
  }
  return result;
}
var objectMap_1 = objectMap$1;
function isPlainObject$7(obj) {
  return obj ? obj.constructor === Object : false;
}
var isPlainObject_1 = isPlainObject$7;
var isArray$t = isArray_1;
var isPlainObject$6 = isPlainObject_1;
var each$g = each_1;
function handleMerge(target, source) {
  if (isPlainObject$6(target) && isPlainObject$6(source) || isArray$t(target) && isArray$t(source)) {
    each$g(source, function(obj, key) {
      target[key] = handleMerge(target[key], obj);
    });
    return target;
  }
  return source;
}
var merge$1 = function(target) {
  if (!target) {
    target = {};
  }
  var args = arguments;
  var len2 = args.length;
  for (var source, index = 1; index < len2; index++) {
    source = args[index];
    if (source) {
      handleMerge(target, source);
    }
  }
  return target;
};
var merge_1 = merge$1;
var each$f = each_1;
function map$7(obj, iterate, context) {
  var result = [];
  if (obj && arguments.length > 1) {
    if (obj.map) {
      return obj.map(iterate, context);
    } else {
      each$f(obj, function() {
        result.push(iterate.apply(context, arguments));
      });
    }
  }
  return result;
}
var map_1 = map$7;
var hasOwnProp$8 = hasOwnProp_1;
var isArray$s = isArray_1;
function helperCreateIterateHandle$4(prop, useArray, restIndex, matchValue, defaultValue) {
  return function(obj, iterate, context) {
    if (obj && iterate) {
      if (prop && obj[prop]) {
        return obj[prop](iterate, context);
      } else {
        if (useArray && isArray$s(obj)) {
          for (var index = 0, len2 = obj.length; index < len2; index++) {
            if (!!iterate.call(context, obj[index], index, obj) === matchValue) {
              return [true, false, index, obj[index]][restIndex];
            }
          }
        } else {
          for (var key in obj) {
            if (hasOwnProp$8(obj, key)) {
              if (!!iterate.call(context, obj[key], key, obj) === matchValue) {
                return [true, false, key, obj[key]][restIndex];
              }
            }
          }
        }
      }
    }
    return defaultValue;
  };
}
var helperCreateIterateHandle_1 = helperCreateIterateHandle$4;
var helperCreateIterateHandle$3 = helperCreateIterateHandle_1;
var some$2 = helperCreateIterateHandle$3("some", 1, 0, true, false);
var some_1 = some$2;
var helperCreateIterateHandle$2 = helperCreateIterateHandle_1;
var every$2 = helperCreateIterateHandle$2("every", 1, 1, false, true);
var every_1 = every$2;
var hasOwnProp$7 = hasOwnProp_1;
function includes$6(obj, val2) {
  if (obj) {
    if (obj.includes) {
      return obj.includes(val2);
    }
    for (var key in obj) {
      if (hasOwnProp$7(obj, key)) {
        if (val2 === obj[key]) {
          return true;
        }
      }
    }
  }
  return false;
}
var includes_1 = includes$6;
var isArray$r = isArray_1;
var includes$5 = includes_1;
function includeArrays$2(array1, array2) {
  var len2;
  var index = 0;
  if (isArray$r(array1) && isArray$r(array2)) {
    for (len2 = array2.length; index < len2; index++) {
      if (!includes$5(array1, array2[index])) {
        return false;
      }
    }
    return true;
  }
  return includes$5(array1, array2);
}
var includeArrays_1 = includeArrays$2;
var each$e = each_1;
var includes$4 = includes_1;
function uniq$2(array2) {
  var result = [];
  each$e(array2, function(value) {
    if (!includes$4(result, value)) {
      result.push(value);
    }
  });
  return result;
}
var uniq_1 = uniq$2;
var map$6 = map_1;
function toArray$4(list) {
  return map$6(list, function(item) {
    return item;
  });
}
var toArray_1 = toArray$4;
var uniq$1 = uniq_1;
var toArray$3 = toArray_1;
function union$1() {
  var args = arguments;
  var result = [];
  var index = 0;
  var len2 = args.length;
  for (; index < len2; index++) {
    result = result.concat(toArray$3(args[index]));
  }
  return uniq$1(result);
}
var union_1 = union$1;
var staticStrUndefined$b = "undefined";
var staticStrUndefined_1 = staticStrUndefined$b;
var staticStrUndefined$a = staticStrUndefined_1;
var helperCreateInTypeof$4 = helperCreateInTypeof_1;
var isUndefined$b = helperCreateInTypeof$4(staticStrUndefined$a);
var isUndefined_1 = isUndefined$b;
var isNull$7 = isNull_1;
var isUndefined$a = isUndefined_1;
function eqNull$7(obj) {
  return isNull$7(obj) || isUndefined$a(obj);
}
var eqNull_1 = eqNull$7;
var staticHGKeyRE$2 = /(.+)?\[(\d+)\]$/;
var staticHGKeyRE_1 = staticHGKeyRE$2;
function helperGetHGSKeys$3(property2) {
  return property2 ? property2.splice && property2.join ? property2 : ("" + property2).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
}
var helperGetHGSKeys_1 = helperGetHGSKeys$3;
var staticHGKeyRE$1 = staticHGKeyRE_1;
var helperGetHGSKeys$2 = helperGetHGSKeys_1;
var hasOwnProp$6 = hasOwnProp_1;
var isUndefined$9 = isUndefined_1;
var eqNull$6 = eqNull_1;
function get$6(obj, property2, defaultValue) {
  if (eqNull$6(obj)) {
    return defaultValue;
  }
  var result = getValueByPath(obj, property2);
  return isUndefined$9(result) ? defaultValue : result;
}
function getDeepProps(obj, key) {
  var matchs = key ? key.match(staticHGKeyRE$1) : "";
  return matchs ? matchs[1] ? obj[matchs[1]] ? obj[matchs[1]][matchs[2]] : void 0 : obj[matchs[2]] : obj[key];
}
function getValueByPath(obj, property2) {
  if (obj) {
    var rest, props, len2;
    var index = 0;
    if (obj[property2] || hasOwnProp$6(obj, property2)) {
      return obj[property2];
    } else {
      props = helperGetHGSKeys$2(property2);
      len2 = props.length;
      if (len2) {
        for (rest = obj; index < len2; index++) {
          rest = getDeepProps(rest, props[index]);
          if (eqNull$6(rest)) {
            if (index === len2 - 1) {
              return rest;
            }
            return;
          }
        }
      }
      return rest;
    }
  }
}
var get_1 = get$6;
var arrayEach$a = arrayEach_1;
var toArray$2 = toArray_1;
var map$5 = map_1;
var isArray$q = isArray_1;
var isFunction$d = isFunction_1;
var isPlainObject$5 = isPlainObject_1;
var isUndefined$8 = isUndefined_1;
var isNull$6 = isNull_1;
var eqNull$5 = eqNull_1;
var get$5 = get_1;
var property$3 = property_1;
var ORDER_PROP_ASC = "asc";
var ORDER_PROP_DESC = "desc";
function handleSort(v1, v2) {
  if (isUndefined$8(v1)) {
    return 1;
  }
  if (isNull$6(v1)) {
    return isUndefined$8(v2) ? -1 : 1;
  }
  return v1 && v1.localeCompare ? v1.localeCompare(v2) : v1 > v2 ? 1 : -1;
}
function buildMultiOrders(name2, confs, compares) {
  return function(item1, item2) {
    var v1 = item1[name2];
    var v2 = item2[name2];
    if (v1 === v2) {
      return compares ? compares(item1, item2) : 0;
    }
    return confs.order === ORDER_PROP_DESC ? handleSort(v2, v1) : handleSort(v1, v2);
  };
}
function getSortConfs(arr, list, fieldConfs, context) {
  var sortConfs = [];
  fieldConfs = isArray$q(fieldConfs) ? fieldConfs : [fieldConfs];
  arrayEach$a(fieldConfs, function(handle, index) {
    if (handle) {
      var field = handle;
      var order;
      if (isArray$q(handle)) {
        field = handle[0];
        order = handle[1];
      } else if (isPlainObject$5(handle)) {
        field = handle.field;
        order = handle.order;
      }
      sortConfs.push({
        field,
        order: order || ORDER_PROP_ASC
      });
      arrayEach$a(list, isFunction$d(field) ? function(item, key) {
        item[index] = field.call(context, item.data, key, arr);
      } : function(item) {
        item[index] = field ? get$5(item.data, field) : item.data;
      });
    }
  });
  return sortConfs;
}
function orderBy$3(arr, fieldConfs, context) {
  if (arr) {
    if (eqNull$5(fieldConfs)) {
      return toArray$2(arr).sort(handleSort);
    }
    var compares;
    var list = map$5(arr, function(item) {
      return { data: item };
    });
    var sortConfs = getSortConfs(arr, list, fieldConfs, context);
    var len2 = sortConfs.length - 1;
    while (len2 >= 0) {
      compares = buildMultiOrders(len2, sortConfs[len2], compares);
      len2--;
    }
    if (compares) {
      list = list.sort(compares);
    }
    return map$5(list, property$3("data"));
  }
  return [];
}
var orderBy_1 = orderBy$3;
var orderBy$2 = orderBy_1;
var sortBy$1 = orderBy$2;
var sortBy_1 = sortBy$1;
function random$3(minVal, maxVal) {
  return minVal >= maxVal ? minVal : (minVal = minVal >> 0) + Math.round(Math.random() * ((maxVal || 9) - minVal));
}
var random_1 = random$3;
var helperCreateGetObjects$1 = helperCreateGetObjects_1;
var values$7 = helperCreateGetObjects$1("values", 0);
var values_1 = values$7;
var random$2 = random_1;
var values$6 = values_1;
function shuffle$2(array2) {
  var index;
  var result = [];
  var list = values$6(array2);
  var len2 = list.length - 1;
  for (; len2 >= 0; len2--) {
    index = len2 > 0 ? random$2(0, len2) : 0;
    result.push(list[index]);
    list.splice(index, 1);
  }
  return result;
}
var shuffle_1 = shuffle$2;
var shuffle$1 = shuffle_1;
function sample$1(array2, number2) {
  var result = shuffle$1(array2);
  if (arguments.length <= 1) {
    return result[0];
  }
  if (number2 < result.length) {
    result.length = number2 || 0;
  }
  return result;
}
var sample_1 = sample$1;
function helperCreateToNumber$2(handle) {
  return function(str) {
    if (str) {
      var num = handle(str);
      if (!isNaN(num)) {
        return num;
      }
    }
    return 0;
  };
}
var helperCreateToNumber_1 = helperCreateToNumber$2;
var helperCreateToNumber$1 = helperCreateToNumber_1;
var toNumber$a = helperCreateToNumber$1(parseFloat);
var toNumber_1 = toNumber$a;
var toNumber$9 = toNumber_1;
function slice$7(array2, startIndex, endIndex) {
  var result = [];
  var argsSize = arguments.length;
  if (array2) {
    startIndex = argsSize >= 2 ? toNumber$9(startIndex) : 0;
    endIndex = argsSize >= 3 ? toNumber$9(endIndex) : array2.length;
    if (array2.slice) {
      return array2.slice(startIndex, endIndex);
    }
    for (; startIndex < endIndex; startIndex++) {
      result.push(array2[startIndex]);
    }
  }
  return result;
}
var slice_1 = slice$7;
var each$d = each_1;
function filter$2(obj, iterate, context) {
  var result = [];
  if (obj && iterate) {
    if (obj.filter) {
      return obj.filter(iterate, context);
    }
    each$d(obj, function(val2, key) {
      if (iterate.call(context, val2, key, obj)) {
        result.push(val2);
      }
    });
  }
  return result;
}
var filter_1 = filter$2;
var helperCreateIterateHandle$1 = helperCreateIterateHandle_1;
var findKey$1 = helperCreateIterateHandle$1("", 0, 2, true);
var findKey_1 = findKey$1;
var helperCreateIterateHandle = helperCreateIterateHandle_1;
var find$2 = helperCreateIterateHandle("find", 1, 3, true);
var find_1 = find$2;
var isArray$p = isArray_1;
var values$5 = values_1;
function findLast$1(obj, iterate, context) {
  if (obj) {
    if (!isArray$p(obj)) {
      obj = values$5(obj);
    }
    for (var len2 = obj.length - 1; len2 >= 0; len2--) {
      if (iterate.call(context, obj[len2], len2, obj)) {
        return obj[len2];
      }
    }
  }
}
var findLast_1 = findLast$1;
var keys$9 = keys_1;
function reduce$1(array2, callback, initialValue) {
  if (array2) {
    var len2, reduceMethod;
    var index = 0;
    var context = null;
    var previous = initialValue;
    var isInitialVal = arguments.length > 2;
    var keyList = keys$9(array2);
    if (array2.length && array2.reduce) {
      reduceMethod = function() {
        return callback.apply(context, arguments);
      };
      if (isInitialVal) {
        return array2.reduce(reduceMethod, previous);
      }
      return array2.reduce(reduceMethod);
    }
    if (isInitialVal) {
      index = 1;
      previous = array2[keyList[0]];
    }
    for (len2 = keyList.length; index < len2; index++) {
      previous = callback.call(context, previous, array2[keyList[index]], index, array2);
    }
    return previous;
  }
}
var reduce_1 = reduce$1;
var isArray$o = isArray_1;
function copyWithin$1(array2, target, start2, end2) {
  if (isArray$o(array2) && array2.copyWithin) {
    return array2.copyWithin(target, start2, end2);
  }
  var replaceIndex, replaceArray;
  var targetIndex = target >> 0;
  var startIndex = start2 >> 0;
  var len2 = array2.length;
  var endIndex = arguments.length > 3 ? end2 >> 0 : len2;
  if (targetIndex < len2) {
    targetIndex = targetIndex >= 0 ? targetIndex : len2 + targetIndex;
    if (targetIndex >= 0) {
      startIndex = startIndex >= 0 ? startIndex : len2 + startIndex;
      endIndex = endIndex >= 0 ? endIndex : len2 + endIndex;
      if (startIndex < endIndex) {
        for (replaceIndex = 0, replaceArray = array2.slice(startIndex, endIndex); targetIndex < len2; targetIndex++) {
          if (replaceArray.length <= replaceIndex) {
            break;
          }
          array2[targetIndex] = replaceArray[replaceIndex++];
        }
      }
    }
  }
  return array2;
}
var copyWithin_1 = copyWithin$1;
var isArray$n = isArray_1;
function chunk$1(array2, size) {
  var index;
  var result = [];
  var arrLen = size >> 0 || 1;
  if (isArray$n(array2)) {
    if (arrLen >= 0 && array2.length > arrLen) {
      index = 0;
      while (index < array2.length) {
        result.push(array2.slice(index, index + arrLen));
        index += arrLen;
      }
    } else {
      result = array2.length ? [array2] : array2;
    }
  }
  return result;
}
var chunk_1 = chunk$1;
var map$4 = map_1;
var property$2 = property_1;
function pluck$2(obj, key) {
  return map$4(obj, property$2(key));
}
var pluck_1 = pluck$2;
var isFunction$c = isFunction_1;
var eqNull$4 = eqNull_1;
var get$4 = get_1;
var arrayEach$9 = arrayEach_1;
function helperCreateMinMax$2(handle) {
  return function(arr, iterate) {
    if (arr && arr.length) {
      var rest, itemIndex;
      arrayEach$9(arr, function(itemVal, index) {
        if (iterate) {
          itemVal = isFunction$c(iterate) ? iterate(itemVal, index, arr) : get$4(itemVal, iterate);
        }
        if (!eqNull$4(itemVal) && (eqNull$4(rest) || handle(rest, itemVal))) {
          itemIndex = index;
          rest = itemVal;
        }
      });
      return arr[itemIndex];
    }
    return rest;
  };
}
var helperCreateMinMax_1 = helperCreateMinMax$2;
var helperCreateMinMax$1 = helperCreateMinMax_1;
var max$2 = helperCreateMinMax$1(function(rest, itemVal) {
  return rest < itemVal;
});
var max_1 = max$2;
var pluck$1 = pluck_1;
var max$1 = max_1;
function unzip$2(arrays) {
  var index, maxItem, len2;
  var result = [];
  if (arrays && arrays.length) {
    index = 0;
    maxItem = max$1(arrays, function(item) {
      return item ? item.length : 0;
    });
    for (len2 = maxItem ? maxItem.length : 0; index < len2; index++) {
      result.push(pluck$1(arrays, index));
    }
  }
  return result;
}
var unzip_1 = unzip$2;
var unzip$1 = unzip_1;
function zip$1() {
  return unzip$1(arguments);
}
var zip_1 = zip$1;
var values$4 = values_1;
var each$c = each_1;
function zipObject$1(props, arr) {
  var result = {};
  arr = arr || [];
  each$c(values$4(props), function(val2, key) {
    result[val2] = arr[key];
  });
  return result;
}
var zipObject_1 = zipObject$1;
var isArray$m = isArray_1;
var arrayEach$8 = arrayEach_1;
function flattenDeep(array2, deep) {
  var result = [];
  arrayEach$8(array2, function(vals) {
    result = result.concat(isArray$m(vals) ? deep ? flattenDeep(vals, deep) : vals : [vals]);
  });
  return result;
}
function flatten$1(array2, deep) {
  if (isArray$m(array2)) {
    return flattenDeep(array2, deep);
  }
  return [];
}
var flatten_1 = flatten$1;
var map$3 = map_1;
var isArray$l = isArray_1;
function deepGetObj(obj, path) {
  var index = 0;
  var len2 = path.length;
  while (obj && index < len2) {
    obj = obj[path[index++]];
  }
  return len2 && obj ? obj : 0;
}
function invoke$1(list, path) {
  var func;
  var args = arguments;
  var params = [];
  var paths = [];
  var index = 2;
  var len2 = args.length;
  for (; index < len2; index++) {
    params.push(args[index]);
  }
  if (isArray$l(path)) {
    len2 = path.length - 1;
    for (index = 0; index < len2; index++) {
      paths.push(path[index]);
    }
    path = path[len2];
  }
  return map$3(list, function(context) {
    if (paths.length) {
      context = deepGetObj(context, paths);
    }
    func = context[path] || path;
    if (func && func.apply) {
      return func.apply(context, params);
    }
  });
}
var invoke_1 = invoke$1;
function helperDeleteProperty$2(obj, property2) {
  try {
    delete obj[property2];
  } catch (e3) {
    obj[property2] = void 0;
  }
}
var helperDeleteProperty_1 = helperDeleteProperty$2;
var isArray$k = isArray_1;
var lastArrayEach$1 = lastArrayEach_1;
var lastObjectEach$1 = lastObjectEach_1;
function lastEach$2(obj, iterate, context) {
  if (obj) {
    return (isArray$k(obj) ? lastArrayEach$1 : lastObjectEach$1)(obj, iterate, context);
  }
  return obj;
}
var lastEach_1 = lastEach$2;
var helperCreateInTypeof$3 = helperCreateInTypeof_1;
var isObject$c = helperCreateInTypeof$3("object");
var isObject_1 = isObject$c;
var helperDeleteProperty$1 = helperDeleteProperty_1;
var isPlainObject$4 = isPlainObject_1;
var isObject$b = isObject_1;
var isArray$j = isArray_1;
var isNull$5 = isNull_1;
var assign$9 = assign_1;
var objectEach$2 = objectEach_1;
function clear$2(obj, defs, assigns) {
  if (obj) {
    var len2;
    var isDefs = arguments.length > 1 && (isNull$5(defs) || !isObject$b(defs));
    var extds = isDefs ? assigns : defs;
    if (isPlainObject$4(obj)) {
      objectEach$2(obj, isDefs ? function(val2, key) {
        obj[key] = defs;
      } : function(val2, key) {
        helperDeleteProperty$1(obj, key);
      });
      if (extds) {
        assign$9(obj, extds);
      }
    } else if (isArray$j(obj)) {
      if (isDefs) {
        len2 = obj.length;
        while (len2 > 0) {
          len2--;
          obj[len2] = defs;
        }
      } else {
        obj.length = 0;
      }
      if (extds) {
        obj.push.apply(obj, extds);
      }
    }
  }
  return obj;
}
var clear_1 = clear$2;
var helperDeleteProperty = helperDeleteProperty_1;
var isFunction$b = isFunction_1;
var isArray$i = isArray_1;
var each$b = each_1;
var arrayEach$7 = arrayEach_1;
var lastEach$1 = lastEach_1;
var clear$1 = clear_1;
var eqNull$3 = eqNull_1;
function pluckProperty(name2) {
  return function(obj, key) {
    return key === name2;
  };
}
function remove$3(obj, iterate, context) {
  if (obj) {
    if (!eqNull$3(iterate)) {
      var removeKeys = [];
      var rest = [];
      if (!isFunction$b(iterate)) {
        iterate = pluckProperty(iterate);
      }
      each$b(obj, function(item, index, rest2) {
        if (iterate.call(context, item, index, rest2)) {
          removeKeys.push(index);
        }
      });
      if (isArray$i(obj)) {
        lastEach$1(removeKeys, function(item, key) {
          rest.push(obj[item]);
          obj.splice(item, 1);
        });
      } else {
        rest = {};
        arrayEach$7(removeKeys, function(key) {
          rest[key] = obj[key];
          helperDeleteProperty(obj, key);
        });
      }
      return rest;
    }
    return clear$1(obj);
  }
  return obj;
}
var remove_1 = remove$3;
var setupDefaults$8 = setupDefaults_1;
var map$2 = map_1;
var orderBy$1 = orderBy_1;
var clone$1 = clone_1;
var includes$3 = includes_1;
var each$a = each_1;
var remove$2 = remove_1;
var assign$8 = assign_1;
function strictTree(array2, optChildren) {
  each$a(array2, function(item) {
    if (item.children && !item.children.length) {
      remove$2(item, optChildren);
    }
  });
}
function toArrayTree$1(array2, options) {
  var opts = assign$8({}, setupDefaults$8.treeOptions, options);
  var optStrict = opts.strict;
  var optKey = opts.key;
  var optParentKey = opts.parentKey;
  var optChildren = opts.children;
  var optMapChildren = opts.mapChildren;
  var optSortKey = opts.sortKey;
  var optReverse = opts.reverse;
  var optData = opts.data;
  var result = [];
  var treeMap = {};
  var idList, id2, treeData, parentId;
  if (optSortKey) {
    array2 = orderBy$1(clone$1(array2), optSortKey);
    if (optReverse) {
      array2 = array2.reverse();
    }
  }
  idList = map$2(array2, function(item) {
    return item[optKey];
  });
  each$a(array2, function(item) {
    id2 = item[optKey];
    if (optData) {
      treeData = {};
      treeData[optData] = item;
    } else {
      treeData = item;
    }
    parentId = item[optParentKey];
    treeMap[id2] = treeMap[id2] || [];
    treeMap[parentId] = treeMap[parentId] || [];
    treeMap[parentId].push(treeData);
    treeData[optKey] = id2;
    treeData[optParentKey] = parentId;
    treeData[optChildren] = treeMap[id2];
    if (optMapChildren) {
      treeData[optMapChildren] = treeMap[id2];
    }
    if (!optStrict || optStrict && !parentId) {
      if (!includes$3(idList, parentId)) {
        result.push(treeData);
      }
    }
  });
  if (optStrict) {
    strictTree(array2, optChildren);
  }
  return result;
}
var toArrayTree_1 = toArrayTree$1;
var setupDefaults$7 = setupDefaults_1;
var each$9 = each_1;
var assign$7 = assign_1;
function unTreeList(result, array2, opts) {
  var optChildren = opts.children;
  var optData = opts.data;
  var optClear = opts.clear;
  each$9(array2, function(item) {
    var children2 = item[optChildren];
    if (optData) {
      item = item[optData];
    }
    result.push(item);
    if (children2 && children2.length) {
      unTreeList(result, children2, opts);
    }
    if (optClear) {
      delete item[optChildren];
    }
  });
  return result;
}
function toTreeArray$1(array2, options) {
  return unTreeList([], array2, assign$7({}, setupDefaults$7.treeOptions, options));
}
var toTreeArray_1 = toTreeArray$1;
function helperCreateTreeFunc$4(handle) {
  return function(obj, iterate, options, context) {
    var opts = options || {};
    var optChildren = opts.children || "children";
    return handle(null, obj, iterate, context, [], [], optChildren, opts);
  };
}
var helperCreateTreeFunc_1 = helperCreateTreeFunc$4;
var helperCreateTreeFunc$3 = helperCreateTreeFunc_1;
function findTreeItem(parent2, obj, iterate, context, path, node, parseChildren, opts) {
  if (obj) {
    var item, index, len2, paths, nodes, match;
    for (index = 0, len2 = obj.length; index < len2; index++) {
      item = obj[index];
      paths = path.concat(["" + index]);
      nodes = node.concat([item]);
      if (iterate.call(context, item, index, obj, paths, parent2, nodes)) {
        return { index, item, path: paths, items: obj, parent: parent2, nodes };
      }
      if (parseChildren && item) {
        match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren);
        if (match) {
          return match;
        }
      }
    }
  }
}
var findTree$1 = helperCreateTreeFunc$3(findTreeItem);
var findTree_1 = findTree$1;
var helperCreateTreeFunc$2 = helperCreateTreeFunc_1;
var each$8 = each_1;
function eachTreeItem(parent2, obj, iterate, context, path, node, parseChildren, opts) {
  var paths, nodes;
  each$8(obj, function(item, index) {
    paths = path.concat(["" + index]);
    nodes = node.concat([item]);
    iterate.call(context, item, index, obj, paths, parent2, nodes);
    if (item && parseChildren) {
      paths.push(parseChildren);
      eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren);
    }
  });
}
var eachTree$2 = helperCreateTreeFunc$2(eachTreeItem);
var eachTree_1 = eachTree$2;
var helperCreateTreeFunc$1 = helperCreateTreeFunc_1;
var map$1 = map_1;
function mapTreeItem(parent2, obj, iterate, context, path, node, parseChildren, opts) {
  var paths, nodes, rest;
  var mapChildren = opts.mapChildren || parseChildren;
  return map$1(obj, function(item, index) {
    paths = path.concat(["" + index]);
    nodes = node.concat([item]);
    rest = iterate.call(context, item, index, obj, paths, parent2, nodes);
    if (rest && item && parseChildren && item[parseChildren]) {
      rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
    }
    return rest;
  });
}
var mapTree$1 = helperCreateTreeFunc$1(mapTreeItem);
var mapTree_1 = mapTree$1;
var eachTree$1 = eachTree_1;
function filterTree$1(obj, iterate, options, context) {
  var result = [];
  if (obj && iterate) {
    eachTree$1(obj, function(item, index, items, path, parent2, nodes) {
      if (iterate.call(context, item, index, items, path, parent2, nodes)) {
        result.push(item);
      }
    }, options);
  }
  return result;
}
var filterTree_1 = filterTree$1;
var helperCreateTreeFunc = helperCreateTreeFunc_1;
var arrayEach$6 = arrayEach_1;
var assign$6 = assign_1;
function searchTreeItem(parentAllow, parent2, obj, iterate, context, path, node, parseChildren, opts) {
  var paths, nodes, rest, isAllow, hasChild;
  var rests = [];
  var hasOriginal = opts.original;
  var sourceData = opts.data;
  var mapChildren = opts.mapChildren || parseChildren;
  arrayEach$6(obj, function(item, index) {
    paths = path.concat(["" + index]);
    nodes = node.concat([item]);
    isAllow = parentAllow || iterate.call(context, item, index, obj, paths, parent2, nodes);
    hasChild = parseChildren && item[parseChildren];
    if (isAllow || hasChild) {
      if (hasOriginal) {
        rest = item;
      } else {
        rest = assign$6({}, item);
        if (sourceData) {
          rest[sourceData] = item;
        }
      }
      rest[mapChildren] = searchTreeItem(isAllow, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
      if (isAllow || rest[mapChildren].length) {
        rests.push(rest);
      }
    } else if (isAllow) {
      rests.push(rest);
    }
  });
  return rests;
}
var searchTree$1 = helperCreateTreeFunc(function(parent2, obj, iterate, context, path, nodes, parseChildren, opts) {
  return searchTreeItem(0, parent2, obj, iterate, context, path, nodes, parseChildren, opts);
});
var searchTree_1 = searchTree$1;
function arrayIndexOf$2(list, val2) {
  if (list.indexOf) {
    return list.indexOf(val2);
  }
  for (var index = 0, len2 = list.length; index < len2; index++) {
    if (val2 === list[index]) {
      return index;
    }
  }
}
var arrayIndexOf_1 = arrayIndexOf$2;
function arrayLastIndexOf$2(list, val2) {
  if (list.lastIndexOf) {
    return list.lastIndexOf(val2);
  }
  for (var len2 = list.length - 1; len2 >= 0; len2--) {
    if (val2 === list[len2]) {
      return len2;
    }
  }
  return -1;
}
var arrayLastIndexOf_1 = arrayLastIndexOf$2;
var helperCreateInTypeof$2 = helperCreateInTypeof_1;
var isNumber$b = helperCreateInTypeof$2("number");
var isNumber_1 = isNumber$b;
var isNumber$a = isNumber_1;
function isNumberNaN$1(obj) {
  return isNumber$a(obj) && isNaN(obj);
}
var _isNaN = isNumberNaN$1;
var helperCreateInTypeof$1 = helperCreateInTypeof_1;
var isString$c = helperCreateInTypeof$1("string");
var isString_1 = isString$c;
var helperCreateInInObjectString$3 = helperCreateInInObjectString_1;
var isDate$8 = helperCreateInInObjectString$3("Date");
var isDate_1 = isDate$8;
var staticParseInt$5 = parseInt;
var staticParseInt_1 = staticParseInt$5;
function helperGetUTCDateTime$1(resMaps) {
  return Date.UTC(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
}
var helperGetUTCDateTime_1 = helperGetUTCDateTime$1;
function helperGetDateTime$c(date) {
  return date.getTime();
}
var helperGetDateTime_1 = helperGetDateTime$c;
var staticParseInt$4 = staticParseInt_1;
var helperGetUTCDateTime = helperGetUTCDateTime_1;
var helperGetDateTime$b = helperGetDateTime_1;
var isString$b = isString_1;
var isDate$7 = isDate_1;
function getParseRule(txt) {
  return "(\\d{" + txt + "})";
}
function toParseMs(num) {
  if (num < 10) {
    return num * 100;
  } else if (num < 100) {
    return num * 10;
  }
  return num;
}
function toParseNum(num) {
  return isNaN(num) ? num : staticParseInt$4(num);
}
var d2 = getParseRule(2);
var d1or2 = getParseRule("1,2");
var d1or7 = getParseRule("1,7");
var d3or4 = getParseRule("3,4");
var place = ".{1}";
var d1Or2RE = place + d1or2;
var dzZ = "(([zZ])|([-+]\\d{2}:?\\d{2}))";
var defaulParseStrs = [d3or4, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, place + d1or7, dzZ];
var defaulParseREs = [];
for (var len = defaulParseStrs.length - 1; len >= 0; len--) {
  var rule = "";
  for (var i$1 = 0; i$1 < len + 1; i$1++) {
    rule += defaulParseStrs[i$1];
  }
  defaulParseREs.push(new RegExp("^" + rule + "$"));
}
function parseDefaultRules(str) {
  var matchRest, resMaps = {};
  for (var i2 = 0, dfrLen = defaulParseREs.length; i2 < dfrLen; i2++) {
    matchRest = str.match(defaulParseREs[i2]);
    if (matchRest) {
      resMaps.y = matchRest[1];
      resMaps.M = matchRest[2];
      resMaps.d = matchRest[3];
      resMaps.H = matchRest[4];
      resMaps.m = matchRest[5];
      resMaps.s = matchRest[6];
      resMaps.S = matchRest[7];
      resMaps.Z = matchRest[8];
      break;
    }
  }
  return resMaps;
}
var customParseStrs = [
  ["yyyy", d3or4],
  ["yy", d2],
  ["MM", d2],
  ["M", d1or2],
  ["dd", d2],
  ["d", d1or2],
  ["HH", d2],
  ["H", d1or2],
  ["mm", d2],
  ["m", d1or2],
  ["ss", d2],
  ["s", d1or2],
  ["SSS", getParseRule(3)],
  ["S", d1or7],
  ["Z", dzZ]
];
var parseRuleMaps = {};
var parseRuleKeys = ["\\[([^\\]]+)\\]"];
for (var i$1 = 0; i$1 < customParseStrs.length; i$1++) {
  var itemRule = customParseStrs[i$1];
  parseRuleMaps[itemRule[0]] = itemRule[1] + "?";
  parseRuleKeys.push(itemRule[0]);
}
var customParseRes = new RegExp(parseRuleKeys.join("|"), "g");
var cacheFormatMaps = {};
function parseCustomRules(str, format2) {
  var cacheItem = cacheFormatMaps[format2];
  if (!cacheItem) {
    var posIndexs = [];
    var re2 = format2.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(customParseRes, function(text2, val2) {
      var firstChar = text2.charAt(0);
      if (firstChar === "[") {
        return val2;
      }
      posIndexs.push(firstChar);
      return parseRuleMaps[text2];
    });
    cacheItem = cacheFormatMaps[format2] = {
      _i: posIndexs,
      _r: new RegExp(re2)
    };
  }
  var resMaps = {};
  var matchRest = str.match(cacheItem._r);
  if (matchRest) {
    var _i2 = cacheItem._i;
    for (var i2 = 1, len2 = matchRest.length; i2 < len2; i2++) {
      resMaps[_i2[i2 - 1]] = matchRest[i2];
    }
    return resMaps;
  }
  return resMaps;
}
function parseTimeZone(resMaps) {
  if (/^[zZ]/.test(resMaps.Z)) {
    return new Date(helperGetUTCDateTime(resMaps));
  } else {
    var matchRest = resMaps.Z.match(/([-+])(\d{2}):?(\d{2})/);
    if (matchRest) {
      return new Date(helperGetUTCDateTime(resMaps) - (matchRest[1] === "-" ? -1 : 1) * staticParseInt$4(matchRest[2]) * 36e5 + staticParseInt$4(matchRest[3]) * 6e4);
    }
  }
  return new Date("");
}
function toStringDate$d(str, format2) {
  if (str) {
    var isDType = isDate$7(str);
    if (isDType || !format2 && /^[0-9]{11,15}$/.test(str)) {
      return new Date(isDType ? helperGetDateTime$b(str) : staticParseInt$4(str));
    }
    if (isString$b(str)) {
      var resMaps = format2 ? parseCustomRules(str, format2) : parseDefaultRules(str);
      if (resMaps.y) {
        if (resMaps.M) {
          resMaps.M = toParseNum(resMaps.M) - 1;
        }
        if (resMaps.S) {
          resMaps.S = toParseMs(toParseNum(resMaps.S.substring(0, 3)));
        }
        if (resMaps.Z) {
          return parseTimeZone(resMaps);
        } else {
          return new Date(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
        }
      }
    }
  }
  return new Date("");
}
var toStringDate_1 = toStringDate$d;
function helperNewDate$4() {
  return new Date();
}
var helperNewDate_1 = helperNewDate$4;
var isDate$6 = isDate_1;
var toStringDate$c = toStringDate_1;
var helperNewDate$3 = helperNewDate_1;
function isLeapYear$2(date) {
  var year;
  var currentDate = date ? toStringDate$c(date) : helperNewDate$3();
  if (isDate$6(currentDate)) {
    year = currentDate.getFullYear();
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  return false;
}
var isLeapYear_1 = isLeapYear$2;
var isArray$h = isArray_1;
var hasOwnProp$5 = hasOwnProp_1;
function forOf$1(obj, iterate, context) {
  if (obj) {
    if (isArray$h(obj)) {
      for (var index = 0, len2 = obj.length; index < len2; index++) {
        if (iterate.call(context, obj[index], index, obj) === false) {
          break;
        }
      }
    } else {
      for (var key in obj) {
        if (hasOwnProp$5(obj, key)) {
          if (iterate.call(context, obj[key], key, obj) === false) {
            break;
          }
        }
      }
    }
  }
}
var forOf_1 = forOf$1;
var isArray$g = isArray_1;
var keys$8 = hasOwnProp_1;
function lastForOf$1(obj, iterate, context) {
  if (obj) {
    var len2, list;
    if (isArray$g(obj)) {
      for (len2 = obj.length - 1; len2 >= 0; len2--) {
        if (iterate.call(context, obj[len2], len2, obj) === false) {
          break;
        }
      }
    } else {
      list = keys$8(obj);
      for (len2 = list.length - 1; len2 >= 0; len2--) {
        if (iterate.call(context, obj[list[len2]], list[len2], obj) === false) {
          break;
        }
      }
    }
  }
}
var lastForOf_1 = lastForOf$1;
var isArray$f = isArray_1;
var isString$a = isString_1;
var hasOwnProp$4 = hasOwnProp_1;
function helperCreateIndexOf$2(name2, callback) {
  return function(obj, val2) {
    if (obj) {
      if (obj[name2]) {
        return obj[name2](val2);
      }
      if (isString$a(obj) || isArray$f(obj)) {
        return callback(obj, val2);
      }
      for (var key in obj) {
        if (hasOwnProp$4(obj, key)) {
          if (val2 === obj[key]) {
            return key;
          }
        }
      }
    }
    return -1;
  };
}
var helperCreateIndexOf_1 = helperCreateIndexOf$2;
var helperCreateIndexOf$1 = helperCreateIndexOf_1;
var arrayIndexOf$1 = arrayIndexOf_1;
var indexOf$1 = helperCreateIndexOf$1("indexOf", arrayIndexOf$1);
var indexOf_1 = indexOf$1;
var helperCreateIndexOf = helperCreateIndexOf_1;
var arrayLastIndexOf$1 = arrayLastIndexOf_1;
var lastIndexOf$2 = helperCreateIndexOf("lastIndexOf", arrayLastIndexOf$1);
var lastIndexOf_1 = lastIndexOf$2;
var isArray$e = isArray_1;
var isString$9 = isString_1;
var each$7 = each_1;
function getSize$2(obj) {
  var len2 = 0;
  if (isString$9(obj) || isArray$e(obj)) {
    return obj.length;
  }
  each$7(obj, function() {
    len2++;
  });
  return len2;
}
var getSize_1 = getSize$2;
var isNumber$9 = isNumber_1;
function isNumberFinite$1(obj) {
  return isNumber$9(obj) && isFinite(obj);
}
var _isFinite = isNumberFinite$1;
var isArray$d = isArray_1;
var isNull$4 = isNull_1;
var isInteger$2 = function(obj) {
  return !isNull$4(obj) && !isNaN(obj) && !isArray$d(obj) && obj % 1 === 0;
};
var isInteger_1 = isInteger$2;
var isArray$c = isArray_1;
var isInteger$1 = isInteger_1;
var isNull$3 = isNull_1;
function isFloat$1(obj) {
  return !isNull$3(obj) && !isNaN(obj) && !isArray$c(obj) && !isInteger$1(obj);
}
var isFloat_1 = isFloat$1;
var helperCreateInTypeof = helperCreateInTypeof_1;
var isBoolean$3 = helperCreateInTypeof("boolean");
var isBoolean_1 = isBoolean$3;
var helperCreateInInObjectString$2 = helperCreateInInObjectString_1;
var isRegExp$3 = helperCreateInInObjectString$2("RegExp");
var isRegExp_1 = isRegExp$3;
var helperCreateInInObjectString$1 = helperCreateInInObjectString_1;
var isError$2 = helperCreateInInObjectString$1("Error");
var isError_1 = isError$2;
function isTypeError$1(obj) {
  return obj ? obj.constructor === TypeError : false;
}
var isTypeError_1 = isTypeError$1;
function isEmpty$2(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}
var isEmpty_1 = isEmpty$2;
var staticStrUndefined$9 = staticStrUndefined_1;
var supportSymbol = typeof Symbol !== staticStrUndefined$9;
function isSymbol$6(obj) {
  return supportSymbol && Symbol.isSymbol ? Symbol.isSymbol(obj) : typeof obj === "symbol";
}
var isSymbol_1 = isSymbol$6;
var helperCreateInInObjectString = helperCreateInInObjectString_1;
var isArguments$3 = helperCreateInInObjectString("Arguments");
var isArguments_1 = isArguments$3;
var isString$8 = isString_1;
var isNumber$8 = isNumber_1;
function isElement$4(obj) {
  return !!(obj && isString$8(obj.nodeName) && isNumber$8(obj.nodeType));
}
var isElement_1 = isElement$4;
var staticStrUndefined$8 = staticStrUndefined_1;
var staticDocument$3 = typeof document === staticStrUndefined$8 ? 0 : document;
var staticDocument_1 = staticDocument$3;
var staticDocument$2 = staticDocument_1;
function isDocument$1(obj) {
  return !!(obj && staticDocument$2 && obj.nodeType === 9);
}
var isDocument_1 = isDocument$1;
var staticStrUndefined$7 = staticStrUndefined_1;
var staticWindow$2 = typeof window === staticStrUndefined$7 ? 0 : window;
var staticWindow_1 = staticWindow$2;
var staticWindow$1 = staticWindow_1;
function isWindow$1(obj) {
  return staticWindow$1 && !!(obj && obj === obj.window);
}
var isWindow_1 = isWindow$1;
var staticStrUndefined$6 = staticStrUndefined_1;
var supportFormData = typeof FormData !== staticStrUndefined$6;
function isFormData$1(obj) {
  return supportFormData && obj instanceof FormData;
}
var isFormData_1 = isFormData$1;
var staticStrUndefined$5 = staticStrUndefined_1;
var supportMap = typeof Map !== staticStrUndefined$5;
function isMap$1(obj) {
  return supportMap && obj instanceof Map;
}
var isMap_1 = isMap$1;
var staticStrUndefined$4 = staticStrUndefined_1;
var supportWeakMap = typeof WeakMap !== staticStrUndefined$4;
function isWeakMap$1(obj) {
  return supportWeakMap && obj instanceof WeakMap;
}
var isWeakMap_1 = isWeakMap$1;
var staticStrUndefined$3 = staticStrUndefined_1;
var supportSet = typeof Set !== staticStrUndefined$3;
function isSet$1(obj) {
  return supportSet && obj instanceof Set;
}
var isSet_1 = isSet$1;
var staticStrUndefined$2 = staticStrUndefined_1;
var supportWeakSet = typeof WeakSet !== staticStrUndefined$2;
function isWeakSet$1(obj) {
  return supportWeakSet && obj instanceof WeakSet;
}
var isWeakSet_1 = isWeakSet$1;
var isFunction$a = isFunction_1;
var isString$7 = isString_1;
var isArray$b = isArray_1;
var hasOwnProp$3 = hasOwnProp_1;
function helperCreateiterateIndexOf$2(callback) {
  return function(obj, iterate, context) {
    if (obj && isFunction$a(iterate)) {
      if (isArray$b(obj) || isString$7(obj)) {
        return callback(obj, iterate, context);
      }
      for (var key in obj) {
        if (hasOwnProp$3(obj, key)) {
          if (iterate.call(context, obj[key], key, obj)) {
            return key;
          }
        }
      }
    }
    return -1;
  };
}
var helperCreateiterateIndexOf_1 = helperCreateiterateIndexOf$2;
var helperCreateiterateIndexOf$1 = helperCreateiterateIndexOf_1;
var findIndexOf$3 = helperCreateiterateIndexOf$1(function(obj, iterate, context) {
  for (var index = 0, len2 = obj.length; index < len2; index++) {
    if (iterate.call(context, obj[index], index, obj)) {
      return index;
    }
  }
  return -1;
});
var findIndexOf_1 = findIndexOf$3;
var isNumber$7 = isNumber_1;
var isArray$a = isArray_1;
var isString$6 = isString_1;
var isRegExp$2 = isRegExp_1;
var isDate$5 = isDate_1;
var isBoolean$2 = isBoolean_1;
var isUndefined$7 = isUndefined_1;
var keys$7 = keys_1;
var every$1 = every_1;
function helperEqualCompare$2(val1, val2, compare2, func, key, obj1, obj2) {
  if (val1 === val2) {
    return true;
  }
  if (val1 && val2 && !isNumber$7(val1) && !isNumber$7(val2) && !isString$6(val1) && !isString$6(val2)) {
    if (isRegExp$2(val1)) {
      return compare2("" + val1, "" + val2, key, obj1, obj2);
    }
    if (isDate$5(val1) || isBoolean$2(val1)) {
      return compare2(+val1, +val2, key, obj1, obj2);
    } else {
      var result, val1Keys, val2Keys;
      var isObj1Arr = isArray$a(val1);
      var isObj2Arr = isArray$a(val2);
      if (isObj1Arr || isObj2Arr ? isObj1Arr && isObj2Arr : val1.constructor === val2.constructor) {
        val1Keys = keys$7(val1);
        val2Keys = keys$7(val2);
        if (func) {
          result = func(val1, val2, key);
        }
        if (val1Keys.length === val2Keys.length) {
          return isUndefined$7(result) ? every$1(val1Keys, function(key2, index) {
            return key2 === val2Keys[index] && helperEqualCompare$2(val1[key2], val2[val2Keys[index]], compare2, func, isObj1Arr || isObj2Arr ? index : key2, val1, val2);
          }) : !!result;
        }
        return false;
      }
    }
  }
  return compare2(val1, val2, key, obj1, obj2);
}
var helperEqualCompare_1 = helperEqualCompare$2;
function helperDefaultCompare$2(v1, v2) {
  return v1 === v2;
}
var helperDefaultCompare_1 = helperDefaultCompare$2;
var helperEqualCompare$1 = helperEqualCompare_1;
var helperDefaultCompare$1 = helperDefaultCompare_1;
function isEqual$2(obj1, obj2) {
  return helperEqualCompare$1(obj1, obj2, helperDefaultCompare$1);
}
var isEqual_1 = isEqual$2;
var keys$6 = keys_1;
var findIndexOf$2 = findIndexOf_1;
var isEqual$1 = isEqual_1;
var some$1 = some_1;
var includeArrays$1 = includeArrays_1;
function isMatch$1(obj, source) {
  var objKeys = keys$6(obj);
  var sourceKeys = keys$6(source);
  if (sourceKeys.length) {
    if (includeArrays$1(objKeys, sourceKeys)) {
      return some$1(sourceKeys, function(key2) {
        return findIndexOf$2(objKeys, function(key1) {
          return key1 === key2 && isEqual$1(obj[key1], source[key2]);
        }) > -1;
      });
    }
  } else {
    return true;
  }
  return isEqual$1(obj, source);
}
var isMatch_1 = isMatch$1;
var helperEqualCompare = helperEqualCompare_1;
var helperDefaultCompare = helperDefaultCompare_1;
var isFunction$9 = isFunction_1;
var isUndefined$6 = isUndefined_1;
function isEqualWith$1(obj1, obj2, func) {
  if (isFunction$9(func)) {
    return helperEqualCompare(obj1, obj2, function(v1, v2, key, obj12, obj22) {
      var result = func(v1, v2, key, obj12, obj22);
      return isUndefined$6(result) ? helperDefaultCompare(v1, v2) : !!result;
    }, func);
  }
  return helperEqualCompare(obj1, obj2, helperDefaultCompare);
}
var isEqualWith_1 = isEqualWith$1;
var isSymbol$5 = isSymbol_1;
var isDate$4 = isDate_1;
var isArray$9 = isArray_1;
var isRegExp$1 = isRegExp_1;
var isError$1 = isError_1;
var isNull$2 = isNull_1;
function getType$1(obj) {
  if (isNull$2(obj)) {
    return "null";
  }
  if (isSymbol$5(obj)) {
    return "symbol";
  }
  if (isDate$4(obj)) {
    return "date";
  }
  if (isArray$9(obj)) {
    return "array";
  }
  if (isRegExp$1(obj)) {
    return "regexp";
  }
  if (isError$1(obj)) {
    return "error";
  }
  return typeof obj;
}
var getType_1 = getType$1;
var __uniqueId = 0;
function uniqueId$1(prefix) {
  return [prefix, ++__uniqueId].join("");
}
var uniqueId_1 = uniqueId$1;
var helperCreateiterateIndexOf = helperCreateiterateIndexOf_1;
var findLastIndexOf$1 = helperCreateiterateIndexOf(function(obj, iterate, context) {
  for (var len2 = obj.length - 1; len2 >= 0; len2--) {
    if (iterate.call(context, obj[len2], len2, obj)) {
      return len2;
    }
  }
  return -1;
});
var findLastIndexOf_1 = findLastIndexOf$1;
var isPlainObject$3 = isPlainObject_1;
var isString$5 = isString_1;
function toStringJSON$1(str) {
  if (isPlainObject$3(str)) {
    return str;
  } else if (isString$5(str)) {
    try {
      return JSON.parse(str);
    } catch (e3) {
    }
  }
  return {};
}
var toStringJSON_1 = toStringJSON$1;
var eqNull$2 = eqNull_1;
function toJSONString$1(obj) {
  return eqNull$2(obj) ? "" : JSON.stringify(obj);
}
var toJSONString_1 = toJSONString$1;
var helperCreateGetObjects = helperCreateGetObjects_1;
var entries$1 = helperCreateGetObjects("entries", 2);
var entries_1 = entries$1;
var isFunction$8 = isFunction_1;
var isArray$8 = isArray_1;
var each$6 = each_1;
var findIndexOf$1 = findIndexOf_1;
function helperCreatePickOmit$2(case1, case2) {
  return function(obj, callback) {
    var item, index;
    var rest = {};
    var result = [];
    var context = this;
    var args = arguments;
    var len2 = args.length;
    if (!isFunction$8(callback)) {
      for (index = 1; index < len2; index++) {
        item = args[index];
        result.push.apply(result, isArray$8(item) ? item : [item]);
      }
      callback = 0;
    }
    each$6(obj, function(val2, key) {
      if ((callback ? callback.call(context, val2, key, obj) : findIndexOf$1(result, function(name2) {
        return name2 === key;
      }) > -1) ? case1 : case2) {
        rest[key] = val2;
      }
    });
    return rest;
  };
}
var helperCreatePickOmit_1 = helperCreatePickOmit$2;
var helperCreatePickOmit$1 = helperCreatePickOmit_1;
var pick$1 = helperCreatePickOmit$1(1, 0);
var pick_1 = pick$1;
var helperCreatePickOmit = helperCreatePickOmit_1;
var omit$1 = helperCreatePickOmit(0, 1);
var omit_1 = omit$1;
var values$3 = values_1;
function first$1(obj) {
  return values$3(obj)[0];
}
var first_1 = first$1;
var values$2 = values_1;
function last$1(obj) {
  var list = values$2(obj);
  return list[list.length - 1];
}
var last_1 = last$1;
var staticHGKeyRE = staticHGKeyRE_1;
var helperGetHGSKeys$1 = helperGetHGSKeys_1;
var hasOwnProp$2 = hasOwnProp_1;
function has$1(obj, property2) {
  if (obj) {
    if (hasOwnProp$2(obj, property2)) {
      return true;
    } else {
      var prop, arrIndex, objProp, matchs, rest, isHas;
      var props = helperGetHGSKeys$1(property2);
      var index = 0;
      var len2 = props.length;
      for (rest = obj; index < len2; index++) {
        isHas = false;
        prop = props[index];
        matchs = prop ? prop.match(staticHGKeyRE) : "";
        if (matchs) {
          arrIndex = matchs[1];
          objProp = matchs[2];
          if (arrIndex) {
            if (rest[arrIndex]) {
              if (hasOwnProp$2(rest[arrIndex], objProp)) {
                isHas = true;
                rest = rest[arrIndex][objProp];
              }
            }
          } else {
            if (hasOwnProp$2(rest, objProp)) {
              isHas = true;
              rest = rest[objProp];
            }
          }
        } else {
          if (hasOwnProp$2(rest, prop)) {
            isHas = true;
            rest = rest[prop];
          }
        }
        if (isHas) {
          if (index === len2 - 1) {
            return true;
          }
        } else {
          break;
        }
      }
    }
  }
  return false;
}
var has_1 = has$1;
var staticParseInt$3 = staticParseInt_1;
var helperGetHGSKeys = helperGetHGSKeys_1;
var hasOwnProp$1 = hasOwnProp_1;
var sKeyRE = /(.+)?\[(\d+)\]$/;
function setDeepProps(obj, key, isEnd, nextKey, value) {
  if (obj[key]) {
    if (isEnd) {
      obj[key] = value;
    }
  } else {
    var index;
    var rest;
    var currMatchs = key ? key.match(sKeyRE) : null;
    if (isEnd) {
      rest = value;
    } else {
      var nextMatchs = nextKey ? nextKey.match(sKeyRE) : null;
      if (nextMatchs && !nextMatchs[1]) {
        rest = new Array(staticParseInt$3(nextMatchs[2]) + 1);
      } else {
        rest = {};
      }
    }
    if (currMatchs) {
      if (currMatchs[1]) {
        index = staticParseInt$3(currMatchs[2]);
        if (obj[currMatchs[1]]) {
          if (isEnd) {
            obj[currMatchs[1]][index] = rest;
          } else {
            if (obj[currMatchs[1]][index]) {
              rest = obj[currMatchs[1]][index];
            } else {
              obj[currMatchs[1]][index] = rest;
            }
          }
        } else {
          obj[currMatchs[1]] = new Array(index + 1);
          obj[currMatchs[1]][index] = rest;
        }
      } else {
        obj[currMatchs[2]] = rest;
      }
    } else {
      obj[key] = rest;
    }
    return rest;
  }
  return obj[key];
}
function set$1(obj, property2, value) {
  if (obj) {
    if ((obj[property2] || hasOwnProp$1(obj, property2)) && !isPrototypePolluted(property2)) {
      obj[property2] = value;
    } else {
      var rest = obj;
      var props = helperGetHGSKeys(property2);
      var len2 = props.length;
      for (var index = 0; index < len2; index++) {
        if (isPrototypePolluted(props[index])) {
          continue;
        }
        var isEnd = index === len2 - 1;
        rest = setDeepProps(rest, props[index], isEnd, isEnd ? null : props[index + 1], value);
      }
    }
  }
  return obj;
}
function isPrototypePolluted(key) {
  return key === "__proto__" || key === "constructor" || key === "prototype";
}
var set_1 = set$1;
var isEmpty$1 = isEmpty_1;
var isObject$a = isObject_1;
var isFunction$7 = isFunction_1;
var property$1 = property_1;
var each$5 = each_1;
function createiterateEmpty(iterate) {
  return function() {
    return isEmpty$1(iterate);
  };
}
function groupBy$2(obj, iterate, context) {
  var groupKey;
  var result = {};
  if (obj) {
    if (iterate && isObject$a(iterate)) {
      iterate = createiterateEmpty(iterate);
    } else if (!isFunction$7(iterate)) {
      iterate = property$1(iterate);
    }
    each$5(obj, function(val2, key) {
      groupKey = iterate ? iterate.call(context, val2, key, obj) : val2;
      if (result[groupKey]) {
        result[groupKey].push(val2);
      } else {
        result[groupKey] = [val2];
      }
    });
  }
  return result;
}
var groupBy_1 = groupBy$2;
var groupBy$1 = groupBy_1;
var objectEach$1 = objectEach_1;
function countBy$1(obj, iterate, context) {
  var result = groupBy$1(obj, iterate, context || this);
  objectEach$1(result, function(item, key) {
    result[key] = item.length;
  });
  return result;
}
var countBy_1 = countBy$1;
function range$1(start2, stop2, step) {
  var index, len2;
  var result = [];
  var args = arguments;
  if (args.length < 2) {
    stop2 = args[0];
    start2 = 0;
  }
  index = start2 >> 0;
  len2 = stop2 >> 0;
  if (index < stop2) {
    step = step >> 0 || 1;
    for (; index < len2; index += step) {
      result.push(index);
    }
  }
  return result;
}
var range_1 = range$1;
var keys$5 = keys_1;
var slice$6 = slice_1;
var includes$2 = includes_1;
var arrayEach$5 = arrayEach_1;
var assign$5 = assign_1;
function destructuring$1(destination, sources) {
  if (destination && sources) {
    var rest = assign$5.apply(this, [{}].concat(slice$6(arguments, 1)));
    var restKeys = keys$5(rest);
    arrayEach$5(keys$5(destination), function(key) {
      if (includes$2(restKeys, key)) {
        destination[key] = rest[key];
      }
    });
  }
  return destination;
}
var destructuring_1 = destructuring$1;
var helperCreateMinMax = helperCreateMinMax_1;
var min$1 = helperCreateMinMax(function(rest, itemVal) {
  return rest > itemVal;
});
var min_1 = min$1;
function helperNumberDecimal$4(numStr) {
  return (numStr.split(".")[1] || "").length;
}
var helperNumberDecimal_1 = helperNumberDecimal$4;
var staticParseInt$2 = staticParseInt_1;
function helperStringRepeat$5(str, count) {
  if (str.repeat) {
    return str.repeat(count);
  }
  var list = isNaN(count) ? [] : new Array(staticParseInt$2(count));
  return list.join(str) + (list.length > 0 ? str : "");
}
var helperStringRepeat_1 = helperStringRepeat$5;
function helperNumberOffsetPoint$2(str, offsetIndex) {
  return str.substring(0, offsetIndex) + "." + str.substring(offsetIndex, str.length);
}
var helperNumberOffsetPoint_1 = helperNumberOffsetPoint$2;
var helperStringRepeat$4 = helperStringRepeat_1;
var helperNumberOffsetPoint$1 = helperNumberOffsetPoint_1;
function toNumberString$8(num) {
  var rest = "" + num;
  var scienceMatchs = rest.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
  if (scienceMatchs) {
    var isNegative = num < 0;
    var absFlag = isNegative ? "-" : "";
    var intNumStr = scienceMatchs[3] || "";
    var dIntNumStr = scienceMatchs[5] || "";
    var dFloatNumStr = scienceMatchs[6] || "";
    var sciencFlag = scienceMatchs[7];
    var scienceNumStr = scienceMatchs[8];
    var floatOffsetIndex = scienceNumStr - dFloatNumStr.length;
    var intOffsetIndex = scienceNumStr - intNumStr.length;
    var dIntOffsetIndex = scienceNumStr - dIntNumStr.length;
    if (sciencFlag === "+") {
      if (intNumStr) {
        return absFlag + intNumStr + helperStringRepeat$4("0", scienceNumStr);
      }
      if (floatOffsetIndex > 0) {
        return absFlag + dIntNumStr + dFloatNumStr + helperStringRepeat$4("0", floatOffsetIndex);
      }
      return absFlag + dIntNumStr + helperNumberOffsetPoint$1(dFloatNumStr, scienceNumStr);
    }
    if (intNumStr) {
      if (intOffsetIndex > 0) {
        return absFlag + "0." + helperStringRepeat$4("0", Math.abs(intOffsetIndex)) + intNumStr;
      }
      return absFlag + helperNumberOffsetPoint$1(intNumStr, intOffsetIndex);
    }
    if (dIntOffsetIndex > 0) {
      return absFlag + "0." + helperStringRepeat$4("0", Math.abs(dIntOffsetIndex)) + dIntNumStr + dFloatNumStr;
    }
    return absFlag + helperNumberOffsetPoint$1(dIntNumStr, dIntOffsetIndex) + dFloatNumStr;
  }
  return rest;
}
var toNumberString_1 = toNumberString$8;
var helperNumberDecimal$3 = helperNumberDecimal_1;
var toNumberString$7 = toNumberString_1;
function helperMultiply$2(multiplier, multiplicand) {
  var str1 = toNumberString$7(multiplier);
  var str2 = toNumberString$7(multiplicand);
  return parseInt(str1.replace(".", "")) * parseInt(str2.replace(".", "")) / Math.pow(10, helperNumberDecimal$3(str1) + helperNumberDecimal$3(str2));
}
var helperMultiply_1 = helperMultiply$2;
var helperMultiply$1 = helperMultiply_1;
var toNumber$8 = toNumber_1;
var toNumberString$6 = toNumberString_1;
function helperCreateMathNumber$3(name2) {
  return function(num, digits) {
    var numRest = toNumber$8(num);
    var rest = numRest;
    if (numRest) {
      digits = digits >> 0;
      var numStr = toNumberString$6(numRest);
      var nums = numStr.split(".");
      var intStr = nums[0];
      var floatStr = nums[1] || "";
      var fStr = floatStr.substring(0, digits + 1);
      var subRest = intStr + (fStr ? "." + fStr : "");
      if (digits >= floatStr.length) {
        return toNumber$8(subRest);
      }
      subRest = numRest;
      if (digits > 0) {
        var ratio = Math.pow(10, digits);
        rest = Math[name2](helperMultiply$1(subRest, ratio)) / ratio;
      } else {
        rest = Math[name2](subRest);
      }
    }
    return rest;
  };
}
var helperCreateMathNumber_1 = helperCreateMathNumber$3;
var helperCreateMathNumber$2 = helperCreateMathNumber_1;
var round$3 = helperCreateMathNumber$2("round");
var round_1 = round$3;
var helperCreateMathNumber$1 = helperCreateMathNumber_1;
var ceil$2 = helperCreateMathNumber$1("ceil");
var ceil_1 = ceil$2;
var helperCreateMathNumber = helperCreateMathNumber_1;
var floor$2 = helperCreateMathNumber("floor");
var floor_1 = floor$2;
var eqNull$1 = eqNull_1;
var isNumber$6 = isNumber_1;
var toNumberString$5 = toNumberString_1;
function toValueString$e(obj) {
  if (isNumber$6(obj)) {
    return toNumberString$5(obj);
  }
  return "" + (eqNull$1(obj) ? "" : obj);
}
var toValueString_1 = toValueString$e;
var round$2 = round_1;
var toValueString$d = toValueString_1;
var helperStringRepeat$3 = helperStringRepeat_1;
var helperNumberOffsetPoint = helperNumberOffsetPoint_1;
function toFixed$3(num, digits) {
  digits = digits >> 0;
  var str = toValueString$d(round$2(num, digits));
  var nums = str.split(".");
  var intStr = nums[0];
  var floatStr = nums[1] || "";
  var digitOffsetIndex = digits - floatStr.length;
  if (digits) {
    if (digitOffsetIndex > 0) {
      return intStr + "." + floatStr + helperStringRepeat$3("0", digitOffsetIndex);
    }
    return intStr + helperNumberOffsetPoint(floatStr, Math.abs(digitOffsetIndex));
  }
  return intStr;
}
var toFixed_1 = toFixed$3;
var setupDefaults$6 = setupDefaults_1;
var round$1 = round_1;
var ceil$1 = ceil_1;
var floor$1 = floor_1;
var isNumber$5 = isNumber_1;
var toValueString$c = toValueString_1;
var toFixed$2 = toFixed_1;
var toNumberString$4 = toNumberString_1;
var assign$4 = assign_1;
function commafy$1(num, options) {
  var opts = assign$4({}, setupDefaults$6.commafyOptions, options);
  var optDigits = opts.digits;
  var isNum = isNumber$5(num);
  var rest, result, isNegative, intStr, floatStr;
  if (isNum) {
    rest = (opts.ceil ? ceil$1 : opts.floor ? floor$1 : round$1)(num, optDigits);
    result = toNumberString$4(optDigits ? toFixed$2(rest, optDigits) : rest).split(".");
    intStr = result[0];
    floatStr = result[1];
    isNegative = intStr && rest < 0;
    if (isNegative) {
      intStr = intStr.substring(1, intStr.length);
    }
  } else {
    rest = toValueString$c(num).replace(/,/g, "");
    result = rest ? [rest] : [];
    intStr = result[0];
  }
  if (result.length) {
    return (isNegative ? "-" : "") + intStr.replace(new RegExp("(?=(?!(\\b))(.{" + (opts.spaceNumber || 3) + "})+$)", "g"), opts.separator || ",") + (floatStr ? "." + floatStr : "");
  }
  return rest;
}
var commafy_1 = commafy$1;
var staticParseInt$1 = staticParseInt_1;
var helperCreateToNumber = helperCreateToNumber_1;
var toInteger$1 = helperCreateToNumber(staticParseInt$1);
var toInteger_1 = toInteger$1;
var helperMultiply = helperMultiply_1;
var toNumber$7 = toNumber_1;
function multiply$3(num1, num2) {
  var multiplier = toNumber$7(num1);
  var multiplicand = toNumber$7(num2);
  return helperMultiply(multiplier, multiplicand);
}
var multiply_1 = multiply$3;
var helperNumberDecimal$2 = helperNumberDecimal_1;
var toNumberString$3 = toNumberString_1;
var multiply$2 = multiply_1;
function helperNumberAdd$2(addend, augend) {
  var str1 = toNumberString$3(addend);
  var str2 = toNumberString$3(augend);
  var ratio = Math.pow(10, Math.max(helperNumberDecimal$2(str1), helperNumberDecimal$2(str2)));
  return (multiply$2(addend, ratio) + multiply$2(augend, ratio)) / ratio;
}
var helperNumberAdd_1 = helperNumberAdd$2;
var helperNumberAdd$1 = helperNumberAdd_1;
var toNumber$6 = toNumber_1;
function add$1(num1, num2) {
  return helperNumberAdd$1(toNumber$6(num1), toNumber$6(num2));
}
var add_1 = add$1;
var helperNumberDecimal$1 = helperNumberDecimal_1;
var toNumberString$2 = toNumberString_1;
var toNumber$5 = toNumber_1;
var toFixed$1 = toFixed_1;
function subtract$1(num1, num2) {
  var subtrahend = toNumber$5(num1);
  var minuend = toNumber$5(num2);
  var str1 = toNumberString$2(subtrahend);
  var str2 = toNumberString$2(minuend);
  var digit1 = helperNumberDecimal$1(str1);
  var digit2 = helperNumberDecimal$1(str2);
  var ratio = Math.pow(10, Math.max(digit1, digit2));
  var precision = digit1 >= digit2 ? digit1 : digit2;
  return parseFloat(toFixed$1((subtrahend * ratio - minuend * ratio) / ratio, precision));
}
var subtract_1 = subtract$1;
var helperNumberDecimal = helperNumberDecimal_1;
var toNumberString$1 = toNumberString_1;
var multiply$1 = multiply_1;
function helperNumberDivide$2(divisor, dividend) {
  var str1 = toNumberString$1(divisor);
  var str2 = toNumberString$1(dividend);
  var divisorDecimal = helperNumberDecimal(str1);
  var dividendDecimal = helperNumberDecimal(str2);
  var powY = dividendDecimal - divisorDecimal;
  var isMinus = powY < 0;
  var multiplicand = Math.pow(10, isMinus ? Math.abs(powY) : powY);
  return multiply$1(str1.replace(".", "") / str2.replace(".", ""), isMinus ? 1 / multiplicand : multiplicand);
}
var helperNumberDivide_1 = helperNumberDivide$2;
var helperNumberDivide$1 = helperNumberDivide_1;
var toNumber$4 = toNumber_1;
function divide$1(num1, num2) {
  return helperNumberDivide$1(toNumber$4(num1), toNumber$4(num2));
}
var divide_1 = divide$1;
var helperNumberAdd = helperNumberAdd_1;
var isFunction$6 = isFunction_1;
var each$4 = each_1;
var get$3 = get_1;
function sum$2(array2, iterate, context) {
  var result = 0;
  each$4(array2, iterate ? isFunction$6(iterate) ? function() {
    result = helperNumberAdd(result, iterate.apply(context, arguments));
  } : function(val2) {
    result = helperNumberAdd(result, get$3(val2, iterate));
  } : function(val2) {
    result = helperNumberAdd(result, val2);
  });
  return result;
}
var sum_1 = sum$2;
var helperNumberDivide = helperNumberDivide_1;
var getSize$1 = getSize_1;
var sum$1 = sum_1;
function mean$1(array2, iterate, context) {
  return helperNumberDivide(sum$1(array2, iterate, context), getSize$1(array2));
}
var mean_1 = mean$1;
var staticStrFirst$5 = "first";
var staticStrFirst_1 = staticStrFirst$5;
var staticStrLast$4 = "last";
var staticStrLast_1 = staticStrLast$4;
function helperGetDateFullYear$5(date) {
  return date.getFullYear();
}
var helperGetDateFullYear_1 = helperGetDateFullYear$5;
var staticDayTime$5 = 864e5;
var staticDayTime_1 = staticDayTime$5;
function helperGetDateMonth$4(date) {
  return date.getMonth();
}
var helperGetDateMonth_1 = helperGetDateMonth$4;
var isDate$3 = isDate_1;
var helperGetDateTime$a = helperGetDateTime_1;
function isValidDate$c(val2) {
  return isDate$3(val2) && !isNaN(helperGetDateTime$a(val2));
}
var isValidDate_1 = isValidDate$c;
var staticStrFirst$4 = staticStrFirst_1;
var staticStrLast$3 = staticStrLast_1;
var staticDayTime$4 = staticDayTime_1;
var helperGetDateFullYear$4 = helperGetDateFullYear_1;
var helperGetDateTime$9 = helperGetDateTime_1;
var helperGetDateMonth$3 = helperGetDateMonth_1;
var toStringDate$b = toStringDate_1;
var isValidDate$b = isValidDate_1;
var isNumber$4 = isNumber_1;
function getWhatMonth$5(date, offsetMonth, offsetDay) {
  var monthNum = offsetMonth && !isNaN(offsetMonth) ? offsetMonth : 0;
  date = toStringDate$b(date);
  if (isValidDate$b(date)) {
    if (offsetDay === staticStrFirst$4) {
      return new Date(helperGetDateFullYear$4(date), helperGetDateMonth$3(date) + monthNum, 1);
    } else if (offsetDay === staticStrLast$3) {
      return new Date(helperGetDateTime$9(getWhatMonth$5(date, monthNum + 1, staticStrFirst$4)) - 1);
    } else if (isNumber$4(offsetDay)) {
      date.setDate(offsetDay);
    }
    if (monthNum) {
      var currDate = date.getDate();
      date.setMonth(helperGetDateMonth$3(date) + monthNum);
      if (currDate !== date.getDate()) {
        date.setDate(1);
        return new Date(helperGetDateTime$9(date) - staticDayTime$4);
      }
    }
  }
  return date;
}
var getWhatMonth_1 = getWhatMonth$5;
var staticStrFirst$3 = staticStrFirst_1;
var staticStrLast$2 = staticStrLast_1;
var helperGetDateFullYear$3 = helperGetDateFullYear_1;
var getWhatMonth$4 = getWhatMonth_1;
var toStringDate$a = toStringDate_1;
var isValidDate$a = isValidDate_1;
function getWhatYear$4(date, offset2, month) {
  var number2;
  date = toStringDate$a(date);
  if (isValidDate$a(date)) {
    if (offset2) {
      number2 = offset2 && !isNaN(offset2) ? offset2 : 0;
      date.setFullYear(helperGetDateFullYear$3(date) + number2);
    }
    if (month || !isNaN(month)) {
      if (month === staticStrFirst$3) {
        return new Date(helperGetDateFullYear$3(date), 0, 1);
      } else if (month === staticStrLast$2) {
        date.setMonth(11);
        return getWhatMonth$4(date, 0, staticStrLast$2);
      } else {
        date.setMonth(month);
      }
    }
  }
  return date;
}
var getWhatYear_1 = getWhatYear$4;
var getWhatMonth$3 = getWhatMonth_1;
var toStringDate$9 = toStringDate_1;
var isValidDate$9 = isValidDate_1;
function getQuarterNumber(date) {
  var month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
function getWhatQuarter$1(date, offset2, day) {
  var currMonth, monthOffset = offset2 && !isNaN(offset2) ? offset2 * 3 : 0;
  date = toStringDate$9(date);
  if (isValidDate$9(date)) {
    currMonth = (getQuarterNumber(date) - 1) * 3;
    date.setMonth(currMonth);
    return getWhatMonth$3(date, monthOffset, day);
  }
  return date;
}
var getWhatQuarter_1 = getWhatQuarter$1;
var staticStrFirst$2 = staticStrFirst_1;
var staticStrLast$1 = staticStrLast_1;
var staticParseInt = staticParseInt_1;
var helperGetDateFullYear$2 = helperGetDateFullYear_1;
var helperGetDateMonth$2 = helperGetDateMonth_1;
var helperGetDateTime$8 = helperGetDateTime_1;
var toStringDate$8 = toStringDate_1;
var isValidDate$8 = isValidDate_1;
function getWhatDay$2(date, offset2, mode) {
  date = toStringDate$8(date);
  if (isValidDate$8(date) && !isNaN(offset2)) {
    date.setDate(date.getDate() + staticParseInt(offset2));
    if (mode === staticStrFirst$2) {
      return new Date(helperGetDateFullYear$2(date), helperGetDateMonth$2(date), date.getDate());
    } else if (mode === staticStrLast$1) {
      return new Date(helperGetDateTime$8(getWhatDay$2(date, 1, staticStrFirst$2)) - 1);
    }
  }
  return date;
}
var getWhatDay_1 = getWhatDay$2;
function helperStringUpperCase$2(str) {
  return str.toUpperCase();
}
var helperStringUpperCase_1 = helperStringUpperCase$2;
var staticDayTime$3 = staticDayTime_1;
var staticWeekTime$2 = staticDayTime$3 * 7;
var staticWeekTime_1 = staticWeekTime$2;
var setupDefaults$5 = setupDefaults_1;
var staticDayTime$2 = staticDayTime_1;
var staticWeekTime$1 = staticWeekTime_1;
var helperGetDateTime$7 = helperGetDateTime_1;
var toStringDate$7 = toStringDate_1;
var isValidDate$7 = isValidDate_1;
var isNumber$3 = isNumber_1;
function getWhatWeek$2(date, offsetWeek, offsetDay, firstDay) {
  date = toStringDate$7(date);
  if (isValidDate$7(date)) {
    var hasCustomDay = isNumber$3(offsetDay);
    var hasStartDay = isNumber$3(firstDay);
    var whatDayTime = helperGetDateTime$7(date);
    if (hasCustomDay || hasStartDay) {
      var viewStartDay = hasStartDay ? firstDay : setupDefaults$5.firstDayOfWeek;
      var currentDay = date.getDay();
      var customDay = hasCustomDay ? offsetDay : currentDay;
      if (currentDay !== customDay) {
        var offsetNum = 0;
        if (viewStartDay > currentDay) {
          offsetNum = -(7 - viewStartDay + currentDay);
        } else if (viewStartDay < currentDay) {
          offsetNum = viewStartDay - currentDay;
        }
        if (customDay > viewStartDay) {
          whatDayTime += ((customDay === 0 ? 7 : customDay) - viewStartDay + offsetNum) * staticDayTime$2;
        } else if (customDay < viewStartDay) {
          whatDayTime += (7 - viewStartDay + customDay + offsetNum) * staticDayTime$2;
        } else {
          whatDayTime += offsetNum * staticDayTime$2;
        }
      }
    }
    if (offsetWeek && !isNaN(offsetWeek)) {
      whatDayTime += offsetWeek * staticWeekTime$1;
    }
    return new Date(whatDayTime);
  }
  return date;
}
var getWhatWeek_1 = getWhatWeek$2;
var setupDefaults$4 = setupDefaults_1;
var staticWeekTime = staticWeekTime_1;
var isNumber$2 = isNumber_1;
var isValidDate$6 = isValidDate_1;
var getWhatWeek$1 = getWhatWeek_1;
var helperGetDateTime$6 = helperGetDateTime_1;
function helperCreateGetDateWeek$2(getStartDate) {
  return function(date, firstDay) {
    var viewStartDay = isNumber$2(firstDay) ? firstDay : setupDefaults$4.firstDayOfWeek;
    var targetDate = getWhatWeek$1(date, 0, viewStartDay, viewStartDay);
    if (isValidDate$6(targetDate)) {
      var targetOffsetDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
      var targerStartDate = getStartDate(targetDate);
      var targetFirstDay = targerStartDate.getDay();
      if (targetFirstDay > viewStartDay) {
        targerStartDate.setDate(7 - targetFirstDay + viewStartDay + 1);
      }
      if (targetFirstDay < viewStartDay) {
        targerStartDate.setDate(viewStartDay - targetFirstDay + 1);
      }
      return Math.floor((helperGetDateTime$6(targetOffsetDate) - helperGetDateTime$6(targerStartDate)) / staticWeekTime + 1);
    }
    return NaN;
  };
}
var helperCreateGetDateWeek_1 = helperCreateGetDateWeek$2;
var helperCreateGetDateWeek$1 = helperCreateGetDateWeek_1;
var getYearWeek$2 = helperCreateGetDateWeek$1(function(targetDate) {
  return new Date(targetDate.getFullYear(), 0, 1);
});
var getYearWeek_1 = getYearWeek$2;
var helperGetDateFullYear$1 = helperGetDateFullYear_1;
var helperGetDateMonth$1 = helperGetDateMonth_1;
function helperGetYMD$1(date) {
  return new Date(helperGetDateFullYear$1(date), helperGetDateMonth$1(date), date.getDate());
}
var helperGetYMD_1 = helperGetYMD$1;
var helperGetDateTime$5 = helperGetDateTime_1;
var helperGetYMD = helperGetYMD_1;
function helperGetYMDTime$1(date) {
  return helperGetDateTime$5(helperGetYMD(date));
}
var helperGetYMDTime_1 = helperGetYMDTime$1;
var staticDayTime$1 = staticDayTime_1;
var staticStrFirst$1 = staticStrFirst_1;
var helperGetYMDTime = helperGetYMDTime_1;
var getWhatYear$3 = getWhatYear_1;
var toStringDate$6 = toStringDate_1;
var isValidDate$5 = isValidDate_1;
function getYearDay$2(date) {
  date = toStringDate$6(date);
  if (isValidDate$5(date)) {
    return Math.floor((helperGetYMDTime(date) - helperGetYMDTime(getWhatYear$3(date, 0, staticStrFirst$1))) / staticDayTime$1) + 1;
  }
  return NaN;
}
var getYearDay_1 = getYearDay$2;
var toValueString$b = toValueString_1;
var isUndefined$5 = isUndefined_1;
var helperStringRepeat$2 = helperStringRepeat_1;
function padStart$2(str, targetLength, padString) {
  var rest = toValueString$b(str);
  targetLength = targetLength >> 0;
  padString = isUndefined$5(padString) ? " " : "" + padString;
  if (rest.padStart) {
    return rest.padStart(targetLength, padString);
  }
  if (targetLength > rest.length) {
    targetLength -= rest.length;
    if (targetLength > padString.length) {
      padString += helperStringRepeat$2(padString, targetLength / padString.length);
    }
    return padString.slice(0, targetLength) + rest;
  }
  return rest;
}
var padStart_1 = padStart$2;
var setupDefaults$3 = setupDefaults_1;
var helperStringUpperCase$1 = helperStringUpperCase_1;
var helperGetDateFullYear = helperGetDateFullYear_1;
var helperGetDateMonth = helperGetDateMonth_1;
var toStringDate$5 = toStringDate_1;
var getYearWeek$1 = getYearWeek_1;
var getYearDay$1 = getYearDay_1;
var assign$3 = assign_1;
var isValidDate$4 = isValidDate_1;
var isFunction$5 = isFunction_1;
var padStart$1 = padStart_1;
function handleCustomTemplate(date, formats2, match, value) {
  var format2 = formats2[match];
  if (format2) {
    if (isFunction$5(format2)) {
      return format2(value, match, date);
    } else {
      return format2[value];
    }
  }
  return value;
}
var dateFormatRE = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
function toDateString$2(date, format2, options) {
  if (date) {
    date = toStringDate$5(date);
    if (isValidDate$4(date)) {
      var result = format2 || setupDefaults$3.parseDateFormat || setupDefaults$3.formatString;
      var hours = date.getHours();
      var apm = hours < 12 ? "am" : "pm";
      var formats2 = assign$3({}, setupDefaults$3.parseDateRules || setupDefaults$3.formatStringMatchs, options ? options.formats : null);
      var fy = function(match, length2) {
        return ("" + helperGetDateFullYear(date)).substr(4 - length2);
      };
      var fM = function(match, length2) {
        return padStart$1(helperGetDateMonth(date) + 1, length2, "0");
      };
      var fd2 = function(match, length2) {
        return padStart$1(date.getDate(), length2, "0");
      };
      var fH = function(match, length2) {
        return padStart$1(hours, length2, "0");
      };
      var fh2 = function(match, length2) {
        return padStart$1(hours <= 12 ? hours : hours - 12, length2, "0");
      };
      var fm = function(match, length2) {
        return padStart$1(date.getMinutes(), length2, "0");
      };
      var fs2 = function(match, length2) {
        return padStart$1(date.getSeconds(), length2, "0");
      };
      var fS = function(match, length2) {
        return padStart$1(date.getMilliseconds(), length2, "0");
      };
      var fZ = function(match, length2) {
        var zoneHours = date.getTimezoneOffset() / 60 * -1;
        return handleCustomTemplate(date, formats2, match, (zoneHours >= 0 ? "+" : "-") + padStart$1(zoneHours, 2, "0") + (length2 === 1 ? ":" : "") + "00");
      };
      var fW = function(match, length2) {
        return padStart$1(handleCustomTemplate(date, formats2, match, getYearWeek$1(date, (options ? options.firstDay : null) || setupDefaults$3.firstDayOfWeek)), length2, "0");
      };
      var fD = function(match, length2) {
        return padStart$1(handleCustomTemplate(date, formats2, match, getYearDay$1(date)), length2, "0");
      };
      var parseDates = {
        yyyy: fy,
        yy: fy,
        MM: fM,
        M: fM,
        dd: fd2,
        d: fd2,
        HH: fH,
        H: fH,
        hh: fh2,
        h: fh2,
        mm: fm,
        m: fm,
        ss: fs2,
        s: fs2,
        SSS: fS,
        S: fS,
        ZZ: fZ,
        Z: fZ,
        WW: fW,
        W: fW,
        DDD: fD,
        D: fD,
        a: function(match) {
          return handleCustomTemplate(date, formats2, match, apm);
        },
        A: function(match) {
          return handleCustomTemplate(date, formats2, match, helperStringUpperCase$1(apm));
        },
        e: function(match) {
          return handleCustomTemplate(date, formats2, match, date.getDay());
        },
        E: function(match) {
          return handleCustomTemplate(date, formats2, match, date.getDay());
        },
        q: function(match) {
          return handleCustomTemplate(date, formats2, match, Math.floor((helperGetDateMonth(date) + 3) / 3));
        }
      };
      return result.replace(dateFormatRE, function(match, skip) {
        return skip || (parseDates[match] ? parseDates[match](match, match.length) : match);
      });
    }
    return "Invalid Date";
  }
  return "";
}
var toDateString_1 = toDateString$2;
var helperGetDateTime$4 = helperGetDateTime_1;
var helperNewDate$2 = helperNewDate_1;
var now$6 = Date.now || function() {
  return helperGetDateTime$4(helperNewDate$2());
};
var now_1 = now$6;
var helperGetDateTime$3 = helperGetDateTime_1;
var now$5 = now_1;
var toStringDate$4 = toStringDate_1;
var isDate$2 = isDate_1;
var timestamp$1 = function(str, format2) {
  if (str) {
    var date = toStringDate$4(str, format2);
    return isDate$2(date) ? helperGetDateTime$3(date) : date;
  }
  return now$5();
};
var timestamp_1 = timestamp$1;
var toDateString$1 = toDateString_1;
function isDateSame$1(date1, date2, format2) {
  if (date1 && date2) {
    date1 = toDateString$1(date1, format2);
    return date1 !== "Invalid Date" && date1 === toDateString$1(date2, format2);
  }
  return false;
}
var isDateSame_1 = isDateSame$1;
var helperCreateGetDateWeek = helperCreateGetDateWeek_1;
var getMonthWeek$1 = helperCreateGetDateWeek(function(targetDate) {
  return new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
});
var getMonthWeek_1 = getMonthWeek$1;
var getWhatYear$2 = getWhatYear_1;
var toStringDate$3 = toStringDate_1;
var isValidDate$3 = isValidDate_1;
var isLeapYear$1 = isLeapYear_1;
function getDayOfYear$1(date, year) {
  date = toStringDate$3(date);
  if (isValidDate$3(date)) {
    return isLeapYear$1(getWhatYear$2(date, year)) ? 366 : 365;
  }
  return NaN;
}
var getDayOfYear_1 = getDayOfYear$1;
var staticDayTime = staticDayTime_1;
var staticStrFirst = staticStrFirst_1;
var staticStrLast = staticStrLast_1;
var helperGetDateTime$2 = helperGetDateTime_1;
var getWhatMonth$2 = getWhatMonth_1;
var toStringDate$2 = toStringDate_1;
var isValidDate$2 = isValidDate_1;
function getDayOfMonth$1(date, month) {
  date = toStringDate$2(date);
  if (isValidDate$2(date)) {
    return Math.floor((helperGetDateTime$2(getWhatMonth$2(date, month, staticStrLast)) - helperGetDateTime$2(getWhatMonth$2(date, month, staticStrFirst))) / staticDayTime) + 1;
  }
  return NaN;
}
var getDayOfMonth_1 = getDayOfMonth$1;
var setupDefaults$2 = setupDefaults_1;
var helperGetDateTime$1 = helperGetDateTime_1;
var helperNewDate$1 = helperNewDate_1;
var toStringDate$1 = toStringDate_1;
var isValidDate$1 = isValidDate_1;
function getDateDiff$1(startDate, endDate, rules) {
  var startTime, endTime, item, diffTime, rule2, len2, index;
  var result = { done: false, time: 0 };
  startDate = toStringDate$1(startDate);
  endDate = endDate ? toStringDate$1(endDate) : helperNewDate$1();
  if (isValidDate$1(startDate) && isValidDate$1(endDate)) {
    startTime = helperGetDateTime$1(startDate);
    endTime = helperGetDateTime$1(endDate);
    if (startTime < endTime) {
      diffTime = result.time = endTime - startTime;
      rule2 = rules && rules.length > 0 ? rules : setupDefaults$2.dateDiffRules;
      result.done = true;
      for (index = 0, len2 = rule2.length; index < len2; index++) {
        item = rule2[index];
        if (diffTime >= item[1]) {
          if (index === len2 - 1) {
            result[item[0]] = diffTime || 0;
          } else {
            result[item[0]] = Math.floor(diffTime / item[1]);
            diffTime -= result[item[0]] * item[1];
          }
        } else {
          result[item[0]] = 0;
        }
      }
    }
  }
  return result;
}
var getDateDiff_1 = getDateDiff$1;
var toValueString$a = toValueString_1;
var isUndefined$4 = isUndefined_1;
var helperStringRepeat$1 = helperStringRepeat_1;
function padEnd$1(str, targetLength, padString) {
  var rest = toValueString$a(str);
  targetLength = targetLength >> 0;
  padString = isUndefined$4(padString) ? " " : "" + padString;
  if (rest.padEnd) {
    return rest.padEnd(targetLength, padString);
  }
  if (targetLength > rest.length) {
    targetLength -= rest.length;
    if (targetLength > padString.length) {
      padString += helperStringRepeat$1(padString, targetLength / padString.length);
    }
    return rest + padString.slice(0, targetLength);
  }
  return rest;
}
var padEnd_1 = padEnd$1;
var toValueString$9 = toValueString_1;
var helperStringRepeat = helperStringRepeat_1;
function repeat$1(str, count) {
  return helperStringRepeat(toValueString$9(str), count);
}
var repeat_1 = repeat$1;
var toValueString$8 = toValueString_1;
function trimRight$2(str) {
  return str && str.trimRight ? str.trimRight() : toValueString$8(str).replace(/[\s\uFEFF\xA0]+$/g, "");
}
var trimRight_1 = trimRight$2;
var toValueString$7 = toValueString_1;
function trimLeft$2(str) {
  return str && str.trimLeft ? str.trimLeft() : toValueString$7(str).replace(/^[\s\uFEFF\xA0]+/g, "");
}
var trimLeft_1 = trimLeft$2;
var trimRight$1 = trimRight_1;
var trimLeft$1 = trimLeft_1;
function trim$2(str) {
  return str && str.trim ? str.trim() : trimRight$1(trimLeft$1(str));
}
var trim_1 = trim$2;
var staticEscapeMap$2 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};
var staticEscapeMap_1 = staticEscapeMap$2;
var toValueString$6 = toValueString_1;
var keys$4 = keys_1;
function helperFormatEscaper$2(dataMap) {
  var replaceRegexp = new RegExp("(?:" + keys$4(dataMap).join("|") + ")", "g");
  return function(str) {
    return toValueString$6(str).replace(replaceRegexp, function(match) {
      return dataMap[match];
    });
  };
}
var helperFormatEscaper_1 = helperFormatEscaper$2;
var staticEscapeMap$1 = staticEscapeMap_1;
var helperFormatEscaper$1 = helperFormatEscaper_1;
var escape$1 = helperFormatEscaper$1(staticEscapeMap$1);
var _escape = escape$1;
var staticEscapeMap = staticEscapeMap_1;
var helperFormatEscaper = helperFormatEscaper_1;
var each$3 = each_1;
var unescapeMap = {};
each$3(staticEscapeMap, function(item, key) {
  unescapeMap[staticEscapeMap[key]] = key;
});
var unescape$2 = helperFormatEscaper(unescapeMap);
var _unescape = unescape$2;
function helperStringSubstring$2(str, start2, end2) {
  return str.substring(start2, end2);
}
var helperStringSubstring_1 = helperStringSubstring$2;
function helperStringLowerCase$2(str) {
  return str.toLowerCase();
}
var helperStringLowerCase_1 = helperStringLowerCase$2;
var toValueString$5 = toValueString_1;
var helperStringSubstring$1 = helperStringSubstring_1;
var helperStringUpperCase = helperStringUpperCase_1;
var helperStringLowerCase$1 = helperStringLowerCase_1;
var camelCacheMaps = {};
function camelCase$2(str) {
  str = toValueString$5(str);
  if (camelCacheMaps[str]) {
    return camelCacheMaps[str];
  }
  var strLen = str.length;
  var rest = str.replace(/([-]+)/g, function(text2, flag, index) {
    return index && index + flag.length < strLen ? "-" : "";
  });
  strLen = rest.length;
  rest = rest.replace(/([A-Z]+)/g, function(text2, upper2, index) {
    var upperLen = upper2.length;
    upper2 = helperStringLowerCase$1(upper2);
    if (index) {
      if (upperLen > 2 && index + upperLen < strLen) {
        return helperStringUpperCase(helperStringSubstring$1(upper2, 0, 1)) + helperStringSubstring$1(upper2, 1, upperLen - 1) + helperStringUpperCase(helperStringSubstring$1(upper2, upperLen - 1, upperLen));
      }
      return helperStringUpperCase(helperStringSubstring$1(upper2, 0, 1)) + helperStringSubstring$1(upper2, 1, upperLen);
    } else {
      if (upperLen > 1 && index + upperLen < strLen) {
        return helperStringSubstring$1(upper2, 0, upperLen - 1) + helperStringUpperCase(helperStringSubstring$1(upper2, upperLen - 1, upperLen));
      }
    }
    return upper2;
  }).replace(/(-[a-zA-Z])/g, function(text2, upper2) {
    return helperStringUpperCase(helperStringSubstring$1(upper2, 1, upper2.length));
  });
  camelCacheMaps[str] = rest;
  return rest;
}
var camelCase_1 = camelCase$2;
var toValueString$4 = toValueString_1;
var helperStringSubstring = helperStringSubstring_1;
var helperStringLowerCase = helperStringLowerCase_1;
var kebabCacheMaps = {};
function kebabCase$1(str) {
  str = toValueString$4(str);
  if (kebabCacheMaps[str]) {
    return kebabCacheMaps[str];
  }
  if (/^[A-Z]+$/.test(str)) {
    return helperStringLowerCase(str);
  }
  var rest = str.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(text2, prevLower, upper2, nextLower) {
    var upperLen = upper2.length;
    if (upperLen > 1) {
      return prevLower + "-" + helperStringLowerCase(helperStringSubstring(upper2, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper2, upperLen - 1, upperLen)) + nextLower;
    }
    return helperStringLowerCase(prevLower + "-" + upper2 + nextLower);
  }).replace(/^([A-Z]+)([a-z]+)?$/, function(text2, upper2, nextLower) {
    var upperLen = upper2.length;
    return helperStringLowerCase(helperStringSubstring(upper2, 0, upperLen - 1) + "-" + helperStringSubstring(upper2, upperLen - 1, upperLen) + (nextLower || ""));
  }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(text2, prevLower, upper2, nextLower, index) {
    var upperLen = upper2.length;
    if (upperLen > 1) {
      if (prevLower) {
        prevLower += "-";
      }
      if (nextLower) {
        return (prevLower || "") + helperStringLowerCase(helperStringSubstring(upper2, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper2, upperLen - 1, upperLen)) + nextLower;
      }
    }
    return (prevLower || "") + (index ? "-" : "") + helperStringLowerCase(upper2) + (nextLower || "");
  });
  rest = rest.replace(/([-]+)/g, function(text2, flag, index) {
    return index && index + flag.length < rest.length ? "-" : "";
  });
  kebabCacheMaps[str] = rest;
  return rest;
}
var kebabCase_1 = kebabCase$1;
var toValueString$3 = toValueString_1;
function startsWith$1(str, val2, startIndex) {
  var rest = toValueString$3(str);
  return (arguments.length === 1 ? rest : rest.substring(startIndex)).indexOf(val2) === 0;
}
var startsWith_1 = startsWith$1;
var toValueString$2 = toValueString_1;
function endsWith$1(str, val2, startIndex) {
  var rest = toValueString$2(str);
  var argsLen = arguments.length;
  return argsLen > 1 && (argsLen > 2 ? rest.substring(0, startIndex).indexOf(val2) === startIndex - 1 : rest.indexOf(val2) === rest.length - 1);
}
var endsWith_1 = endsWith$1;
var setupDefaults$1 = setupDefaults_1;
var toValueString$1 = toValueString_1;
var trim$1 = trim_1;
var get$2 = get_1;
function template$2(str, args, options) {
  return toValueString$1(str).replace((options || setupDefaults$1).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(match, key) {
    return get$2(args, trim$1(key));
  });
}
var template_1 = template$2;
var template$1 = template_1;
function toFormatString$1(str, obj) {
  return template$1(str, obj, { tmplRE: /\{([.\w[\]\s]+)\}/g });
}
var toFormatString_1 = toFormatString$1;
function noop$2() {
}
var noop_1 = noop$2;
var slice$5 = slice_1;
function bind$1(callback, context) {
  var args = slice$5(arguments, 2);
  return function() {
    return callback.apply(context, slice$5(arguments).concat(args));
  };
}
var bind_1 = bind$1;
var slice$4 = slice_1;
function once$1(callback, context) {
  var done = false;
  var rest = null;
  var args = slice$4(arguments, 2);
  return function() {
    if (done) {
      return rest;
    }
    rest = callback.apply(context, slice$4(arguments).concat(args));
    done = true;
    return rest;
  };
}
var once_1 = once$1;
var slice$3 = slice_1;
function after$1(count, callback, context) {
  var runCount = 0;
  var rests = [];
  return function() {
    var args = arguments;
    runCount++;
    if (runCount <= count) {
      rests.push(args[0]);
    }
    if (runCount >= count) {
      callback.apply(context, [rests].concat(slice$3(args)));
    }
  };
}
var after_1 = after$1;
var slice$2 = slice_1;
function before$1(count, callback, context) {
  var runCount = 0;
  var rests = [];
  context = context || this;
  return function() {
    var args = arguments;
    runCount++;
    if (runCount < count) {
      rests.push(args[0]);
      callback.apply(context, [rests].concat(slice$2(args)));
    }
  };
}
var before_1 = before$1;
function throttle$3(callback, wait, options) {
  var args, context;
  var opts = options || {};
  var runFlag = false;
  var timeout = 0;
  var optLeading = "leading" in opts ? opts.leading : true;
  var optTrailing = "trailing" in opts ? opts.trailing : false;
  var runFn = function() {
    {
      runFlag = true;
      callback.apply(context, args);
      timeout = setTimeout(endFn, wait);
    }
  };
  var endFn = function() {
    timeout = 0;
    if (!runFlag && optTrailing === true) {
      runFn();
    }
  };
  var cancelFn = function() {
    var rest = timeout !== 0;
    clearTimeout(timeout);
    args = null;
    context = null;
    runFlag = false;
    timeout = 0;
    return rest;
  };
  var throttled = function() {
    args = arguments;
    context = this;
    runFlag = false;
    if (timeout === 0) {
      if (optLeading === true) {
        runFn();
      } else if (optTrailing === true) {
        timeout = setTimeout(endFn, wait);
      }
    }
  };
  throttled.cancel = cancelFn;
  return throttled;
}
var throttle_1 = throttle$3;
function debounce$5(callback, wait, options) {
  var args, context;
  var opts = options || {};
  var runFlag = false;
  var timeout = 0;
  var isLeading = typeof options === "boolean";
  var optLeading = "leading" in opts ? opts.leading : isLeading;
  var optTrailing = "trailing" in opts ? opts.trailing : !isLeading;
  var runFn = function() {
    {
      runFlag = true;
      timeout = 0;
      callback.apply(context, args);
    }
  };
  var endFn = function() {
    if (optLeading === true) {
      timeout = 0;
    }
    if (!runFlag && optTrailing === true) {
      runFn();
    }
  };
  var cancelFn = function() {
    var rest = timeout !== 0;
    clearTimeout(timeout);
    args = null;
    context = null;
    timeout = 0;
    return rest;
  };
  var debounced = function() {
    runFlag = false;
    args = arguments;
    context = this;
    if (timeout === 0) {
      if (optLeading === true) {
        runFn();
      }
    } else {
      clearTimeout(timeout);
    }
    timeout = setTimeout(endFn, wait);
  };
  debounced.cancel = cancelFn;
  return debounced;
}
var debounce_1 = debounce$5;
var slice$1 = slice_1;
function delay$1(callback, wait) {
  var args = slice$1(arguments, 2);
  var context = this;
  return setTimeout(function() {
    callback.apply(context, args);
  }, wait);
}
var delay_1 = delay$1;
var staticDecodeURIComponent$2 = decodeURIComponent;
var staticDecodeURIComponent_1 = staticDecodeURIComponent$2;
var staticDecodeURIComponent$1 = staticDecodeURIComponent_1;
var arrayEach$4 = arrayEach_1;
var isString$4 = isString_1;
function unserialize$2(str) {
  var items;
  var result = {};
  if (str && isString$4(str)) {
    arrayEach$4(str.split("&"), function(param) {
      items = param.split("=");
      result[staticDecodeURIComponent$1(items[0])] = staticDecodeURIComponent$1(items[1] || "");
    });
  }
  return result;
}
var unserialize_1 = unserialize$2;
var staticEncodeURIComponent$2 = encodeURIComponent;
var staticEncodeURIComponent_1 = staticEncodeURIComponent$2;
var staticEncodeURIComponent$1 = staticEncodeURIComponent_1;
var each$2 = each_1;
var isArray$7 = isArray_1;
var isNull$1 = isNull_1;
var isUndefined$3 = isUndefined_1;
var isPlainObject$2 = isPlainObject_1;
function stringifyParams(resultVal, resultKey, isArr) {
  var _arr;
  var result = [];
  each$2(resultVal, function(item, key) {
    _arr = isArray$7(item);
    if (isPlainObject$2(item) || _arr) {
      result = result.concat(stringifyParams(item, resultKey + "[" + key + "]", _arr));
    } else {
      result.push(staticEncodeURIComponent$1(resultKey + "[" + (isArr ? "" : key) + "]") + "=" + staticEncodeURIComponent$1(isNull$1(item) ? "" : item));
    }
  });
  return result;
}
function serialize$1(query) {
  var _arr;
  var params = [];
  each$2(query, function(item, key) {
    if (!isUndefined$3(item)) {
      _arr = isArray$7(item);
      if (isPlainObject$2(item) || _arr) {
        params = params.concat(stringifyParams(item, key, _arr));
      } else {
        params.push(staticEncodeURIComponent$1(key) + "=" + staticEncodeURIComponent$1(isNull$1(item) ? "" : item));
      }
    }
  });
  return params.join("&").replace(/%20/g, "+");
}
var serialize_1 = serialize$1;
var staticStrUndefined$1 = staticStrUndefined_1;
var staticLocation$4 = typeof location === staticStrUndefined$1 ? 0 : location;
var staticLocation_1 = staticLocation$4;
var staticLocation$3 = staticLocation_1;
function helperGetLocatOrigin$2() {
  return staticLocation$3 ? staticLocation$3.origin || staticLocation$3.protocol + "//" + staticLocation$3.host : "";
}
var helperGetLocatOrigin_1 = helperGetLocatOrigin$2;
var staticLocation$2 = staticLocation_1;
var unserialize$1 = unserialize_1;
var helperGetLocatOrigin$1 = helperGetLocatOrigin_1;
function parseURLQuery(uri) {
  return unserialize$1(uri.split("?")[1] || "");
}
function parseUrl$2(url) {
  var hashs, portText, searchs, parsed;
  var href = "" + url;
  if (href.indexOf("//") === 0) {
    href = (staticLocation$2 ? staticLocation$2.protocol : "") + href;
  } else if (href.indexOf("/") === 0) {
    href = helperGetLocatOrigin$1() + href;
  }
  searchs = href.replace(/#.*/, "").match(/(\?.*)/);
  parsed = {
    href,
    hash: "",
    host: "",
    hostname: "",
    protocol: "",
    port: "",
    search: searchs && searchs[1] && searchs[1].length > 1 ? searchs[1] : ""
  };
  parsed.path = href.replace(/^([a-z0-9.+-]*:)\/\//, function(text2, protocol) {
    parsed.protocol = protocol;
    return "";
  }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(text2, hostname, port) {
    portText = port || "";
    parsed.port = portText.replace(":", "");
    parsed.hostname = hostname;
    parsed.host = hostname + portText;
    return "/";
  }).replace(/(#.*)/, function(text2, hash) {
    parsed.hash = hash.length > 1 ? hash : "";
    return "";
  });
  hashs = parsed.hash.match(/#((.*)\?|(.*))/);
  parsed.pathname = parsed.path.replace(/(\?|#.*).*/, "");
  parsed.origin = parsed.protocol + "//" + parsed.host;
  parsed.hashKey = hashs ? hashs[2] || hashs[1] || "" : "";
  parsed.hashQuery = parseURLQuery(parsed.hash);
  parsed.searchQuery = parseURLQuery(parsed.search);
  return parsed;
}
var parseUrl_1 = parseUrl$2;
var staticLocation$1 = staticLocation_1;
var helperGetLocatOrigin = helperGetLocatOrigin_1;
var lastIndexOf$1 = lastIndexOf_1;
function getBaseURL$1() {
  if (staticLocation$1) {
    var pathname = staticLocation$1.pathname;
    var lastIndex = lastIndexOf$1(pathname, "/") + 1;
    return helperGetLocatOrigin() + (lastIndex === pathname.length ? pathname : pathname.substring(0, lastIndex));
  }
  return "";
}
var getBaseURL_1 = getBaseURL$1;
var staticLocation = staticLocation_1;
var parseUrl$1 = parseUrl_1;
function locat$1() {
  return staticLocation ? parseUrl$1(staticLocation.href) : {};
}
var locat_1 = locat$1;
var setupDefaults = setupDefaults_1;
var staticDocument$1 = staticDocument_1;
var staticDecodeURIComponent = staticDecodeURIComponent_1;
var staticEncodeURIComponent = staticEncodeURIComponent_1;
var isArray$6 = isArray_1;
var isObject$9 = isObject_1;
var isDate$1 = isDate_1;
var isUndefined$2 = isUndefined_1;
var includes$1 = includes_1;
var keys$3 = keys_1;
var assign$2 = assign_1;
var arrayEach$3 = arrayEach_1;
var helperNewDate = helperNewDate_1;
var helperGetDateTime = helperGetDateTime_1;
var getWhatYear$1 = getWhatYear_1;
var getWhatMonth$1 = getWhatMonth_1;
var getWhatDay$1 = getWhatDay_1;
function toCookieUnitTime(unit, expires) {
  var num = parseFloat(expires);
  var nowdate = helperNewDate();
  var time2 = helperGetDateTime(nowdate);
  switch (unit) {
    case "y":
      return helperGetDateTime(getWhatYear$1(nowdate, num));
    case "M":
      return helperGetDateTime(getWhatMonth$1(nowdate, num));
    case "d":
      return helperGetDateTime(getWhatDay$1(nowdate, num));
    case "h":
    case "H":
      return time2 + num * 60 * 60 * 1e3;
    case "m":
      return time2 + num * 60 * 1e3;
    case "s":
      return time2 + num * 1e3;
  }
  return time2;
}
function toCookieUTCString(date) {
  return (isDate$1(date) ? date : new Date(date)).toUTCString();
}
function cookie$1(name2, value, options) {
  if (staticDocument$1) {
    var opts, expires, values2, result, cookies, keyIndex;
    var inserts = [];
    var args = arguments;
    if (isArray$6(name2)) {
      inserts = name2;
    } else if (args.length > 1) {
      inserts = [assign$2({ name: name2, value }, options)];
    } else if (isObject$9(name2)) {
      inserts = [name2];
    }
    if (inserts.length > 0) {
      arrayEach$3(inserts, function(obj) {
        opts = assign$2({}, setupDefaults.cookies, obj);
        values2 = [];
        if (opts.name) {
          expires = opts.expires;
          values2.push(staticEncodeURIComponent(opts.name) + "=" + staticEncodeURIComponent(isObject$9(opts.value) ? JSON.stringify(opts.value) : opts.value));
          if (expires) {
            if (isNaN(expires)) {
              expires = expires.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(text2, num, unit) {
                return toCookieUTCString(toCookieUnitTime(unit, num));
              });
            } else if (/^[0-9]{11,13}$/.test(expires) || isDate$1(expires)) {
              expires = toCookieUTCString(expires);
            } else {
              expires = toCookieUTCString(toCookieUnitTime("d", expires));
            }
            opts.expires = expires;
          }
          arrayEach$3(["expires", "path", "domain", "secure"], function(key) {
            if (!isUndefined$2(opts[key])) {
              values2.push(opts[key] && key === "secure" ? key : key + "=" + opts[key]);
            }
          });
        }
        staticDocument$1.cookie = values2.join("; ");
      });
      return true;
    } else {
      result = {};
      cookies = staticDocument$1.cookie;
      if (cookies) {
        arrayEach$3(cookies.split("; "), function(val2) {
          keyIndex = val2.indexOf("=");
          result[staticDecodeURIComponent(val2.substring(0, keyIndex))] = staticDecodeURIComponent(val2.substring(keyIndex + 1) || "");
        });
      }
      return args.length === 1 ? result[name2] : result;
    }
  }
  return false;
}
function hasCookieItem(value) {
  return includes$1(cookieKeys(), value);
}
function getCookieItem(name2) {
  return cookie$1(name2);
}
function setCookieItem(name2, value, options) {
  cookie$1(name2, value, options);
  return cookie$1;
}
function removeCookieItem(name2, options) {
  cookie$1(name2, "", assign$2({ expires: -1 }, setupDefaults.cookies, options));
}
function cookieKeys() {
  return keys$3(cookie$1());
}
function cookieJson() {
  return cookie$1();
}
assign$2(cookie$1, {
  has: hasCookieItem,
  set: setCookieItem,
  setItem: setCookieItem,
  get: getCookieItem,
  getItem: getCookieItem,
  remove: removeCookieItem,
  removeItem: removeCookieItem,
  keys: cookieKeys,
  getJSON: cookieJson
});
var cookie_1 = cookie$1;
var staticStrUndefined = staticStrUndefined_1;
var staticDocument = staticDocument_1;
var staticWindow = staticWindow_1;
var assign$1 = assign_1;
var arrayEach$2 = arrayEach_1;
function isBrowseStorage(storage) {
  try {
    var testKey = "__xe_t";
    storage.setItem(testKey, 1);
    storage.removeItem(testKey);
    return true;
  } catch (e3) {
    return false;
  }
}
function isBrowseType(type2) {
  return navigator.userAgent.indexOf(type2) > -1;
}
function browse$2() {
  var $body, isChrome, isEdge;
  var isMobile = false;
  var result = {
    isNode: false,
    isMobile,
    isPC: false,
    isDoc: !!staticDocument
  };
  if (!staticWindow && typeof process !== staticStrUndefined) {
    result.isNode = true;
  } else {
    isEdge = isBrowseType("Edge");
    isChrome = isBrowseType("Chrome");
    isMobile = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
    if (result.isDoc) {
      $body = staticDocument.body || staticDocument.documentElement;
      arrayEach$2(["webkit", "khtml", "moz", "ms", "o"], function(core) {
        result["-" + core] = !!$body[core + "MatchesSelector"];
      });
    }
    assign$1(result, {
      edge: isEdge,
      firefox: isBrowseType("Firefox"),
      msie: !isEdge && result["-ms"],
      safari: !isChrome && !isEdge && isBrowseType("Safari"),
      isMobile,
      isPC: !isMobile,
      isLocalStorage: isBrowseStorage(staticWindow.localStorage),
      isSessionStorage: isBrowseStorage(staticWindow.sessionStorage)
    });
  }
  return result;
}
var browse_1 = browse$2;
var XEUtils = ctor;
var assign = assign_1;
var objectEach = objectEach_1;
var lastObjectEach = lastObjectEach_1;
var objectMap = objectMap_1;
var merge = merge_1;
var map = map_1;
var some = some_1;
var every = every_1;
var includeArrays = includeArrays_1;
var arrayEach$1 = arrayEach_1;
var lastArrayEach = lastArrayEach_1;
var uniq = uniq_1;
var union = union_1;
var toArray$1 = toArray_1;
var sortBy = sortBy_1;
var orderBy = orderBy_1;
var shuffle = shuffle_1;
var sample = sample_1;
var slice = slice_1;
var filter$1 = filter_1;
var findKey = findKey_1;
var includes = includes_1;
var find$1 = find_1;
var findLast = findLast_1;
var reduce = reduce_1;
var copyWithin = copyWithin_1;
var chunk = chunk_1;
var zip = zip_1;
var unzip = unzip_1;
var zipObject = zipObject_1;
var flatten = flatten_1;
var pluck = pluck_1;
var invoke = invoke_1;
var toArrayTree = toArrayTree_1;
var toTreeArray = toTreeArray_1;
var findTree = findTree_1;
var eachTree = eachTree_1;
var mapTree = mapTree_1;
var filterTree = filterTree_1;
var searchTree = searchTree_1;
var arrayIndexOf = arrayIndexOf_1;
var arrayLastIndexOf = arrayLastIndexOf_1;
var hasOwnProp = hasOwnProp_1;
var isArray$5 = isArray_1;
var isNull = isNull_1;
var isNumberNaN = _isNaN;
var isUndefined$1 = isUndefined_1;
var isFunction$4 = isFunction_1;
var isObject$8 = isObject_1;
var isString$3 = isString_1;
var isPlainObject$1 = isPlainObject_1;
var isLeapYear = isLeapYear_1;
var isDate = isDate_1;
var eqNull = eqNull_1;
var each$1 = each_1;
var forOf = forOf_1;
var lastForOf = lastForOf_1;
var indexOf = indexOf_1;
var lastIndexOf = lastIndexOf_1;
var keys$2 = keys_1;
var values$1 = values_1;
var clone = clone_1;
var getSize = getSize_1;
var lastEach = lastEach_1;
var remove$1 = remove_1;
var clear = clear_1;
var isNumberFinite = _isFinite;
var isFloat = isFloat_1;
var isInteger = isInteger_1;
var isBoolean$1 = isBoolean_1;
var isNumber$1 = isNumber_1;
var isRegExp = isRegExp_1;
var isError = isError_1;
var isTypeError = isTypeError_1;
var isEmpty = isEmpty_1;
var isSymbol$4 = isSymbol_1;
var isArguments$2 = isArguments_1;
var isElement$3 = isElement_1;
var isDocument = isDocument_1;
var isWindow = isWindow_1;
var isFormData = isFormData_1;
var isMap = isMap_1;
var isWeakMap = isWeakMap_1;
var isSet = isSet_1;
var isWeakSet = isWeakSet_1;
var isMatch = isMatch_1;
var isEqual = isEqual_1;
var isEqualWith = isEqualWith_1;
var getType = getType_1;
var uniqueId = uniqueId_1;
var findIndexOf = findIndexOf_1;
var findLastIndexOf = findLastIndexOf_1;
var toStringJSON = toStringJSON_1;
var toJSONString = toJSONString_1;
var entries = entries_1;
var pick = pick_1;
var omit = omit_1;
var first = first_1;
var last = last_1;
var has = has_1;
var get$1 = get_1;
var set = set_1;
var groupBy = groupBy_1;
var countBy = countBy_1;
var range = range_1;
var destructuring = destructuring_1;
var random$1 = random_1;
var max = max_1;
var min = min_1;
var commafy = commafy_1;
var round = round_1;
var ceil = ceil_1;
var floor = floor_1;
var toFixed = toFixed_1;
var toInteger = toInteger_1;
var toNumber$3 = toNumber_1;
var toNumberString = toNumberString_1;
var add = add_1;
var subtract = subtract_1;
var multiply = multiply_1;
var divide = divide_1;
var sum = sum_1;
var mean = mean_1;
var getWhatYear = getWhatYear_1;
var getWhatQuarter = getWhatQuarter_1;
var getWhatMonth = getWhatMonth_1;
var getWhatDay = getWhatDay_1;
var toStringDate = toStringDate_1;
var toDateString = toDateString_1;
var now$4 = now_1;
var timestamp = timestamp_1;
var isValidDate = isValidDate_1;
var isDateSame = isDateSame_1;
var getWhatWeek = getWhatWeek_1;
var getYearDay = getYearDay_1;
var getYearWeek = getYearWeek_1;
var getMonthWeek = getMonthWeek_1;
var getDayOfYear = getDayOfYear_1;
var getDayOfMonth = getDayOfMonth_1;
var getDateDiff = getDateDiff_1;
var padEnd = padEnd_1;
var padStart = padStart_1;
var repeat = repeat_1;
var trim = trim_1;
var trimRight = trimRight_1;
var trimLeft = trimLeft_1;
var escape = _escape;
var unescape$1 = _unescape;
var camelCase$1 = camelCase_1;
var kebabCase = kebabCase_1;
var startsWith = startsWith_1;
var endsWith = endsWith_1;
var template = template_1;
var toFormatString = toFormatString_1;
var toValueString = toValueString_1;
var noop$1 = noop_1;
var property = property_1;
var bind = bind_1;
var once = once_1;
var after = after_1;
var before = before_1;
var throttle$2 = throttle_1;
var debounce$4 = debounce_1;
var delay = delay_1;
var unserialize = unserialize_1;
var serialize = serialize_1;
var parseUrl = parseUrl_1;
var getBaseURL = getBaseURL_1;
var locat = locat_1;
var cookie = cookie_1;
var browse$1 = browse_1;
assign(XEUtils, {
  assign,
  objectEach,
  lastObjectEach,
  objectMap,
  merge,
  uniq,
  union,
  sortBy,
  orderBy,
  shuffle,
  sample,
  some,
  every,
  slice,
  filter: filter$1,
  find: find$1,
  findLast,
  findKey,
  includes,
  arrayIndexOf,
  arrayLastIndexOf,
  map,
  reduce,
  copyWithin,
  chunk,
  zip,
  unzip,
  zipObject,
  flatten,
  toArray: toArray$1,
  includeArrays,
  pluck,
  invoke,
  arrayEach: arrayEach$1,
  lastArrayEach,
  toArrayTree,
  toTreeArray,
  findTree,
  eachTree,
  mapTree,
  filterTree,
  searchTree,
  hasOwnProp,
  eqNull,
  isNaN: isNumberNaN,
  isFinite: isNumberFinite,
  isUndefined: isUndefined$1,
  isArray: isArray$5,
  isFloat,
  isInteger,
  isFunction: isFunction$4,
  isBoolean: isBoolean$1,
  isString: isString$3,
  isNumber: isNumber$1,
  isRegExp,
  isObject: isObject$8,
  isPlainObject: isPlainObject$1,
  isDate,
  isError,
  isTypeError,
  isEmpty,
  isNull,
  isSymbol: isSymbol$4,
  isArguments: isArguments$2,
  isElement: isElement$3,
  isDocument,
  isWindow,
  isFormData,
  isMap,
  isWeakMap,
  isSet,
  isWeakSet,
  isLeapYear,
  isMatch,
  isEqual,
  isEqualWith,
  getType,
  uniqueId,
  getSize,
  indexOf,
  lastIndexOf,
  findIndexOf,
  findLastIndexOf,
  toStringJSON,
  toJSONString,
  keys: keys$2,
  values: values$1,
  entries,
  pick,
  omit,
  first,
  last,
  each: each$1,
  forOf,
  lastForOf,
  lastEach,
  has,
  get: get$1,
  set,
  groupBy,
  countBy,
  clone,
  clear,
  remove: remove$1,
  range,
  destructuring,
  random: random$1,
  min,
  max,
  commafy,
  round,
  ceil,
  floor,
  toFixed,
  toNumber: toNumber$3,
  toNumberString,
  toInteger,
  add,
  subtract,
  multiply,
  divide,
  sum,
  mean,
  now: now$4,
  timestamp,
  isValidDate,
  isDateSame,
  toStringDate,
  toDateString,
  getWhatYear,
  getWhatQuarter,
  getWhatMonth,
  getWhatWeek,
  getWhatDay,
  getYearDay,
  getYearWeek,
  getMonthWeek,
  getDayOfYear,
  getDayOfMonth,
  getDateDiff,
  trim,
  trimLeft,
  trimRight,
  escape,
  unescape: unescape$1,
  camelCase: camelCase$1,
  kebabCase,
  repeat,
  padStart,
  padEnd,
  startsWith,
  endsWith,
  template,
  toFormatString,
  toString: toValueString,
  toValueString,
  noop: noop$1,
  property,
  bind,
  once,
  after,
  before,
  throttle: throttle$2,
  debounce: debounce$4,
  delay,
  unserialize,
  serialize,
  parseUrl,
  getBaseURL,
  locat,
  browse: browse$1,
  cookie
});
var xeUtils = XEUtils;
var iconPrefix = "vxe-icon-";
var GlobalConfig = {
  size: null,
  zIndex: 999,
  version: 0,
  emptyCell: "\u3000",
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    radioConfig: {
      strict: true
    },
    checkboxConfig: {
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      message: "default"
    },
    sortConfig: {
      showIcon: true
    },
    filterConfig: {
      showIcon: true
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      children: "children",
      hasChild: "hasChild",
      mapChildren: "_X_ROW_CHILD",
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      showIcon: true
    },
    editConfig: {
      showIcon: true,
      showAsterisk: true
    },
    importConfig: {
      modes: ["insert", "covering"]
    },
    exportConfig: {
      modes: ["current", "selected"]
    },
    printConfig: {
      modes: ["current", "selected"]
    },
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      selectCellByHeader: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      enabled: true,
      gt: 60
    },
    scrollY: {
      enabled: true,
      gt: 100
    }
  },
  export: {
    types: {}
  },
  icon: {
    LOADING: iconPrefix + "spinner roll vxe-loading--default-icon",
    TABLE_SORT_ASC: iconPrefix + "caret-up",
    TABLE_SORT_DESC: iconPrefix + "caret-down",
    TABLE_FILTER_NONE: iconPrefix + "funnel",
    TABLE_FILTER_MATCH: iconPrefix + "funnel",
    TABLE_EDIT: iconPrefix + "edit",
    TABLE_HELP: iconPrefix + "question-circle-fill",
    TABLE_TREE_LOADED: iconPrefix + "spinner roll",
    TABLE_TREE_OPEN: iconPrefix + "caret-right rotate90",
    TABLE_TREE_CLOSE: iconPrefix + "caret-right",
    TABLE_EXPAND_LOADED: iconPrefix + "spinner roll",
    TABLE_EXPAND_OPEN: iconPrefix + "arrow-right rotate90",
    TABLE_EXPAND_CLOSE: iconPrefix + "arrow-right",
    TABLE_CHECKBOX_CHECKED: iconPrefix + "checkbox-checked",
    TABLE_CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
    TABLE_CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate",
    TABLE_RADIO_CHECKED: iconPrefix + "radio-checked",
    TABLE_RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
    BUTTON_DROPDOWN: iconPrefix + "arrow-down",
    BUTTON_LOADING: iconPrefix + "spinner roll",
    SELECT_LOADED: iconPrefix + "spinner roll",
    SELECT_OPEN: iconPrefix + "caret-down rotate180",
    SELECT_CLOSE: iconPrefix + "caret-down",
    PAGER_JUMP_PREV: iconPrefix + "arrow-double-left",
    PAGER_JUMP_NEXT: iconPrefix + "arrow-double-right",
    PAGER_PREV_PAGE: iconPrefix + "arrow-left",
    PAGER_NEXT_PAGE: iconPrefix + "arrow-right",
    PAGER_JUMP_MORE: iconPrefix + "ellipsis-h",
    INPUT_CLEAR: iconPrefix + "error-circle-fill",
    INPUT_PWD: iconPrefix + "eye-fill",
    INPUT_SHOW_PWD: iconPrefix + "eye-fill-close",
    INPUT_PREV_NUM: iconPrefix + "caret-up",
    INPUT_NEXT_NUM: iconPrefix + "caret-down",
    INPUT_DATE: iconPrefix + "calendar",
    INPUT_SEARCH: iconPrefix + "search",
    MODAL_ZOOM_IN: iconPrefix + "square",
    MODAL_ZOOM_OUT: iconPrefix + "maximize",
    MODAL_CLOSE: iconPrefix + "close",
    MODAL_INFO: iconPrefix + "info-circle-fill",
    MODAL_SUCCESS: iconPrefix + "success-circle-fill",
    MODAL_WARNING: iconPrefix + "warnion-circle-fill",
    MODAL_ERROR: iconPrefix + "error-circle-fill",
    MODAL_QUESTION: iconPrefix + "question-circle-fill",
    MODAL_LOADING: iconPrefix + "spinner roll",
    TOOLBAR_TOOLS_REFRESH: iconPrefix + "repeat",
    TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + "repeat roll",
    TOOLBAR_TOOLS_IMPORT: iconPrefix + "upload",
    TOOLBAR_TOOLS_EXPORT: iconPrefix + "download",
    TOOLBAR_TOOLS_PRINT: iconPrefix + "print",
    TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + "fullscreen",
    TOOLBAR_TOOLS_MINIMIZE: iconPrefix + "minimize",
    TOOLBAR_TOOLS_CUSTOM: iconPrefix + "custom-column",
    FORM_PREFIX: iconPrefix + "question-circle-fill",
    FORM_SUFFIX: iconPrefix + "question-circle-fill",
    FORM_FOLDING: iconPrefix + "arrow-up rotate180",
    FORM_UNFOLDING: iconPrefix + "arrow-up"
  },
  grid: {
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
    },
    toolbarConfig: {
      enabled: true
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      message: true,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
    }
  },
  tooltip: {
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300
  },
  pager: {},
  form: {
    validConfig: {
      showMessage: true,
      autoPos: true
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true
  },
  input: {
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  textarea: {},
  select: {
    multiCharOverflow: 8
  },
  toolbar: {},
  button: {},
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  checkbox: {},
  switch: {},
  modal: {
    top: 15,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    draggable: true,
    storageKey: "VXE_MODAL_POSITION"
  },
  list: {
    scrollY: {
      enabled: true,
      gt: 100
    }
  },
  i18n: function(key) {
    return key;
  }
};
function getLog(message2, params) {
  return "[vxe-table v".concat("4.3.2", "] ").concat(GlobalConfig.i18n(message2, params));
}
function outLog(type2) {
  return function(message2, params) {
    var msg = getLog(message2, params);
    console[type2](msg);
    return msg;
  };
}
var warnLog = outLog("warn");
var errLog = outLog("error");
var storeMap = {};
var interceptor = {
  mixin: function(options) {
    xeUtils.each(options, function(callback, type2) {
      return interceptor.add(type2, callback);
    });
    return interceptor;
  },
  get: function(type2) {
    return storeMap[type2] || [];
  },
  add: function(type2, callback) {
    if (callback) {
      var eList = storeMap[type2];
      if (!eList) {
        eList = storeMap[type2] = [];
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete: function(type2, callback) {
    var eList = storeMap[type2];
    if (eList) {
      if (callback) {
        xeUtils.remove(eList, function(fn2) {
          return fn2 === callback;
        });
      } else {
        delete storeMap[type2];
      }
    }
  }
};
var zindexIndex = 0;
var lastZindex = 1;
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function parseFile(file) {
  var name2 = file.name;
  var tIndex = xeUtils.lastIndexOf(name2, ".");
  var type2 = name2.substring(tIndex + 1, name2.length);
  var filename = name2.substring(0, tIndex);
  return { filename, type: type2 };
}
function nextZIndex() {
  lastZindex = GlobalConfig.zIndex + zindexIndex++;
  return lastZindex;
}
function getLastZIndex() {
  return lastZindex;
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content) {
  return content ? xeUtils.toValueString(GlobalConfig.translate ? GlobalConfig.translate("" + content) : content) : "";
}
function formatText(value, placeholder) {
  return "" + (isEmptyValue(value) ? placeholder ? GlobalConfig.emptyCell : "" : value);
}
function eqEmptyValue(cellValue) {
  return cellValue === "" || xeUtils.eqNull(cellValue);
}
var ColumnInfo = function() {
  function ColumnInfo2($xetable, _vm, _a2) {
    var _b2 = _a2 === void 0 ? {} : _a2, renderHeader = _b2.renderHeader, renderCell = _b2.renderCell, renderFooter = _b2.renderFooter, renderData = _b2.renderData;
    var $xegrid = $xetable.xegrid;
    var formatter = _vm.formatter;
    var visible = xeUtils.isBoolean(_vm.visible) ? _vm.visible : true;
    Object.assign(this, {
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: xeUtils.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      params: _vm.params,
      id: _vm.colId || xeUtils.uniqueId("col_"),
      parentId: null,
      visible,
      halfVisible: false,
      defaultVisible: visible,
      checked: false,
      halfChecked: false,
      disabled: false,
      level: 1,
      rowSpan: 1,
      colSpan: 1,
      order: null,
      sortTime: 0,
      renderWidth: 0,
      renderHeight: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      slots: _vm.slots
    });
    if ($xegrid) {
      var computeProxyOpts = $xegrid.getComputeMaps().computeProxyOpts;
      var proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({ $grid: $xegrid, column: this });
      }
    }
  }
  ColumnInfo2.prototype.getTitle = function() {
    return getFuncText(this.title || (this.type === "seq" ? GlobalConfig.i18n("vxe.table.seqTitle") : ""));
  };
  ColumnInfo2.prototype.getKey = function() {
    return this.field || (this.type ? "type=".concat(this.type) : null);
  };
  ColumnInfo2.prototype.update = function(name2, value) {
    if (name2 !== "filters") {
      if (name2 === "field") {
        this.property = value;
      }
      this[name2] = value;
    }
  };
  return ColumnInfo2;
}();
var reClsMap = {};
var browse = xeUtils.browse();
function getPropClass(property2, params) {
  return property2 ? xeUtils.isFunction(property2) ? property2(params) : property2 : "";
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp("(?:^|\\s)".concat(cls, "(?!\\S)"), "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    var parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val2) {
  return val2 && /^\d+(px)?$/.test(val2);
}
function isScale(val2) {
  return val2 && /^\d+%$/.test(val2);
}
function hasClass$1(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass$2(elem, cls) {
  if (elem && hasClass$1(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass$2(elem, cls) {
  if (elem && !hasClass$1(elem, cls)) {
    removeClass$2(elem, cls);
    elem.className = "".concat(elem.className, " ").concat(cls);
  }
}
function getDomNode() {
  var documentElement = document.documentElement;
  var bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    var computedStyle = getComputedStyle(elem);
    var paddingTop = xeUtils.toNumber(computedStyle.paddingTop);
    var paddingBottom = xeUtils.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
function updateCellTitle(overflowElem, column2) {
  var content = column2.type === "html" ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute("title") !== content) {
    overflowElem.setAttribute("title", content);
  }
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  var targetElem;
  var target = evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass$1(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  var bounding = elem.getBoundingClientRect();
  var boundingTop = bounding.top;
  var boundingLeft = bounding.left;
  var _a2 = getDomNode(), scrollTop = _a2.scrollTop, scrollLeft = _a2.scrollLeft, visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
function restoreScrollLocation($xetable, scrollLeft, scrollTop) {
  var internalData = $xetable.internalData;
  return $xetable.clearScroll().then(function() {
    if (scrollLeft || scrollTop) {
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      return $xetable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function removeScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = null;
  }
}
function restoreScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = scrollElem._onscroll;
  }
}
function getRowUniqueId() {
  return xeUtils.uniqueId("row_");
}
function getRowkey($xetable) {
  var props = $xetable.props;
  var computeRowOpts = $xetable.getComputeMaps().computeRowOpts;
  var rowId = props.rowId;
  var rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || "_X_ROW_KEY";
}
function getRowid($xetable, row2) {
  var rowid = xeUtils.get(row2, getRowkey($xetable));
  return xeUtils.eqNull(rowid) ? "" : encodeURIComponent(rowid);
}
var handleFieldOrColumn = function($xetable, fieldOrColumn) {
  if (fieldOrColumn) {
    return xeUtils.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    var computedStyle = getComputedStyle(elem);
    var paddingLeft = xeUtils.toNumber(computedStyle.paddingLeft);
    var paddingRight = xeUtils.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElemenMarginWidth(elem) {
  if (elem) {
    var computedStyle = getComputedStyle(elem);
    var marginLeft = xeUtils.toNumber(computedStyle.marginLeft);
    var marginRight = xeUtils.toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector(".vxe-cell" + selector);
}
function toFilters(filters) {
  if (filters && xeUtils.isArray(filters)) {
    return filters.map(function(_a2) {
      var label = _a2.label, value = _a2.value, data5 = _a2.data, resetValue = _a2.resetValue, checked = _a2.checked;
      return { label, value, data: data5, resetValue, checked: !!checked, _checked: !!checked };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map(function(num, i2) {
    return i2 % 2 === 0 ? Number(num) + 1 : ".";
  }).join("");
}
function getCellValue(row2, column2) {
  return xeUtils.get(row2, column2.field);
}
function setCellValue(row2, column2, value) {
  return xeUtils.set(row2, column2.field, value);
}
function getColMinWidth(params) {
  var $table = params.$table, column2 = params.column, cell = params.cell;
  var tableProps2 = $table.props;
  var computeResizableOpts = $table.getComputeMaps().computeResizableOpts;
  var resizableOpts = computeResizableOpts.value;
  var reMinWidth = resizableOpts.minWidth;
  if (reMinWidth) {
    var customMinWidth = xeUtils.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== "auto") {
      return Math.max(1, xeUtils.toNumber(customMinWidth));
    }
  }
  var allColumnHeaderOverflow = tableProps2.showHeaderOverflow;
  var showHeaderOverflow = column2.showHeaderOverflow, colMinWidth = column2.minWidth;
  var headOverflow = xeUtils.isUndefined(showHeaderOverflow) || xeUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  var showEllipsis = headOverflow === "ellipsis";
  var showTitle = headOverflow === "title";
  var showTooltip2 = headOverflow === true || headOverflow === "tooltip";
  var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
  var minTitleWidth = xeUtils.floor((xeUtils.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  var paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ""));
  var mWidth = minTitleWidth + paddingLeftRight;
  if (hasEllipsis) {
    var checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, "--title>.vxe-cell--checkbox"));
    var requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--required-icon"));
    var editIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--edit-icon"));
    var helpIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell-help-icon"));
    var sortIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--sort"));
    var filterIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--filter"));
    mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + helpIconWidth + filterIconWidth + sortIconWidth;
  }
  if (colMinWidth) {
    var refTableBody = $table.getRefMaps().refTableBody;
    var tableBody = refTableBody.value;
    var bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        var bodyWidth = bodyElem.clientWidth - 1;
        var meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(xeUtils.toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, xeUtils.toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column2) {
  return column2 && (column2.constructor === ColumnInfo || column2 instanceof ColumnInfo);
}
function createColumn($xetable, options, renderOptions) {
  return isColumnInfo(options) ? options : reactive$1(new ColumnInfo($xetable, options, renderOptions));
}
function watchColumn(props, column2) {
  Object.keys(props).forEach(function(name2) {
    watch$1(function() {
      return props[name2];
    }, function(value) {
      column2.update(name2, value);
    });
  });
}
function assemColumn($xetable, elem, column2, colgroup) {
  var reactData = $xetable.reactData;
  var staticColumns = reactData.staticColumns;
  var parentElem = elem.parentNode;
  var parentColumn = colgroup ? colgroup.column : null;
  var parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(xeUtils.arrayIndexOf(parentElem.children, elem), 0, column2);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xetable, column2) {
  var reactData = $xetable.reactData;
  var staticColumns = reactData.staticColumns;
  var matchObj = xeUtils.findTree(staticColumns, function(item) {
    return item.id === column2.id;
  }, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (var mIndex = 0; mIndex < mergeList.length; mIndex++) {
    var _a2 = mergeList[mIndex], mergeRowIndex = _a2.row, mergeColIndex = _a2.col, mergeRowspan = _a2.rowspan, mergeColspan = _a2.colspan;
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
function clearTableDefaultStatus($xetable) {
  var props = $xetable.props, internalData = $xetable.internalData;
  internalData.initStatus = false;
  $xetable.clearSort();
  $xetable.clearCurrentRow();
  $xetable.clearCurrentColumn();
  $xetable.clearRadioRow();
  $xetable.clearRadioReserve();
  $xetable.clearCheckboxRow();
  $xetable.clearCheckboxReserve();
  $xetable.clearRowExpand();
  $xetable.clearTreeExpand();
  $xetable.clearTreeExpandReserve();
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xetable.clearSelected();
  }
  if ($xetable.clearCellAreas && props.mouseConfig) {
    $xetable.clearCellAreas();
    $xetable.clearCopyCellArea();
  }
  return $xetable.clearScroll();
}
function clearTableAllStatus($xetable) {
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  return clearTableDefaultStatus($xetable);
}
function rowToVisible($xetable, row2) {
  var reactData = $xetable.reactData, internalData = $xetable.internalData;
  var refTableBody = $xetable.getRefMaps().refTableBody;
  var scrollYLoad = reactData.scrollYLoad;
  var afterFullData = internalData.afterFullData, scrollYStore = internalData.scrollYStore;
  var tableBody = refTableBody.value;
  var bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    var trElem = bodyElem.querySelector('[rowid="'.concat(getRowid($xetable, row2), '"]'));
    if (trElem) {
      var bodyHeight = bodyElem.clientHeight;
      var bodySrcollTop = bodyElem.scrollTop;
      var trOffsetParent = trElem.offsetParent;
      var trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      var trHeight = trElem.clientHeight;
      if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {
        return $xetable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {
        return $xetable.scrollTo(null, bodySrcollTop + trHeight);
      }
    } else {
      if (scrollYLoad) {
        return $xetable.scrollTo(null, (afterFullData.indexOf(row2) - 1) * scrollYStore.rowHeight);
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xetable, column2) {
  var reactData = $xetable.reactData, internalData = $xetable.internalData;
  var refTableBody = $xetable.getRefMaps().refTableBody;
  var scrollXLoad = reactData.scrollXLoad;
  var visibleColumn = internalData.visibleColumn;
  var tableBody = refTableBody.value;
  var bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    var tdElem = bodyElem.querySelector(".".concat(column2.id));
    if (tdElem) {
      var bodyWidth = bodyElem.clientWidth;
      var bodySrcollLeft = bodyElem.scrollLeft;
      var tdOffsetParent = tdElem.offsetParent;
      var tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      var tdWidth = tdElem.clientWidth;
      if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {
        return $xetable.scrollTo(tdOffsetLeft);
      } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {
        return $xetable.scrollTo(bodySrcollLeft + tdWidth);
      }
    } else {
      if (scrollXLoad) {
        var scrollLeft = 0;
        for (var index = 0; index < visibleColumn.length; index++) {
          if (visibleColumn[index] === column2) {
            break;
          }
          scrollLeft += visibleColumn[index].renderWidth;
        }
        return $xetable.scrollTo(scrollLeft);
      }
    }
  }
  return Promise.resolve();
}
function getOnName(type2) {
  return "on" + type2.substring(0, 1).toLocaleUpperCase() + type2.substring(1);
}
function getSlotVNs(vns) {
  if (xeUtils.isArray(vns)) {
    return vns;
  }
  return [vns];
}
var __assign$k = globalThis && globalThis.__assign || function() {
  __assign$k = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$k.apply(this, arguments);
};
var __spreadArray$4 = globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var componentDefaultModelProp = "modelValue";
var defaultCompProps = { transfer: true };
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function parseDate(value, props) {
  return value && props.valueFormat ? xeUtils.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  var _a2 = props.dateConfig, dateConfig = _a2 === void 0 ? {} : _a2;
  return xeUtils.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, GlobalConfig.i18n("vxe.input.date.labelFormat.".concat(props.type)));
}
function getComponentName(name2) {
  return "vxe-".concat(name2.replace("$", ""));
}
function getDefaultComponent(_a2) {
  var name2 = _a2.name;
  return resolveComponent(getComponentName(name2));
}
function handleConfirmFilter(params, checked, option) {
  var $panel = params.$panel;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  var name2 = renderOpts.name, attrs2 = renderOpts.attrs;
  if (name2 === "input") {
    attrs2 = Object.assign({ type: "text" }, attrs2);
  }
  return attrs2;
}
function getInputImmediateModel(renderOpts) {
  var name2 = renderOpts.name, immediate = renderOpts.immediate, props = renderOpts.props;
  if (!immediate) {
    if (name2 === "$input") {
      var type2 = (props || {}).type;
      return !(!type2 || type2 === "text" || type2 === "number" || type2 === "integer" || type2 === "float");
    }
    if (name2 === "input" || name2 === "textarea" || name2 === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  var _a2;
  return xeUtils.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, (_a2 = {}, _a2[componentDefaultModelProp] = value, _a2));
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  var _a2;
  return xeUtils.assign({}, defaultCompProps, defaultProps, renderOpts.props, (_a2 = {}, _a2[componentDefaultModelProp] = value, _a2));
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  var _a2;
  return xeUtils.assign({}, defaultCompProps, defaultProps, renderOpts.props, (_a2 = {}, _a2[componentDefaultModelProp] = value, _a2));
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  var placeholder = renderOpts.placeholder;
  return [
    h$6("span", {
      class: "vxe-cell--label"
    }, placeholder && isEmptyValue(cellLabel) ? [
      h$6("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  var events = renderOpts.events;
  var modelEvent = getModelEvent(renderOpts);
  var changeEvent = getChangeEvent(renderOpts);
  var isSameEvent = changeEvent === modelEvent;
  var ons = {};
  if (events) {
    xeUtils.objectEach(events, function(func, key) {
      ons[getOnName(key)] = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        func.apply(void 0, __spreadArray$4([params], args, false));
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      changeFunc.apply(void 0, args);
      if (events && events[changeEvent]) {
        events[changeEvent].apply(events, __spreadArray$4([params], args, false));
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  var events = renderOpts.events;
  var modelEvent = getModelEvent(renderOpts);
  var changeEvent = getChangeEvent(renderOpts);
  var ons = {};
  xeUtils.objectEach(events, function(func, key) {
    ons[getOnName(key)] = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      func.apply(void 0, __spreadArray$4([params], args, false));
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      changeFunc.apply(void 0, args);
      if (events && events[changeEvent]) {
        events[changeEvent].apply(events, __spreadArray$4([params], args, false));
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  var $table = params.$table, row2 = params.row, column2 = params.column;
  var name2 = renderOpts.name;
  var model = column2.model;
  var isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, function(cellValue) {
    if (isImmediate) {
      setCellValue(row2, column2, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, function(eventParams) {
    if (!isImmediate && (name2 === "$input" || name2 === "$textarea")) {
      var cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, function(value) {
    option.data = value;
  }, function() {
    handleConfirmFilter(params, !xeUtils.eqNull(option.data), option);
  });
}
function getItemOns(renderOpts, params) {
  var $form = params.$form, data5 = params.data, property2 = params.property;
  return getComponentOns(renderOpts, params, function(value) {
    xeUtils.set(data5, property2, value);
  }, function() {
    $form.updateStatus(params);
  });
}
function getNativeEditOns(renderOpts, params) {
  var $table = params.$table, row2 = params.row, column2 = params.column;
  var model = column2.model;
  return getElementOns(renderOpts, params, function(evnt) {
    var cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row2, column2, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, function(evnt) {
    var cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getElementOns(renderOpts, params, function(evnt) {
    option.data = evnt.target.value;
  }, function() {
    handleConfirmFilter(params, !xeUtils.eqNull(option.data), option);
  });
}
function getNativeItemOns(renderOpts, params) {
  var $form = params.$form, data5 = params.data, property2 = params.property;
  return getElementOns(renderOpts, params, function(evnt) {
    var itemValue = evnt.target.value;
    xeUtils.set(data5, property2, itemValue);
  }, function() {
    $form.updateStatus(params);
  });
}
function nativeEditRender(renderOpts, params) {
  var row2 = params.row, column2 = params.column;
  var name2 = renderOpts.name;
  var cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row2, column2) : column2.model.value;
  return [
    h$6(name2, __assign$k(__assign$k(__assign$k({ class: "vxe-default-".concat(name2) }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  var row2 = params.row, column2 = params.column;
  var cellValue = getCellValue(row2, column2);
  return [
    h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function defaultButtonEditRender(renderOpts, params) {
  return [
    h$6(resolveComponent("vxe-button"), __assign$k(__assign$k({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map(function(childRenderOpts) {
    return defaultButtonEditRender(childRenderOpts, params)[0];
  });
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  var optionGroups = renderOpts.optionGroups, _a2 = renderOpts.optionGroupProps, optionGroupProps = _a2 === void 0 ? {} : _a2;
  var groupOptions = optionGroupProps.options || "options";
  var groupLabel = optionGroupProps.label || "label";
  return optionGroups.map(function(group, gIndex) {
    return h$6("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  var _a2 = renderOpts.optionProps, optionProps = _a2 === void 0 ? {} : _a2;
  var row2 = params.row, column2 = params.column;
  var labelProp = optionProps.label || "label";
  var valueProp = optionProps.value || "value";
  var disabledProp = optionProps.disabled || "disabled";
  var cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row2, column2) : column2.model.value;
  return options.map(function(option, oIndex) {
    return h$6("option", {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  var column2 = params.column;
  var name2 = renderOpts.name;
  var attrs2 = getNativeAttrs(renderOpts);
  return column2.filters.map(function(option, oIndex) {
    return h$6(name2, __assign$k(__assign$k(__assign$k({ key: oIndex, class: "vxe-default-".concat(name2) }, attrs2), { value: option.data }), getNativeFilterOns(renderOpts, params, option)));
  });
}
function defaultFilterRender(renderOpts, params) {
  var column2 = params.column;
  return column2.filters.map(function(option, oIndex) {
    var optionValue = option.data;
    return h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function handleFilterMethod(_a2) {
  var option = _a2.option, row2 = _a2.row, column2 = _a2.column;
  var data5 = option.data;
  var cellValue = xeUtils.get(row2, column2.property);
  return cellValue == data5;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h$6("select", __assign$k(__assign$k({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  var row2 = params.row, column2 = params.column;
  var options = renderOpts.options, optionProps = renderOpts.optionProps, optionGroups = renderOpts.optionGroups, optionGroupProps = renderOpts.optionGroupProps;
  var cellValue = getCellValue(row2, column2);
  return [
    h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, _a2) {
  var row2 = _a2.row, column2 = _a2.column;
  var _b2 = renderOpts.props, props = _b2 === void 0 ? {} : _b2, options = renderOpts.options, optionGroups = renderOpts.optionGroups, _c2 = renderOpts.optionProps, optionProps = _c2 === void 0 ? {} : _c2, _d2 = renderOpts.optionGroupProps, optionGroupProps = _d2 === void 0 ? {} : _d2;
  var cellValue = xeUtils.get(row2, column2.property);
  var selectItem;
  var labelProp = optionProps.label || "label";
  var valueProp = optionProps.value || "value";
  if (!isEmptyValue(cellValue)) {
    return xeUtils.map(props.multiple ? cellValue : [cellValue], optionGroups ? function(value) {
      var groupOptions = optionGroupProps.options || "options";
      for (var index = 0; index < optionGroups.length; index++) {
        selectItem = xeUtils.find(optionGroups[index][groupOptions], function(item) {
          return item[valueProp] == value;
        });
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : function(value) {
      selectItem = xeUtils.find(options, function(item) {
        return item[valueProp] == value;
      });
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function nativeItemRender(renderOpts, params) {
  var data5 = params.data, property2 = params.property;
  var name2 = renderOpts.name;
  var attrs2 = getNativeAttrs(renderOpts);
  var itemValue = xeUtils.get(data5, property2);
  return [
    h$6(name2, __assign$k(__assign$k(__assign$k({ class: "vxe-default-".concat(name2) }, attrs2), { value: attrs2 && name2 === "input" && (attrs2.type === "submit" || attrs2.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  var data5 = params.data, property2 = params.property;
  var itemValue = xeUtils.get(data5, property2);
  return [
    h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function defaultButtonItemRender(renderOpts, params) {
  return [
    h$6(resolveComponent("vxe-button"), __assign$k(__assign$k({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map(function(childRenderOpts) {
    return defaultButtonItemRender(childRenderOpts, params)[0];
  });
}
function renderNativeFormOptions(options, renderOpts, params) {
  var data5 = params.data, property2 = params.property;
  var _a2 = renderOpts.optionProps, optionProps = _a2 === void 0 ? {} : _a2;
  var labelProp = optionProps.label || "label";
  var valueProp = optionProps.value || "value";
  var disabledProp = optionProps.disabled || "disabled";
  var cellValue = xeUtils.get(data5, property2);
  return options.map(function(item, oIndex) {
    return h$6("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function handleExportSelectMethod(params) {
  var row2 = params.row, column2 = params.column, options = params.options;
  return options.original ? getCellValue(row2, column2) : getSelectCellValue(column2.editRender || column2.cellRender, params);
}
function defaultFormItemRadioAndCheckboxRender(renderOpts, params) {
  var name2 = renderOpts.name, options = renderOpts.options, _a2 = renderOpts.optionProps, optionProps = _a2 === void 0 ? {} : _a2;
  var data5 = params.data, property2 = params.property;
  var labelProp = optionProps.label || "label";
  var valueProp = optionProps.value || "value";
  var disabledProp = optionProps.disabled || "disabled";
  var itemValue = xeUtils.get(data5, property2);
  var compName = getComponentName(name2);
  if (options) {
    return [
      h$6(resolveComponent("".concat(compName, "-group")), __assign$k(__assign$k({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: function() {
          return options.map(function(item, index) {
            return h$6(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h$6(resolveComponent(compName), __assign$k(__assign$k({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
var renderMap = {
  input: {
    autofocus: "input",
    renderEdit: nativeEditRender,
    renderDefault: nativeEditRender,
    renderFilter: nativeFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: nativeItemRender
  },
  textarea: {
    autofocus: "textarea",
    renderEdit: nativeEditRender,
    renderItemContent: nativeItemRender
  },
  select: {
    renderEdit: nativeSelectEditRender,
    renderDefault: nativeSelectEditRender,
    renderCell: function(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter: function(renderOpts, params) {
      var column2 = params.column;
      return column2.filters.map(function(option, oIndex) {
        return h$6("select", __assign$k(__assign$k({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: function(renderOpts, params) {
      return [
        h$6("select", __assign$k(__assign$k({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    },
    cellExportMethod: handleExportSelectMethod
  },
  $input: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultEditRender,
    renderCell: function(renderOpts, params) {
      var _a2 = renderOpts.props, props = _a2 === void 0 ? {} : _a2;
      var row2 = params.row, column2 = params.column;
      var digits = props.digits || GlobalConfig.input.digits;
      var cellValue = xeUtils.get(row2, column2.property);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = xeUtils.toFixed(xeUtils.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: defaultEditRender,
    renderFilter: defaultFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: defaultItemRender
  },
  $textarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: defaultItemRender
  },
  $button: {
    renderDefault: defaultButtonEditRender,
    renderItemContent: defaultButtonItemRender
  },
  $buttons: {
    renderDefault: defaultButtonsEditRender,
    renderItemContent: defaultButtonsItemRender
  },
  $select: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultSelectEditRender,
    renderDefault: defaultSelectEditRender,
    renderCell: function(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter: function(renderOpts, params) {
      var column2 = params.column;
      var options = renderOpts.options, optionProps = renderOpts.optionProps, optionGroups = renderOpts.optionGroups, optionGroupProps = renderOpts.optionGroupProps;
      return column2.filters.map(function(option, oIndex) {
        var optionValue = option.data;
        return h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: function(renderOpts, params) {
      var data5 = params.data, property2 = params.property;
      var options = renderOpts.options, optionProps = renderOpts.optionProps, optionGroups = renderOpts.optionGroups, optionGroupProps = renderOpts.optionGroupProps;
      var itemValue = xeUtils.get(data5, property2);
      return [
        h$6(getDefaultComponent(renderOpts), __assign$k(__assign$k({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    },
    cellExportMethod: handleExportSelectMethod
  },
  $radio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: defaultFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: defaultFormItemRadioAndCheckboxRender
  },
  $switch: {
    autofocus: ".vxe-switch--button",
    renderEdit: defaultEditRender,
    renderDefault: defaultEditRender,
    renderItemContent: defaultItemRender
  }
};
var renderer = {
  mixin: function(opts) {
    xeUtils.each(opts, function(options, name2) {
      return renderer.add(name2, options);
    });
    return renderer;
  },
  get: function(name2) {
    return renderMap[name2] || null;
  },
  add: function(name2, options) {
    if (name2 && options) {
      var renders_1 = renderMap[name2];
      if (renders_1) {
        Object.assign(renders_1, options);
      } else {
        renderMap[name2] = options;
      }
    }
    return renderer;
  },
  delete: function(name2) {
    delete renderMap[name2];
    return renderer;
  }
};
var Store = function() {
  function Store2() {
    this.store = {};
  }
  Store2.prototype.mixin = function(options) {
    Object.assign(this.store, options);
    return this;
  };
  Store2.prototype.has = function(name2) {
    return !!this.get(name2);
  };
  Store2.prototype.get = function(name2) {
    return this.store[name2];
  };
  Store2.prototype.add = function(name2, render17) {
    var conf = this.store[name2];
    this.store[name2] = conf ? xeUtils.merge(conf, render17) : render17;
    return this;
  };
  Store2.prototype.delete = function(name2) {
    delete this.store[name2];
  };
  Store2.prototype.forEach = function(callback) {
    xeUtils.objectEach(this.store, callback);
  };
  return Store2;
}();
var commands = new Store();
var menus = new Store();
var formats = new Store();
var hooks$1 = new Store();
var setup = function(options) {
  return xeUtils.merge(GlobalConfig, options);
};
function getExportOrImpotType(types, flag) {
  var rest = [];
  xeUtils.objectEach(types, function(val2, type2) {
    if (val2 === 0 || val2 === flag) {
      rest.push(type2);
    }
  });
  return rest;
}
var installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VXETable, options);
      installedPlugins.push(Plugin);
    }
  }
  return VXETable;
}
function t$1(key, args) {
  return GlobalConfig.i18n(key, args);
}
function _t$7(key, args) {
  return key ? xeUtils.toValueString(GlobalConfig.translate ? GlobalConfig.translate(key, args) : key) : "";
}
var VXETableConfig = function() {
  function VXETableConfig2() {
  }
  Object.defineProperty(VXETableConfig2.prototype, "zIndex", {
    get: function() {
      return getLastZIndex();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VXETableConfig2.prototype, "nextZIndex", {
    get: function() {
      return nextZIndex();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VXETableConfig2.prototype, "exportTypes", {
    get: function() {
      return getExportOrImpotType(GlobalConfig.export.types, 1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(VXETableConfig2.prototype, "importTypes", {
    get: function() {
      return getExportOrImpotType(GlobalConfig.export.types, 2);
    },
    enumerable: false,
    configurable: true
  });
  return VXETableConfig2;
}();
var config = new VXETableConfig();
var v$4 = "v4";
var VXETable = {
  v: v$4,
  version: "4.3.2",
  setup,
  interceptor,
  renderer,
  commands,
  formats,
  menus,
  hooks: hooks$1,
  config,
  use,
  t: t$1,
  _t: _t$7
};
var PanelComponent$1 = defineComponent({
  name: "VxeTableFilter",
  props: {
    filterStore: Object
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;
    var computeHasCheckOption = computed$1(function() {
      var filterStore = props.filterStore;
      return filterStore && filterStore.options.some(function(option) {
        return option.checked;
      });
    });
    var filterCheckAllEvent = function(evnt, value) {
      var filterStore = props.filterStore;
      filterStore.options.forEach(function(option) {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    var confirmFilter = function(evnt) {
      var filterStore = props.filterStore;
      filterStore.options.forEach(function(option) {
        option.checked = option._checked;
      });
      $xetable.confirmFilterEvent(evnt);
    };
    var changeRadioOption = function(evnt, checked, item) {
      var filterStore = props.filterStore;
      filterStore.options.forEach(function(option) {
        option._checked = false;
      });
      item._checked = checked;
      $xetable.checkFilterOptions();
      confirmFilter(evnt);
    };
    var resetFilter = function(evnt) {
      var filterStore = props.filterStore;
      $xetable.handleClearFilter(filterStore.column);
      $xetable.confirmFilterEvent(evnt);
    };
    var changeMultipleOption = function(evnt, checked, item) {
      item._checked = checked;
      $xetable.checkFilterOptions();
    };
    var changeOption = function(evnt, checked, item) {
      var filterStore = props.filterStore;
      if (filterStore.multiple) {
        changeMultipleOption(evnt, checked, item);
      } else {
        changeRadioOption(evnt, checked, item);
      }
    };
    var changeAllOption = function(evnt, checked) {
      var filterStore = props.filterStore;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    var $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    var renderOptions = function(filterRender, compConf) {
      var filterStore = props.filterStore;
      var column2 = filterStore.column, multiple = filterStore.multiple, maxHeight = filterStore.maxHeight;
      var slots = column2.slots;
      var filterSlot = slots ? slots.filter : null;
      var params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      if (filterSlot) {
        return [
          h$6("div", {
            class: "vxe-table--filter-template"
          }, $xetable.callSlot(filterSlot, params))
        ];
      } else if (compConf && compConf.renderFilter) {
        return [
          h$6("div", {
            class: "vxe-table--filter-template"
          }, compConf.renderFilter(filterRender, params))
        ];
      }
      var isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some(function(item) {
        return item._checked;
      });
      var isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h$6("ul", {
          class: "vxe-table--filter-header"
        }, [
          h$6("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: GlobalConfig.i18n(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: function(evnt) {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h$6("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h$6("span", {
              class: "vxe-checkbox--label"
            }, GlobalConfig.i18n("vxe.table.allFilter"))
          ]))
        ]),
        h$6("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: "".concat(maxHeight, "px")
          } : {}
        }, filterStore.options.map(function(item) {
          var isChecked = item._checked;
          return h$6("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: function(evnt) {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h$6("span", {
              class: ["vxe-checkbox--icon", isChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h$6("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    var renderFooters = function() {
      var filterStore = props.filterStore;
      var column2 = filterStore.column, multiple = filterStore.multiple;
      var hasCheckOption = computeHasCheckOption.value;
      var filterRender = column2.filterRender;
      var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      var isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (!compConf || compConf.showFilterFooter !== false) ? [
        h$6("div", {
          class: "vxe-table--filter-footer"
        }, [
          h$6("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, GlobalConfig.i18n("vxe.table.confirmFilter")),
          h$6("button", {
            onClick: resetFilter
          }, GlobalConfig.i18n("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    var renderVN = function() {
      var filterStore = props.filterStore;
      var initStore = tableReactData.initStore;
      var column2 = filterStore.column;
      var filterRender = column2 ? column2.filterRender : null;
      var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      var filterClassName = compConf ? compConf.filterClassName : "";
      var params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      return h$6("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xetable.props.animat,
            "is--multiple": filterStore.multiple,
            "is--active": filterStore.visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && filterStore.visible ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});
var __assign$j = globalThis && globalThis.__assign || function() {
  __assign$j = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$j.apply(this, arguments);
};
var dynamicContainerElem;
var dynamicStore = reactive$1({
  modals: []
});
var VxeDynamics = defineComponent({
  setup: function() {
    return function() {
      var modals = dynamicStore.modals;
      return h$6("div", {
        class: "vxe-dynamics--modal"
      }, modals.map(function(item) {
        return h$6(resolveComponent("vxe-modal"), item);
      }));
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}
dynamicApp.component(PanelComponent$1.name, PanelComponent$1);
var PanelComponent = defineComponent({
  name: "VxeTableContextMenu",
  setup: function(props, context) {
    var xID = xeUtils.uniqueId();
    var $xetable = inject("$xetable", {});
    var tableReactData = $xetable.reactData;
    var refElem = ref$1();
    var refMaps = {
      refElem
    };
    var $xemenupanel = {
      xID,
      props,
      context,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var renderVN = function() {
      var ctxMenuStore = tableReactData.ctxMenuStore;
      var computeMenuOpts = $xetable.getComputeMaps().computeMenuOpts;
      var menuOpts = computeMenuOpts.value;
      return h$6(Teleport, {
        to: "body",
        disabled: false
      }, [
        h$6("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map(function(options, gIndex) {
          return options.every(function(item) {
            return item.visible === false;
          }) ? createCommentVNode() : h$6("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map(function(item, index) {
            var hasChildMenus = item.children && item.children.some(function(child) {
              return child.visible !== false;
            });
            return item.visible === false ? null : h$6("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: "".concat(gIndex, "_").concat(index)
            }, [
              h$6("a", {
                class: "vxe-context-menu--link",
                onClick: function(evnt) {
                  $xetable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover: function(evnt) {
                  $xetable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout: function(evnt) {
                  $xetable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h$6("i", {
                  class: ["vxe-context-menu--link-prefix", item.prefixIcon]
                }),
                h$6("span", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h$6("i", {
                  class: ["vxe-context-menu--link-suffix", hasChildMenus ? item.suffixIcon || "suffix--haschild" : item.suffixIcon]
                })
              ]),
              hasChildMenus ? h$6("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map(function(child, cIndex) {
                return child.visible === false ? null : h$6("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: "".concat(gIndex, "_").concat(index, "_").concat(cIndex)
                }, [
                  h$6("a", {
                    class: "vxe-context-menu--link",
                    onClick: function(evnt) {
                      $xetable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover: function(evnt) {
                      $xetable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout: function(evnt) {
                      $xetable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h$6("i", {
                      class: ["vxe-context-menu--link-prefix", child.prefixIcon]
                    }),
                    h$6("span", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name))
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xemenupanel.renderVN = renderVN;
    return $xemenupanel;
  },
  render: function() {
    return this.renderVN();
  }
});
var EVENT_KEYS = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var convertEventKeys = {
  " ": "Spacebar",
  Apps: EVENT_KEYS.CONTEXT_MENU,
  Del: EVENT_KEYS.DELETE,
  Up: EVENT_KEYS.ARROW_UP,
  Down: EVENT_KEYS.ARROW_DOWN,
  Left: EVENT_KEYS.ARROW_LEFT,
  Right: EVENT_KEYS.ARROW_RIGHT
};
var wheelName = browse.firefox ? "DOMMouseScroll" : "mousewheel";
var eventStore$1 = [];
var hasEventKey = function(evnt, targetKey) {
  var key = evnt.key;
  targetKey = targetKey.toLowerCase();
  return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
};
function triggerEvent(evnt) {
  var isWheel = evnt.type === wheelName;
  eventStore$1.forEach(function(_a2) {
    var type2 = _a2.type, cb = _a2.cb;
    if (!evnt.cancelBubble) {
      if (type2 === evnt.type || isWheel && type2 === "mousewheel") {
        cb(evnt);
      }
    }
  });
}
var GlobalEvent = {
  on: function(comp, type2, cb) {
    eventStore$1.push({ comp, type: type2, cb });
  },
  off: function(comp, type2) {
    xeUtils.remove(eventStore$1, function(item) {
      return item.comp === comp && item.type === type2;
    });
  },
  trigger: triggerEvent,
  eqKeypad: function(evnt, keyVal) {
    var key = evnt.key;
    if (keyVal.toLowerCase() === key.toLowerCase()) {
      return true;
    }
    return false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    document.addEventListener("copy", triggerEvent, false);
    document.addEventListener("cut", triggerEvent, false);
    document.addEventListener("paste", triggerEvent, false);
  }
  document.addEventListener("keydown", triggerEvent, false);
  document.addEventListener("contextmenu", triggerEvent, false);
  window.addEventListener("mousedown", triggerEvent, false);
  window.addEventListener("blur", triggerEvent, false);
  window.addEventListener("resize", triggerEvent, false);
  window.addEventListener(wheelName, xeUtils.throttle(triggerEvent, 100, { leading: true, trailing: false }), { passive: true, capture: false });
}
var __assign$i = globalThis && globalThis.__assign || function() {
  __assign$i = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$i.apply(this, arguments);
};
dynamicApp.component(PanelComponent.name, PanelComponent);
var __assign$h = globalThis && globalThis.__assign || function() {
  __assign$h = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$h.apply(this, arguments);
};
globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function useSize$1(props) {
  var xesize = inject("xesize", null);
  var computeSize = computed$1(function() {
    return props.size || (xesize ? xesize.value : null);
  });
  provide("xesize", computeSize);
  return computeSize;
}
var VxeButtonComponent = defineComponent({
  name: "VxeButton",
  props: {
    type: String,
    className: String,
    size: { type: String, default: function() {
      return GlobalConfig.button.size || GlobalConfig.size;
    } },
    name: [String, Number],
    content: String,
    placement: String,
    status: String,
    icon: String,
    round: Boolean,
    circle: Boolean,
    disabled: Boolean,
    loading: Boolean,
    destroyOnClose: Boolean,
    transfer: { type: Boolean, default: function() {
      return GlobalConfig.button.transfer;
    } }
  },
  emits: [
    "click",
    "dropdown-click"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inited: false,
      showPanel: false,
      animatVisible: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    var internalData = {
      showTime: null
    };
    var refElem = ref$1();
    var refButton = ref$1();
    var refBtnPanel = ref$1();
    var refMaps = {
      refElem
    };
    var $xebutton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var buttonMethods = {};
    var computeIsFormBtn = computed$1(function() {
      var type2 = props.type;
      if (type2) {
        return ["submit", "reset", "button"].indexOf(type2) > -1;
      }
      return false;
    });
    var computeBtnType = computed$1(function() {
      var type2 = props.type;
      return type2 && type2 === "text" ? type2 : "button";
    });
    var updateZindex = function() {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    var updatePlacement = function() {
      return nextTick$1().then(function() {
        var transfer = props.transfer, placement = props.placement;
        var panelIndex = reactData.panelIndex;
        var targetElem = refButton.value;
        var panelElem = refBtnPanel.value;
        if (panelElem && targetElem) {
          var targetHeight = targetElem.offsetHeight;
          var targetWidth = targetElem.offsetWidth;
          var panelHeight = panelElem.offsetHeight;
          var panelWidth = panelElem.offsetWidth;
          var marginSize = 5;
          var panelStyle = {
            zIndex: panelIndex
          };
          var _a2 = getAbsolutePos(targetElem), top_1 = _a2.top, left = _a2.left, boundingTop = _a2.boundingTop, visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
          var panelPlacement = "bottom";
          if (transfer) {
            var btnLeft = left + targetWidth - panelWidth;
            var btnTop = top_1 + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top_1 - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top_1 - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top_1 + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: "".concat(btnLeft, "px"),
              right: "auto",
              top: "".concat(btnTop, "px"),
              minWidth: "".concat(targetWidth, "px")
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = "".concat(targetHeight, "px");
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = "".concat(targetHeight, "px");
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick$1();
        }
      });
    };
    var clickEvent = function(evnt) {
      buttonMethods.dispatchEvent("click", { $event: evnt }, evnt);
    };
    var mousedownDropdownEvent = function(evnt) {
      var isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    var clickDropdownEvent = function(evnt) {
      var dropdownElem = evnt.currentTarget;
      var panelElem = refBtnPanel.value;
      var _a2 = getEventTargetNode(evnt, dropdownElem, "vxe-button"), flag = _a2.flag, targetElem = _a2.targetElem;
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.showPanel = false;
        setTimeout(function() {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    var mouseenterEvent = function() {
      var panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.animatVisible = true;
        setTimeout(function() {
          if (panelElem.dataset.active === "Y") {
            reactData.showPanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(function() {
              if (reactData.showPanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    var mouseenterTargetEvent = function() {
      var panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(function() {
          if (panelElem.dataset.active === "Y") {
            mouseenterEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, 250);
      }
    };
    var closePanel = function() {
      var panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(function() {
          if (panelElem.dataset.active !== "Y") {
            reactData.showPanel = false;
            setTimeout(function() {
              if (panelElem.dataset.active !== "Y") {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.showPanel = false;
      }
    };
    var mouseleaveEvent = function() {
      closePanel();
    };
    var renderContent = function() {
      var content = props.content, icon = props.icon, loading = props.loading;
      var contVNs = [];
      if (loading) {
        contVNs.push(h$6("i", {
          class: ["vxe-button--loading-icon", GlobalConfig.icon.BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push(h$6("span", {
          class: "vxe-button--custom-icon"
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push(h$6("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (slots.default) {
        contVNs.push(h$6("span", {
          class: "vxe-button--content"
        }, slots.default({})));
      } else if (content) {
        contVNs.push(h$6("span", {
          class: "vxe-button--content"
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $button: $xebutton, $event: evnt }, params));
      },
      focus: function() {
        var btnElem = refButton.value;
        btnElem.focus();
        return nextTick$1();
      },
      blur: function() {
        var btnElem = refButton.value;
        btnElem.blur();
        return nextTick$1();
      }
    };
    Object.assign($xebutton, buttonMethods);
    onMounted$1(function() {
      GlobalEvent.on($xebutton, "mousewheel", function(evnt) {
        var panelElem = refBtnPanel.value;
        if (reactData.showPanel && !getEventTargetNode(evnt, panelElem).flag) {
          closePanel();
        }
      });
    });
    onUnmounted(function() {
      GlobalEvent.off($xebutton, "mousewheel");
    });
    var renderVN = function() {
      var _a2, _b2, _c2, _d2;
      var className = props.className, transfer = props.transfer, type2 = props.type, round2 = props.round, circle = props.circle, destroyOnClose = props.destroyOnClose, status = props.status, name2 = props.name, disabled3 = props.disabled, loading = props.loading;
      var inited = reactData.inited, showPanel = reactData.showPanel;
      var isFormBtn = computeIsFormBtn.value;
      var btnType = computeBtnType.value;
      var vSize = computeSize.value;
      if (slots.dropdowns) {
        return h$6("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className, (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--active"] = showPanel, _a2)]
        }, [
          h$6("button", {
            ref: refButton,
            class: ["vxe-button", "type--".concat(btnType), (_b2 = {}, _b2["size--".concat(vSize)] = vSize, _b2["theme--".concat(status)] = status, _b2["is--round"] = round2, _b2["is--circle"] = circle, _b2["is--disabled"] = disabled3 || loading, _b2["is--loading"] = loading, _b2)],
            name: name2,
            type: isFormBtn ? type2 : "button",
            disabled: disabled3 || loading,
            onMouseenter: mouseenterTargetEvent,
            onMouseleave: mouseleaveEvent,
            onClick: clickEvent
          }, renderContent().concat([
            h$6("i", {
              class: "vxe-button--dropdown-arrow ".concat(GlobalConfig.icon.BUTTON_DROPDOWN)
            })
          ])),
          h$6(Teleport, {
            to: "body",
            disabled: transfer ? !inited : true
          }, [
            h$6("div", {
              ref: refBtnPanel,
              class: ["vxe-button--dropdown-panel", (_c2 = {}, _c2["size--".concat(vSize)] = vSize, _c2["animat--leave"] = reactData.animatVisible, _c2["animat--enter"] = showPanel, _c2)],
              placement: reactData.panelPlacement,
              style: reactData.panelStyle
            }, inited ? [
              h$6("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent,
                onMouseenter: mouseenterEvent,
                onMouseleave: mouseleaveEvent
              }, destroyOnClose && !showPanel ? [] : slots.dropdowns({}))
            ] : [])
          ])
        ]);
      }
      return h$6("button", {
        ref: refButton,
        class: ["vxe-button", "type--".concat(btnType), (_d2 = {}, _d2["size--".concat(vSize)] = vSize, _d2["theme--".concat(status)] = status, _d2["is--round"] = round2, _d2["is--circle"] = circle, _d2["is--disabled"] = disabled3 || loading, _d2["is--loading"] = loading, _d2)],
        name: name2,
        type: isFormBtn ? type2 : "button",
        disabled: disabled3 || loading,
        onClick: clickEvent
      }, renderContent());
    };
    $xebutton.renderVN = renderVN;
    return $xebutton;
  },
  render: function() {
    return this.renderVN();
  }
});
var VxeLoadingComponent = defineComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: String,
    text: String
  },
  setup: function(props) {
    var computeLoadingIcon = computed$1(function() {
      return props.icon || GlobalConfig.icon.LOADING;
    });
    var computeLoadingText = computed$1(function() {
      var loadingText = GlobalConfig.loadingText;
      return props.text || (loadingText === null ? loadingText : GlobalConfig.i18n("vxe.loading.text"));
    });
    return function() {
      var loadingIcon = computeLoadingIcon.value;
      var loadingText = computeLoadingText.value;
      return h$6("div", {
        class: ["vxe-loading", {
          "is--visible": props.modelValue
        }]
      }, [
        h$6("div", {
          class: "vxe-loading--chunk"
        }, [
          loadingIcon ? h$6("i", {
            class: loadingIcon
          }) : h$6("div", {
            class: "vxe-loading--spinner"
          }),
          loadingText ? h$6("div", {
            class: "vxe-loading--text"
          }, "".concat(loadingText)) : null
        ])
      ]);
    };
  }
});
var VxeLoading = Object.assign(VxeLoadingComponent, {
  install: function(app) {
    app.component(VxeLoadingComponent.name, VxeLoadingComponent);
  }
});
var __assign$g = globalThis && globalThis.__assign || function() {
  __assign$g = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$g.apply(this, arguments);
};
var allActivedModals = [];
var msgQueue = [];
var VxeModalComponent = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: { type: String, default: "modal" },
    loading: { type: Boolean, default: null },
    status: String,
    iconStatus: String,
    className: String,
    top: { type: [Number, String], default: function() {
      return GlobalConfig.modal.top;
    } },
    position: [String, Object],
    title: String,
    duration: { type: [Number, String], default: function() {
      return GlobalConfig.modal.duration;
    } },
    message: [Number, String],
    content: [Number, String],
    cancelButtonText: { type: String, default: function() {
      return GlobalConfig.modal.cancelButtonText;
    } },
    confirmButtonText: { type: String, default: function() {
      return GlobalConfig.modal.confirmButtonText;
    } },
    lockView: { type: Boolean, default: function() {
      return GlobalConfig.modal.lockView;
    } },
    lockScroll: Boolean,
    mask: { type: Boolean, default: function() {
      return GlobalConfig.modal.mask;
    } },
    maskClosable: { type: Boolean, default: function() {
      return GlobalConfig.modal.maskClosable;
    } },
    escClosable: { type: Boolean, default: function() {
      return GlobalConfig.modal.escClosable;
    } },
    resize: Boolean,
    showHeader: { type: Boolean, default: function() {
      return GlobalConfig.modal.showHeader;
    } },
    showFooter: { type: Boolean, default: function() {
      return GlobalConfig.modal.showFooter;
    } },
    showZoom: Boolean,
    showClose: { type: Boolean, default: function() {
      return GlobalConfig.modal.showClose;
    } },
    dblclickZoom: { type: Boolean, default: function() {
      return GlobalConfig.modal.dblclickZoom;
    } },
    width: [Number, String],
    height: [Number, String],
    minWidth: { type: [Number, String], default: function() {
      return GlobalConfig.modal.minWidth;
    } },
    minHeight: { type: [Number, String], default: function() {
      return GlobalConfig.modal.minHeight;
    } },
    zIndex: Number,
    marginSize: { type: [Number, String], default: function() {
      return GlobalConfig.modal.marginSize;
    } },
    fullscreen: Boolean,
    draggable: { type: Boolean, default: function() {
      return GlobalConfig.modal.draggable;
    } },
    remember: { type: Boolean, default: function() {
      return GlobalConfig.modal.remember;
    } },
    destroyOnClose: { type: Boolean, default: function() {
      return GlobalConfig.modal.destroyOnClose;
    } },
    showTitleOverflow: { type: Boolean, default: function() {
      return GlobalConfig.modal.showTitleOverflow;
    } },
    transfer: { type: Boolean, default: function() {
      return GlobalConfig.modal.transfer;
    } },
    storage: { type: Boolean, default: function() {
      return GlobalConfig.modal.storage;
    } },
    storageKey: { type: String, default: function() {
      return GlobalConfig.modal.storageKey;
    } },
    animat: { type: Boolean, default: function() {
      return GlobalConfig.modal.animat;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.modal.size || GlobalConfig.size;
    } },
    beforeHideMethod: { type: Function, default: function() {
      return GlobalConfig.modal.beforeHideMethod;
    } },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inited: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      zoomLocat: null,
      firstOpen: true
    });
    var refElem = ref$1();
    var refModalBox = ref$1();
    var refConfirmBtn = ref$1();
    var refCancelBtn = ref$1();
    var refMaps = {
      refElem
    };
    var $xemodal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var modalMethods = {};
    var computeIsMsg = computed$1(function() {
      return props.type === "message";
    });
    var getBox = function() {
      var boxElem = refModalBox.value;
      return boxElem;
    };
    var recalculate = function() {
      var width2 = props.width, height2 = props.height;
      var boxElem = getBox();
      boxElem.style.width = "".concat(width2 ? isNaN(width2) ? width2 : "".concat(width2, "px") : "");
      boxElem.style.height = "".concat(height2 ? isNaN(height2) ? height2 : "".concat(height2, "px") : "");
      return nextTick$1();
    };
    var updateZindex = function() {
      var zIndex2 = props.zIndex;
      var modalZindex = reactData.modalZindex;
      if (zIndex2) {
        reactData.modalZindex = zIndex2;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    var updatePosition = function() {
      return nextTick$1().then(function() {
        var position = props.position;
        var marginSize = xeUtils.toNumber(props.marginSize);
        var boxElem = getBox();
        var clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        var clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        var isPosCenter = position === "center";
        var _a2 = xeUtils.isString(position) ? { top: position, left: position } : Object.assign({}, position), top = _a2.top, left = _a2.left;
        var topCenter = isPosCenter || top === "center";
        var leftCenter = isPosCenter || left === "center";
        var posTop = "";
        var posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : "".concat(left, "px");
        } else {
          posLeft = "".concat(Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2), "px");
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : "".concat(top, "px");
        } else {
          posTop = "".concat(Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2), "px");
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    var updateStyle2 = function() {
      nextTick$1(function() {
        var offsetTop = 0;
        msgQueue.forEach(function(comp) {
          var boxElem = comp.getBox();
          offsetTop += xeUtils.toNumber(comp.props.top);
          comp.reactData.modalTop = offsetTop;
          offsetTop += boxElem.clientHeight;
        });
      });
    };
    var removeMsgQueue = function() {
      if (msgQueue.indexOf($xemodal) > -1) {
        xeUtils.remove(msgQueue, function(comp) {
          return comp === $xemodal;
        });
      }
      updateStyle2();
    };
    var closeModal2 = function(type2) {
      var remember = props.remember, beforeHideMethod = props.beforeHideMethod;
      var visible = reactData.visible;
      var isMsg = computeIsMsg.value;
      var params = { type: type2 };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(function(rest) {
          if (!xeUtils.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              reactData.zoomLocat = null;
            }
            xeUtils.remove(allActivedModals, function(item) {
              return item === $xemodal;
            });
            modalMethods.dispatchEvent("before-hide", params);
            setTimeout(function() {
              reactData.visible = false;
              emit("update:modelValue", false);
              modalMethods.dispatchEvent("hide", params);
            }, 200);
          }
        }).catch(function(e3) {
          return e3;
        });
      }
      return nextTick$1();
    };
    var closeEvent = function(evnt) {
      var type2 = "close";
      modalMethods.dispatchEvent(type2, { type: type2 }, evnt);
      closeModal2(type2);
    };
    var confirmEvent = function(evnt) {
      var type2 = "confirm";
      modalMethods.dispatchEvent(type2, { type: type2 }, evnt);
      closeModal2(type2);
    };
    var cancelEvent = function(evnt) {
      var type2 = "cancel";
      modalMethods.dispatchEvent(type2, { type: type2 }, evnt);
      closeModal2(type2);
    };
    var getStorageMap = function(key) {
      var version2 = GlobalConfig.version;
      var rest = xeUtils.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    var hasPosStorage = function() {
      var id2 = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;
      return !!(id2 && remember && storage && getStorageMap(storageKey)[id2]);
    };
    var restorePosStorage = function() {
      var id2 = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;
      if (id2 && remember && storage) {
        var posStorage = getStorageMap(storageKey)[id2];
        if (posStorage) {
          var boxElem = getBox();
          var _a2 = posStorage.split(","), left = _a2[0], top_1 = _a2[1], width2 = _a2[2], height2 = _a2[3], zoomLeft = _a2[4], zoomTop = _a2[5], zoomWidth = _a2[6], zoomHeight = _a2[7];
          if (left) {
            boxElem.style.left = "".concat(left, "px");
          }
          if (top_1) {
            boxElem.style.top = "".concat(top_1, "px");
          }
          if (width2) {
            boxElem.style.width = "".concat(width2, "px");
          }
          if (height2) {
            boxElem.style.height = "".concat(height2, "px");
          }
          if (zoomLeft && zoomTop) {
            reactData.zoomLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    var addMsgQueue = function() {
      if (msgQueue.indexOf($xemodal) === -1) {
        msgQueue.push($xemodal);
      }
      updateStyle2();
    };
    var savePosStorage = function() {
      var id2 = props.id, remember = props.remember, storage = props.storage, storageKey = props.storageKey;
      var zoomLocat = reactData.zoomLocat;
      if (id2 && remember && storage) {
        var boxElem = getBox();
        var posStorageMap = getStorageMap(storageKey);
        posStorageMap[id2] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(zoomLocat ? [
          zoomLocat.left,
          zoomLocat.top,
          zoomLocat.width,
          zoomLocat.height
        ] : []).map(function(val2) {
          return val2 ? xeUtils.toNumber(val2) : "";
        }).join(",");
        localStorage.setItem(storageKey, xeUtils.toJSONString(posStorageMap));
      }
    };
    var maximize = function() {
      return nextTick$1().then(function() {
        if (!reactData.zoomLocat) {
          var marginSize = Math.max(0, xeUtils.toNumber(props.marginSize));
          var boxElem = getBox();
          var _a2 = getDomNode(), visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
          reactData.zoomLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
          Object.assign(boxElem.style, {
            top: "".concat(marginSize, "px"),
            left: "".concat(marginSize, "px"),
            width: "".concat(visibleWidth - marginSize * 2, "px"),
            height: "".concat(visibleHeight - marginSize * 2, "px")
          });
          savePosStorage();
        }
      });
    };
    var openModal2 = function() {
      var duration = props.duration, remember = props.remember, showFooter = props.showFooter;
      var inited = reactData.inited, visible = reactData.visible;
      var isMsg = computeIsMsg.value;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActivedModals.push($xemodal);
        setTimeout(function() {
          reactData.contentVisible = true;
          nextTick$1(function() {
            if (showFooter) {
              var confirmBtn = refConfirmBtn.value;
              var cancelBtn = refCancelBtn.value;
              var operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            var type2 = "";
            var params = { type: type2 };
            emit("update:modelValue", true);
            modalMethods.dispatchEvent("show", params);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          if (duration !== -1) {
            setTimeout(function() {
              return closeModal2("close");
            }, xeUtils.toNumber(duration));
          }
        } else {
          nextTick$1(function() {
            var fullscreen = props.fullscreen;
            var firstOpen = reactData.firstOpen;
            if (!remember || firstOpen) {
              updatePosition().then(function() {
                setTimeout(function() {
                  return updatePosition();
                }, 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick$1(function() {
                  return maximize();
                });
              }
            } else {
              if (fullscreen) {
                nextTick$1(function() {
                  return maximize();
                });
              }
            }
          });
        }
      }
      return nextTick$1();
    };
    var selfClickEvent = function(evnt) {
      var el2 = refElem.value;
      if (props.maskClosable && evnt.target === el2) {
        var type2 = "mask";
        closeModal2(type2);
      }
    };
    var handleGlobalKeydownEvent = function(evnt) {
      var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        var lastModal_1 = xeUtils.max(allActivedModals, function(item) {
          return item.reactData.modalZindex;
        });
        if (lastModal_1) {
          setTimeout(function() {
            if (lastModal_1 === $xemodal && lastModal_1.props.escClosable) {
              closeModal2("exit");
            }
          }, 10);
        }
      }
    };
    var isMaximized = function() {
      return !!reactData.zoomLocat;
    };
    var revert = function() {
      return nextTick$1().then(function() {
        var zoomLocat = reactData.zoomLocat;
        if (zoomLocat) {
          var boxElem = getBox();
          reactData.zoomLocat = null;
          Object.assign(boxElem.style, {
            top: "".concat(zoomLocat.top, "px"),
            left: "".concat(zoomLocat.left, "px"),
            width: "".concat(zoomLocat.width, "px"),
            height: "".concat(zoomLocat.height, "px")
          });
          savePosStorage();
        }
      });
    };
    var zoom = function() {
      if (reactData.zoomLocat) {
        return revert().then(function() {
          return isMaximized();
        });
      }
      return maximize().then(function() {
        return isMaximized();
      });
    };
    var toggleZoomEvent = function(evnt) {
      var zoomLocat = reactData.zoomLocat;
      var params = { type: zoomLocat ? "revert" : "max" };
      return zoom().then(function() {
        modalMethods.dispatchEvent("zoom", params, evnt);
      });
    };
    var getPosition = function() {
      var isMsg = computeIsMsg.value;
      if (!isMsg) {
        var boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    var setPosition = function(top, left) {
      var isMsg = computeIsMsg.value;
      if (!isMsg) {
        var boxElem = getBox();
        if (xeUtils.isNumber(top)) {
          boxElem.style.top = "".concat(top, "px");
        }
        if (xeUtils.isNumber(left)) {
          boxElem.style.left = "".concat(left, "px");
        }
      }
      return nextTick$1();
    };
    var boxMousedownEvent = function() {
      var modalZindex = reactData.modalZindex;
      if (allActivedModals.some(function(comp) {
        return comp.reactData.visible && comp.reactData.modalZindex > modalZindex;
      })) {
        updateZindex();
      }
    };
    var mousedownEvent = function(evnt) {
      var remember = props.remember, storage = props.storage;
      var zoomLocat = reactData.zoomLocat;
      var marginSize = xeUtils.toNumber(props.marginSize);
      var boxElem = getBox();
      if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        var domMousemove_1 = document.onmousemove;
        var domMouseup_1 = document.onmouseup;
        var disX_1 = evnt.clientX - boxElem.offsetLeft;
        var disY_1 = evnt.clientY - boxElem.offsetTop;
        var _a2 = getDomNode(), visibleHeight_1 = _a2.visibleHeight, visibleWidth_1 = _a2.visibleWidth;
        document.onmousemove = function(evnt2) {
          evnt2.preventDefault();
          var offsetWidth = boxElem.offsetWidth;
          var offsetHeight = boxElem.offsetHeight;
          var minX = marginSize;
          var maxX = visibleWidth_1 - offsetWidth - marginSize - 1;
          var minY = marginSize;
          var maxY = visibleHeight_1 - offsetHeight - marginSize - 1;
          var left = evnt2.clientX - disX_1;
          var top = evnt2.clientY - disY_1;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = "".concat(left, "px");
          boxElem.style.top = "".concat(top, "px");
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        };
        document.onmouseup = function() {
          document.onmousemove = domMousemove_1;
          document.onmouseup = domMouseup_1;
          if (remember && storage) {
            nextTick$1(function() {
              savePosStorage();
            });
          }
          setTimeout(function() {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    var dragEvent = function(evnt) {
      evnt.preventDefault();
      var remember = props.remember, storage = props.storage;
      var _a2 = getDomNode(), visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
      var marginSize = xeUtils.toNumber(props.marginSize);
      var targetElem = evnt.target;
      var type2 = targetElem.getAttribute("type");
      var minWidth = xeUtils.toNumber(props.minWidth);
      var minHeight = xeUtils.toNumber(props.minHeight);
      var maxWidth = visibleWidth;
      var maxHeight = visibleHeight;
      var boxElem = getBox();
      var domMousemove = document.onmousemove;
      var domMouseup = document.onmouseup;
      var clientWidth = boxElem.clientWidth;
      var clientHeight = boxElem.clientHeight;
      var disX = evnt.clientX;
      var disY = evnt.clientY;
      var offsetTop = boxElem.offsetTop;
      var offsetLeft = boxElem.offsetLeft;
      var params = { type: "resize" };
      document.onmousemove = function(evnt2) {
        evnt2.preventDefault();
        var dragLeft;
        var dragTop;
        var width2;
        var height2;
        switch (type2) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width2 = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
                boxElem.style.left = "".concat(offsetLeft - dragLeft, "px");
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width2 = dragLeft + clientWidth;
            height2 = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
                boxElem.style.left = "".concat(offsetLeft - dragLeft, "px");
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
                boxElem.style.top = "".concat(offsetTop - dragTop, "px");
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width2 = dragLeft + clientWidth;
            height2 = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
                boxElem.style.left = "".concat(offsetLeft - dragLeft, "px");
              }
            }
            if (offsetTop + height2 + marginSize < visibleHeight) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height2 = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
                boxElem.style.top = "".concat(offsetTop - dragTop, "px");
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width2 = dragLeft + clientWidth;
            if (offsetLeft + width2 + marginSize < visibleWidth) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width2 = dragLeft + clientWidth;
            height2 = dragTop + clientHeight;
            if (offsetLeft + width2 + marginSize < visibleWidth) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
                boxElem.style.top = "".concat(offsetTop - dragTop, "px");
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width2 = dragLeft + clientWidth;
            height2 = dragTop + clientHeight;
            if (offsetLeft + width2 + marginSize < visibleWidth) {
              if (width2 > minWidth) {
                boxElem.style.width = "".concat(width2 < maxWidth ? width2 : maxWidth, "px");
              }
            }
            if (offsetTop + height2 + marginSize < visibleHeight) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height2 = dragTop + clientHeight;
            if (offsetTop + height2 + marginSize < visibleHeight) {
              if (height2 > minHeight) {
                boxElem.style.height = "".concat(height2 < maxHeight ? height2 : maxHeight, "px");
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent("zoom", params, evnt2);
      };
      document.onmouseup = function() {
        reactData.zoomLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(function() {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    var renderTitles = function() {
      var _a2 = props.slots, propSlots = _a2 === void 0 ? {} : _a2, showClose = props.showClose, showZoom = props.showZoom, title = props.title;
      var zoomLocat = reactData.zoomLocat;
      var titleSlot = slots.title || propSlots.title;
      var cornerSlot = slots.corner || propSlots.corner;
      var titVNs = [
        h$6("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $modal: $xemodal })) : title ? getFuncText(title) : GlobalConfig.i18n("vxe.alert.title"))
      ];
      var rightVNs = [];
      if (cornerSlot) {
        rightVNs.push(h$6("span", {
          class: "vxe-modal--corner-warpper"
        }, getSlotVNs(cornerSlot({ $modal: $xemodal }))));
      }
      if (showZoom) {
        rightVNs.push(h$6("i", {
          class: ["vxe-modal--zoom-btn", "trigger--btn", zoomLocat ? GlobalConfig.icon.MODAL_ZOOM_OUT : GlobalConfig.icon.MODAL_ZOOM_IN],
          title: GlobalConfig.i18n("vxe.modal.zoom".concat(zoomLocat ? "Out" : "In")),
          onClick: toggleZoomEvent
        }));
      }
      if (showClose) {
        rightVNs.push(h$6("i", {
          class: ["vxe-modal--close-btn", "trigger--btn", GlobalConfig.icon.MODAL_CLOSE],
          title: GlobalConfig.i18n("vxe.modal.close"),
          onClick: closeEvent
        }));
      }
      titVNs.push(h$6("div", {
        class: "vxe-modal--header-right"
      }, rightVNs));
      return titVNs;
    };
    var renderHeaders = function() {
      var _a2 = props.slots, propSlots = _a2 === void 0 ? {} : _a2, showZoom = props.showZoom, draggable = props.draggable;
      var isMsg = computeIsMsg.value;
      var headerSlot = slots.header || propSlots.header;
      var headVNs = [];
      if (props.showHeader) {
        var headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if (showZoom && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomEvent;
        }
        headVNs.push(h$6("div", __assign$g({ class: ["vxe-modal--header", {
          "is--draggable": draggable,
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({ $modal: $xemodal })) : renderTitles()));
      }
      return headVNs;
    };
    var renderBodys = function() {
      var _a2 = props.slots, propSlots = _a2 === void 0 ? {} : _a2, status = props.status, message2 = props.message;
      var content = props.content || message2;
      var isMsg = computeIsMsg.value;
      var defaultSlot = slots.default || propSlots.default;
      var contVNs = [];
      if (status) {
        contVNs.push(h$6("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h$6("i", {
            class: ["vxe-modal--status-icon", props.iconStatus || GlobalConfig.icon["MODAL_".concat(status).toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h$6("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({ $modal: $xemodal })) : getFuncText(content)));
      if (!isMsg) {
        contVNs.push(h$6(VxeLoading, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        }));
      }
      return [
        h$6("div", {
          class: "vxe-modal--body"
        }, contVNs)
      ];
    };
    var renderBtns = function() {
      var type2 = props.type;
      var btnVNs = [];
      if (type2 === "confirm") {
        btnVNs.push(h$6(VxeButtonComponent, {
          ref: refCancelBtn,
          content: props.cancelButtonText || GlobalConfig.i18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      btnVNs.push(h$6(VxeButtonComponent, {
        ref: refConfirmBtn,
        status: "primary",
        content: props.confirmButtonText || GlobalConfig.i18n("vxe.button.confirm"),
        onClick: confirmEvent
      }));
      return btnVNs;
    };
    var renderFooters = function() {
      var _a2 = props.slots, propSlots = _a2 === void 0 ? {} : _a2;
      var isMsg = computeIsMsg.value;
      var footerSlot = slots.footer || propSlots.footer;
      var footVNs = [];
      if (props.showFooter) {
        footVNs.push(h$6("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({ $modal: $xemodal })) : renderBtns()));
      }
      if (!isMsg && props.resize) {
        footVNs.push(h$6("span", {
          class: "vxe-modal--resize"
        }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map(function(type2) {
          return h$6("span", {
            class: "".concat(type2, "-resize"),
            type: type2,
            onMousedown: dragEvent
          });
        })));
      }
      return footVNs;
    };
    modalMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $modal: $xemodal, $event: evnt }, params));
      },
      open: openModal2,
      close: function() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMaximized,
      zoom,
      maximize,
      revert
    };
    Object.assign($xemodal, modalMethods);
    watch$1(function() {
      return props.width;
    }, recalculate);
    watch$1(function() {
      return props.height;
    }, recalculate);
    watch$1(function() {
      return props.modelValue;
    }, function(value) {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted$1(function() {
      nextTick$1(function() {
        if (props.storage && !props.id) {
          errLog("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xemodal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(function() {
      GlobalEvent.off($xemodal, "keydown");
      removeMsgQueue();
    });
    var renderVN = function() {
      var _a2;
      var className = props.className, type2 = props.type, animat = props.animat, loading = props.loading, status = props.status, lockScroll = props.lockScroll, lockView = props.lockView, mask = props.mask, resize = props.resize;
      var inited = reactData.inited, zoomLocat = reactData.zoomLocat, modalTop = reactData.modalTop, contentVisible = reactData.contentVisible, visible = reactData.visible;
      var vSize = computeSize.value;
      return h$6(Teleport, {
        to: "body",
        disabled: props.transfer ? !inited : true
      }, [
        h$6("div", {
          ref: refElem,
          class: ["vxe-modal--wrapper", "type--".concat(type2), className || "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["status--".concat(status)] = status, _a2["is--animat"] = animat, _a2["lock--scroll"] = lockScroll, _a2["lock--view"] = lockView, _a2["is--resize"] = resize, _a2["is--mask"] = mask, _a2["is--maximize"] = zoomLocat, _a2["is--visible"] = contentVisible, _a2["is--active"] = visible, _a2["is--loading"] = loading, _a2)],
          style: {
            zIndex: reactData.modalZindex,
            top: modalTop ? "".concat(modalTop, "px") : null
          },
          onClick: selfClickEvent
        }, [
          h$6("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, renderHeaders().concat(renderBodys(), renderFooters()))
        ])
      ]);
    };
    $xemodal.renderVN = renderVN;
    return $xemodal;
  },
  render: function() {
    return this.renderVN();
  }
});
function toStringTimeDate(str) {
  if (str) {
    var rest = new Date();
    var h2 = 0;
    var m2 = 0;
    var s2 = 0;
    if (xeUtils.isDate(str)) {
      h2 = str.getHours();
      m2 = str.getMinutes();
      s2 = str.getSeconds();
    } else {
      str = xeUtils.toValueString(str);
      var parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = xeUtils.toNumber(parses[1]);
        m2 = xeUtils.toNumber(parses[3]);
        s2 = xeUtils.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m2);
    rest.setSeconds(s2);
    return rest;
  }
  return new Date("");
}
function getDateQuarter(date) {
  var month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
function handleNumber(val2) {
  return xeUtils.isString(val2) ? val2.replace(/,/g, "") : val2;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return xeUtils.toFixed(xeUtils.ceil(inputValue, digitsValue), digitsValue);
  }
  return xeUtils.toFixed(xeUtils.floor(inputValue, digitsValue), digitsValue);
}
var yearSize = 12;
var monthSize = 20;
var quarterSize = 8;
var VxeInputConstructor = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "text" },
    clearable: { type: Boolean, default: function() {
      return GlobalConfig.input.clearable;
    } },
    readonly: Boolean,
    disabled: Boolean,
    placeholder: String,
    maxlength: [String, Number],
    autocomplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: function() {
      return GlobalConfig.input.size || GlobalConfig.size;
    } },
    multiple: Boolean,
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: function() {
      return GlobalConfig.input.exponential;
    } },
    controls: { type: Boolean, default: function() {
      return GlobalConfig.input.controls;
    } },
    digits: { type: [String, Number], default: function() {
      return GlobalConfig.input.digits;
    } },
    startDate: { type: [String, Number, Date], default: function() {
      return GlobalConfig.input.startDate;
    } },
    endDate: { type: [String, Number, Date], default: function() {
      return GlobalConfig.input.endDate;
    } },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startWeek: Number,
    startDay: { type: [String, Number], default: function() {
      return GlobalConfig.input.startDay;
    } },
    labelFormat: { type: String, default: function() {
      return GlobalConfig.input.labelFormat;
    } },
    valueFormat: { type: String, default: function() {
      return GlobalConfig.input.valueFormat;
    } },
    editable: { type: Boolean, default: true },
    festivalMethod: { type: Function, default: function() {
      return GlobalConfig.input.festivalMethod;
    } },
    disabledMethod: { type: Function, default: function() {
      return GlobalConfig.input.disabledMethod;
    } },
    selectDay: { type: [String, Number], default: function() {
      return GlobalConfig.input.selectDay;
    } },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: { type: Boolean, default: function() {
      return GlobalConfig.input.transfer;
    } }
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      animatVisible: false,
      panelStyle: null,
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    var refElem = ref$1();
    var refInputTarget = ref$1();
    var refInputPanel = ref$1();
    var refInputTimeBody = ref$1();
    var refMaps = {
      refElem,
      refInput: refInputTarget
    };
    var $xeinput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var inputMethods = {};
    var parseDate2 = function(value, format2) {
      var type2 = props.type;
      if (type2 === "time") {
        return toStringTimeDate(value);
      }
      return xeUtils.toStringDate(value, format2);
    };
    var computeIsDateTimeType = computed$1(function() {
      var type2 = props.type;
      return type2 === "time" || type2 === "datetime";
    });
    var computeIsNumType = computed$1(function() {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    var computeIsDatePickerType = computed$1(function() {
      var isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    var computeIsPawdType = computed$1(function() {
      return props.type === "password";
    });
    var computeIsSearchType = computed$1(function() {
      return props.type === "search";
    });
    var computeDigitsValue = computed$1(function() {
      return xeUtils.toInteger(props.digits) || 1;
    });
    var computeStepValue = computed$1(function() {
      var type2 = props.type;
      var digitsValue = computeDigitsValue.value;
      var step = props.step;
      if (type2 === "integer") {
        return xeUtils.toInteger(step) || 1;
      } else if (type2 === "float") {
        return xeUtils.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return xeUtils.toNumber(step) || 1;
    });
    var computeIsClearable = computed$1(function() {
      var type2 = props.type;
      var isNumType = computeIsNumType.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type2 === "text" || type2 === "search");
    });
    var computeDateStartTime = computed$1(function() {
      return props.startDate ? xeUtils.toStringDate(props.startDate) : null;
    });
    var computeDateEndTime = computed$1(function() {
      return props.endDate ? xeUtils.toStringDate(props.endDate) : null;
    });
    var computeSupportMultiples = computed$1(function() {
      return ["date", "week", "month", "quarter", "year"].includes(props.type);
    });
    var computeDateListValue = computed$1(function() {
      var modelValue5 = props.modelValue, multiple = props.multiple;
      var isDatePickerType = computeIsDatePickerType.value;
      var dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue5 && isDatePickerType) {
        return xeUtils.toValueString(modelValue5).split(",").map(function(item) {
          var date = parseDate2(item, dateValueFormat);
          if (xeUtils.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    var computeDateMultipleValue = computed$1(function() {
      var dateListValue = computeDateListValue.value;
      var dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(function(date) {
        return xeUtils.toDateString(date, dateValueFormat);
      });
    });
    var computeDateMultipleLabel = computed$1(function() {
      var dateListValue = computeDateListValue.value;
      var dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(function(date) {
        return xeUtils.toDateString(date, dateLabelFormat);
      }).join(", ");
    });
    var computeDateValueFormat = computed$1(function() {
      var type2 = props.type;
      return type2 === "time" ? "HH:mm:ss" : props.valueFormat || (type2 === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    });
    var computeDateValue = computed$1(function() {
      var modelValue5 = props.modelValue;
      var isDatePickerType = computeIsDatePickerType.value;
      var dateValueFormat = computeDateValueFormat.value;
      var val2 = null;
      if (modelValue5 && isDatePickerType) {
        var date = parseDate2(modelValue5, dateValueFormat);
        if (xeUtils.isValidDate(date)) {
          val2 = date;
        }
      }
      return val2;
    });
    var computeIsDisabledPrevDateBtn = computed$1(function() {
      var dateStartTime = computeDateStartTime.value;
      var selectMonth = reactData.selectMonth;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    var computeIsDisabledNextDateBtn = computed$1(function() {
      var dateEndTime = computeDateEndTime.value;
      var selectMonth = reactData.selectMonth;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    var computeDateTimeLabel = computed$1(function() {
      var datetimePanelValue = reactData.datetimePanelValue;
      if (datetimePanelValue) {
        return xeUtils.toDateString(datetimePanelValue, "HH:mm:ss");
      }
      return "";
    });
    var computeDateHMSTime = computed$1(function() {
      var dateValue = computeDateValue.value;
      var isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    var computeDateLabelFormat = computed$1(function() {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return props.labelFormat || GlobalConfig.i18n("vxe.input.date.labelFormat.".concat(props.type));
      }
      return null;
    });
    var computeYearList = computed$1(function() {
      var selectMonth = reactData.selectMonth, currentDate = reactData.currentDate;
      var years = [];
      if (selectMonth && currentDate) {
        var currFullYear = currentDate.getFullYear();
        var selectFullYear = selectMonth.getFullYear();
        var startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (var index = -4; index < yearSize + 4; index++) {
          var date = xeUtils.getWhatYear(startYearDate, index, "first");
          var itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    var computeSelectDatePanelLabel = computed$1(function() {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        var datePanelType = reactData.datePanelType, selectMonth = reactData.selectMonth;
        var yearList = computeYearList.value;
        var year = "";
        var month = void 0;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return GlobalConfig.i18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return GlobalConfig.i18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? "".concat(yearList[0].year, " - ").concat(yearList[yearList.length - 1].year) : "";
        }
        return GlobalConfig.i18n("vxe.input.date.dayLabel", [year, month ? GlobalConfig.i18n("vxe.input.date.m".concat(month)) : "-"]);
      }
      return "";
    });
    var computeFirstDayOfWeek = computed$1(function() {
      var startDay = props.startDay, startWeek = props.startWeek;
      return xeUtils.toNumber(xeUtils.isNumber(startDay) || xeUtils.isString(startDay) ? startDay : startWeek);
    });
    var computeWeekDatas = computed$1(function() {
      var weeks = [];
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        var sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (var index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    var computeDateHeaders = computed$1(function() {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        var weekDatas = computeWeekDatas.value;
        return weekDatas.map(function(day) {
          return {
            value: day,
            label: GlobalConfig.i18n("vxe.input.date.weeks.w".concat(day))
          };
        });
      }
      return [];
    });
    var computeWeekHeaders = computed$1(function() {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        var dateHeaders = computeDateHeaders.value;
        return [{ label: GlobalConfig.i18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    var computeYearDatas = computed$1(function() {
      var yearList = computeYearList.value;
      return xeUtils.chunk(yearList, 4);
    });
    var computeQuarterList = computed$1(function() {
      var selectMonth = reactData.selectMonth, currentDate = reactData.currentDate;
      var quarters = [];
      if (selectMonth && currentDate) {
        var currFullYear = currentDate.getFullYear();
        var currQuarter = getDateQuarter(currentDate);
        var firstYear = xeUtils.getWhatYear(selectMonth, 0, "first");
        var selFullYear = firstYear.getFullYear();
        for (var index = -2; index < quarterSize - 2; index++) {
          var date = xeUtils.getWhatQuarter(firstYear, index);
          var itemFullYear = date.getFullYear();
          var itemQuarter = getDateQuarter(date);
          var isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    var computeQuarterDatas = computed$1(function() {
      var quarterList = computeQuarterList.value;
      return xeUtils.chunk(quarterList, 2);
    });
    var computeMonthList = computed$1(function() {
      var selectMonth = reactData.selectMonth, currentDate = reactData.currentDate;
      var months = [];
      if (selectMonth && currentDate) {
        var currFullYear = currentDate.getFullYear();
        var currMonth = currentDate.getMonth();
        var selFullYear = xeUtils.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (var index = -4; index < monthSize - 4; index++) {
          var date = xeUtils.getWhatYear(selectMonth, 0, index);
          var itemFullYear = date.getFullYear();
          var itemMonth = date.getMonth();
          var isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    var computeMonthDatas = computed$1(function() {
      var monthList = computeMonthList.value;
      return xeUtils.chunk(monthList, 4);
    });
    var computeDayList = computed$1(function() {
      var selectMonth = reactData.selectMonth, currentDate = reactData.currentDate;
      var days = [];
      if (selectMonth && currentDate) {
        var dateHMSTime = computeDateHMSTime.value;
        var weekDatas = computeWeekDatas.value;
        var currFullYear = currentDate.getFullYear();
        var currMonth = currentDate.getMonth();
        var currDate = currentDate.getDate();
        var selFullYear = selectMonth.getFullYear();
        var selMonth = selectMonth.getMonth();
        var selDay = selectMonth.getDay();
        var prevOffsetDate = -weekDatas.indexOf(selDay);
        var startDayDate = new Date(xeUtils.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (var index = 0; index < 42; index++) {
          var date = xeUtils.getWhatDay(startDayDate, index);
          var itemFullYear = date.getFullYear();
          var itemMonth = date.getMonth();
          var itemDate = date.getDate();
          var isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    var computeDayDatas = computed$1(function() {
      var dayList = computeDayList.value;
      return xeUtils.chunk(dayList, 7);
    });
    var computeWeekDates = computed$1(function() {
      var dayDatas = computeDayDatas.value;
      var firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(function(list) {
        var firstItem = list[0];
        var item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: xeUtils.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    var computeHourList = computed$1(function() {
      var list = [];
      var isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (var index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    var computeMinuteList = computed$1(function() {
      var list = [];
      var isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (var index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    var computeSecondList = computed$1(function() {
      var minuteList = computeMinuteList.value;
      return minuteList;
    });
    var computeInpReadonly = computed$1(function() {
      var type2 = props.type, readonly = props.readonly, editable = props.editable, multiple = props.multiple;
      return readonly || multiple || !editable || type2 === "week" || type2 === "quarter";
    });
    var computeInputType = computed$1(function() {
      var type2 = props.type;
      var showPwd = reactData.showPwd;
      var isNumType = computeIsNumType.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type2 === "number") {
        return "text";
      }
      return type2;
    });
    var computeInpPlaceholder = computed$1(function() {
      var placeholder = props.placeholder;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      return "";
    });
    var computeInpMaxlength = computed$1(function() {
      var maxlength = props.maxlength;
      var isNumType = computeIsNumType.value;
      return isNumType && !xeUtils.toNumber(maxlength) ? 16 : maxlength;
    });
    var computeInpImmediate = computed$1(function() {
      var type2 = props.type, immediate = props.immediate;
      return immediate || !(type2 === "text" || type2 === "number" || type2 === "integer" || type2 === "float");
    });
    var computeNumValue = computed$1(function() {
      var type2 = props.type;
      var inputValue = reactData.inputValue;
      var isNumType = computeIsNumType.value;
      if (isNumType) {
        return type2 === "integer" ? xeUtils.toInteger(handleNumber(inputValue)) : xeUtils.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    var computeIsDisabledSubtractNumber = computed$1(function() {
      var min3 = props.min;
      var inputValue = reactData.inputValue;
      var isNumType = computeIsNumType.value;
      var numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min3 !== null) {
        return numValue <= xeUtils.toNumber(min3);
      }
      return false;
    });
    var computeIsDisabledAddNumber = computed$1(function() {
      var max3 = props.max;
      var inputValue = reactData.inputValue;
      var isNumType = computeIsNumType.value;
      var numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max3 !== null) {
        return numValue >= xeUtils.toNumber(max3);
      }
      return false;
    });
    var getNumberValue = function(val2) {
      var type2 = props.type, exponential = props.exponential;
      var inpMaxlength = computeInpMaxlength.value;
      var digitsValue = computeDigitsValue.value;
      var restVal = type2 === "float" ? toFloatValueFixed(val2, digitsValue) : xeUtils.toValueString(val2);
      if (exponential && (val2 === restVal || xeUtils.toValueString(val2).toLowerCase() === xeUtils.toNumber(restVal).toExponential())) {
        return val2;
      }
      return restVal.slice(0, inpMaxlength);
    };
    var triggerEvent2 = function(evnt) {
      var inputValue = reactData.inputValue;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    var emitModel = function(value, evnt) {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (xeUtils.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    var emitInputEvent = function(value, evnt) {
      var isDatePickerType = computeIsDatePickerType.value;
      var inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    var inputEvent = function(evnt) {
      var inputElem = evnt.target;
      var value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    var changeEvent = function(evnt) {
      var inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent2(evnt);
      }
    };
    var focusEvent = function(evnt) {
      reactData.isActivated = true;
      triggerEvent2(evnt);
    };
    var clickPrefixEvent = function(evnt) {
      var disabled3 = props.disabled;
      if (!disabled3) {
        var inputValue = reactData.inputValue;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    var hidePanelTimeout;
    var hidePanel = function() {
      return new Promise(function(resolve) {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(function() {
          reactData.animatVisible = false;
          resolve();
        }, 350);
      });
    };
    var clearValueEvent = function(evnt, value) {
      var type2 = props.type;
      var isNumType = computeIsNumType.value;
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type2) > -1) {
        focus();
      }
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    var clickSuffixEvent = function(evnt) {
      var disabled3 = props.disabled;
      if (!disabled3) {
        if (hasClass$1(evnt.currentTarget, "is--clear")) {
          emitModel("", evnt);
          clearValueEvent(evnt, "");
        } else {
          var inputValue = reactData.inputValue;
          inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
        }
      }
    };
    var dateParseValue = function(value) {
      var type2 = props.type;
      var valueFormat = props.valueFormat;
      var dateLabelFormat = computeDateLabelFormat.value;
      var firstDayOfWeek = computeFirstDayOfWeek.value;
      var dValue = null;
      var dLabel = "";
      if (value) {
        dValue = parseDate2(value, valueFormat);
      }
      if (xeUtils.isValidDate(dValue)) {
        dLabel = xeUtils.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type2 === "week") {
          var firstWeekDate = xeUtils.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            var yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              var yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace("".concat(yyNum), "".concat(yyNum - 1));
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    var changeValue = function() {
      var isDatePickerType = computeIsDatePickerType.value;
      var inputValue = reactData.inputValue;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    var initValue = function() {
      var type2 = props.type;
      var inputValue = reactData.inputValue;
      var isDatePickerType = computeIsDatePickerType.value;
      var digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type2 === "float") {
        if (inputValue) {
          var validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, { type: "init" });
          }
        }
      }
    };
    var vaildMaxNum = function(num) {
      return props.max === null || xeUtils.toNumber(num) <= xeUtils.toNumber(props.max);
    };
    var vaildMinNum = function(num) {
      return props.min === null || xeUtils.toNumber(num) >= xeUtils.toNumber(props.min);
    };
    var dateRevert = function() {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    var dateCheckMonth = function(date) {
      var month = xeUtils.getWhatMonth(date, 0, "first");
      if (!xeUtils.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    var dateChange = function(date) {
      var modelValue5 = props.modelValue, multiple = props.multiple;
      var datetimePanelValue = reactData.datetimePanelValue;
      var isDateTimeType = computeIsDateTimeType.value;
      var dateValueFormat = computeDateValueFormat.value;
      var firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        var sWeek = xeUtils.toNumber(props.selectDay);
        date = xeUtils.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      var inpVal = xeUtils.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        var dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          var dateListValue = computeDateListValue.value;
          var datetimeRest_1 = [];
          dateListValue.forEach(function(item) {
            if (item && !xeUtils.isDateSame(date, item, "yyyyMMdd")) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest_1.push(item);
            }
          });
          datetimeRest_1.push(date);
          emitModel(datetimeRest_1.map(function(date2) {
            return xeUtils.toDateString(date2, dateValueFormat);
          }).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some(function(val2) {
            return xeUtils.isEqual(val2, inpVal);
          })) {
            emitModel(dateMultipleValue.filter(function(val2) {
              return !xeUtils.isEqual(val2, inpVal);
            }).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!xeUtils.isEqual(modelValue5, inpVal)) {
          emitModel(inpVal, { type: "update" });
        }
      }
    };
    var afterCheckValue = function() {
      var type2 = props.type, min3 = props.min, max3 = props.max, exponential = props.exponential;
      var inputValue = reactData.inputValue, datetimePanelValue = reactData.datetimePanelValue;
      var isNumType = computeIsNumType.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var dateLabelFormat = computeDateLabelFormat.value;
      var inpReadonly = computeInpReadonly.value;
      if (!inpReadonly) {
        if (isNumType) {
          if (inputValue) {
            var inpNumVal = type2 === "integer" ? xeUtils.toInteger(handleNumber(inputValue)) : xeUtils.toNumber(handleNumber(inputValue));
            if (!vaildMinNum(inpNumVal)) {
              inpNumVal = min3;
            } else if (!vaildMaxNum(inpNumVal)) {
              inpNumVal = max3;
            }
            if (exponential) {
              var inpStringVal = xeUtils.toValueString(inputValue).toLowerCase();
              if (inpStringVal === xeUtils.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            var inpDateVal = parseDate2(inputValue, dateLabelFormat);
            if (xeUtils.isValidDate(inpDateVal)) {
              if (type2 === "time") {
                inpDateVal = xeUtils.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                var isChange = false;
                var firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type2 === "datetime") {
                  var dateValue = computeDateValue.value;
                  if (inputValue !== xeUtils.toDateString(dateValue, dateLabelFormat) || inputValue !== xeUtils.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = xeUtils.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel("", { type: "check" });
          }
        }
      }
    };
    var blurEvent = function(evnt) {
      var inputValue = reactData.inputValue;
      var inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    var passwordToggleEvent = function(evnt) {
      var readonly = props.readonly, disabled3 = props.disabled;
      var showPwd = reactData.showPwd;
      if (!disabled3 && !readonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    var searchEvent = function(evnt) {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    var numberChange = function(isPlus, evnt) {
      var min3 = props.min, max3 = props.max, type2 = props.type;
      var inputValue = reactData.inputValue;
      var stepValue = computeStepValue.value;
      var numValue = type2 === "integer" ? xeUtils.toInteger(handleNumber(inputValue)) : xeUtils.toNumber(handleNumber(inputValue));
      var newValue = isPlus ? xeUtils.add(numValue, stepValue) : xeUtils.subtract(numValue, stepValue);
      var restNum;
      if (!vaildMinNum(newValue)) {
        restNum = min3;
      } else if (!vaildMaxNum(newValue)) {
        restNum = max3;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    var downbumTimeout;
    var numberNextEvent = function(evnt) {
      var readonly = props.readonly, disabled3 = props.disabled;
      var isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled3 && !readonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", {}, evnt);
    };
    var numberDownNextEvent = function(evnt) {
      downbumTimeout = window.setTimeout(function() {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    var numberPrevEvent = function(evnt) {
      var readonly = props.readonly, disabled3 = props.disabled;
      var isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled3 && !readonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", {}, evnt);
    };
    var numberKeydownEvent = function(evnt) {
      var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
      var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    var keydownEvent = function(evnt) {
      var exponential = props.exponential, controls = props.controls;
      var isNumType = computeIsNumType.value;
      if (isNumType) {
        var isCtrlKey = evnt.ctrlKey;
        var isShiftKey = evnt.shiftKey;
        var isAltKey = evnt.altKey;
        var keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (hasEventKey(evnt, EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent2(evnt);
    };
    var keyupEvent = function(evnt) {
      triggerEvent2(evnt);
    };
    var numberStopDown = function() {
      clearTimeout(downbumTimeout);
    };
    var numberDownPrevEvent = function(evnt) {
      downbumTimeout = window.setTimeout(function() {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    var numberMousedownEvent = function(evnt) {
      numberStopDown();
      if (evnt.button === 0) {
        var isPrevNumber_1 = hasClass$1(evnt.currentTarget, "is--prev");
        if (isPrevNumber_1) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(function() {
          if (isPrevNumber_1) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    var wheelEvent = function(evnt) {
      var isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          var delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent2(evnt);
    };
    var dateMonthHandle = function(date, offsetMonth) {
      reactData.selectMonth = xeUtils.getWhatMonth(date, offsetMonth, "first");
    };
    var dateNowHandle = function() {
      var currentDate = xeUtils.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    var dateToggleTypeEvent = function() {
      var datePanelType = reactData.datePanelType;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    var datePrevEvent = function(evnt) {
      var type2 = props.type;
      var datePanelType = reactData.datePanelType, selectMonth = reactData.selectMonth;
      var isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type2 === "year") {
          reactData.selectMonth = xeUtils.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type2 === "month" || type2 === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = xeUtils.getWhatMonth(selectMonth, -1, "first");
          }
        }
        inputMethods.dispatchEvent("date-prev", { type: type2 }, evnt);
      }
    };
    var dateTodayMonthEvent = function(evnt) {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    var dateNextEvent = function(evnt) {
      var type2 = props.type;
      var datePanelType = reactData.datePanelType, selectMonth = reactData.selectMonth;
      var isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type2 === "year") {
          reactData.selectMonth = xeUtils.getWhatYear(selectMonth, yearSize, "first");
        } else if (type2 === "month" || type2 === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = xeUtils.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = xeUtils.getWhatMonth(selectMonth, 1, "first");
          }
        }
        inputMethods.dispatchEvent("date-next", { type: type2 }, evnt);
      }
    };
    var isDateDisabled = function(item) {
      var disabledMethod = props.disabledMethod;
      var datePanelType = reactData.datePanelType;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
    };
    var dateSelectItem = function(date) {
      var type2 = props.type, multiple = props.multiple;
      var datePanelType = reactData.datePanelType;
      if (type2 === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type2 === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type2 === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type2 === "week" ? type2 : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      }
    };
    var dateSelectEvent = function(item) {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    var dateMoveDay = function(offsetDay) {
      if (!isDateDisabled({ date: offsetDay })) {
        var dayList = computeDayList.value;
        if (!dayList.some(function(item) {
          return xeUtils.isDateSame(item.date, offsetDay, "yyyyMMdd");
        })) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    var dateMoveYear = function(offsetYear) {
      if (!isDateDisabled({ date: offsetYear })) {
        var yearList = computeYearList.value;
        if (!yearList.some(function(item) {
          return xeUtils.isDateSame(item.date, offsetYear, "yyyy");
        })) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    var dateMoveQuarter = function(offsetQuarter) {
      if (!isDateDisabled({ date: offsetQuarter })) {
        var quarterList = computeQuarterList.value;
        if (!quarterList.some(function(item) {
          return xeUtils.isDateSame(item.date, offsetQuarter, "yyyyq");
        })) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    var dateMoveMonth = function(offsetMonth) {
      if (!isDateDisabled({ date: offsetMonth })) {
        var monthList = computeMonthList.value;
        if (!monthList.some(function(item) {
          return xeUtils.isDateSame(item.date, offsetMonth, "yyyyMM");
        })) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    var dateMouseenterEvent = function(item) {
      if (!isDateDisabled(item)) {
        var datePanelType = reactData.datePanelType;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    var updateTimePos = function(liElem) {
      if (liElem) {
        var height2 = liElem.offsetHeight;
        var ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height2 * 4;
      }
    };
    var dateTimeChangeEvent = function(evnt) {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    var dateHourEvent = function(evnt, item) {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    var dateConfirmEvent = function() {
      var multiple = props.multiple;
      var dateValue = computeDateValue.value;
      var isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType || multiple) {
        dateChange(dateValue || reactData.currentDate);
      }
      hidePanel();
    };
    var dateMinuteEvent = function(evnt, item) {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    var dateSecondEvent = function(evnt, item) {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    var dateOffsetEvent = function(evnt) {
      var isActivated = reactData.isActivated, datePanelValue = reactData.datePanelValue, datePanelType = reactData.datePanelType;
      if (isActivated) {
        evnt.preventDefault();
        var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          var offsetYear = xeUtils.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = xeUtils.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = xeUtils.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = xeUtils.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = xeUtils.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          var offsetQuarter = xeUtils.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = xeUtils.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = xeUtils.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = xeUtils.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = xeUtils.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          var offsetMonth = xeUtils.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = xeUtils.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = xeUtils.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = xeUtils.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = xeUtils.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          var offsetDay = datePanelValue || xeUtils.getWhatDay(Date.now(), 0, "first");
          var firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = xeUtils.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = xeUtils.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = xeUtils.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = xeUtils.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    var datePgOffsetEvent = function(evnt) {
      var isActivated = reactData.isActivated;
      if (isActivated) {
        var isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    var dateOpenPanel = function() {
      var type2 = props.type;
      var isDateTimeType = computeIsDateTimeType.value;
      var dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type2) > -1) {
        reactData.datePanelType = type2;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = xeUtils.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || xeUtils.getWhatDay(Date.now(), 0, "first");
        nextTick$1(function() {
          var timeBodyElem = refInputTimeBody.value;
          xeUtils.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), updateTimePos);
        });
      }
    };
    var updateZindex = function() {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    var updatePlacement = function() {
      return nextTick$1().then(function() {
        var transfer = props.transfer, placement = props.placement;
        var panelIndex = reactData.panelIndex;
        var targetElem = refInputTarget.value;
        var panelElem = refInputPanel.value;
        if (targetElem && panelElem) {
          var targetHeight = targetElem.offsetHeight;
          var targetWidth = targetElem.offsetWidth;
          var panelHeight = panelElem.offsetHeight;
          var panelWidth = panelElem.offsetWidth;
          var marginSize = 5;
          var panelStyle = {
            zIndex: panelIndex
          };
          var _a2 = getAbsolutePos(targetElem), boundingTop = _a2.boundingTop, boundingLeft = _a2.boundingLeft, visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
          var panelPlacement = "bottom";
          if (transfer) {
            var left = boundingLeft;
            var top_1 = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top_1 = boundingTop - panelHeight;
            } else if (!placement) {
              if (top_1 + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top_1 = boundingTop - panelHeight;
              }
              if (top_1 < marginSize) {
                panelPlacement = "bottom";
                top_1 = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: "".concat(left, "px"),
              top: "".concat(top_1, "px"),
              minWidth: "".concat(targetWidth, "px")
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = "".concat(targetHeight, "px");
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = "".concat(targetHeight, "px");
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick$1();
        }
      });
    };
    var showPanel = function() {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      var isDatePickerType = computeIsDatePickerType.value;
      if (!disabled3 && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(function() {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick$1();
    };
    var datePickerOpenEvent = function(evnt) {
      var readonly = props.readonly;
      if (!readonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    var clickEvent = function(evnt) {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent2(evnt);
    };
    var handleGlobalMousedownEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel, isActivated = reactData.isActivated;
      var isDatePickerType = computeIsDatePickerType.value;
      var el2 = refElem.value;
      var panelElem = refInputPanel.value;
      if (!disabled3 && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el2).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    var handleGlobalKeydownEvent = function(evnt) {
      var clearable = props.clearable, disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      var isDatePickerType = computeIsDatePickerType.value;
      if (!disabled3) {
        var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        var isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        var isPgDn = hasEventKey(evnt, EVENT_KEYS.PAGE_DOWN);
        var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        var isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    var handleGlobalMousewheelEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      if (!disabled3) {
        if (visiblePanel) {
          var panelElem = refInputPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    var handleGlobalBlurEvent = function() {
      var isActivated = reactData.isActivated, visiblePanel = reactData.visiblePanel;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    var renderDateLabel = function(item, label) {
      var festivalMethod = props.festivalMethod;
      if (festivalMethod) {
        var datePanelType = reactData.datePanelType;
        var festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
        var festivalItem = festivalRest ? xeUtils.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        var extraItem = festivalItem.extra ? xeUtils.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        var labels = [
          h$6("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h$6("span", label),
            h$6("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, xeUtils.toValueString(extraItem.label))
          ] : label)
        ];
        var festivalLabel = festivalItem.label;
        if (festivalLabel) {
          var festivalLabels = xeUtils.toValueString(festivalLabel).split(",");
          labels.push(h$6("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h$6("span", {
              class: ["vxe-input--date-festival--overlap", "overlap--".concat(festivalLabels.length)]
            }, festivalLabels.map(function(label2) {
              return h$6("span", label2.substring(0, 3));
            })) : h$6("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    var renderDateDayTable = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType, datePanelValue = reactData.datePanelValue;
      var dateValue = computeDateValue.value;
      var dateHeaders = computeDateHeaders.value;
      var dayDatas = computeDayDatas.value;
      var dateListValue = computeDateListValue.value;
      var matchFormat = "yyyyMMdd";
      return [
        h$6("table", {
          class: "vxe-input--date-".concat(datePanelType, "-view"),
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("thead", [
            h$6("tr", dateHeaders.map(function(item) {
              return h$6("th", item.label);
            }))
          ]),
          h$6("tbody", dayDatas.map(function(rows) {
            return h$6("tr", rows.map(function(item) {
              return h$6("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some(function(val2) {
                    return xeUtils.isDateSame(val2, item.date, matchFormat);
                  }) : xeUtils.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": xeUtils.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: function() {
                  return dateSelectEvent(item);
                },
                onMouseenter: function() {
                  return dateMouseenterEvent(item);
                }
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    var renderDateWeekTable = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType, datePanelValue = reactData.datePanelValue;
      var dateValue = computeDateValue.value;
      var weekHeaders = computeWeekHeaders.value;
      var weekDates = computeWeekDates.value;
      var dateListValue = computeDateListValue.value;
      var matchFormat = "yyyyMMdd";
      return [
        h$6("table", {
          class: "vxe-input--date-".concat(datePanelType, "-view"),
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("thead", [
            h$6("tr", weekHeaders.map(function(item) {
              return h$6("th", item.label);
            }))
          ]),
          h$6("tbody", weekDates.map(function(rows) {
            var isSelected = multiple ? rows.some(function(item) {
              return dateListValue.some(function(val2) {
                return xeUtils.isDateSame(val2, item.date, matchFormat);
              });
            }) : rows.some(function(item) {
              return xeUtils.isDateSame(dateValue, item.date, matchFormat);
            });
            var isHover2 = rows.some(function(item) {
              return xeUtils.isDateSame(datePanelValue, item.date, matchFormat);
            });
            return h$6("tr", rows.map(function(item) {
              return h$6("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover2
                },
                onClick: function() {
                  return dateSelectEvent(item);
                },
                onMouseenter: function() {
                  return dateMouseenterEvent(item);
                }
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    var renderDateMonthTable = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType, datePanelValue = reactData.datePanelValue;
      var dateValue = computeDateValue.value;
      var monthDatas = computeMonthDatas.value;
      var dateListValue = computeDateListValue.value;
      var matchFormat = "yyyyMM";
      return [
        h$6("table", {
          class: "vxe-input--date-".concat(datePanelType, "-view"),
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("tbody", monthDatas.map(function(rows) {
            return h$6("tr", rows.map(function(item) {
              return h$6("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some(function(val2) {
                    return xeUtils.isDateSame(val2, item.date, matchFormat);
                  }) : xeUtils.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": xeUtils.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: function() {
                  return dateSelectEvent(item);
                },
                onMouseenter: function() {
                  return dateMouseenterEvent(item);
                }
              }, renderDateLabel(item, GlobalConfig.i18n("vxe.input.date.months.m".concat(item.month))));
            }));
          }))
        ])
      ];
    };
    var renderDateQuarterTable = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType, datePanelValue = reactData.datePanelValue;
      var dateValue = computeDateValue.value;
      var quarterDatas = computeQuarterDatas.value;
      var dateListValue = computeDateListValue.value;
      var matchFormat = "yyyyq";
      return [
        h$6("table", {
          class: "vxe-input--date-".concat(datePanelType, "-view"),
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("tbody", quarterDatas.map(function(rows) {
            return h$6("tr", rows.map(function(item) {
              return h$6("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some(function(val2) {
                    return xeUtils.isDateSame(val2, item.date, matchFormat);
                  }) : xeUtils.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": xeUtils.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: function() {
                  return dateSelectEvent(item);
                },
                onMouseenter: function() {
                  return dateMouseenterEvent(item);
                }
              }, renderDateLabel(item, GlobalConfig.i18n("vxe.input.date.quarters.q".concat(item.quarter))));
            }));
          }))
        ])
      ];
    };
    var renderDateYearTable = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType, datePanelValue = reactData.datePanelValue;
      var dateValue = computeDateValue.value;
      var yearDatas = computeYearDatas.value;
      var dateListValue = computeDateListValue.value;
      var matchFormat = "yyyy";
      return [
        h$6("table", {
          class: "vxe-input--date-".concat(datePanelType, "-view"),
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("tbody", yearDatas.map(function(rows) {
            return h$6("tr", rows.map(function(item) {
              return h$6("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some(function(val2) {
                    return xeUtils.isDateSame(val2, item.date, matchFormat);
                  }) : xeUtils.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": xeUtils.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: function() {
                  return dateSelectEvent(item);
                },
                onMouseenter: function() {
                  return dateMouseenterEvent(item);
                }
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    var renderDateTable = function() {
      var datePanelType = reactData.datePanelType;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    var renderDatePanel = function() {
      var multiple = props.multiple;
      var datePanelType = reactData.datePanelType;
      var isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      var isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      var selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h$6("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h$6("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h$6("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h$6("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h$6("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h$6("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h$6("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h$6("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h$6("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h$6("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h$6("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h$6("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h$6("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, GlobalConfig.i18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h$6("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    var renderTimePanel = function() {
      var datetimePanelValue = reactData.datetimePanelValue;
      var dateTimeLabel = computeDateTimeLabel.value;
      var hourList = computeHourList.value;
      var minuteList = computeMinuteList.value;
      var secondList = computeSecondList.value;
      return [
        h$6("div", {
          class: "vxe-input--time-picker-header"
        }, [
          h$6("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel),
          h$6("button", {
            class: "vxe-input--time-picker-confirm",
            type: "button",
            onClick: dateConfirmEvent
          }, GlobalConfig.i18n("vxe.button.confirm"))
        ]),
        h$6("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h$6("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map(function(item, index) {
            return h$6("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: function(evnt) {
                return dateHourEvent(evnt, item);
              }
            }, item.label);
          })),
          h$6("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map(function(item, index) {
            return h$6("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: function(evnt) {
                return dateMinuteEvent(evnt, item);
              }
            }, item.label);
          })),
          h$6("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map(function(item, index) {
            return h$6("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: function(evnt) {
                return dateSecondEvent(evnt, item);
              }
            }, item.label);
          }))
        ])
      ];
    };
    var renderPanel = function() {
      var _a2;
      var type2 = props.type, transfer = props.transfer;
      var inited = reactData.inited, animatVisible = reactData.animatVisible, visiblePanel = reactData.visiblePanel, panelPlacement = reactData.panelPlacement, panelStyle = reactData.panelStyle;
      var vSize = computeSize.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var renders = [];
      if (isDatePickerType) {
        if (type2 === "datetime") {
          renders.push(h$6("div", {
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h$6("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h$6("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type2 === "time") {
          renders.push(h$6("div", {
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h$6("div", {
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h$6(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h$6("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", "type--".concat(type2), (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--transfer"] = transfer, _a2["animat--leave"] = animatVisible, _a2["animat--enter"] = visiblePanel, _a2)],
            placement: panelPlacement,
            style: panelStyle
          }, renders)
        ]);
      }
      return null;
    };
    var renderNumberIcon = function() {
      var isDisabledAddNumber = computeIsDisabledAddNumber.value;
      var isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h$6("span", {
        class: "vxe-input--number-suffix"
      }, [
        h$6("span", {
          class: ["vxe-input--number-prev is--prev", {
            "is--disabled": isDisabledAddNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h$6("i", {
            class: ["vxe-input--number-prev-icon", GlobalConfig.icon.INPUT_PREV_NUM]
          })
        ]),
        h$6("span", {
          class: ["vxe-input--number-next is--next", {
            "is--disabled": isDisabledSubtractNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h$6("i", {
            class: ["vxe-input--number-next-icon", GlobalConfig.icon.INPUT_NEXT_NUM]
          })
        ])
      ]);
    };
    var renderDatePickerIcon = function() {
      return h$6("span", {
        class: "vxe-input--date-picker-suffix",
        onClick: datePickerOpenEvent
      }, [
        h$6("i", {
          class: ["vxe-input--date-picker-icon", GlobalConfig.icon.INPUT_DATE]
        })
      ]);
    };
    var renderSearchIcon = function() {
      return h$6("span", {
        class: "vxe-input--search-suffix",
        onClick: searchEvent
      }, [
        h$6("i", {
          class: ["vxe-input--search-icon", GlobalConfig.icon.INPUT_SEARCH]
        })
      ]);
    };
    var renderPasswordIcon = function() {
      var showPwd = reactData.showPwd;
      return h$6("span", {
        class: "vxe-input--password-suffix",
        onClick: passwordToggleEvent
      }, [
        h$6("i", {
          class: ["vxe-input--password-icon", showPwd ? GlobalConfig.icon.INPUT_SHOW_PWD : GlobalConfig.icon.INPUT_PWD]
        })
      ]);
    };
    var rendePrefixIcon = function() {
      var prefixIcon = props.prefixIcon;
      var prefixSlot = slots.prefix;
      var icons = [];
      if (prefixSlot) {
        icons.push(h$6("span", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot({})));
      } else if (prefixIcon) {
        icons.push(h$6("i", {
          class: ["vxe-input--prefix-icon", prefixIcon]
        }));
      }
      return icons.length ? h$6("span", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, icons) : null;
    };
    var renderSuffixIcon2 = function() {
      var disabled3 = props.disabled, suffixIcon = props.suffixIcon;
      var inputValue = reactData.inputValue;
      var suffixSlot = slots.suffix;
      var isClearable = computeIsClearable.value;
      var icons = [];
      if (suffixSlot) {
        icons.push(h$6("span", {
          class: "vxe-input--suffix-icon"
        }, suffixSlot({})));
      } else if (suffixIcon) {
        icons.push(h$6("i", {
          class: ["vxe-input--suffix-icon", suffixIcon]
        }));
      }
      if (isClearable) {
        icons.push(h$6("i", {
          class: ["vxe-input--clear-icon", GlobalConfig.icon.INPUT_CLEAR]
        }));
      }
      return icons.length ? h$6("span", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !disabled3 && !(inputValue === "" || xeUtils.eqNull(inputValue))
        }],
        onClick: clickSuffixEvent
      }, icons) : null;
    };
    var renderExtraSuffixIcon = function() {
      var controls = props.controls;
      var isNumType = computeIsNumType.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var isPawdType = computeIsPawdType.value;
      var isSearchType = computeIsSearchType.value;
      var icons;
      if (isPawdType) {
        icons = renderPasswordIcon();
      } else if (isNumType) {
        if (controls) {
          icons = renderNumberIcon();
        }
      } else if (isDatePickerType) {
        icons = renderDatePickerIcon();
      } else if (isSearchType) {
        icons = renderSearchIcon();
      }
      return icons ? h$6("span", {
        class: "vxe-input--extra-suffix"
      }, [icons]) : null;
    };
    inputMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $input: $xeinput, $event: evnt }, params));
      },
      focus: function() {
        var inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick$1();
      },
      blur: function() {
        var inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick$1();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeinput, inputMethods);
    watch$1(function() {
      return props.modelValue;
    }, function(val2) {
      reactData.inputValue = val2;
      changeValue();
    });
    watch$1(function() {
      return props.type;
    }, function() {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch$1(computeDateLabelFormat, function() {
      var isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick$1(function() {
      GlobalEvent.on($xeinput, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeinput, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeinput, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeinput, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(function() {
      numberStopDown();
      GlobalEvent.off($xeinput, "mousewheel");
      GlobalEvent.off($xeinput, "mousedown");
      GlobalEvent.off($xeinput, "keydown");
      GlobalEvent.off($xeinput, "blur");
    });
    initValue();
    var renderVN = function() {
      var _a2;
      var className = props.className, controls = props.controls, type2 = props.type, align = props.align, name2 = props.name, disabled3 = props.disabled, readonly = props.readonly, autocomplete = props.autocomplete;
      var inputValue = reactData.inputValue, visiblePanel = reactData.visiblePanel, isActivated = reactData.isActivated;
      var vSize = computeSize.value;
      var isDatePickerType = computeIsDatePickerType.value;
      var inpReadonly = computeInpReadonly.value;
      var inpMaxlength = computeInpMaxlength.value;
      var inputType = computeInputType.value;
      var inpPlaceholder = computeInpPlaceholder.value;
      var childs = [];
      var prefix = rendePrefixIcon();
      var suffix = renderSuffixIcon2();
      if (prefix) {
        childs.push(prefix);
      }
      childs.push(h$6("input", {
        ref: refInputTarget,
        class: "vxe-input--inner",
        value: inputValue,
        name: name2,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inpReadonly,
        disabled: disabled3,
        autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }));
      if (suffix) {
        childs.push(suffix);
      }
      childs.push(renderExtraSuffixIcon());
      if (isDatePickerType) {
        childs.push(renderPanel());
      }
      return h$6("div", {
        ref: refElem,
        class: ["vxe-input", "type--".concat(type2), className, (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--".concat(align)] = align, _a2["is--controls"] = controls, _a2["is--prefix"] = !!prefix, _a2["is--suffix"] = !!suffix, _a2["is--readonly"] = readonly, _a2["is--visivle"] = visiblePanel, _a2["is--disabled"] = disabled3, _a2["is--active"] = isActivated, _a2)]
      }, childs);
    };
    $xeinput.renderVN = renderVN;
    return $xeinput;
  },
  render: function() {
    return this.renderVN();
  }
});
var VxeCheckboxComponent = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number], default: null },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: { type: [String, Number, Boolean], default: true },
    uncheckedValue: { type: [String, Number, Boolean], default: false },
    content: [String, Number],
    disabled: Boolean,
    size: { type: String, default: function() {
      return GlobalConfig.checkbox.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var $xecheckbox = {
      xID,
      props,
      context
    };
    var checkboxMethods = {};
    var computeSize = useSize$1(props);
    var $xecheckboxgroup = inject("$xecheckboxgroup", null);
    var computeIsChecked = computed$1(function() {
      if ($xecheckboxgroup) {
        return xeUtils.includes($xecheckboxgroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    var computeIsDisabled = computed$1(function() {
      if (props.disabled) {
        return true;
      }
      if ($xecheckboxgroup) {
        var groupProps = $xecheckboxgroup.props;
        var computeIsMaximize = $xecheckboxgroup.getComputeMaps().computeIsMaximize;
        var isMaximize = computeIsMaximize.value;
        var isChecked = computeIsChecked.value;
        return groupProps.disabled || isMaximize && !isChecked;
      }
      return false;
    });
    var changeEvent = function(evnt) {
      var checkedValue = props.checkedValue, uncheckedValue = props.uncheckedValue;
      var isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        var checked = evnt.target.checked;
        var value = checked ? checkedValue : uncheckedValue;
        var params = { checked, value, label: props.label };
        if ($xecheckboxgroup) {
          $xecheckboxgroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeform && $xeformiteminfo) {
            $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $checkbox: $xecheckbox, $event: evnt }, params));
      }
    };
    Object.assign($xecheckbox, checkboxMethods);
    var renderVN = function() {
      var _a2;
      var vSize = computeSize.value;
      var isDisabled = computeIsDisabled.value;
      var isChecked = computeIsChecked.value;
      var indeterminate = props.indeterminate;
      return h$6("label", {
        class: ["vxe-checkbox", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--indeterminate"] = indeterminate, _a2["is--disabled"] = isDisabled, _a2["is--checked"] = isChecked, _a2)],
        title: props.title
      }, [
        h$6("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h$6("span", {
          class: ["vxe-checkbox--icon", indeterminate ? "vxe-icon-checkbox-indeterminate" : isChecked ? "vxe-icon-checkbox-checked" : "vxe-icon-checkbox-unchecked"]
        }),
        h$6("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xecheckbox.renderVN = renderVN;
    return $xecheckbox;
  },
  render: function() {
    return this.renderVN();
  }
});
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return xeUtils.uniqueId("opt_");
}
var VxeSelectComponent = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: null,
    clearable: Boolean,
    placeholder: String,
    loading: Boolean,
    disabled: Boolean,
    multiple: Boolean,
    multiCharOverflow: { type: [Number, String], default: function() {
      return GlobalConfig.select.multiCharOverflow;
    } },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    max: { type: [String, Number], default: null },
    size: { type: String, default: function() {
      return GlobalConfig.select.size || GlobalConfig.size;
    } },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    optionId: { type: String, default: function() {
      return GlobalConfig.select.optionId;
    } },
    optionKey: Boolean,
    transfer: { type: Boolean, default: function() {
      return GlobalConfig.select.transfer;
    } }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inited: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      searchValue: "",
      searchLoading: false
    });
    var refElem = ref$1();
    var refInput = ref$1();
    var refInpSearch = ref$1();
    var refOptionWrapper = ref$1();
    var refOptionPanel = ref$1();
    var refMaps = {
      refElem
    };
    var $xeselect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var selectMethods = {};
    var computePropsOpts = computed$1(function() {
      return props.optionProps || {};
    });
    var computeGroupPropsOpts = computed$1(function() {
      return props.optionGroupProps || {};
    });
    var computeLabelField = computed$1(function() {
      var propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    var computeValueField = computed$1(function() {
      var propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    var computeGroupLabelField = computed$1(function() {
      var groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    var computeGroupOptionsField = computed$1(function() {
      var groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    var computeIsMaximize = computed$1(function() {
      var modelValue5 = props.modelValue, multiple = props.multiple, max3 = props.max;
      if (multiple && max3) {
        return (modelValue5 ? modelValue5.length : 0) >= xeUtils.toNumber(max3);
      }
      return false;
    });
    var computeOptionOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.select.optionConfig, props.optionConfig);
    });
    var computeIsGroup = computed$1(function() {
      return reactData.fullGroupList.some(function(item) {
        return item.options && item.options.length;
      });
    });
    var computeMultiMaxCharNum = computed$1(function() {
      return xeUtils.toNumber(props.multiCharOverflow);
    });
    var callSlot = function(slotFunc, params) {
      if (slotFunc) {
        if (xeUtils.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (xeUtils.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    var findOption = function(optionValue) {
      var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;
      var isGroup = computeIsGroup.value;
      var valueField = computeValueField.value;
      if (isGroup) {
        for (var gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          var group = fullGroupList[gIndex];
          if (group.options) {
            for (var index = 0; index < group.options.length; index++) {
              var option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find(function(item) {
        return optionValue === item[valueField];
      });
    };
    var getRemoteSelectLabel = function(value) {
      var remoteValueList = reactData.remoteValueList;
      var labelField = computeLabelField.value;
      var remoteItem = remoteValueList.find(function(item2) {
        return value === item2.key;
      });
      var item = remoteItem ? remoteItem.result : null;
      return xeUtils.toValueString(item ? item[labelField] : value);
    };
    var getSelectLabel = function(value) {
      var labelField = computeLabelField.value;
      var item = findOption(value);
      return xeUtils.toValueString(item ? item[labelField] : value);
    };
    var computeSelectLabel = computed$1(function() {
      var modelValue5 = props.modelValue, multiple = props.multiple, remote = props.remote;
      var multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue5 && multiple) {
        var vals = xeUtils.isArray(modelValue5) ? modelValue5 : [modelValue5];
        if (remote) {
          return vals.map(function(val2) {
            return getRemoteSelectLabel(val2);
          }).join(", ");
        }
        return vals.map(function(val2) {
          var label = getSelectLabel(val2);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return "".concat(label.substring(0, multiMaxCharNum), "...");
          }
          return label;
        }).join(", ");
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue5);
      }
      return getSelectLabel(modelValue5);
    });
    var getOptkey = function() {
      var optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    var getOptid = function(option) {
      var optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    var refreshOption = function() {
      var filterable = props.filterable, filterMethod = props.filterMethod;
      var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList, searchValue = reactData.searchValue;
      var isGroup = computeIsGroup.value;
      var groupLabelField = computeGroupLabelField.value;
      var labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter(function(group) {
            return isOptionVisible(group) && filterMethod({ group, option: null, searchValue });
          });
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter(function(group) {
            return isOptionVisible(group) && (!searchValue || "".concat(group[groupLabelField]).indexOf(searchValue) > -1);
          });
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter(function(option) {
            return isOptionVisible(option) && filterMethod({ group: null, option, searchValue });
          });
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter(function(option) {
            return isOptionVisible(option) && (!searchValue || "".concat(option[labelField]).indexOf(searchValue) > -1);
          });
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return nextTick$1();
    };
    var cacheItemMap = function() {
      var fullOptionList = reactData.fullOptionList, fullGroupList = reactData.fullGroupList;
      var groupOptionsField = computeGroupOptionsField.value;
      var key = getOptkey();
      var handleOptis = function(item) {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach(function(group) {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    var setCurrentOption = function(option) {
      var valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    var scrollToOption = function(option, isAlignBottom) {
      return nextTick$1().then(function() {
        if (option) {
          var optWrapperElem = refOptionWrapper.value;
          var panelElem = refOptionPanel.value;
          var optElem = panelElem.querySelector("[optid='".concat(getOptid(option), "']"));
          if (optWrapperElem && optElem) {
            var wrapperHeight = optWrapperElem.offsetHeight;
            var offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    var updateZindex = function() {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    var updatePlacement = function() {
      return nextTick$1().then(function() {
        var transfer = props.transfer, placement = props.placement;
        var panelIndex = reactData.panelIndex;
        var el2 = refElem.value;
        var panelElem = refOptionPanel.value;
        if (panelElem && el2) {
          var targetHeight = el2.offsetHeight;
          var targetWidth = el2.offsetWidth;
          var panelHeight = panelElem.offsetHeight;
          var panelWidth = panelElem.offsetWidth;
          var marginSize = 5;
          var panelStyle = {
            zIndex: panelIndex
          };
          var _a2 = getAbsolutePos(el2), boundingTop = _a2.boundingTop, boundingLeft = _a2.boundingLeft, visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
          var panelPlacement = "bottom";
          if (transfer) {
            var left = boundingLeft;
            var top_1 = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top_1 = boundingTop - panelHeight;
            } else if (!placement) {
              if (top_1 + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top_1 = boundingTop - panelHeight;
              }
              if (top_1 < marginSize) {
                panelPlacement = "bottom";
                top_1 = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: "".concat(left, "px"),
              top: "".concat(top_1, "px"),
              minWidth: "".concat(targetWidth, "px")
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = "".concat(targetHeight, "px");
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = "".concat(targetHeight, "px");
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick$1();
        }
      });
    };
    var hidePanelTimeout;
    var showOptionPanel = function() {
      var loading = props.loading, disabled3 = props.disabled, filterable = props.filterable;
      if (!loading && !disabled3) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.inited) {
          reactData.inited = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(function() {
          var modelValue5 = props.modelValue, multiple = props.multiple;
          var currOption = findOption(multiple && modelValue5 ? modelValue5[0] : modelValue5);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    var hideOptionPanel = function() {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(function() {
        reactData.animatVisible = false;
      }, 350);
    };
    var changeEvent = function(evnt, selectValue) {
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        selectMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);
        }
      }
    };
    var clearValueEvent = function(evnt, selectValue) {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    var clearEvent = function(params, evnt) {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    var changeOptionEvent = function(evnt, selectValue, option) {
      var modelValue5 = props.modelValue, multiple = props.multiple;
      var remoteValueList = reactData.remoteValueList;
      if (multiple) {
        var multipleValue = void 0;
        if (modelValue5) {
          if (modelValue5.indexOf(selectValue) === -1) {
            multipleValue = modelValue5.concat([selectValue]);
          } else {
            multipleValue = modelValue5.filter(function(val2) {
              return val2 !== selectValue;
            });
          }
        } else {
          multipleValue = [selectValue];
        }
        var remoteItem = remoteValueList.find(function(item) {
          return item.key === selectValue;
        });
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({ key: selectValue, result: option });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{ key: selectValue, result: option }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    var handleGlobalMousewheelEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      if (!disabled3) {
        if (visiblePanel) {
          var panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    var handleGlobalMousedownEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      if (!disabled3) {
        var el2 = refElem.value;
        var panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el2).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    var findOffsetOption = function(optionValue, isUpArrow) {
      var visibleOptionList = reactData.visibleOptionList, visibleGroupList = reactData.visibleGroupList;
      var isGroup = computeIsGroup.value;
      var valueField = computeValueField.value;
      var groupOptionsField = computeGroupOptionsField.value;
      var firstOption;
      var prevOption;
      var nextOption;
      var currOption;
      if (isGroup) {
        for (var gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          var group = visibleGroupList[gIndex];
          var groupOptionList = group[groupOptionsField];
          var isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (var index = 0; index < groupOptionList.length; index++) {
              var option = groupOptionList[index];
              var isVisible = isOptionVisible(option);
              var isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return { offsetOption: nextOption };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return { offsetOption: prevOption };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (var index = 0; index < visibleOptionList.length; index++) {
          var option = visibleOptionList[index];
          var isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return { offsetOption: nextOption };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return { offsetOption: prevOption };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return { firstOption };
    };
    var handleGlobalKeydownEvent = function(evnt) {
      var clearable = props.clearable, disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel, currentValue = reactData.currentValue, currentOption = reactData.currentOption;
      if (!disabled3) {
        var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            var _a2 = findOffsetOption(currentValue, isUpArrow), firstOption = _a2.firstOption, offsetOption = _a2.offsetOption;
            if (!offsetOption && !findOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    var handleGlobalBlurEvent = function() {
      hideOptionPanel();
    };
    var handleFocusSearch = function() {
      if (props.filterable) {
        nextTick$1(function() {
          var inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    var focusEvent = function() {
      if (!props.disabled) {
        reactData.isActivated = true;
      }
    };
    var blurEvent = function() {
      reactData.isActivated = false;
    };
    var modelSearchEvent = function(value) {
      reactData.searchValue = value;
    };
    var focusSearchEvent = function() {
      reactData.isActivated = true;
    };
    var keydownSearchEvent = function(params) {
      var $event = params.$event;
      var isEnter = hasEventKey($event, EVENT_KEYS.ENTER);
      if (isEnter) {
        $event.preventDefault();
        $event.stopPropagation();
      }
    };
    var triggerSearchEvent = xeUtils.debounce(function() {
      var remote = props.remote, remoteMethod = props.remoteMethod;
      var searchValue = reactData.searchValue;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(function() {
          return nextTick$1();
        }).catch(function() {
          return nextTick$1();
        }).finally(function() {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, { trailing: true });
    var togglePanelEvent = function(params) {
      var $event = params.$event;
      $event.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    var checkOptionDisabled = function(isSelected, option, group) {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      var isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    var renderOption = function(list, group) {
      var optionKey = props.optionKey, modelValue5 = props.modelValue, multiple = props.multiple;
      var currentValue = reactData.currentValue;
      var optionOpts = computeOptionOpts.value;
      var labelField = computeLabelField.value;
      var valueField = computeValueField.value;
      var isGroup = computeIsGroup.value;
      var useKey = optionOpts.useKey;
      return list.map(function(option, cIndex) {
        var slots2 = option.slots, className = option.className;
        var optionValue = option[valueField];
        var isSelected = multiple ? modelValue5 && modelValue5.indexOf(optionValue) > -1 : modelValue5 === optionValue;
        var isVisible = !isGroup || isOptionVisible(option);
        var isDisabled = checkOptionDisabled(isSelected, option, group);
        var optid = getOptid(option);
        var defaultSlot = slots2 ? slots2.default : null;
        return isVisible ? h$6("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? xeUtils.isFunction(className) ? className({ option, $select: $xeselect }) : className : "", {
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentValue === optionValue
          }],
          optid,
          onMousedown: function(evnt) {
            var isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: function(evnt) {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: function() {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, defaultSlot ? callSlot(defaultSlot, { option, $select: $xeselect }) : formatText(getFuncText(option[labelField]))) : null;
      });
    };
    var renderOptgroup = function() {
      var optionKey = props.optionKey;
      var visibleGroupList = reactData.visibleGroupList;
      var optionOpts = computeOptionOpts.value;
      var groupLabelField = computeGroupLabelField.value;
      var groupOptionsField = computeGroupOptionsField.value;
      var useKey = optionOpts.useKey;
      return visibleGroupList.map(function(group, gIndex) {
        var slots2 = group.slots, className = group.className;
        var optid = getOptid(group);
        var isGroupDisabled = group.disabled;
        var defaultSlot = slots2 ? slots2.default : null;
        return h$6("div", {
          key: useKey || optionKey ? optid : gIndex,
          class: ["vxe-optgroup", className ? xeUtils.isFunction(className) ? className({ option: group, $select: $xeselect }) : className : "", {
            "is--disabled": isGroupDisabled
          }],
          optid
        }, [
          h$6("div", {
            class: "vxe-optgroup--title"
          }, defaultSlot ? callSlot(defaultSlot, { option: group, $select: $xeselect }) : getFuncText(group[groupLabelField])),
          h$6("div", {
            class: "vxe-optgroup--wrapper"
          }, renderOption(group[groupOptionsField] || [], group))
        ]);
      });
    };
    var renderOpts = function() {
      var visibleGroupList = reactData.visibleGroupList, visibleOptionList = reactData.visibleOptionList, searchLoading = reactData.searchLoading;
      var isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [
          h$6("div", {
            class: "vxe-select--search-loading"
          }, [
            h$6("i", {
              class: ["vxe-select--search-icon", GlobalConfig.icon.SELECT_LOADED]
            }),
            h$6("span", {
              class: "vxe-select--search-text"
            }, GlobalConfig.i18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [
        h$6("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || GlobalConfig.i18n("vxe.select.emptyText"))
      ];
    };
    selectMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $select: $xeselect, $event: evnt }, params));
      },
      isPanelVisible: function() {
        return reactData.visiblePanel;
      },
      togglePanel: function() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick$1();
      },
      hidePanel: function() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick$1();
      },
      showPanel: function() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick$1();
      },
      refreshOption,
      focus: function() {
        var $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick$1();
      },
      blur: function() {
        var $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick$1();
      }
    };
    Object.assign($xeselect, selectMethods);
    watch$1(function() {
      return reactData.staticOptions;
    }, function(value) {
      if (value.some(function(item) {
        return item.options && item.options.length;
      })) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    watch$1(function() {
      return props.options;
    }, function(value) {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    watch$1(function() {
      return props.optionGroups;
    }, function(value) {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    onMounted$1(function() {
      nextTick$1(function() {
        var options = props.options, optionGroups = props.optionGroups;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      GlobalEvent.on($xeselect, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeselect, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeselect, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeselect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(function() {
      GlobalEvent.off($xeselect, "mousewheel");
      GlobalEvent.off($xeselect, "mousedown");
      GlobalEvent.off($xeselect, "keydown");
      GlobalEvent.off($xeselect, "blur");
    });
    var renderVN = function() {
      var _a2, _b2;
      var className = props.className, transfer = props.transfer, disabled3 = props.disabled, loading = props.loading, filterable = props.filterable;
      var inited = reactData.inited, isActivated = reactData.isActivated, visiblePanel = reactData.visiblePanel;
      var vSize = computeSize.value;
      var selectLabel = computeSelectLabel.value;
      var prefixSlot = slots.prefix;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-select", className ? xeUtils.isFunction(className) ? className({ $select: $xeselect }) : className : "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--visivle"] = visiblePanel, _a2["is--disabled"] = disabled3, _a2["is--filter"] = filterable, _a2["is--loading"] = loading, _a2["is--active"] = isActivated, _a2)]
      }, [
        h$6("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, slots.default ? slots.default({}) : []),
        h$6(VxeInputConstructor, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: props.placeholder,
          readonly: true,
          disabled: disabled3,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading ? GlobalConfig.icon.SELECT_LOADED : visiblePanel ? GlobalConfig.icon.SELECT_OPEN : GlobalConfig.icon.SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: togglePanelEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: function() {
            return prefixSlot({});
          }
        } : {}),
        h$6(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h$6("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", (_b2 = {}, _b2["size--".concat(vSize)] = vSize, _b2["is--transfer"] = transfer, _b2["animat--leave"] = !loading && reactData.animatVisible, _b2["animat--enter"] = !loading && visiblePanel, _b2)],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, inited ? [
            filterable ? h$6("div", {
              class: "vxe-select-filter--wrapper"
            }, [
              h$6(VxeInputConstructor, {
                ref: refInpSearch,
                class: "vxe-select-filter--input",
                modelValue: reactData.searchValue,
                clearable: true,
                placeholder: GlobalConfig.i18n("vxe.select.search"),
                prefixIcon: GlobalConfig.icon.INPUT_SEARCH,
                "onUpdate:modelValue": modelSearchEvent,
                onFocus: focusSearchEvent,
                onKeydown: keydownSearchEvent,
                onChange: triggerSearchEvent,
                onSearch: triggerSearchEvent
              })
            ]) : createCommentVNode(),
            h$6("div", {
              ref: refOptionWrapper,
              class: "vxe-select-option--wrapper"
            }, renderOpts())
          ] : [])
        ])
      ]);
    };
    $xeselect.renderVN = renderVN;
    provide("$xeselect", $xeselect);
    return $xeselect;
  },
  render: function() {
    return this.renderVN();
  }
});
var ExportPanelComponent = defineComponent({
  name: "VxeExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var _a2 = $xetable.getComputeMaps(), computeExportOpts = _a2.computeExportOpts, computePrintOpts = _a2.computePrintOpts;
    var reactData = reactive$1({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    var xButtonConfirm = ref$1();
    var xInputFilename = ref$1();
    var xInputSheetname = ref$1();
    var computeCheckedAll = computed$1(function() {
      var storeData = props.storeData;
      return storeData.columns.every(function(column2) {
        return column2.checked;
      });
    });
    var computeShowSheet = computed$1(function() {
      var defaultOptions = props.defaultOptions;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    var computeSupportMerge = computed$1(function() {
      var storeData = props.storeData, defaultOptions = props.defaultOptions;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    var computeSupportStyle = computed$1(function() {
      var defaultOptions = props.defaultOptions;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    var handleOptionCheck = function(column2) {
      var storeData = props.storeData;
      var matchObj = xeUtils.findTree(storeData.columns, function(item) {
        return item === column2;
      });
      if (matchObj && matchObj.parent) {
        var parent_1 = matchObj.parent;
        if (parent_1.children && parent_1.children.length) {
          parent_1.checked = parent_1.children.every(function(column3) {
            return column3.checked;
          });
          parent_1.halfChecked = !parent_1.checked && parent_1.children.some(function(column3) {
            return column3.checked || column3.halfChecked;
          });
          handleOptionCheck(parent_1);
        }
      }
    };
    var checkStatus = function() {
      var storeData = props.storeData;
      var columns = storeData.columns;
      reactData.isAll = columns.every(function(column2) {
        return column2.disabled || column2.checked;
      });
      reactData.isIndeterminate = !reactData.isAll && columns.some(function(column2) {
        return !column2.disabled && (column2.checked || column2.halfChecked);
      });
    };
    var changeOption = function(column2) {
      var isChecked = !column2.checked;
      xeUtils.eachTree([column2], function(item) {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column2);
      checkStatus();
    };
    var allColumnEvent = function() {
      var storeData = props.storeData;
      var isAll = !reactData.isAll;
      xeUtils.eachTree(storeData.columns, function(column2) {
        if (!column2.disabled) {
          column2.checked = isAll;
          column2.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    var showEvent = function() {
      nextTick$1(function() {
        var filenameInp = xInputFilename.value;
        var sheetnameInp = xInputSheetname.value;
        var confirmBtn = xButtonConfirm.value;
        var targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    var getExportOption = function() {
      var storeData = props.storeData, defaultOptions = props.defaultOptions;
      var hasMerge = storeData.hasMerge, columns = storeData.columns;
      var checkedAll = computeCheckedAll.value;
      var supportMerge = computeSupportMerge.value;
      var expColumns = xeUtils.searchTree(columns, function(column2) {
        return column2.checked;
      }, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    var printEvent = function() {
      var storeData = props.storeData;
      var printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xetable.print(Object.assign({}, printOpts, getExportOption()));
    };
    var exportEvent = function() {
      var storeData = props.storeData;
      var exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xetable.exportData(Object.assign({}, exportOpts, getExportOption())).then(function() {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(function() {
        reactData.loading = false;
      });
    };
    var cancelEvent = function() {
      var storeData = props.storeData;
      storeData.visible = false;
    };
    var confirmEvent = function() {
      var storeData = props.storeData;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    var renderVN = function() {
      var defaultOptions = props.defaultOptions, storeData = props.storeData;
      var isAllChecked = reactData.isAll, isAllIndeterminate = reactData.isIndeterminate;
      var hasTree = storeData.hasTree, hasMerge = storeData.hasMerge, isPrint = storeData.isPrint, hasColgroup = storeData.hasColgroup;
      var isHeader = defaultOptions.isHeader;
      var cols = [];
      var checkedAll = computeCheckedAll.value;
      var showSheet = computeShowSheet.value;
      var supportMerge = computeSupportMerge.value;
      var supportStyle = computeSupportStyle.value;
      xeUtils.eachTree(storeData.columns, function(column2) {
        var colTitle = formatText(column2.getTitle(), 1);
        var isColGroup = column2.children && column2.children.length;
        var isChecked = column2.checked;
        var indeterminate = column2.halfChecked;
        cols.push(h$6("li", {
          class: ["vxe-export--panel-column-option", "level--".concat(column2.level), {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column2.disabled
          }],
          title: colTitle,
          onClick: function() {
            if (!column2.disabled) {
              changeOption(column2);
            }
          }
        }, [
          h$6("span", {
            class: ["vxe-checkbox--icon", indeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
          }),
          h$6("span", {
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return h$6(VxeModalComponent, {
        modelValue: storeData.visible,
        title: GlobalConfig.i18n(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        width: 660,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue": function(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: function() {
          return h$6("div", {
            class: "vxe-export--panel"
          }, [
            h$6("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h$6("tbody", [
                [
                  isPrint ? createCommentVNode() : h$6("tr", [
                    h$6("td", GlobalConfig.i18n("vxe.export.expName")),
                    h$6("td", [
                      h$6(VxeInputConstructor, {
                        ref: xInputFilename,
                        modelValue: defaultOptions.filename,
                        type: "text",
                        clearable: true,
                        placeholder: GlobalConfig.i18n("vxe.export.expNamePlaceholder"),
                        "onUpdate:modelValue": function(value) {
                          defaultOptions.filename = value;
                        }
                      })
                    ])
                  ]),
                  isPrint ? createCommentVNode() : h$6("tr", [
                    h$6("td", GlobalConfig.i18n("vxe.export.expType")),
                    h$6("td", [
                      h$6(VxeSelectComponent, {
                        modelValue: defaultOptions.type,
                        options: storeData.typeList.map(function(item) {
                          return {
                            value: item.value,
                            label: GlobalConfig.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue": function(value) {
                          defaultOptions.type = value;
                        }
                      })
                    ])
                  ]),
                  isPrint || showSheet ? h$6("tr", [
                    h$6("td", GlobalConfig.i18n("vxe.export.expSheetName")),
                    h$6("td", [
                      h$6(VxeInputConstructor, {
                        ref: xInputSheetname,
                        modelValue: defaultOptions.sheetName,
                        type: "text",
                        clearable: true,
                        placeholder: GlobalConfig.i18n("vxe.export.expSheetNamePlaceholder"),
                        "onUpdate:modelValue": function(value) {
                          defaultOptions.sheetName = value;
                        }
                      })
                    ])
                  ]) : createCommentVNode(),
                  h$6("tr", [
                    h$6("td", GlobalConfig.i18n("vxe.export.expMode")),
                    h$6("td", [
                      h$6(VxeSelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData.modeList.map(function(item) {
                          return {
                            value: item.value,
                            label: GlobalConfig.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue": function(value) {
                          defaultOptions.mode = value;
                        }
                      })
                    ])
                  ]),
                  h$6("tr", [
                    h$6("td", [GlobalConfig.i18n("vxe.export.expColumn")]),
                    h$6("td", [
                      h$6("div", {
                        class: "vxe-export--panel-column"
                      }, [
                        h$6("ul", {
                          class: "vxe-export--panel-column-header"
                        }, [
                          h$6("li", {
                            class: ["vxe-export--panel-column-option", {
                              "is--checked": isAllChecked,
                              "is--indeterminate": isAllIndeterminate
                            }],
                            title: GlobalConfig.i18n("vxe.table.allTitle"),
                            onClick: allColumnEvent
                          }, [
                            h$6("span", {
                              class: ["vxe-checkbox--icon", isAllIndeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
                            }),
                            h$6("span", {
                              class: "vxe-checkbox--label"
                            }, GlobalConfig.i18n("vxe.export.expCurrentColumn"))
                          ])
                        ]),
                        h$6("ul", {
                          class: "vxe-export--panel-column-body"
                        }, cols)
                      ])
                    ])
                  ]),
                  h$6("tr", [
                    h$6("td", GlobalConfig.i18n("vxe.export.expOpts")),
                    h$6("td", [
                      h$6("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h$6(VxeCheckboxComponent, {
                          modelValue: defaultOptions.isHeader,
                          title: GlobalConfig.i18n("vxe.export.expHeaderTitle"),
                          content: GlobalConfig.i18n("vxe.export.expOptHeader"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.isHeader = value;
                          }
                        }),
                        h$6(VxeCheckboxComponent, {
                          modelValue: defaultOptions.isFooter,
                          disabled: !storeData.hasFooter,
                          title: GlobalConfig.i18n("vxe.export.expFooterTitle"),
                          content: GlobalConfig.i18n("vxe.export.expOptFooter"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.isFooter = value;
                          }
                        }),
                        h$6(VxeCheckboxComponent, {
                          modelValue: defaultOptions.original,
                          title: GlobalConfig.i18n("vxe.export.expOriginalTitle"),
                          content: GlobalConfig.i18n("vxe.export.expOptOriginal"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.original = value;
                          }
                        })
                      ]),
                      h$6("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h$6(VxeCheckboxComponent, {
                          modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                          title: GlobalConfig.i18n("vxe.export.expColgroupTitle"),
                          disabled: !isHeader || !hasColgroup || !supportMerge,
                          content: GlobalConfig.i18n("vxe.export.expOptColgroup"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.isColgroup = value;
                          }
                        }),
                        h$6(VxeCheckboxComponent, {
                          modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                          title: GlobalConfig.i18n("vxe.export.expMergeTitle"),
                          disabled: !hasMerge || !supportMerge || !checkedAll,
                          content: GlobalConfig.i18n("vxe.export.expOptMerge"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.isMerge = value;
                          }
                        }),
                        isPrint ? createCommentVNode() : h$6(VxeCheckboxComponent, {
                          modelValue: supportStyle ? defaultOptions.useStyle : false,
                          disabled: !supportStyle,
                          title: GlobalConfig.i18n("vxe.export.expUseStyleTitle"),
                          content: GlobalConfig.i18n("vxe.export.expOptUseStyle"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.useStyle = value;
                          }
                        }),
                        h$6(VxeCheckboxComponent, {
                          modelValue: hasTree ? defaultOptions.isAllExpand : false,
                          disabled: !hasTree,
                          title: GlobalConfig.i18n("vxe.export.expAllExpandTitle"),
                          content: GlobalConfig.i18n("vxe.export.expOptAllExpand"),
                          "onUpdate:modelValue": function(value) {
                            defaultOptions.isAllExpand = value;
                          }
                        })
                      ])
                    ])
                  ])
                ]
              ])
            ]),
            h$6("div", {
              class: "vxe-export--panel-btns"
            }, [
              h$6(VxeButtonComponent, {
                content: GlobalConfig.i18n("vxe.export.expCancel"),
                onClick: cancelEvent
              }),
              h$6(VxeButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: GlobalConfig.i18n(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});
var VxeRadioGroupComponent = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    strict: { type: Boolean, default: function() {
      return GlobalConfig.radio.strict;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.radio.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var $xeradiogroup = {
      xID,
      props,
      context,
      name: xeUtils.uniqueId("xegroup_")
    };
    var radioGroupMethods = {};
    useSize$1(props);
    var radioGroupPrivateMethods = {
      handleChecked: function(params, evnt) {
        emit("update:modelValue", params.label);
        radioGroupMethods.dispatchEvent("change", params);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $radioGroup: $xeradiogroup, $event: evnt }, params));
      }
    };
    var renderVN = function() {
      return h$6("div", {
        class: "vxe-radio-group"
      }, slots.default ? slots.default({}) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    provide("$xeradiogroup", $xeradiogroup);
    return renderVN;
  }
});
var VxeRadioComponent = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    name: String,
    strict: { type: Boolean, default: function() {
      return GlobalConfig.radio.strict;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.radio.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var $xeradio = {
      xID,
      props,
      context
    };
    var computeSize = useSize$1(props);
    var $xeradiogroup = inject("$xeradiogroup", null);
    var radioMethods = {};
    var computeDisabled = computed$1(function() {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    var computeName = computed$1(function() {
      return $xeradiogroup ? $xeradiogroup.name : props.name;
    });
    var computeStrict = computed$1(function() {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    var computeChecked = computed$1(function() {
      var modelValue5 = props.modelValue, label = props.label;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue5 === label;
    });
    var handleValue = function(label, evnt) {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    var changeEvent = function(evnt) {
      var isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    var clickEvent = function(evnt) {
      var isDisabled = computeDisabled.value;
      var isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $radio: $xeradio, $event: evnt }, params));
      }
    };
    Object.assign($xeradio, radioMethods);
    var renderVN = function() {
      var _a2;
      var vSize = computeSize.value;
      var isDisabled = computeDisabled.value;
      var name2 = computeName.value;
      var isChecked = computeChecked.value;
      return h$6("label", {
        class: ["vxe-radio", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--checked"] = isChecked, _a2["is--disabled"] = isDisabled, _a2)],
        title: props.title
      }, [
        h$6("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: name2,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h$6("span", {
          class: ["vxe-radio--icon", isChecked ? "vxe-icon-radio-checked" : "vxe-icon-radio-unchecked"]
        }),
        h$6("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeradio.renderVN = renderVN;
    return $xeradio;
  },
  render: function() {
    return this.renderVN();
  }
});
var ImportPanelComponent = defineComponent({
  name: "VxeImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var computeImportOpts = $xetable.getComputeMaps().computeImportOpts;
    var reactData = reactive$1({
      loading: false
    });
    var refFileBtn = ref$1();
    var computeSelectName = computed$1(function() {
      var storeData = props.storeData;
      return "".concat(storeData.filename, ".").concat(storeData.type);
    });
    var computeHasFile = computed$1(function() {
      var storeData = props.storeData;
      return storeData.file && storeData.type;
    });
    var computeParseTypeLabel = computed$1(function() {
      var storeData = props.storeData;
      var type2 = storeData.type, typeList = storeData.typeList;
      if (type2) {
        var selectItem = xeUtils.find(typeList, function(item) {
          return type2 === item.value;
        });
        return selectItem ? GlobalConfig.i18n(selectItem.label) : "*.*";
      }
      return "*.".concat(typeList.map(function(item) {
        return item.value;
      }).join(", *."));
    });
    var clearFileEvent = function() {
      var storeData = props.storeData;
      Object.assign(storeData, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    var selectFileEvent = function() {
      var storeData = props.storeData, defaultOptions = props.defaultOptions;
      $xetable.readFile(defaultOptions).then(function(params) {
        var file = params.file;
        Object.assign(storeData, parseFile(file), { file });
      }).catch(function(e3) {
        return e3;
      });
    };
    var showEvent = function() {
      nextTick$1(function() {
        var targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    var cancelEvent = function() {
      var storeData = props.storeData;
      storeData.visible = false;
    };
    var importEvent = function() {
      var storeData = props.storeData, defaultOptions = props.defaultOptions;
      var importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xetable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(function() {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(function() {
        reactData.loading = false;
      });
    };
    var renderVN = function() {
      var defaultOptions = props.defaultOptions, storeData = props.storeData;
      var selectName = computeSelectName.value;
      var hasFile = computeHasFile.value;
      var parseTypeLabel = computeParseTypeLabel.value;
      return h$6(VxeModalComponent, {
        modelValue: storeData.visible,
        title: GlobalConfig.i18n("vxe.import.impTitle"),
        width: 440,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue": function(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: function() {
          return h$6("div", {
            class: "vxe-export--panel"
          }, [
            h$6("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h$6("tbody", [
                h$6("tr", [
                  h$6("td", GlobalConfig.i18n("vxe.import.impFile")),
                  h$6("td", [
                    hasFile ? h$6("div", {
                      class: "vxe-import-selected--file",
                      title: selectName
                    }, [
                      h$6("span", selectName),
                      h$6("i", {
                        class: GlobalConfig.icon.INPUT_CLEAR,
                        onClick: clearFileEvent
                      })
                    ]) : h$6("button", {
                      ref: refFileBtn,
                      class: "vxe-import-select--file",
                      onClick: selectFileEvent
                    }, GlobalConfig.i18n("vxe.import.impSelect"))
                  ])
                ]),
                h$6("tr", [
                  h$6("td", GlobalConfig.i18n("vxe.import.impType")),
                  h$6("td", parseTypeLabel)
                ]),
                h$6("tr", [
                  h$6("td", GlobalConfig.i18n("vxe.import.impOpts")),
                  h$6("td", [
                    h$6(VxeRadioGroupComponent, {
                      modelValue: defaultOptions.mode,
                      "onUpdate:modelValue": function(value) {
                        defaultOptions.mode = value;
                      }
                    }, {
                      default: function() {
                        return storeData.modeList.map(function(item) {
                          return h$6(VxeRadioComponent, { label: item.value, content: GlobalConfig.i18n(item.label) });
                        });
                      }
                    })
                  ])
                ])
              ])
            ]),
            h$6("div", {
              class: "vxe-export--panel-btns"
            }, [
              h$6(VxeButtonComponent, {
                content: GlobalConfig.i18n("vxe.import.impCancel"),
                onClick: cancelEvent
              }),
              h$6(VxeButtonComponent, {
                status: "primary",
                disabled: !hasFile,
                content: GlobalConfig.i18n("vxe.import.impConfirm"),
                onClick: importEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});
dynamicApp.component(ExportPanelComponent.name, ExportPanelComponent);
dynamicApp.component(ImportPanelComponent.name, ImportPanelComponent);
var __assign$f = globalThis && globalThis.__assign || function() {
  __assign$f = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$f.apply(this, arguments);
};
var VxeIconComponent = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    roll: Boolean
  },
  emits: [
    "click"
  ],
  setup: function(props, _a2) {
    var emit = _a2.emit;
    var clickEvent = function(evnt) {
      emit("click", { $event: evnt });
    };
    return function() {
      return h$6("i", {
        class: ["vxe-icon-".concat(props.name), props.roll ? "roll" : ""],
        onClick: clickEvent
      });
    };
  }
});
var VxeIcon = Object.assign(VxeIconComponent, {
  install: function(app) {
    app.component(VxeIconComponent.name, VxeIconComponent);
  }
});
dynamicApp.component(VxeIcon.name, VxeIcon);
var __assign$e = globalThis && globalThis.__assign || function() {
  __assign$e = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$e.apply(this, arguments);
};
function renderHelpIcon(params) {
  var $table = params.$table, column2 = params.column;
  var titlePrefix = column2.titlePrefix || column2.titleHelp;
  return titlePrefix ? [
    h$6("i", {
      class: ["vxe-cell-help-icon", titlePrefix.icon || GlobalConfig.icon.TABLE_HELP],
      onMouseenter: function(evnt) {
        $table.triggerHeaderHelpEvent(evnt, params);
      },
      onMouseleave: function(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    })
  ] : [];
}
function renderTitleContent(params, content) {
  var $table = params.$table, column2 = params.column;
  var props = $table.props, internalData = $table.internalData;
  var computeTooltipOpts = $table.getComputeMaps().computeTooltipOpts;
  var allColumnHeaderOverflow = props.showHeaderOverflow;
  var type2 = column2.type, showHeaderOverflow = column2.showHeaderOverflow;
  var tooltipOpts = computeTooltipOpts.value;
  var showAllTip = tooltipOpts.showAll;
  var headOverflow = xeUtils.isUndefined(showHeaderOverflow) || xeUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  var showTitle = headOverflow === "title";
  var showTooltip2 = headOverflow === true || headOverflow === "tooltip";
  var ons = {};
  if (showTitle || showTooltip2 || showAllTip) {
    ons.onMouseenter = function(evnt) {
      if (internalData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column2);
      } else if (showTooltip2 || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip2 || showAllTip) {
    ons.onMouseleave = function(evnt) {
      if (internalData._isResize) {
        return;
      }
      if (showTooltip2 || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [
    type2 === "html" && xeUtils.isString(content) ? h$6("span", __assign$e({ class: "vxe-cell--title", innerHTML: content }, ons)) : h$6("span", __assign$e({ class: "vxe-cell--title" }, ons), content)
  ];
}
function getFooterContent(params) {
  var $table = params.$table, column2 = params.column, _columnIndex = params._columnIndex, items = params.items;
  var slots = column2.slots, editRender = column2.editRender, cellRender = column2.cellRender;
  var renderOpts = editRender || cellRender;
  var footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    var compConf = VXETable.renderer.get(renderOpts.name);
    if (compConf && compConf.renderFooter) {
      return getSlotVNs(compConf.renderFooter(renderOpts, params));
    }
  }
  return [formatText(items[_columnIndex], 1)];
}
function getDefaultCellLabel(params) {
  var $table = params.$table, row2 = params.row, column2 = params.column;
  return formatText($table.getCellLabel(row2, column2), 1);
}
var Cell = {
  createColumn: function($xetable, columnOpts) {
    var type2 = columnOpts.type, sortable = columnOpts.sortable, filters = columnOpts.filters, editRender = columnOpts.editRender, treeNode = columnOpts.treeNode;
    var props = $xetable.props;
    var editConfig = props.editConfig;
    var _a2 = $xetable.getComputeMaps(), computeEditOpts = _a2.computeEditOpts, computeCheckboxOpts = _a2.computeCheckboxOpts;
    var checkboxOpts = computeCheckboxOpts.value;
    var editOpts = computeEditOpts.value;
    var renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type2) {
      case "seq":
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case "radio":
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case "checkbox":
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case "expand":
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case "html":
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === "cell" ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xetable, columnOpts, renConfs);
  },
  renderHeaderTitle: function(params) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots, editRender = column2.editRender, cellRender = column2.cellRender;
    var renderOpts = editRender || cellRender;
    var headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      var compConf = VXETable.renderer.get(renderOpts.name);
      if (compConf && compConf.renderHeader) {
        return renderTitleContent(params, getSlotVNs(compConf.renderHeader(renderOpts, params)));
      }
    }
    return renderTitleContent(params, [formatText(column2.getTitle(), 1)]);
  },
  renderDefaultHeader: function(params) {
    return renderHelpIcon(params).concat(Cell.renderHeaderTitle(params));
  },
  renderDefaultCell: function(params) {
    var $table = params.$table, row2 = params.row, column2 = params.column;
    var slots = column2.slots, editRender = column2.editRender, cellRender = column2.cellRender;
    var renderOpts = editRender || cellRender;
    var defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (renderOpts) {
      var funName = editRender ? "renderCell" : "renderDefault";
      var compConf = VXETable.renderer.get(renderOpts.name);
      var compFn = compConf ? compConf[funName] : null;
      if (compFn) {
        return getSlotVNs(compFn(renderOpts, Object.assign({ $type: editRender ? "edit" : "cell" }, params)));
      }
    }
    var cellValue = $table.getCellLabel(row2, column2);
    var cellPlaceholder = editRender ? editRender.placeholder : "";
    return [
      h$6("span", {
        class: "vxe-cell--label"
      }, editRender && eqEmptyValue(cellValue) ? [
        h$6("span", {
          class: "vxe-cell--placeholder"
        }, formatText(getFuncText(cellPlaceholder), 1))
      ] : formatText(cellValue, 1))
    ];
  },
  renderTreeCell: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter: function(params) {
    return [
      h$6("span", {
        class: "vxe-cell--item"
      }, getFooterContent(params))
    ];
  },
  renderTreeIcon: function(params, cellVNodes) {
    var $table = params.$table, isHidden = params.isHidden;
    var reactData = $table.reactData;
    var computeTreeOpts = $table.getComputeMaps().computeTreeOpts;
    var treeExpandeds = reactData.treeExpandeds, treeLazyLoadeds = reactData.treeLazyLoadeds;
    var treeOpts = computeTreeOpts.value;
    var row2 = params.row, column2 = params.column, level = params.level;
    var slots = column2.slots;
    var children2 = treeOpts.children, hasChild = treeOpts.hasChild, indent = treeOpts.indent, lazy = treeOpts.lazy, trigger2 = treeOpts.trigger, iconLoaded = treeOpts.iconLoaded, showIcon = treeOpts.showIcon, iconOpen = treeOpts.iconOpen, iconClose = treeOpts.iconClose;
    var rowChilds = row2[children2];
    var iconSlot = slots ? slots.icon : null;
    var hasLazyChilds = false;
    var isAceived = false;
    var isLazyLoaded = false;
    var ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      isAceived = $table.findRowIndexOf(treeExpandeds, row2) > -1;
      if (lazy) {
        isLazyLoaded = $table.findRowIndexOf(treeLazyLoadeds, row2) > -1;
        hasLazyChilds = row2[hasChild];
      }
    }
    if (!trigger2 || trigger2 === "default") {
      ons.onClick = function(evnt) {
        return $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [
      h$6("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": isAceived
        }],
        style: {
          paddingLeft: "".concat(level * indent, "px")
        }
      }, [
        showIcon && (rowChilds && rowChilds.length || hasLazyChilds) ? [
          h$6("div", __assign$e({ class: "vxe-tree--btn-wrapper" }, ons), [
            h$6("i", {
              class: ["vxe-tree--node-btn", isLazyLoaded ? iconLoaded || GlobalConfig.icon.TABLE_TREE_LOADED : isAceived ? iconOpen || GlobalConfig.icon.TABLE_TREE_OPEN : iconClose || GlobalConfig.icon.TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        h$6("div", {
          class: "vxe-tree-cell"
        }, cellVNodes)
      ])
    ];
  },
  renderSeqHeader: function(params) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots;
    var headerSlot = slots ? slots.header : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [formatText(column2.getTitle(), 1)]);
  },
  renderSeqCell: function(params) {
    var $table = params.$table, column2 = params.column;
    var props = $table.props;
    var treeConfig = props.treeConfig;
    var computeSeqOpts = $table.getComputeMaps().computeSeqOpts;
    var seqOpts = computeSeqOpts.value;
    var slots = column2.slots;
    var defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    var seq = params.seq;
    var seqMethod = seqOpts.seqMethod;
    return [formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)];
  },
  renderTreeIndexCell: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  renderRadioHeader: function(params) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots;
    var headerSlot = slots ? slots.header : null;
    var titleSlot = slots ? slots.title : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [
      h$6("span", {
        class: "vxe-radio--label"
      }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column2.getTitle(), 1))
    ]);
  },
  renderRadioCell: function(params) {
    var $table = params.$table, column2 = params.column, isHidden = params.isHidden;
    var reactData = $table.reactData;
    var computeRadioOpts = $table.getComputeMaps().computeRadioOpts;
    var selectRow = reactData.selectRow;
    var radioOpts = computeRadioOpts.value;
    var slots = column2.slots;
    var labelField = radioOpts.labelField, checkMethod = radioOpts.checkMethod, visibleMethod = radioOpts.visibleMethod;
    var row2 = params.row;
    var defaultSlot = slots ? slots.default : null;
    var radioSlot = slots ? slots.radio : null;
    var isChecked = row2 === selectRow;
    var isVisible = !visibleMethod || visibleMethod({ row: row2 });
    var isDisabled = !!checkMethod;
    var ons;
    if (!isHidden) {
      ons = {
        onClick: function(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row: row2 });
      }
    }
    var radioParams = __assign$e(__assign$e({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible });
    if (radioSlot) {
      return $table.callSlot(radioSlot, radioParams);
    }
    var radioVNs = [];
    if (isVisible) {
      radioVNs.push(h$6("span", {
        class: ["vxe-radio--icon", isChecked ? GlobalConfig.icon.TABLE_RADIO_CHECKED : GlobalConfig.icon.TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h$6("span", {
        class: "vxe-radio--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : xeUtils.get(row2, labelField)));
    }
    return [
      h$6("span", __assign$e({ class: ["vxe-cell--radio", {
        "is--checked": isChecked,
        "is--disabled": isDisabled
      }] }, ons), radioVNs)
    ];
  },
  renderTreeRadioCell: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  renderCheckboxHeader: function(params) {
    var $table = params.$table, column2 = params.column, isHidden = params.isHidden;
    var reactData = $table.reactData;
    var _a2 = $table.getComputeMaps(), computeIsAllCheckboxDisabled = _a2.computeIsAllCheckboxDisabled, computeCheckboxOpts = _a2.computeCheckboxOpts;
    var isAllCheckboxSelected = reactData.isAllSelected, isAllCheckboxIndeterminate = reactData.isIndeterminate;
    var isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    var slots = column2.slots;
    var headerSlot = slots ? slots.header : null;
    var titleSlot = slots ? slots.title : null;
    var checkboxOpts = computeCheckboxOpts.value;
    var headerTitle = column2.getTitle();
    var ons;
    if (!isHidden) {
      ons = {
        onClick: function(evnt) {
          if (!isAllCheckboxDisabled) {
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    var checkboxParams = __assign$e(__assign$e({}, params), { checked: isAllCheckboxSelected, disabled: isAllCheckboxDisabled, indeterminate: isAllCheckboxIndeterminate });
    if (headerSlot) {
      return renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderTitleContent(checkboxParams, [
        h$6("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ]);
    }
    return renderTitleContent(checkboxParams, [
      h$6("span", __assign$e({ class: ["vxe-cell--checkbox", {
        "is--checked": isAllCheckboxSelected,
        "is--disabled": isAllCheckboxDisabled,
        "is--indeterminate": isAllCheckboxIndeterminate
      }], title: GlobalConfig.i18n("vxe.table.allTitle") }, ons), [
        h$6("span", {
          class: ["vxe-checkbox--icon", isAllCheckboxIndeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(titleSlot || headerTitle ? [
        h$6("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ] : []))
    ]);
  },
  renderCheckboxCell: function(params) {
    var $table = params.$table, row2 = params.row, column2 = params.column, isHidden = params.isHidden;
    var props = $table.props, reactData = $table.reactData;
    var treeConfig = props.treeConfig;
    var selection = reactData.selection, treeIndeterminates = reactData.treeIndeterminates;
    var computeCheckboxOpts = $table.getComputeMaps().computeCheckboxOpts;
    var checkboxOpts = computeCheckboxOpts.value;
    var labelField = checkboxOpts.labelField, checkMethod = checkboxOpts.checkMethod, visibleMethod = checkboxOpts.visibleMethod;
    var slots = column2.slots;
    var defaultSlot = slots ? slots.default : null;
    var checkboxSlot = slots ? slots.checkbox : null;
    var indeterminate = false;
    var isChecked = false;
    var isVisible = !visibleMethod || visibleMethod({ row: row2 });
    var isDisabled = !!checkMethod;
    var ons;
    if (!isHidden) {
      isChecked = $table.findRowIndexOf(selection, row2) > -1;
      ons = {
        onClick: function(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row: row2 });
      }
      if (treeConfig) {
        indeterminate = $table.findRowIndexOf(treeIndeterminates, row2) > -1;
      }
    }
    var checkboxParams = __assign$e(__assign$e({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    var checkVNs = [];
    if (isVisible) {
      checkVNs.push(h$6("span", {
        class: ["vxe-checkbox--icon", indeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h$6("span", {
        class: "vxe-checkbox--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : xeUtils.get(row2, labelField)));
    }
    return [
      h$6("span", __assign$e({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminate
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCell: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp: function(params) {
    var $table = params.$table, row2 = params.row, column2 = params.column, isHidden = params.isHidden;
    var props = $table.props, reactData = $table.reactData;
    var treeConfig = props.treeConfig;
    var treeIndeterminates = reactData.treeIndeterminates;
    var computeCheckboxOpts = $table.getComputeMaps().computeCheckboxOpts;
    var checkboxOpts = computeCheckboxOpts.value;
    var labelField = checkboxOpts.labelField, checkField = checkboxOpts.checkField, halfField = checkboxOpts.halfField, checkMethod = checkboxOpts.checkMethod, visibleMethod = checkboxOpts.visibleMethod;
    var slots = column2.slots;
    var defaultSlot = slots ? slots.default : null;
    var checkboxSlot = slots ? slots.checkbox : null;
    var indeterminate = false;
    var isChecked = false;
    var isVisible = !visibleMethod || visibleMethod({ row: row2 });
    var isDisabled = !!checkMethod;
    var ons;
    if (!isHidden) {
      isChecked = xeUtils.get(row2, checkField);
      ons = {
        onClick: function(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row: row2 });
      }
      if (treeConfig) {
        indeterminate = $table.findRowIndexOf(treeIndeterminates, row2) > -1;
      }
    }
    var checkboxParams = __assign$e(__assign$e({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    var checkVNs = [];
    if (isVisible) {
      checkVNs.push(h$6("span", {
        class: ["vxe-checkbox--icon", indeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push(h$6("span", {
          class: "vxe-checkbox--label"
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : xeUtils.get(row2, labelField)));
      }
    }
    return [
      h$6("span", __assign$e({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": halfField && !isChecked ? row2[halfField] : indeterminate
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCellByProp: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  renderExpandCell: function(params) {
    var $table = params.$table, isHidden = params.isHidden, row2 = params.row, column2 = params.column;
    var reactData = $table.reactData;
    var rowExpandeds = reactData.rowExpandeds, expandLazyLoadeds = reactData.expandLazyLoadeds;
    var computeExpandOpts = $table.getComputeMaps().computeExpandOpts;
    var expandOpts = computeExpandOpts.value;
    var lazy = expandOpts.lazy, labelField = expandOpts.labelField, iconLoaded = expandOpts.iconLoaded, showIcon = expandOpts.showIcon, iconOpen = expandOpts.iconOpen, iconClose = expandOpts.iconClose, visibleMethod = expandOpts.visibleMethod;
    var slots = column2.slots;
    var defaultSlot = slots ? slots.default : null;
    var iconSlot = slots ? slots.icon : null;
    var isAceived = false;
    var isLazyLoaded = false;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      isAceived = $table.findRowIndexOf(rowExpandeds, params.row) > -1;
      if (lazy) {
        isLazyLoaded = $table.findRowIndexOf(expandLazyLoadeds, row2) > -1;
      }
    }
    return [
      showIcon && (!visibleMethod || visibleMethod(params)) ? h$6("span", {
        class: ["vxe-table--expanded", {
          "is--active": isAceived
        }],
        onClick: function(evnt) {
          $table.triggerRowExpandEvent(evnt, params);
        }
      }, [
        h$6("i", {
          class: ["vxe-table--expand-btn", isLazyLoaded ? iconLoaded || GlobalConfig.icon.TABLE_EXPAND_LOADED : isAceived ? iconOpen || GlobalConfig.icon.TABLE_EXPAND_OPEN : iconClose || GlobalConfig.icon.TABLE_EXPAND_CLOSE]
        })
      ]) : null,
      defaultSlot || labelField ? h$6("span", {
        class: "vxe-table--expand-label"
      }, defaultSlot ? $table.callSlot(defaultSlot, params) : xeUtils.get(row2, labelField)) : null
    ];
  },
  renderExpandData: function(params) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots, contentRender = column2.contentRender;
    var contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      var compConf = VXETable.renderer.get(contentRender.name);
      if (compConf && compConf.renderExpand) {
        return getSlotVNs(compConf.renderExpand(contentRender, params));
      }
    }
    return [];
  },
  renderHTMLCell: function(params) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots;
    var defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    return [
      h$6("span", {
        class: "vxe-cell--html",
        innerHTML: getDefaultCellLabel(params)
      })
    ];
  },
  renderTreeHTMLCell: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  renderSortAndFilterHeader: function(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params)).concat(Cell.renderFilterIcon(params));
  },
  renderSortHeader: function(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params));
  },
  renderSortIcon: function(params) {
    var $table = params.$table, column2 = params.column;
    var computeSortOpts = $table.getComputeMaps().computeSortOpts;
    var sortOpts = computeSortOpts.value;
    var showIcon = sortOpts.showIcon, iconAsc = sortOpts.iconAsc, iconDesc = sortOpts.iconDesc;
    var order = column2.order;
    return showIcon ? [
      h$6("span", {
        class: "vxe-cell--sort"
      }, [
        h$6("i", {
          class: ["vxe-sort--asc-btn", iconAsc || GlobalConfig.icon.TABLE_SORT_ASC, {
            "sort--active": order === "asc"
          }],
          title: GlobalConfig.i18n("vxe.table.sortAsc"),
          onClick: function(evnt) {
            $table.triggerSortEvent(evnt, column2, "asc");
          }
        }),
        h$6("i", {
          class: ["vxe-sort--desc-btn", iconDesc || GlobalConfig.icon.TABLE_SORT_DESC, {
            "sort--active": order === "desc"
          }],
          title: GlobalConfig.i18n("vxe.table.sortDesc"),
          onClick: function(evnt) {
            $table.triggerSortEvent(evnt, column2, "desc");
          }
        })
      ])
    ] : [];
  },
  renderFilterHeader: function(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderFilterIcon(params));
  },
  renderFilterIcon: function(params) {
    var $table = params.$table, column2 = params.column, hasFilter = params.hasFilter;
    var reactData = $table.reactData;
    var filterStore = reactData.filterStore;
    var computeFilterOpts = $table.getComputeMaps().computeFilterOpts;
    var filterOpts = computeFilterOpts.value;
    var showIcon = filterOpts.showIcon, iconNone = filterOpts.iconNone, iconMatch = filterOpts.iconMatch;
    return showIcon ? [
      h$6("span", {
        class: ["vxe-cell--filter", {
          "is--active": filterStore.visible && filterStore.column === column2
        }]
      }, [
        h$6("i", {
          class: ["vxe-filter--btn", hasFilter ? iconMatch || GlobalConfig.icon.TABLE_FILTER_MATCH : iconNone || GlobalConfig.icon.TABLE_FILTER_NONE],
          title: GlobalConfig.i18n("vxe.table.filter"),
          onClick: function(evnt) {
            $table.triggerFilterEvent(evnt, params.column, params);
          }
        })
      ])
    ] : [];
  },
  renderEditHeader: function(params) {
    var $table = params.$table, column2 = params.column;
    var props = $table.props;
    var computeEditOpts = $table.getComputeMaps().computeEditOpts;
    var editConfig = props.editConfig, editRules = props.editRules;
    var editOpts = computeEditOpts.value;
    var sortable = column2.sortable, filters = column2.filters, editRender = column2.editRender;
    var isRequired = false;
    if (editRules) {
      var columnRules = xeUtils.get(editRules, column2.field);
      if (columnRules) {
        isRequired = columnRules.some(function(rule2) {
          return rule2.required;
        });
      }
    }
    return (isEnableConf(editConfig) ? [
      isRequired && editOpts.showAsterisk ? h$6("i", {
        class: "vxe-cell--required-icon"
      }) : null,
      isEnableConf(editRender) && editOpts.showIcon ? h$6("i", {
        class: ["vxe-cell--edit-icon", editOpts.icon || GlobalConfig.icon.TABLE_EDIT]
      }) : null
    ] : []).concat(Cell.renderDefaultHeader(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []);
  },
  renderRowEdit: function(params) {
    var $table = params.$table, column2 = params.column;
    var reactData = $table.reactData;
    var editStore = reactData.editStore;
    var actived = editStore.actived;
    var editRender = column2.editRender;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  renderCellEdit: function(params) {
    var $table = params.$table, column2 = params.column;
    var reactData = $table.reactData;
    var editStore = reactData.editStore;
    var actived = editStore.actived;
    var editRender = column2.editRender;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit: function(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer: function(params, isEdit) {
    var $table = params.$table, column2 = params.column;
    var slots = column2.slots, editRender = column2.editRender, formatter = column2.formatter;
    var defaultSlot = slots ? slots.default : null;
    var editSlot = slots ? slots.edit : null;
    var compConf = VXETable.renderer.get(editRender.name);
    if (isEdit) {
      if (editSlot) {
        return $table.callSlot(editSlot, params);
      }
      if (compConf && compConf.renderEdit) {
        return getSlotVNs(compConf.renderEdit(editRender, Object.assign({ $type: "edit" }, params)));
      }
      return [];
    }
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (formatter) {
      return [
        h$6("span", {
          class: "vxe-cell--label"
        }, getDefaultCellLabel(params))
      ];
    }
    return Cell.renderDefaultCell(params);
  }
};
var columnProps = {
  colId: [String, Number],
  type: String,
  field: String,
  title: String,
  width: [Number, String],
  minWidth: [Number, String],
  resizable: { type: Boolean, default: null },
  fixed: String,
  align: String,
  headerAlign: String,
  footerAlign: String,
  showOverflow: { type: [Boolean, String], default: null },
  showHeaderOverflow: { type: [Boolean, String], default: null },
  showFooterOverflow: { type: [Boolean, String], default: null },
  className: [String, Function],
  headerClassName: [String, Function],
  footerClassName: [String, Function],
  formatter: [Function, Array, String],
  sortable: Boolean,
  sortBy: [String, Function],
  sortType: String,
  filters: { type: Array, default: null },
  filterMultiple: { type: Boolean, default: true },
  filterMethod: Function,
  filterResetMethod: Function,
  filterRecoverMethod: Function,
  filterRender: Object,
  treeNode: Boolean,
  visible: { type: Boolean, default: null },
  exportMethod: Function,
  footerExportMethod: Function,
  titleHelp: Object,
  titlePrefix: Object,
  cellType: String,
  cellRender: Object,
  editRender: Object,
  contentRender: Object,
  params: Object
};
var VxeTableColumnComponent = defineComponent({
  name: "VxeColumn",
  props: columnProps,
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var refElem = ref$1();
    var $xetable = inject("$xetable", {});
    var colgroup = inject("xecolgroup", null);
    var column2 = Cell.createColumn($xetable, props);
    column2.slots = slots;
    provide("$xegrid", null);
    watchColumn(props, column2);
    onMounted$1(function() {
      assemColumn($xetable, refElem.value, column2, colgroup);
    });
    onUnmounted(function() {
      destroyColumn($xetable, column2);
    });
    var renderVN = function() {
      return h$6("div", {
        ref: refElem
      });
    };
    return renderVN;
  }
});
Object.assign(VxeTableColumnComponent, {
  install: function(app) {
    app.component(VxeTableColumnComponent.name, VxeTableColumnComponent);
    app.component("VxeTableColumn", VxeTableColumnComponent);
  }
});
dynamicApp.component(VxeTableColumnComponent.name, VxeTableColumnComponent);
dynamicApp.component("VxeTableColumn", VxeTableColumnComponent);
var VxeTableColgroupComponent = defineComponent({
  name: "VxeColgroup",
  props: columnProps,
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var refElem = ref$1();
    var $xetable = inject("$xetable", {});
    var colgroup = inject("xecolgroup", null);
    var column2 = Cell.createColumn($xetable, props);
    var columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    var xecolumn = { column: column2 };
    column2.slots = columnSlots;
    column2.children = [];
    provide("xecolgroup", xecolumn);
    provide("$xegrid", null);
    watchColumn(props, column2);
    onMounted$1(function() {
      assemColumn($xetable, refElem.value, column2, colgroup);
    });
    onUnmounted(function() {
      destroyColumn($xetable, column2);
    });
    var renderVN = function() {
      return h$6("div", {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    return renderVN;
  }
});
Object.assign(VxeTableColgroupComponent, {
  install: function(app) {
    app.component(VxeTableColgroupComponent.name, VxeTableColgroupComponent);
    app.component("VxeTableColgroup", VxeTableColgroupComponent);
  }
});
dynamicApp.component(VxeTableColgroupComponent.name, VxeTableColgroupComponent);
dynamicApp.component("VxeTableColgroup", VxeTableColgroupComponent);
var tableProps = {
  id: String,
  data: Array,
  height: [Number, String],
  maxHeight: [Number, String],
  resizable: { type: Boolean, default: function() {
    return GlobalConfig.table.resizable;
  } },
  stripe: { type: Boolean, default: function() {
    return GlobalConfig.table.stripe;
  } },
  border: { type: [Boolean, String], default: function() {
    return GlobalConfig.table.border;
  } },
  round: { type: Boolean, default: function() {
    return GlobalConfig.table.round;
  } },
  size: { type: String, default: function() {
    return GlobalConfig.table.size || GlobalConfig.size;
  } },
  fit: { type: Boolean, default: function() {
    return GlobalConfig.table.fit;
  } },
  loading: Boolean,
  align: { type: String, default: function() {
    return GlobalConfig.table.align;
  } },
  headerAlign: { type: String, default: function() {
    return GlobalConfig.table.headerAlign;
  } },
  footerAlign: { type: String, default: function() {
    return GlobalConfig.table.footerAlign;
  } },
  showHeader: { type: Boolean, default: function() {
    return GlobalConfig.table.showHeader;
  } },
  highlightCurrentRow: { type: Boolean, default: function() {
    return GlobalConfig.table.highlightCurrentRow;
  } },
  highlightHoverRow: { type: Boolean, default: function() {
    return GlobalConfig.table.highlightHoverRow;
  } },
  highlightCurrentColumn: { type: Boolean, default: function() {
    return GlobalConfig.table.highlightCurrentColumn;
  } },
  highlightHoverColumn: { type: Boolean, default: function() {
    return GlobalConfig.table.highlightHoverColumn;
  } },
  highlightCell: Boolean,
  showFooter: Boolean,
  footerMethod: Function,
  rowClassName: [String, Function],
  cellClassName: [String, Function],
  headerRowClassName: [String, Function],
  headerCellClassName: [String, Function],
  footerRowClassName: [String, Function],
  footerCellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerCellStyle: [Object, Function],
  footerCellStyle: [Object, Function],
  rowStyle: [Object, Function],
  headerRowStyle: [Object, Function],
  footerRowStyle: [Object, Function],
  mergeCells: Array,
  mergeFooterItems: Array,
  spanMethod: Function,
  footerSpanMethod: Function,
  showOverflow: { type: [Boolean, String], default: function() {
    return GlobalConfig.table.showOverflow;
  } },
  showHeaderOverflow: { type: [Boolean, String], default: function() {
    return GlobalConfig.table.showHeaderOverflow;
  } },
  showFooterOverflow: { type: [Boolean, String], default: function() {
    return GlobalConfig.table.showFooterOverflow;
  } },
  columnKey: Boolean,
  rowKey: Boolean,
  rowId: { type: String, default: function() {
    return GlobalConfig.table.rowId;
  } },
  zIndex: Number,
  emptyText: { type: String, default: function() {
    return GlobalConfig.table.emptyText;
  } },
  keepSource: { type: Boolean, default: function() {
    return GlobalConfig.table.keepSource;
  } },
  autoResize: { type: Boolean, default: function() {
    return GlobalConfig.table.autoResize;
  } },
  syncResize: [Boolean, String, Number],
  columnConfig: Object,
  rowConfig: Object,
  resizableConfig: Object,
  seqConfig: Object,
  sortConfig: Object,
  filterConfig: Object,
  radioConfig: Object,
  checkboxConfig: Object,
  tooltipConfig: Object,
  exportConfig: Object,
  importConfig: Object,
  printConfig: Object,
  expandConfig: Object,
  treeConfig: Object,
  menuConfig: Object,
  mouseConfig: Object,
  areaConfig: Object,
  keyboardConfig: Object,
  clipConfig: Object,
  fnrConfig: Object,
  editConfig: Object,
  validConfig: Object,
  editRules: Object,
  loadingConfig: Object,
  emptyRender: Object,
  customConfig: Object,
  scrollX: Object,
  scrollY: Object,
  animat: { type: Boolean, default: function() {
    return GlobalConfig.table.animat;
  } },
  delayHover: { type: Number, default: function() {
    return GlobalConfig.table.delayHover;
  } },
  params: Object
};
var tableEmits = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "edit-actived",
  "edit-disabled",
  "valid-error",
  "scroll",
  "custom",
  "change-fnr",
  "open-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];
var __assign$d = globalThis && globalThis.__assign || function() {
  __assign$d = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$d.apply(this, arguments);
};
var __spreadArray$3 = globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var tableComponentPropKeys = Object.keys(tableProps);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getData", "getCheckboxRecords", "getParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "sort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "openTooltip", "focus", "blur", "connect"];
var gridComponentEmits = __spreadArray$3(__spreadArray$3([], tableEmits, true), [
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
], false);
var VxeGridComponent = defineComponent({
  name: "VxeGrid",
  props: __assign$d(__assign$d({}, tableProps), { columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: { type: String, default: function() {
    return GlobalConfig.grid.size || GlobalConfig.size;
  } } }),
  emits: gridComponentEmits,
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var instance2 = getCurrentInstance$1();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      pendingRecords: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: GlobalConfig.pager.pageSize || 10,
        currentPage: 1
      }
    });
    var refElem = ref$1();
    var refTable = ref$1();
    var refForm = ref$1();
    var refToolbar = ref$1();
    var refPager = ref$1();
    var refFormWrapper = ref$1();
    var refToolbarWrapper = ref$1();
    var refTopWrapper = ref$1();
    var refBottomWrapper = ref$1();
    var refPagerWrapper = ref$1();
    var extendTableMethods = function(methodKeys) {
      var funcs = {};
      methodKeys.forEach(function(name2) {
        funcs[name2] = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          var $xetable = refTable.value;
          return $xetable && $xetable[name2].apply($xetable, args);
        };
      });
      return funcs;
    };
    var gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach(function(name2) {
      gridExtendTableMethods[name2] = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var $xetable = refTable.value;
        return $xetable && $xetable[name2].apply($xetable, args);
      };
    });
    var computeProxyOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.grid.proxyConfig, props.proxyConfig);
    });
    var computeIsMsg = computed$1(function() {
      var proxyOpts = computeProxyOpts.value;
      return proxyOpts.message !== false;
    });
    var computePagerOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.grid.pagerConfig, props.pagerConfig);
    });
    var computeFormOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.grid.formConfig, props.formConfig);
    });
    var computeToolbarOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.grid.toolbarConfig, props.toolbarConfig);
    });
    var computeZoomOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.grid.zoomConfig, props.zoomConfig);
    });
    var computeStyles = computed$1(function() {
      return reactData.isZMax ? { zIndex: reactData.tZindex } : null;
    });
    var computeTableExtendProps = computed$1(function() {
      var rest = {};
      var gridProps = props;
      tableComponentPropKeys.forEach(function(key) {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    var refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    var computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    var $xegrid = {
      xID,
      props,
      context,
      instance: instance2,
      reactData,
      getRefMaps: function() {
        return refMaps;
      },
      getComputeMaps: function() {
        return computeMaps;
      }
    };
    var gridMethods = {};
    var handleRowClassName = function(params) {
      var pendingRecords = reactData.pendingRecords;
      var rowClassName = props.rowClassName;
      var clss = [];
      if (pendingRecords.some(function(item) {
        return item === params.row;
      })) {
        clss.push("row--pending");
      }
      clss.push(rowClassName ? xeUtils.isFunction(rowClassName) ? rowClassName(params) : rowClassName : "");
      return clss;
    };
    var handleBeforeEditMethod = function(params) {
      var editConfig = props.editConfig;
      var pendingRecords = reactData.pendingRecords;
      var $xetable = refTable.value;
      var beforeEditMethod = editConfig ? editConfig.beforeEditMethod || editConfig.activeMethod : null;
      if ($xetable.findRowIndexOf(pendingRecords, params.row) === -1) {
        return !beforeEditMethod || beforeEditMethod(__assign$d(__assign$d({}, params), { $grid: $xegrid }));
      }
      return false;
    };
    var computeTableProps = computed$1(function() {
      var seqConfig = props.seqConfig, pagerConfig = props.pagerConfig, loading = props.loading, editConfig = props.editConfig, proxyConfig = props.proxyConfig;
      var isZMax = reactData.isZMax, tableLoading = reactData.tableLoading, tablePage = reactData.tablePage, tableData = reactData.tableData;
      var tableExtendProps = computeTableExtendProps.value;
      var proxyOpts = computeProxyOpts.value;
      var tableProps2 = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps2.maxHeight = "auto";
        } else {
          tableProps2.height = "auto";
        }
      }
      if (proxyConfig) {
        tableProps2.loading = loading || tableLoading;
        tableProps2.data = tableData;
        tableProps2.rowClassName = handleRowClassName;
        if (proxyOpts.seq && isEnableConf(pagerConfig)) {
          tableProps2.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tableProps2.editConfig = Object.assign({}, editConfig, { beforeEditMethod: handleBeforeEditMethod });
      }
      return tableProps2;
    });
    var initToolbar = function() {
      nextTick$1(function() {
        var $xetable = refTable.value;
        var $xetoolbar = refToolbar.value;
        if ($xetable && $xetoolbar) {
          $xetable.connect($xetoolbar);
        }
      });
    };
    var initPages = function() {
      var tablePage = reactData.tablePage;
      var pagerConfig = props.pagerConfig;
      var pagerOpts = computePagerOpts.value;
      var currentPage = pagerOpts.currentPage, pageSize = pagerOpts.pageSize;
      if (pagerConfig) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    var triggerPendingEvent = function(code) {
      var pendingRecords = reactData.pendingRecords;
      var isMsg = computeIsMsg.value;
      var $xetable = refTable.value;
      var selectRecords = $xetable.getCheckboxRecords();
      if (selectRecords.length) {
        var plus_1 = [];
        var minus_1 = [];
        selectRecords.forEach(function(data5) {
          if (pendingRecords.some(function(item) {
            return data5 === item;
          })) {
            minus_1.push(data5);
          } else {
            plus_1.push(data5);
          }
        });
        if (minus_1.length) {
          reactData.pendingRecords = pendingRecords.filter(function(item) {
            return $xetable.findRowIndexOf(minus_1, item) === -1;
          }).concat(plus_1);
        } else if (plus_1.length) {
          reactData.pendingRecords = pendingRecords.concat(plus_1);
        }
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isMsg) {
          VXETable.modal.message({ id: code, content: GlobalConfig.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      }
    };
    var getRespMsg = function(rest, defaultMsg) {
      var proxyOpts = computeProxyOpts.value;
      var _a2 = proxyOpts.props, proxyProps = _a2 === void 0 ? {} : _a2;
      var msg;
      if (rest && proxyProps.message) {
        msg = xeUtils.get(rest, proxyProps.message);
      }
      return msg || GlobalConfig.i18n(defaultMsg);
    };
    var handleDeleteRow = function(code, alertKey, callback) {
      var isMsg = computeIsMsg.value;
      var selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isMsg) {
        if (selectRecords.length) {
          return VXETable.modal.confirm({ id: "cfm_".concat(code), content: GlobalConfig.i18n(alertKey), escClosable: true }).then(function(type2) {
            if (type2 === "confirm") {
              callback();
            }
          });
        } else {
          VXETable.modal.message({ id: "msg_".concat(code), content: GlobalConfig.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    var pageChangeEvent = function(params) {
      var proxyConfig = props.proxyConfig;
      var tablePage = reactData.tablePage;
      var currentPage = params.currentPage, pageSize = params.pageSize;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent("page-change", params);
      if (proxyConfig) {
        gridMethods.commitProxy("query");
      }
    };
    var sortChangeEvent = function(params) {
      var $xetable = refTable.value;
      var proxyConfig = props.proxyConfig;
      var computeSortOpts = $xetable.getComputeMaps().computeSortOpts;
      var sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query");
        }
      }
      gridMethods.dispatchEvent("sort-change", params);
    };
    var filterChangeEvent = function(params) {
      var $xetable = refTable.value;
      var proxyConfig = props.proxyConfig;
      var computeFilterOpts = $xetable.getComputeMaps().computeFilterOpts;
      var filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query");
        }
      }
      gridMethods.dispatchEvent("filter-change", params);
    };
    var submitFormEvent = function(params) {
      var proxyConfig = props.proxyConfig;
      if (proxyConfig) {
        gridMethods.commitProxy("reload");
      }
      gridMethods.dispatchEvent("form-submit", params);
    };
    var resetFormEvent = function(params) {
      var proxyConfig = props.proxyConfig;
      if (proxyConfig) {
        gridMethods.commitProxy("reload");
      }
      gridMethods.dispatchEvent("form-reset", params);
    };
    var submitInvalidEvent = function(params) {
      gridMethods.dispatchEvent("form-submit-invalid", params);
    };
    var collapseEvent = function(params) {
      nextTick$1(function() {
        return gridExtendTableMethods.recalculate(true);
      });
      gridMethods.dispatchEvent("form-toggle-collapse", params);
      gridMethods.dispatchEvent("form-collapse", params);
    };
    var handleZoom = function(isMax) {
      var isZMax = reactData.isZMax;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick$1().then(function() {
        return gridExtendTableMethods.recalculate(true);
      }).then(function() {
        return reactData.isZMax;
      });
    };
    var getFuncSlot = function(optSlots, slotKey) {
      var funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (xeUtils.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    var renderForms = function() {
      var formConfig = props.formConfig, proxyConfig = props.proxyConfig;
      var formData3 = reactData.formData;
      var proxyOpts = computeProxyOpts.value;
      var formOpts = computeFormOpts.value;
      var restVNs = [];
      if (isEnableConf(formConfig) || slots.form) {
        var slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xegrid });
        } else {
          if (formOpts.items) {
            var formSlots_1 = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              var beforeItem_1 = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem_1) {
                formOpts.items.forEach(function(item) {
                  beforeItem_1({ $grid: $xegrid, item });
                });
              }
            }
            formOpts.items.forEach(function(item) {
              xeUtils.each(item.slots, function(func) {
                if (!xeUtils.isFunction(func)) {
                  if (slots[func]) {
                    formSlots_1[func] = slots[func];
                  }
                }
              });
            });
            slotVNs.push(h$6(resolveComponent("vxe-form"), __assign$d(__assign$d({ ref: refForm }, Object.assign({}, formOpts, {
              data: proxyConfig && proxyOpts.form ? formData3 : formOpts.data
            })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots_1));
          }
        }
        restVNs.push(h$6("div", {
          ref: refFormWrapper,
          class: "vxe-grid--form-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    var renderToolbars = function() {
      var toolbarConfig = props.toolbarConfig;
      var toolbarOpts = computeToolbarOpts.value;
      var restVNs = [];
      if (isEnableConf(toolbarConfig) || slots.toolbar) {
        var slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xegrid });
        } else {
          var toolbarOptSlots = toolbarOpts.slots;
          var buttonsSlot = void 0;
          var toolsSlot = void 0;
          var toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h$6(resolveComponent("vxe-toolbar"), __assign$d({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        restVNs.push(h$6("div", {
          ref: refToolbarWrapper,
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    var renderTops = function() {
      if (slots.top) {
        return [
          h$6("div", {
            ref: refTopWrapper,
            class: "vxe-grid--top-wrapper"
          }, slots.top({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    var tableCompEvents = {};
    tableEmits.forEach(function(name2) {
      var type2 = xeUtils.camelCase("on-".concat(name2));
      tableCompEvents[type2] = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        return emit.apply(void 0, __spreadArray$3([name2], args, false));
      };
    });
    var renderTables = function() {
      var proxyConfig = props.proxyConfig;
      var tableProps2 = computeTableProps.value;
      var proxyOpts = computeProxyOpts.value;
      var tableOns = Object.assign({}, tableCompEvents);
      var emptySlot = slots.empty;
      if (proxyConfig) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      return [
        h$6(resolveComponent("vxe-table"), __assign$d(__assign$d({ ref: refTable }, tableProps2), tableOns), emptySlot ? {
          empty: function() {
            return emptySlot({});
          }
        } : {})
      ];
    };
    var renderBottoms = function() {
      if (slots.bottom) {
        return [
          h$6("div", {
            ref: refBottomWrapper,
            class: "vxe-grid--bottom-wrapper"
          }, slots.bottom({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    var renderPagers = function() {
      var pagerConfig = props.pagerConfig;
      var pagerOpts = computePagerOpts.value;
      var restVNs = [];
      if (isEnableConf(pagerConfig) || slots.pager) {
        var slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({ $grid: $xegrid });
        } else {
          var pagerOptSlots = pagerOpts.slots;
          var pagerSlots = {};
          var leftSlot = void 0;
          var rightSlot = void 0;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, "left");
            rightSlot = getFuncSlot(pagerOptSlots, "right");
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          slotVNs.push(h$6(resolveComponent("vxe-pager"), __assign$d(__assign$d(__assign$d({ ref: refPager }, pagerOpts), props.proxyConfig ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), pagerSlots));
        }
        restVNs.push(h$6("div", {
          ref: refPagerWrapper,
          class: "vxe-grid--pager-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    var initProxy = function() {
      var proxyConfig = props.proxyConfig, formConfig = props.formConfig;
      var proxyInited = reactData.proxyInited;
      var proxyOpts = computeProxyOpts.value;
      var formOpts = computeFormOpts.value;
      if (proxyConfig) {
        if (isEnableConf(formConfig) && proxyOpts.form && formOpts.items) {
          var formData_1 = {};
          formOpts.items.forEach(function(item) {
            var field = item.field, itemRender = item.itemRender;
            if (field) {
              var itemValue = null;
              if (itemRender) {
                var defaultValue = itemRender.defaultValue;
                if (xeUtils.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!xeUtils.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              formData_1[field] = itemValue;
            }
          });
          reactData.formData = formData_1;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick$1(function() {
              return gridMethods.commitProxy("_init");
            });
          }
        }
      }
    };
    gridMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $grid: $xegrid, $event: evnt }, params));
      },
      commitProxy: function(proxyTarget) {
        var args = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          args[_i2 - 1] = arguments[_i2];
        }
        var toolbarConfig = props.toolbarConfig, pagerConfig = props.pagerConfig, editRules = props.editRules;
        var tablePage = reactData.tablePage, formData3 = reactData.formData;
        var isMsg = computeIsMsg.value;
        var proxyOpts = computeProxyOpts.value;
        var toolbarOpts = computeToolbarOpts.value;
        var beforeQuery = proxyOpts.beforeQuery, afterQuery = proxyOpts.afterQuery, beforeDelete = proxyOpts.beforeDelete, afterDelete = proxyOpts.afterDelete, beforeSave = proxyOpts.beforeSave, afterSave = proxyOpts.afterSave, _a2 = proxyOpts.ajax, ajax = _a2 === void 0 ? {} : _a2, _b2 = proxyOpts.props, proxyProps = _b2 === void 0 ? {} : _b2;
        var $xetable = refTable.value;
        var button = null;
        var code = null;
        if (xeUtils.isString(proxyTarget)) {
          var buttons = toolbarOpts.buttons;
          var matchObj = toolbarConfig && buttons ? xeUtils.findTree(buttons, function(item) {
            return item.code === proxyTarget;
          }, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        var btnParams = button ? button.params : null;
        switch (code) {
          case "insert":
            $xetable.insert({});
            break;
          case "insert_actived":
            $xetable.insert({}).then(function(_a3) {
              var row2 = _a3.row;
              return $xetable.setActiveRow(row2);
            });
            break;
          case "mark_cancel":
            triggerPendingEvent(code);
            break;
          case "remove":
            return handleDeleteRow(code, "vxe.grid.removeSelectRecord", function() {
              return $xetable.removeCheckboxRow();
            });
          case "import":
            $xetable.importData(btnParams);
            break;
          case "open_import":
            $xetable.openImport(btnParams);
            break;
          case "export":
            $xetable.exportData(btnParams);
            break;
          case "open_export":
            $xetable.openExport(btnParams);
            break;
          case "reset_custom":
            $xetable.resetColumn(true);
            break;
          case "_init":
          case "reload":
          case "query": {
            var ajaxMethods = ajax.query;
            if (ajaxMethods) {
              var isInited = code === "_init";
              var isReload = code === "reload";
              var sortList = [];
              var filterList = [];
              var pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerConfig)) {
                  pageParams = __assign$d({}, tablePage);
                }
              }
              if (isInited) {
                var computeSortOpts = $xetable.getComputeMaps().computeSortOpts;
                var sortOpts = computeSortOpts.value;
                var defaultSort = sortOpts.defaultSort;
                if (defaultSort) {
                  if (!xeUtils.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map(function(item) {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                filterList = $xetable.getCheckedFilters();
              } else {
                if (isReload) {
                  reactData.pendingRecords = [];
                  $xetable.clearAll();
                } else {
                  sortList = $xetable.getSortColumns();
                  filterList = $xetable.getCheckedFilters();
                }
              }
              var params = {
                code,
                button,
                $grid: $xegrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData3,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              var applyArgs_1 = [params].concat(args);
              return Promise.resolve((beforeQuery || ajaxMethods).apply(void 0, applyArgs_1)).catch(function(e3) {
                return e3;
              }).then(function(rest) {
                reactData.tableLoading = false;
                if (rest) {
                  if (isEnableConf(pagerConfig)) {
                    var total = xeUtils.get(rest, proxyProps.total || "page.total") || 0;
                    tablePage.total = xeUtils.toNumber(total);
                    reactData.tableData = xeUtils.get(rest, proxyProps.result || "result") || [];
                    var pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    reactData.tableData = (proxyProps.list ? xeUtils.get(rest, proxyProps.list) : rest) || [];
                  }
                } else {
                  reactData.tableData = [];
                }
                if (afterQuery) {
                  afterQuery.apply(void 0, applyArgs_1);
                }
              });
            }
            break;
          }
          case "delete": {
            var ajaxMethods_1 = ajax.delete;
            if (ajaxMethods_1) {
              var selectRecords_1 = gridExtendTableMethods.getCheckboxRecords();
              var removeRecords_1 = selectRecords_1.filter(function(row2) {
                return !$xetable.isInsertByRow(row2);
              });
              var body = { removeRecords: removeRecords_1 };
              var applyArgs_2 = [{ $grid: $xegrid, code, button, body, options: ajaxMethods_1 }].concat(args);
              if (selectRecords_1.length) {
                return handleDeleteRow(code, "vxe.grid.deleteSelectRecord", function() {
                  if (!removeRecords_1.length) {
                    return $xetable.remove(selectRecords_1);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods_1).apply(void 0, applyArgs_2)).then(function(rest) {
                    reactData.tableLoading = false;
                    reactData.pendingRecords = reactData.pendingRecords.filter(function(row2) {
                      return $xetable.findRowIndexOf(removeRecords_1, row2) === -1;
                    });
                    if (isMsg) {
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                    }
                    if (afterDelete) {
                      afterDelete.apply(void 0, applyArgs_2);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                  }).catch(function(rest) {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                  });
                });
              } else {
                if (isMsg) {
                  VXETable.modal.message({ id: code, content: GlobalConfig.i18n("vxe.grid.selectOneRecord"), status: "warning" });
                }
              }
            }
            break;
          }
          case "save": {
            var ajaxMethods_2 = ajax.save;
            if (ajaxMethods_2) {
              var body_1 = Object.assign({ pendingRecords: reactData.pendingRecords }, $xetable.getRecordset());
              var insertRecords_1 = body_1.insertRecords, removeRecords_2 = body_1.removeRecords, updateRecords_1 = body_1.updateRecords, pendingRecords_1 = body_1.pendingRecords;
              var applyArgs_3 = [{ $grid: $xegrid, code, button, body: body_1, options: ajaxMethods_2 }].concat(args);
              if (insertRecords_1.length) {
                body_1.pendingRecords = pendingRecords_1.filter(function(row2) {
                  return $xetable.findRowIndexOf(insertRecords_1, row2) === -1;
                });
              }
              if (pendingRecords_1.length) {
                body_1.insertRecords = insertRecords_1.filter(function(row2) {
                  return $xetable.findRowIndexOf(pendingRecords_1, row2) === -1;
                });
              }
              var restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xetable.validate(body_1.insertRecords.concat(updateRecords_1));
              }
              return restPromise.then(function(errMap) {
                if (errMap) {
                  return;
                }
                if (body_1.insertRecords.length || removeRecords_2.length || updateRecords_1.length || body_1.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods_2).apply(void 0, applyArgs_3)).then(function(rest) {
                    reactData.tableLoading = false;
                    reactData.pendingRecords = [];
                    if (isMsg) {
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                    }
                    if (afterSave) {
                      afterSave.apply(void 0, applyArgs_3);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                  }).catch(function(rest) {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                  });
                } else {
                  if (isMsg) {
                    VXETable.modal.message({ id: code, content: GlobalConfig.i18n("vxe.grid.dataUnchanged"), status: "info" });
                  }
                }
              });
            }
            break;
          }
          default: {
            var btnMethod = VXETable.commands.get(code);
            if (btnMethod) {
              btnMethod.apply(void 0, __spreadArray$3([{ code, button, $grid: $xegrid, $table: $xetable }], args, false));
            }
          }
        }
        return nextTick$1();
      },
      zoom: function() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized: function() {
        return reactData.isZMax;
      },
      maximize: function() {
        return handleZoom(true);
      },
      revert: function() {
        return handleZoom();
      },
      getFormItems: function(itemIndex) {
        var formOpts = computeFormOpts.value;
        var formConfig = props.formConfig;
        var items = formOpts.items;
        var itemList = [];
        xeUtils.eachTree(isEnableConf(formConfig) && items ? items : [], function(item) {
          itemList.push(item);
        }, { children: "children" });
        return xeUtils.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getPendingRecords: function() {
        return reactData.pendingRecords;
      },
      getProxyInfo: function() {
        if (props.proxyConfig) {
          var sortData = reactData.sortData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: reactData.formData,
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: reactData.pendingRecords
          };
        }
        return null;
      }
    };
    var gridPrivateMethods = {
      extendTableMethods,
      callSlot: function(slotFunc, params) {
        if (slotFunc) {
          if (xeUtils.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (xeUtils.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      getExcludeHeight: function() {
        var height2 = props.height;
        var isZMax = reactData.isZMax;
        var el2 = refElem.value;
        var formWrapper = refFormWrapper.value;
        var toolbarWrapper = refToolbarWrapper.value;
        var topWrapper = refTopWrapper.value;
        var bottomWrapper = refBottomWrapper.value;
        var pagerWrapper = refPagerWrapper.value;
        var parentPaddingSize = isZMax || height2 !== "auto" ? 0 : getPaddingTopBottomSize(el2.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el2) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight: function() {
        var el2 = refElem.value;
        if (el2) {
          return (reactData.isZMax ? getDomNode().visibleHeight : xeUtils.toNumber(getComputedStyle(el2.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarBtnEvent: function(button, evnt) {
        gridMethods.commitProxy(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent: function(tool, evnt) {
        gridMethods.commitProxy(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool, $event: evnt });
      },
      triggerZoomEvent: function(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xegrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    watch$1(function() {
      return props.columns;
    }, function(value) {
      nextTick$1(function() {
        return $xegrid.loadColumn(value || []);
      });
    });
    watch$1(function() {
      return props.toolbarConfig;
    }, function(value) {
      if (value) {
        initToolbar();
      }
    });
    watch$1(function() {
      return props.pagerConfig;
    }, function() {
      initPages();
    });
    watch$1(function() {
      return props.proxyConfig;
    }, function() {
      initProxy();
    });
    var handleGlobalKeydownEvent = function(evnt) {
      var zoomOpts = computeZoomOpts.value;
      var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    VXETable.hooks.forEach(function(options) {
      var setupGrid = options.setupGrid;
      if (setupGrid) {
        var hookRest = setupGrid($xegrid);
        if (hookRest && xeUtils.isObject(hookRest)) {
          Object.assign($xegrid, hookRest);
        }
      }
    });
    initPages();
    onMounted$1(function() {
      nextTick$1(function() {
        var data5 = props.data, columns = props.columns, proxyConfig = props.proxyConfig;
        var proxyOpts = computeProxyOpts.value;
        var formOpts = computeFormOpts.value;
        if (proxyConfig && (data5 || proxyOpts.form && formOpts.data)) {
          errLog("vxe.error.errConflicts", ["grid.data", "grid.proxy-config"]);
        }
        if (columns && columns.length) {
          $xegrid.loadColumn(columns);
        }
        initToolbar();
      });
      GlobalEvent.on($xegrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(function() {
      GlobalEvent.off($xegrid, "keydown");
    });
    nextTick$1(function() {
      initProxy();
    });
    var renderVN = function() {
      var _a2;
      var vSize = computeSize.value;
      var styles = computeStyles.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-grid", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--animat"] = !!props.animat, _a2["is--round"] = props.round, _a2["is--maximize"] = reactData.isZMax, _a2["is--loading"] = props.loading || reactData.tableLoading, _a2)],
        style: styles
      }, renderForms().concat(renderToolbars(), renderTops(), renderTables(), renderBottoms(), renderPagers()));
    };
    $xegrid.renderVN = renderVN;
    provide("$xegrid", $xegrid);
    return $xegrid;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeGridComponent, {
  install: function(app) {
    app.component(VxeGridComponent.name, VxeGridComponent);
  }
});
dynamicApp.component(VxeGridComponent.name, VxeGridComponent);
var __assign$c = globalThis && globalThis.__assign || function() {
  __assign$c = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$c.apply(this, arguments);
};
var VxeToolbarComponent = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: { type: Array, default: function() {
      return GlobalConfig.toolbar.buttons;
    } },
    tools: { type: Array, default: function() {
      return GlobalConfig.toolbar.tools;
    } },
    perfect: { type: Boolean, default: function() {
      return GlobalConfig.toolbar.perfect;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.toolbar.size || GlobalConfig.size;
    } },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      isRefresh: false,
      columns: []
    });
    var refElem = ref$1();
    var refCustomWrapper = ref$1();
    var customStore = reactive$1({
      isAll: false,
      isIndeterminate: false,
      activeBtn: false,
      activeWrapper: false,
      visible: false
    });
    var refMaps = {
      refElem
    };
    var $xetoolbar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var toolbarMethods = {};
    var $xegrid = inject("$xegrid", null);
    var $xetable;
    var computeRefreshOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.refresh, props.refresh);
    });
    var computeImportOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.import, props.import);
    });
    var computeExportOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.export, props.export);
    });
    var computePrintOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.print, props.print);
    });
    var computeZoomOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.zoom, props.zoom);
    });
    var computeCustomOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.toolbar.custom, props.custom);
    });
    var checkTable = function() {
      if ($xetable) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    var checkCustomStatus = function() {
      var columns = reactData.columns;
      var computeTableCustomOpts = $xetable.getComputeMaps().computeCustomOpts;
      var tableCustomOpts = computeTableCustomOpts.value;
      var checkMethod = tableCustomOpts.checkMethod;
      customStore.isAll = columns.every(function(column2) {
        return (checkMethod ? !checkMethod({ column: column2 }) : false) || column2.visible;
      });
      customStore.isIndeterminate = !customStore.isAll && columns.some(function(column2) {
        return (!checkMethod || checkMethod({ column: column2 })) && (column2.visible || column2.halfVisible);
      });
    };
    var showCustom = function() {
      customStore.visible = true;
      checkCustomStatus();
    };
    var handleTableCustom = function() {
      $xetable.handleCustom();
    };
    var closeCustom = function() {
      var custom = props.custom;
      var customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (custom && !customOpts.immediate) {
          handleTableCustom();
        }
      }
    };
    var emitCustomEvent = function(type2, evnt) {
      var comp = $xegrid || $xetable;
      comp.dispatchEvent("custom", { type: type2 }, evnt);
    };
    var confirmCustomEvent = function(evnt) {
      closeCustom();
      emitCustomEvent("confirm", evnt);
    };
    var customOpenEvent = function(evnt) {
      if (checkTable()) {
        if (!customStore.visible) {
          showCustom();
          emitCustomEvent("open", evnt);
        }
      }
    };
    var customColseEvent = function(evnt) {
      if (customStore.visible) {
        closeCustom();
        emitCustomEvent("close", evnt);
      }
    };
    var resetCustomEvent = function(evnt) {
      var columns = reactData.columns;
      var computeTableCustomOpts = $xetable.getComputeMaps().computeCustomOpts;
      var tableCustomOpts = computeTableCustomOpts.value;
      var checkMethod = tableCustomOpts.checkMethod;
      xeUtils.eachTree(columns, function(column2) {
        if (!checkMethod || checkMethod({ column: column2 })) {
          column2.visible = column2.defaultVisible;
          column2.halfVisible = false;
        }
        column2.resizeWidth = 0;
      });
      $xetable.saveCustomResizable(true);
      closeCustom();
      emitCustomEvent("reset", evnt);
    };
    var handleOptionCheck = function(column2) {
      var columns = reactData.columns;
      var matchObj = xeUtils.findTree(columns, function(item) {
        return item === column2;
      });
      if (matchObj && matchObj.parent) {
        var parent_1 = matchObj.parent;
        if (parent_1.children && parent_1.children.length) {
          parent_1.visible = parent_1.children.every(function(column3) {
            return column3.visible;
          });
          parent_1.halfVisible = !parent_1.visible && parent_1.children.some(function(column3) {
            return column3.visible || column3.halfVisible;
          });
          handleOptionCheck(parent_1);
        }
      }
    };
    var changeCustomOption = function(column2) {
      var isChecked = !column2.visible;
      var customOpts = computeCustomOpts.value;
      xeUtils.eachTree([column2], function(item) {
        item.visible = isChecked;
        item.halfVisible = false;
      });
      handleOptionCheck(column2);
      if (props.custom && customOpts.immediate) {
        handleTableCustom();
      }
      checkCustomStatus();
    };
    var allCustomEvent = function() {
      var columns = reactData.columns;
      var computeTableCustomOpts = $xetable.getComputeMaps().computeCustomOpts;
      var tableCustomOpts = computeTableCustomOpts.value;
      var checkMethod = tableCustomOpts.checkMethod;
      var isAll = !customStore.isAll;
      xeUtils.eachTree(columns, function(column2) {
        if (!checkMethod || checkMethod({ column: column2 })) {
          column2.visible = isAll;
          column2.halfVisible = false;
        }
      });
      customStore.isAll = isAll;
      checkCustomStatus();
    };
    var handleGlobalMousedownEvent = function(evnt) {
      var customWrapperElem = refCustomWrapper.value;
      if (!getEventTargetNode(evnt, customWrapperElem).flag) {
        customColseEvent(evnt);
      }
    };
    var handleGlobalBlurEvent = function(evnt) {
      customColseEvent(evnt);
    };
    var handleClickSettingEvent = function(evnt) {
      if (customStore.visible) {
        customColseEvent(evnt);
      } else {
        customOpenEvent(evnt);
      }
    };
    var handleMouseenterSettingEvent = function(evnt) {
      customStore.activeBtn = true;
      customOpenEvent(evnt);
    };
    var handleMouseleaveSettingEvent = function(evnt) {
      customStore.activeBtn = false;
      setTimeout(function() {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          customColseEvent(evnt);
        }
      }, 300);
    };
    var handleWrapperMouseenterEvent = function(evnt) {
      customStore.activeWrapper = true;
      customOpenEvent(evnt);
    };
    var handleWrapperMouseleaveEvent = function(evnt) {
      customStore.activeWrapper = false;
      setTimeout(function() {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          customColseEvent(evnt);
        }
      }, 300);
    };
    var refreshEvent = function() {
      var isRefresh = reactData.isRefresh;
      var refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        var queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch(function(e3) {
              return e3;
            }).then(function() {
              reactData.isRefresh = false;
            });
          } catch (e3) {
            reactData.isRefresh = false;
          }
        } else if ($xegrid) {
          reactData.isRefresh = true;
          $xegrid.commitProxy(refreshOpts.code || "reload").catch(function(e3) {
            return e3;
          }).then(function() {
            reactData.isRefresh = false;
          });
        }
      }
    };
    var zoomEvent = function(evnt) {
      if ($xegrid) {
        $xegrid.triggerZoomEvent(evnt);
      }
    };
    var btnEvent = function(evnt, item) {
      var code = item.code;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          var commandMethod = VXETable.commands.get(code);
          var params = { code, button: item, $table: $xetable, $event: evnt };
          if (commandMethod) {
            commandMethod(params, evnt);
          }
          $xetoolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    var tolEvent = function(evnt, item) {
      var code = item.code;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarTolEvent(item, evnt);
        } else {
          var commandMethod = VXETable.commands.get(code);
          var params = { code, tool: item, $table: $xetable, $event: evnt };
          if (commandMethod) {
            commandMethod(params, evnt);
          }
          $xetoolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    var importEvent = function() {
      if (checkTable()) {
        $xetable.openImport();
      }
    };
    var exportEvent = function() {
      if (checkTable()) {
        $xetable.openExport();
      }
    };
    var printEvent = function() {
      if (checkTable()) {
        $xetable.openPrint();
      }
    };
    var renderDropdowns = function(item, isBtn) {
      var dropdowns = item.dropdowns;
      var downVNs = [];
      if (dropdowns) {
        return dropdowns.map(function(child, index) {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return h$6(resolveComponent("vxe-button"), {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            onClick: function(evnt) {
              return isBtn ? btnEvent(evnt, child) : tolEvent(evnt, child);
            }
          });
        });
      }
      return downVNs;
    };
    var renderBtns = function() {
      var buttons = props.buttons;
      var buttonsSlot = slots.buttons;
      if (buttonsSlot) {
        return getSlotVNs(buttonsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      var btnVNs = [];
      if (buttons) {
        buttons.forEach(function(item) {
          var dropdowns = item.dropdowns, buttonRender = item.buttonRender;
          if (item.visible !== false) {
            var compConf = buttonRender ? VXETable.renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              btnVNs.push(h$6("span", {
                class: "vxe-button--item"
              }, compConf.renderToolbarButton(buttonRender, { $grid: $xegrid, $table: $xetable, button: item })));
            } else {
              btnVNs.push(h$6(resolveComponent("vxe-button"), {
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: function(evnt) {
                  return btnEvent(evnt, item);
                }
              }, dropdowns && dropdowns.length ? {
                dropdowns: function() {
                  return renderDropdowns(item, true);
                }
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    var renderRightTools = function() {
      var tools = props.tools;
      var toolsSlot = slots.tools;
      if (toolsSlot) {
        return getSlotVNs(toolsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      var btnVNs = [];
      if (tools) {
        tools.forEach(function(item) {
          var dropdowns = item.dropdowns, toolRender = item.toolRender;
          if (item.visible !== false) {
            var compConf = toolRender ? VXETable.renderer.get(toolRender.name) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              btnVNs.push(h$6("span", {
                class: "vxe-tool--item"
              }, compConf.renderToolbarTool(toolRender, { $grid: $xegrid, $table: $xetable, tool: item })));
            } else {
              btnVNs.push(h$6(resolveComponent("vxe-button"), {
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: function(evnt) {
                  return tolEvent(evnt, item);
                }
              }, dropdowns && dropdowns.length ? {
                dropdowns: function() {
                  return renderDropdowns(item, false);
                }
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    var renderCustoms = function() {
      var columns = reactData.columns;
      var customOpts = computeCustomOpts.value;
      var colVNs = [];
      var customBtnOns = {};
      var customWrapperOns = {};
      var checkMethod;
      if ($xetable) {
        var computeTableCustomOpts = $xetable.getComputeMaps().computeCustomOpts;
        var tableCustomOpts = computeTableCustomOpts.value;
        checkMethod = tableCustomOpts.checkMethod;
      }
      if (customOpts.trigger === "manual")
        ;
      else if (customOpts.trigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      xeUtils.eachTree(columns, function(column2) {
        var colTitle = formatText(column2.getTitle(), 1);
        var colKey = column2.getKey();
        var isColGroup = column2.children && column2.children.length;
        var isDisabled = checkMethod ? !checkMethod({ column: column2 }) : false;
        if (isColGroup || colKey) {
          var isChecked = column2.visible;
          var isIndeterminate = column2.halfVisible;
          colVNs.push(h$6("li", {
            class: ["vxe-custom--option", "level--".concat(column2.level), {
              "is--group": isColGroup,
              "is--checked": isChecked,
              "is--indeterminate": isIndeterminate,
              "is--disabled": isDisabled
            }],
            title: colTitle,
            onClick: function() {
              if (!isDisabled) {
                changeCustomOption(column2);
              }
            }
          }, [
            h$6("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
            }),
            h$6("span", {
              class: "vxe-checkbox--label"
            }, colTitle)
          ]));
        }
      });
      var isAllChecked = customStore.isAll;
      var isAllIndeterminate = customStore.isIndeterminate;
      return h$6("div", {
        class: ["vxe-custom--wrapper", {
          "is--active": customStore.visible
        }],
        ref: refCustomWrapper
      }, [
        h$6(resolveComponent("vxe-button"), __assign$c({ circle: true, icon: customOpts.icon || GlobalConfig.icon.TOOLBAR_TOOLS_CUSTOM, title: GlobalConfig.i18n("vxe.toolbar.custom") }, customBtnOns)),
        h$6("div", {
          class: "vxe-custom--option-wrapper"
        }, [
          h$6("ul", {
            class: "vxe-custom--header"
          }, [
            h$6("li", {
              class: ["vxe-custom--option", {
                "is--checked": isAllChecked,
                "is--indeterminate": isAllIndeterminate
              }],
              title: GlobalConfig.i18n("vxe.table.allTitle"),
              onClick: allCustomEvent
            }, [
              h$6("span", {
                class: ["vxe-checkbox--icon", isAllIndeterminate ? GlobalConfig.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? GlobalConfig.icon.TABLE_CHECKBOX_CHECKED : GlobalConfig.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              h$6("span", {
                class: "vxe-checkbox--label"
              }, GlobalConfig.i18n("vxe.toolbar.customAll"))
            ])
          ]),
          h$6("ul", __assign$c({ class: "vxe-custom--body" }, customWrapperOns), colVNs),
          customOpts.isFooter === false ? null : h$6("div", {
            class: "vxe-custom--footer"
          }, [
            h$6("button", {
              class: "btn--confirm",
              onClick: confirmCustomEvent
            }, GlobalConfig.i18n("vxe.toolbar.customConfirm")),
            h$6("button", {
              class: "btn--reset",
              onClick: resetCustomEvent
            }, GlobalConfig.i18n("vxe.toolbar.customRestore"))
          ])
        ])
      ]);
    };
    toolbarMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $toolbar: $xetoolbar, $event: evnt }, params));
      },
      syncUpdate: function(params) {
        var collectColumn = params.collectColumn;
        $xetable = params.$table;
        reactData.columns = collectColumn;
      }
    };
    Object.assign($xetoolbar, toolbarMethods);
    onMounted$1(function() {
      GlobalEvent.on($xetoolbar, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xetoolbar, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(function() {
      GlobalEvent.off($xetoolbar, "mousedown");
      GlobalEvent.off($xetoolbar, "blur");
    });
    nextTick$1(function() {
      var refresh = props.refresh;
      var refreshOpts = computeRefreshOpts.value;
      var queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xegrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
    });
    var renderVN = function() {
      var _a2;
      var perfect = props.perfect, loading = props.loading, refresh = props.refresh, zoom = props.zoom, custom = props.custom, className = props.className;
      var vSize = computeSize.value;
      var refreshOpts = computeRefreshOpts.value;
      var importOpts = computeImportOpts.value;
      var exportOpts = computeExportOpts.value;
      var printOpts = computePrintOpts.value;
      var zoomOpts = computeZoomOpts.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? xeUtils.isFunction(className) ? className({ $toolbar: $xetoolbar }) : className : "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--perfect"] = perfect, _a2["is--loading"] = loading, _a2)]
      }, [
        h$6("div", {
          class: "vxe-buttons--wrapper"
        }, renderBtns()),
        h$6("div", {
          class: "vxe-tools--wrapper"
        }, renderRightTools()),
        h$6("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? h$6(resolveComponent("vxe-button"), {
            circle: true,
            icon: importOpts.icon || GlobalConfig.icon.TOOLBAR_TOOLS_IMPORT,
            title: GlobalConfig.i18n("vxe.toolbar.import"),
            onClick: importEvent
          }) : createCommentVNode(),
          props.export ? h$6(resolveComponent("vxe-button"), {
            circle: true,
            icon: exportOpts.icon || GlobalConfig.icon.TOOLBAR_TOOLS_EXPORT,
            title: GlobalConfig.i18n("vxe.toolbar.export"),
            onClick: exportEvent
          }) : createCommentVNode(),
          props.print ? h$6(resolveComponent("vxe-button"), {
            circle: true,
            icon: printOpts.icon || GlobalConfig.icon.TOOLBAR_TOOLS_PRINT,
            title: GlobalConfig.i18n("vxe.toolbar.print"),
            onClick: printEvent
          }) : createCommentVNode(),
          refresh ? h$6(resolveComponent("vxe-button"), {
            circle: true,
            icon: reactData.isRefresh ? refreshOpts.iconLoading || GlobalConfig.icon.TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || GlobalConfig.icon.TOOLBAR_TOOLS_REFRESH,
            title: GlobalConfig.i18n("vxe.toolbar.refresh"),
            onClick: refreshEvent
          }) : createCommentVNode(),
          zoom && $xegrid ? h$6(resolveComponent("vxe-button"), {
            circle: true,
            icon: $xegrid.isMaximized() ? zoomOpts.iconOut || GlobalConfig.icon.TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || GlobalConfig.icon.TOOLBAR_TOOLS_FULLSCREEN,
            title: GlobalConfig.i18n("vxe.toolbar.zoom".concat($xegrid.isMaximized() ? "Out" : "In")),
            onClick: zoomEvent
          }) : createCommentVNode(),
          custom ? renderCustoms() : createCommentVNode()
        ])
      ]);
    };
    $xetoolbar.renderVN = renderVN;
    return $xetoolbar;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeToolbarComponent, {
  install: function(app) {
    app.component(VxeToolbarComponent.name, VxeToolbarComponent);
  }
});
dynamicApp.component(VxeToolbarComponent.name, VxeToolbarComponent);
var __assign$b = globalThis && globalThis.__assign || function() {
  __assign$b = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$b.apply(this, arguments);
};
var VxePagerComponent = defineComponent({
  name: "VxePager",
  props: {
    size: { type: String, default: function() {
      return GlobalConfig.pager.size || GlobalConfig.size;
    } },
    layouts: { type: Array, default: function() {
      return GlobalConfig.pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"];
    } },
    currentPage: { type: Number, default: 1 },
    loading: Boolean,
    pageSize: { type: Number, default: function() {
      return GlobalConfig.pager.pageSize || 10;
    } },
    total: { type: Number, default: 0 },
    pagerCount: { type: Number, default: function() {
      return GlobalConfig.pager.pagerCount || 7;
    } },
    pageSizes: { type: Array, default: function() {
      return GlobalConfig.pager.pageSizes || [10, 15, 20, 50, 100];
    } },
    align: { type: String, default: function() {
      return GlobalConfig.pager.align;
    } },
    border: { type: Boolean, default: function() {
      return GlobalConfig.pager.border;
    } },
    background: { type: Boolean, default: function() {
      return GlobalConfig.pager.background;
    } },
    perfect: { type: Boolean, default: function() {
      return GlobalConfig.pager.perfect;
    } },
    autoHidden: { type: Boolean, default: function() {
      return GlobalConfig.pager.autoHidden;
    } },
    transfer: { type: Boolean, default: function() {
      return GlobalConfig.pager.transfer;
    } },
    className: [String, Function],
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var $xegrid = inject("$xegrid", null);
    var reactData = reactive$1({
      inpCurrPage: props.currentPage
    });
    var refElem = ref$1();
    var refMaps = {
      refElem
    };
    var $xepager = {
      xID,
      props,
      context,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var pagerMethods = {};
    var pagerPrivateMethods = {};
    var getPageCount = function(total, size) {
      return Math.max(Math.ceil(total / size), 1);
    };
    var computePageCount = computed$1(function() {
      return getPageCount(props.total, props.pageSize);
    });
    var jumpPageEvent = function(evnt, currentPage) {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    var changeCurrentPage = function(currentPage, evnt) {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    var triggerJumpEvent = function(evnt) {
      var inputElem = evnt.target;
      var inpValue = xeUtils.toNumber(inputElem.value);
      var pageCount = computePageCount.value;
      var current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      inputElem.value = xeUtils.toValueString(current);
      changeCurrentPage(current, evnt);
    };
    var computeNumList = computed$1(function() {
      var pagerCount = props.pagerCount;
      var pageCount = computePageCount.value;
      var len2 = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      var rest = [];
      for (var index = 0; index < len2; index++) {
        rest.push(index);
      }
      return rest;
    });
    var computeOffsetNumber = computed$1(function() {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    var computeSizeList = computed$1(function() {
      return props.pageSizes.map(function(item) {
        if (xeUtils.isNumber(item)) {
          return {
            value: item,
            label: "".concat(GlobalConfig.i18n("vxe.pager.pagesize", [item]))
          };
        }
        return __assign$b({ value: "", label: "" }, item);
      });
    });
    var handlePrevPage = function(evnt) {
      var currentPage = props.currentPage;
      var pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    var handleNextPage = function(evnt) {
      var currentPage = props.currentPage;
      var pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    var handlePrevJump = function(evnt) {
      var numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    var handleNextJump = function(evnt) {
      var pageCount = computePageCount.value;
      var numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    var pageSizeEvent = function(params) {
      var value = params.value;
      var pageSize = xeUtils.toNumber(value);
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage: Math.min(props.currentPage, getPageCount(props.total, pageSize)) });
    };
    var jumpInputEvent = function(evnt) {
      var inputElem = evnt.target;
      reactData.inpCurrPage = inputElem.value;
    };
    var jumpKeydownEvent = function(evnt) {
      if (hasEventKey(evnt, EVENT_KEYS.ENTER)) {
        triggerJumpEvent(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
        evnt.preventDefault();
        handleNextPage(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
        evnt.preventDefault();
        handlePrevPage(evnt);
      }
    };
    var renderPrevPage = function() {
      return h$6("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: GlobalConfig.i18n("vxe.pager.prevPage"),
        onClick: handlePrevPage
      }, [
        h$6("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || GlobalConfig.icon.PAGER_PREV_PAGE]
        })
      ]);
    };
    var renderPrevJump = function(tagName2) {
      return h$6(tagName2 || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName2,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: GlobalConfig.i18n("vxe.pager.prevJump"),
        onClick: handlePrevJump
      }, [
        tagName2 ? h$6("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || GlobalConfig.icon.PAGER_JUMP_MORE]
        }) : null,
        h$6("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || GlobalConfig.icon.PAGER_JUMP_PREV]
        })
      ]);
    };
    var renderNextJump = function(tagName2) {
      var pageCount = computePageCount.value;
      return h$6(tagName2 || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName2,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: GlobalConfig.i18n("vxe.pager.nextJump"),
        onClick: handleNextJump
      }, [
        tagName2 ? h$6("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || GlobalConfig.icon.PAGER_JUMP_MORE]
        }) : null,
        h$6("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || GlobalConfig.icon.PAGER_JUMP_NEXT]
        })
      ]);
    };
    var renderNextPage = function() {
      var pageCount = computePageCount.value;
      return h$6("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: GlobalConfig.i18n("vxe.pager.nextPage"),
        onClick: handleNextPage
      }, [
        h$6("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || GlobalConfig.icon.PAGER_NEXT_PAGE]
        })
      ]);
    };
    var renderNumber = function(showJump) {
      var currentPage = props.currentPage, pagerCount = props.pagerCount;
      var nums = [];
      var pageCount = computePageCount.value;
      var numList = computeNumList.value;
      var offsetNumber = computeOffsetNumber.value;
      var isOv = pageCount > pagerCount;
      var isLt = isOv && currentPage > offsetNumber + 1;
      var isGt = isOv && currentPage < pageCount - offsetNumber;
      var startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h$6("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: function(evnt) {
            return jumpPageEvent(evnt, 1);
          }
        }, 1), renderPrevJump("span"));
      }
      numList.forEach(function(item, index) {
        var number2 = startNumber + index;
        if (number2 <= pageCount) {
          nums.push(h$6("button", {
            key: number2,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number2
            }],
            type: "button",
            onClick: function(evnt) {
              return jumpPageEvent(evnt, number2);
            }
          }, number2));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h$6("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: function(evnt) {
            return jumpPageEvent(evnt, pageCount);
          }
        }, pageCount));
      }
      return h$6("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    var renderJumpNumber = function() {
      return renderNumber(true);
    };
    var renderSizes = function() {
      var sizeList = computeSizeList.value;
      return h$6(resolveComponent("vxe-select"), {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: "top",
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    var renderJump = function(isFull) {
      return h$6("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h$6("span", {
          class: "vxe-pager--goto-text"
        }, GlobalConfig.i18n("vxe.pager.goto")) : null,
        h$6("input", {
          class: "vxe-pager--goto",
          value: reactData.inpCurrPage,
          type: "text",
          autocomplete: "off",
          onInput: jumpInputEvent,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent
        }),
        isFull ? h$6("span", {
          class: "vxe-pager--classifier-text"
        }, GlobalConfig.i18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    var renderFullJump = function() {
      return renderJump(true);
    };
    var renderPageCount = function() {
      var pageCount = computePageCount.value;
      return h$6("span", {
        class: "vxe-pager--count"
      }, [
        h$6("span", {
          class: "vxe-pager--separator"
        }),
        h$6("span", pageCount)
      ]);
    };
    var renderTotal = function() {
      return h$6("span", {
        class: "vxe-pager--total"
      }, GlobalConfig.i18n("vxe.pager.total", [props.total]));
    };
    pagerMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $pager: $xepager, $event: evnt }, params));
      },
      prevPage: function() {
        handlePrevPage();
        return nextTick$1();
      },
      nextPage: function() {
        handleNextPage();
        return nextTick$1();
      },
      prevJump: function() {
        handlePrevJump();
        return nextTick$1();
      },
      nextJump: function() {
        handleNextJump();
        return nextTick$1();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xepager, pagerMethods, pagerPrivateMethods);
    watch$1(function() {
      return props.currentPage;
    }, function(value) {
      reactData.inpCurrPage = value;
    });
    var renderVN = function() {
      var _a2;
      var align = props.align, layouts = props.layouts, className = props.className;
      var childNodes = [];
      var vSize = computeSize.value;
      var pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h$6("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xegrid })));
      }
      layouts.forEach(function(name2) {
        var renderFn;
        switch (name2) {
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        }
      });
      if (slots.right) {
        childNodes.push(h$6("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xegrid })));
      }
      return h$6("div", {
        ref: refElem,
        class: ["vxe-pager", className ? xeUtils.isFunction(className) ? className({ $pager: $xepager }) : className : "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["align--".concat(align)] = align, _a2["is--border"] = props.border, _a2["is--background"] = props.background, _a2["is--perfect"] = props.perfect, _a2["is--hidden"] = props.autoHidden && pageCount === 1, _a2["is--loading"] = props.loading, _a2)]
      }, [
        h$6("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xepager.renderVN = renderVN;
    return $xepager;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxePagerComponent, {
  install: function(app) {
    app.component(VxePagerComponent.name, VxePagerComponent);
  }
});
dynamicApp.component(VxePagerComponent.name, VxePagerComponent);
Object.assign(VxeCheckboxComponent, {
  install: function(app) {
    app.component(VxeCheckboxComponent.name, VxeCheckboxComponent);
  }
});
dynamicApp.component(VxeCheckboxComponent.name, VxeCheckboxComponent);
var VxeCheckboxGroupComponent = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    disabled: Boolean,
    max: { type: [String, Number], default: null },
    size: { type: String, default: function() {
      return GlobalConfig.checkbox.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeIsMaximize = computed$1(function() {
      var modelValue5 = props.modelValue, max3 = props.max;
      if (max3) {
        return (modelValue5 ? modelValue5.length : 0) >= xeUtils.toNumber(max3);
      }
      return false;
    });
    var computeMaps = {
      computeIsMaximize
    };
    var $xecheckboxgroup = {
      xID,
      props,
      context,
      getComputeMaps: function() {
        return computeMaps;
      }
    };
    useSize$1(props);
    var checkboxGroupMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $checkboxGroup: $xecheckboxgroup, $event: evnt }, params));
      }
    };
    var checkboxGroupPrivateMethods = {
      handleChecked: function(params, evnt) {
        var checked = params.checked, label = params.label;
        var checklist = props.modelValue || [];
        var checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xecheckboxgroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xecheckboxgroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    var renderVN = function() {
      return h$6("div", {
        class: "vxe-checkbox-group"
      }, slots.default ? slots.default({}) : []);
    };
    $xecheckboxgroup.renderVN = renderVN;
    provide("$xecheckboxgroup", $xecheckboxgroup);
    return renderVN;
  }
});
Object.assign(VxeCheckboxGroupComponent, {
  install: function(app) {
    app.component(VxeCheckboxGroupComponent.name, VxeCheckboxGroupComponent);
  }
});
dynamicApp.component(VxeCheckboxGroupComponent.name, VxeCheckboxGroupComponent);
Object.assign(VxeRadioComponent, {
  install: function(app) {
    app.component(VxeRadioComponent.name, VxeRadioComponent);
  }
});
dynamicApp.component(VxeRadioComponent.name, VxeRadioComponent);
Object.assign(VxeRadioGroupComponent, {
  install: function(app) {
    app.component(VxeRadioGroupComponent.name, VxeRadioGroupComponent);
  }
});
dynamicApp.component(VxeRadioGroupComponent.name, VxeRadioGroupComponent);
var VxeRadioButtonComponent = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    strict: { type: Boolean, default: function() {
      return GlobalConfig.radioButton.strict;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.radioButton.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var $xeradiobutton = {
      xID,
      props,
      context
    };
    var radioButtonMethods = {};
    var $xeradiogroup = inject("$xeradiogroup", null);
    var computeDisabled = computed$1(function() {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    var computeName = computed$1(function() {
      return $xeradiogroup ? $xeradiogroup.name : null;
    });
    var computeStrict = computed$1(function() {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    var computeChecked = computed$1(function() {
      var modelValue5 = props.modelValue, label = props.label;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue5 === label;
    });
    radioButtonMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $radioButton: $xeradiobutton, $event: evnt }, params));
      }
    };
    Object.assign($xeradiobutton, radioButtonMethods);
    var handleValue = function(label, evnt) {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    var changeEvent = function(evnt) {
      var isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    var clickEvent = function(evnt) {
      var isDisabled = computeDisabled.value;
      var isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    var renderVN = function() {
      var _a2;
      var vSize = computeSize.value;
      var isDisabled = computeDisabled.value;
      var name2 = computeName.value;
      var checked = computeChecked.value;
      return h$6("label", {
        class: ["vxe-radio", "vxe-radio-button", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--disabled"] = isDisabled, _a2)],
        title: props.title
      }, [
        h$6("input", {
          class: "vxe-radio--input",
          type: "radio",
          name: name2,
          checked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h$6("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    Object.assign($xeradiobutton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
});
Object.assign(VxeRadioButtonComponent, {
  install: function(app) {
    app.component(VxeRadioButtonComponent.name, VxeRadioButtonComponent);
  }
});
dynamicApp.component(VxeRadioButtonComponent.name, VxeRadioButtonComponent);
Object.assign(VxeInputConstructor, {
  install: function(app) {
    app.component(VxeInputConstructor.name, VxeInputConstructor);
  }
});
dynamicApp.component(VxeInputConstructor.name, VxeInputConstructor);
var autoTxtElem;
var VxeTextareaComponent = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: { type: Boolean, default: true },
    name: String,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: String,
    maxlength: [String, Number],
    rows: { type: [String, Number], default: 2 },
    cols: { type: [String, Number], default: null },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: { type: String, default: function() {
      return GlobalConfig.textarea.resize;
    } },
    size: { type: String, default: function() {
      return GlobalConfig.textarea.size || GlobalConfig.size;
    } }
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup: function(props, context) {
    var emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inputValue: props.modelValue
    });
    var refElem = ref$1();
    var refTextarea = ref$1();
    var refMaps = {
      refElem,
      refTextarea
    };
    var $xetextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var textareaMethods = {};
    var computeInputCount = computed$1(function() {
      return xeUtils.getSize(reactData.inputValue);
    });
    var computeIsCountError = computed$1(function() {
      var inputCount = computeInputCount.value;
      return props.maxlength && inputCount > xeUtils.toNumber(props.maxlength);
    });
    var computeSizeOpts = computed$1(function() {
      return Object.assign({ minRows: 1, maxRows: 10 }, GlobalConfig.textarea.autosize, props.autosize);
    });
    var updateAutoTxt = function() {
      var size = props.size, autosize = props.autosize;
      var inputValue = reactData.inputValue;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        var textElem = refTextarea.value;
        var textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? "size--".concat(size) : ""].join(" ");
        autoTxtElem.style.width = "".concat(textElem.clientWidth, "px");
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerHTML = ("" + (inputValue || "\u3000")).replace(/\n$/, "\n\u3000");
      }
    };
    var handleResize = function() {
      if (props.autosize) {
        nextTick$1(function() {
          var sizeOpts = computeSizeOpts.value;
          var minRows = sizeOpts.minRows, maxRows = sizeOpts.maxRows;
          var textElem = refTextarea.value;
          var sizeHeight = autoTxtElem.clientHeight;
          var textStyle = getComputedStyle(textElem);
          var lineHeight = xeUtils.toNumber(textStyle.lineHeight);
          var paddingTop = xeUtils.toNumber(textStyle.paddingTop);
          var paddingBottom = xeUtils.toNumber(textStyle.paddingBottom);
          var borderTopWidth = xeUtils.toNumber(textStyle.borderTopWidth);
          var borderBottomWidth = xeUtils.toNumber(textStyle.borderBottomWidth);
          var intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          var rowNum = (sizeHeight - intervalHeight) / lineHeight;
          var textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          var vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = "".concat(vaildRows * lineHeight + intervalHeight, "px");
        });
      }
    };
    var triggerEvent2 = function(evnt) {
      var value = reactData.inputValue;
      $xetextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    var emitUpdate = function(value, evnt) {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (xeUtils.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    var inputEvent = function(evnt) {
      var immediate = props.immediate;
      var textElem = evnt.target;
      var value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xetextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    var changeEvent = function(evnt) {
      var immediate = props.immediate;
      if (immediate) {
        triggerEvent2(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    var blurEvent = function(evnt) {
      var immediate = props.immediate;
      var inputValue = reactData.inputValue;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xetextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $textarea: $xetextarea, $event: evnt }, params));
      },
      focus: function() {
        var textElem = refTextarea.value;
        textElem.focus();
        return nextTick$1();
      },
      blur: function() {
        var textElem = refTextarea.value;
        textElem.blur();
        return nextTick$1();
      }
    };
    Object.assign($xetextarea, textareaMethods);
    watch$1(function() {
      return props.modelValue;
    }, function(val2) {
      reactData.inputValue = val2;
      updateAutoTxt();
    });
    nextTick$1(function() {
      var autosize = props.autosize;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    var renderVN = function() {
      var _a2;
      var className = props.className, resize = props.resize, placeholder = props.placeholder, disabled3 = props.disabled, maxlength = props.maxlength, autosize = props.autosize, showWordCount = props.showWordCount, countMethod = props.countMethod, rows = props.rows, cols = props.cols;
      var inputValue = reactData.inputValue;
      var vSize = computeSize.value;
      var isCountError = computeIsCountError.value;
      var inputCount = computeInputCount.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-textarea", className, (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--autosize"] = autosize, _a2["is--disabled"] = disabled3, _a2["def--rows"] = !xeUtils.eqNull(rows), _a2["def--cols"] = !xeUtils.eqNull(cols), _a2)]
      }, [
        h$6("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: placeholder ? getFuncText(placeholder) : null,
          maxlength,
          readonly: props.readonly,
          disabled: disabled3,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent2,
          onKeyup: triggerEvent2,
          onClick: triggerEvent2,
          onFocus: triggerEvent2,
          onBlur: blurEvent
        }),
        showWordCount ? h$6("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? "".concat(countMethod({ value: inputValue })) : "".concat(inputCount).concat(maxlength ? "/".concat(maxlength) : "")) : null
      ]);
    };
    $xetextarea.renderVN = renderVN;
    return $xetextarea;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeTextareaComponent, {
  install: function(app) {
    app.component(VxeTextareaComponent.name, VxeTextareaComponent);
  }
});
dynamicApp.component(VxeTextareaComponent.name, VxeTextareaComponent);
var VxeButton = Object.assign(VxeButtonComponent, {
  install: function(app) {
    app.component(VxeButtonComponent.name, VxeButtonComponent);
  }
});
dynamicApp.component(VxeButtonComponent.name, VxeButtonComponent);
var __assign$a = globalThis && globalThis.__assign || function() {
  __assign$a = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$a.apply(this, arguments);
};
function openModal(options) {
  checkDynamic();
  return new Promise(function(resolve) {
    if (options && options.id && allActivedModals.some(function(comp) {
      return comp.props.id === options.id;
    })) {
      resolve("exist");
    } else {
      var _onHide_1 = options.onHide;
      var modalOpts_1 = Object.assign(options, {
        key: xeUtils.uniqueId(),
        modelValue: true,
        onHide: function(params) {
          var modalList = dynamicStore.modals;
          if (_onHide_1) {
            _onHide_1(params);
          }
          dynamicStore.modals = modalList.filter(function(item) {
            return item.key !== modalOpts_1.key;
          });
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts_1);
    }
  });
}
function getModal(id2) {
  return xeUtils.find(allActivedModals, function($modal) {
    return $modal.props.id === id2;
  });
}
function closeModal(id2) {
  var modals = id2 ? [getModal(id2)] : allActivedModals;
  var restPromises = [];
  modals.forEach(function($modal) {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  var opts;
  if (xeUtils.isObject(content)) {
    opts = content;
  } else {
    opts = { content: xeUtils.toValueString(content), title };
  }
  return openModal(__assign$a(__assign$a(__assign$a({}, defOpts), options), opts));
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    showHeader: false
  }, content, "", options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage
};
Object.assign(VxeModalComponent, {
  install: function(app) {
    app.component(VxeModalComponent.name, VxeModalComponent);
    VXETable.modal = ModalController;
  }
});
dynamicApp.component(VxeModalComponent.name, VxeModalComponent);
var __assign$9 = globalThis && globalThis.__assign || function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var VxeTooltipComponent = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: { type: String, default: function() {
      return GlobalConfig.tooltip.size || GlobalConfig.size;
    } },
    trigger: { type: String, default: function() {
      return GlobalConfig.tooltip.trigger;
    } },
    theme: { type: String, default: function() {
      return GlobalConfig.tooltip.theme;
    } },
    content: { type: [String, Number], default: null },
    useHTML: Boolean,
    zIndex: [String, Number],
    isArrow: { type: Boolean, default: true },
    enterable: Boolean,
    enterDelay: { type: Number, default: function() {
      return GlobalConfig.tooltip.enterDelay;
    } },
    leaveDelay: { type: Number, default: function() {
      return GlobalConfig.tooltip.leaveDelay;
    } }
  },
  emits: [
    "update:modelValue"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    var refElem = ref$1();
    var refMaps = {
      refElem
    };
    var $xetooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var tooltipMethods = {};
    var updateTipStyle = function() {
      var tipTarget = reactData.tipTarget, tipStore = reactData.tipStore;
      if (tipTarget) {
        var _a2 = getDomNode(), scrollTop = _a2.scrollTop, scrollLeft = _a2.scrollLeft, visibleWidth = _a2.visibleWidth;
        var _b2 = getAbsolutePos(tipTarget), top_1 = _b2.top, left = _b2.left;
        var el2 = refElem.value;
        var marginSize = 6;
        var offsetHeight = el2.offsetHeight;
        var offsetWidth = el2.offsetWidth;
        var tipLeft = left;
        var tipTop = top_1 - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top_1 - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top_1 + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = "".concat(tipTop, "px");
        tipStore.style.left = "".concat(tipLeft, "px");
        tipStore.arrowStyle.left = "".concat(left - tipLeft + tipTarget.offsetWidth / 2, "px");
      }
    };
    var updateValue2 = function(value) {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    var updateZindex = function() {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    var clickEvent = function() {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    var targetMouseenterEvent = function() {
      tooltipMethods.open();
    };
    var targetMouseleaveEvent = function() {
      var trigger2 = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;
      reactData.tipActive = false;
      if (enterable && trigger2 === "hover") {
        setTimeout(function() {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    var wrapperMouseenterEvent = function() {
      reactData.tipActive = true;
    };
    var wrapperMouseleaveEvent = function() {
      var trigger2 = props.trigger, enterable = props.enterable, leaveDelay = props.leaveDelay;
      reactData.tipActive = false;
      if (enterable && trigger2 === "hover") {
        setTimeout(function() {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    var showTip = function() {
      var tipStore = reactData.tipStore;
      var el2 = refElem.value;
      if (el2) {
        var parentNode2 = el2.parentNode;
        if (!parentNode2) {
          document.body.appendChild(el2);
        }
      }
      updateValue2(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    var showDelayTip = xeUtils.debounce(function() {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, { leading: false, trailing: true });
    tooltipMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $tooltip: $xetooltip, $event: evnt }, params));
      },
      open: function(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close: function() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue2(false);
        return nextTick$1();
      },
      toVisible: function(target, content) {
        if (target) {
          var trigger2 = props.trigger, enterDelay = props.enterDelay;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger2 === "hover") {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return nextTick$1();
      },
      updatePlacement: function() {
        return nextTick$1().then(function() {
          var tipTarget = reactData.tipTarget;
          var el2 = refElem.value;
          if (tipTarget && el2) {
            updateTipStyle();
            return nextTick$1().then(updateTipStyle);
          }
        });
      },
      isActived: function() {
        return reactData.tipActive;
      },
      setActived: function(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xetooltip, tooltipMethods);
    watch$1(function() {
      return props.content;
    }, function() {
      reactData.tipContent = props.content;
    });
    watch$1(function() {
      return props.modelValue;
    }, function() {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted$1(function() {
      nextTick$1(function() {
        var trigger2 = props.trigger, content = props.content, modelValue5 = props.modelValue;
        var wrapperElem = refElem.value;
        var parentNode2 = wrapperElem.parentNode;
        if (parentNode2) {
          reactData.tipContent = content;
          reactData.tipZindex = nextZIndex();
          xeUtils.arrayEach(wrapperElem.children, function(elem, index) {
            if (index > 1) {
              parentNode2.insertBefore(elem, wrapperElem);
              if (!reactData.target) {
                reactData.target = elem;
              }
            }
          });
          parentNode2.removeChild(wrapperElem);
          var target = reactData.target;
          if (target) {
            if (trigger2 === "hover") {
              target.onmouseenter = targetMouseenterEvent;
              target.onmouseleave = targetMouseleaveEvent;
            } else if (trigger2 === "click") {
              target.onclick = clickEvent;
            }
          }
          if (modelValue5) {
            tooltipMethods.open();
          }
        }
      });
    });
    onBeforeUnmount(function() {
      var trigger2 = props.trigger;
      var target = reactData.target;
      var wrapperElem = refElem.value;
      if (wrapperElem) {
        var parentNode2 = wrapperElem.parentNode;
        if (parentNode2) {
          parentNode2.removeChild(wrapperElem);
        }
      }
      if (target) {
        if (trigger2 === "hover") {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger2 === "click") {
          target.onclick = null;
        }
      }
    });
    var renderContent = function() {
      var useHTML = props.useHTML;
      var tipContent = reactData.tipContent;
      var contentSlot = slots.content;
      if (contentSlot) {
        return h$6("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return h$6("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h$6("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, formatText(tipContent));
    };
    var renderVN = function() {
      var _a2;
      var theme2 = props.theme, isArrow = props.isArrow, enterable = props.enterable;
      var tipActive = reactData.tipActive, visible = reactData.visible, tipStore = reactData.tipStore;
      var defaultSlot = slots.default;
      var vSize = computeSize.value;
      var ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h$6("div", __assign$9({ ref: refElem, class: ["vxe-table--tooltip-wrapper", "theme--".concat(theme2), (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["placement--".concat(tipStore.placement)] = tipStore.placement, _a2["is--enterable"] = enterable, _a2["is--visible"] = visible, _a2["is--arrow"] = isArrow, _a2["is--actived"] = tipActive, _a2)], style: tipStore.style }, ons), __spreadArray$2([
        renderContent(),
        h$6("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        })
      ], defaultSlot ? getSlotVNs(defaultSlot({})) : [], true));
    };
    $xetooltip.renderVN = renderVN;
    return $xetooltip;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeTooltipComponent, {
  install: function(app) {
    VXETable.tooltip = true;
    app.component(VxeTooltipComponent.name, VxeTooltipComponent);
  }
});
dynamicApp.component(VxeTooltipComponent.name, VxeTooltipComponent);
var ItemInfo = function() {
  function ItemInfo2($xeform, item) {
    Object.assign(this, {
      id: xeUtils.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      itemRender: item.itemRender,
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  ItemInfo2.prototype.update = function(name2, value) {
    this[name2] = value;
  };
  return ItemInfo2;
}();
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeform, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeform, _vm);
}
function handleFieldOrItem($xeform, fieldOrItem) {
  if (fieldOrItem) {
    return xeUtils.isString(fieldOrItem) ? $xeform.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeform, formItem) {
  var reactData = $xeform.reactData;
  var collapseAll = reactData.collapseAll;
  var folding = formItem.folding, visible = formItem.visible;
  return visible === false || folding && collapseAll;
}
function isActivetem($xeform, formItem) {
  var visibleMethod = formItem.visibleMethod, itemRender = formItem.itemRender, visible = formItem.visible, field = formItem.field;
  if (visible === false) {
    return visible;
  }
  var compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  if (!visibleMethod && compConf && compConf.itemVisibleMethod) {
    visibleMethod = compConf.itemVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  var data5 = $xeform.props.data;
  return visibleMethod({ data: data5, field, property: field, item: formItem, $form: $xeform });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach(function(name2) {
    watch$1(function() {
      return props[name2];
    }, function(value) {
      formItem.update(name2, value);
    });
  });
}
function assemItem($xeform, el2, formItem, formGather) {
  var reactData = $xeform.reactData;
  var staticItems = reactData.staticItems;
  var parentElem = el2.parentNode;
  var parentItem = formGather ? formGather.formItem : null;
  var parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(xeUtils.arrayIndexOf(parentElem.children, el2), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeform, formItem) {
  var reactData = $xeform.reactData;
  var staticItems = reactData.staticItems;
  var index = xeUtils.findIndexOf(staticItems, function(item) {
    return item.id === formItem.id;
  });
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}
var __assign$8 = globalThis && globalThis.__assign || function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
function renderPrefixIcon(titlePrefix) {
  return h$6("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h$6("i", {
      class: titlePrefix.icon || GlobalConfig.icon.FORM_PREFIX
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h$6("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h$6("i", {
      class: titleSuffix.icon || GlobalConfig.icon.FORM_SUFFIX
    })
  ]);
}
function renderTitle($xeform, item) {
  var data5 = $xeform.props.data;
  var computeTooltipOpts = $xeform.getComputeMaps().computeTooltipOpts;
  var slots = item.slots, field = item.field, itemRender = item.itemRender, titlePrefix = item.titlePrefix, titleSuffix = item.titleSuffix;
  var tooltipOpts = computeTooltipOpts.value;
  var compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  var params = { data: data5, field, property: field, item, $form: $xeform };
  var titleSlot = slots ? slots.title : null;
  var contVNs = [];
  var titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h$6(resolveComponent("vxe-tooltip"), __assign$8(__assign$8(__assign$8({}, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: function() {
        return renderPrefixIcon(titlePrefix);
      }
    }) : renderPrefixIcon(titlePrefix));
  }
  titVNs.push(h$6("span", {
    class: "vxe-form--item-title-label"
  }, compConf && compConf.renderItemTitle ? compConf.renderItemTitle(itemRender, params) : titleSlot ? $xeform.callSlot(titleSlot, params) : getFuncText(item.title)));
  contVNs.push(h$6("div", {
    class: "vxe-form--item-title-content"
  }, titVNs));
  var fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h$6(resolveComponent("vxe-tooltip"), __assign$8(__assign$8(__assign$8({}, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: function() {
        return renderSuffixIcon(titleSuffix);
      }
    }) : renderSuffixIcon(titleSuffix));
  }
  contVNs.push(h$6("div", {
    class: "vxe-form--item-title-postfix"
  }, fixVNs));
  return contVNs;
}
var __assign$7 = globalThis && globalThis.__assign || function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig2: Object,
    itemConfig: Object
  },
  setup: function(props) {
    var $xeform = inject("$xeform", {});
    var xeformiteminfo = { itemConfig: props.itemConfig };
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", null);
    var renderVN = function() {
      var reactData = $xeform.reactData;
      var _a2 = $xeform.props, data5 = _a2.data, rules = _a2.rules, allSpan = _a2.span, allAlign = _a2.align, allTitleAlign = _a2.titleAlign, allTitleWidth = _a2.titleWidth, allTitleColon = _a2.titleColon, allTitleAsterisk = _a2.titleAsterisk, allTitleOverflow = _a2.titleOverflow;
      var computeValidOpts = $xeform.getComputeMaps().computeValidOpts;
      var item = props.itemConfig;
      var collapseAll = reactData.collapseAll;
      var validOpts = computeValidOpts.value;
      var slots = item.slots, title = item.title, visible = item.visible, folding = item.folding, field = item.field, collapseNode = item.collapseNode, itemRender = item.itemRender, showError = item.showError, errRule = item.errRule, className = item.className, titleOverflow = item.titleOverflow, children2 = item.children;
      var compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      var itemClassName = compConf ? compConf.itemClassName : "";
      var defaultSlot = slots ? slots.default : null;
      var titleSlot = slots ? slots.title : null;
      var span = item.span || allSpan;
      var align = item.align || allAlign;
      var titleAlign = xeUtils.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      var titleWidth = xeUtils.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      var titleColon = xeUtils.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      var titleAsterisk = xeUtils.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      var itemOverflow = xeUtils.isUndefined(titleOverflow) || xeUtils.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      var showEllipsis = itemOverflow === "ellipsis";
      var showTitle = itemOverflow === "title";
      var showTooltip2 = itemOverflow === true || itemOverflow === "tooltip";
      var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
      var params = { data: data5, field, property: field, item, $form: $xeform };
      if (visible === false) {
        return createCommentVNode();
      }
      var isRequired = false;
      if (rules) {
        var itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some(function(rule2) {
            return rule2.required;
          });
        }
      }
      var isGather = children2 && children2.length > 0;
      if (isGather) {
        var childVNs = children2.map(function(childItem, index) {
          return h$6(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? h$6("div", {
          class: ["vxe-form--gather vxe-row", item.id, span ? "vxe-col--".concat(span, " is--span") : "", className ? xeUtils.isFunction(className) ? className(params) : className : ""]
        }, childVNs) : createCommentVNode();
      }
      var contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [xeUtils.toValueString(xeUtils.get(data5, field))];
      }
      if (collapseNode) {
        contentVNs.push(h$6("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform.toggleCollapseEvent
        }, [
          h$6("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? GlobalConfig.i18n("vxe.form.unfolding") : GlobalConfig.i18n("vxe.form.folding")),
          h$6("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? GlobalConfig.icon.FORM_FOLDING : GlobalConfig.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h$6("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: "".concat(errRule.maxWidth, "px")
          } : null
        }, errRule.content));
      }
      var ons = showTooltip2 ? {
        onMouseenter: function(evnt) {
          $xeform.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform.handleTitleTipLeaveEvent
      } : {};
      return h$6("div", {
        class: [
          "vxe-form--item",
          item.id,
          span ? "vxe-col--".concat(span, " is--span") : "",
          className ? xeUtils.isFunction(className) ? className(params) : className : "",
          itemClassName ? xeUtils.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--asterisk": titleAsterisk,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform, item),
            "is--error": showError
          }
        ],
        itemConfig: item,
        key: item.id
      }, [
        h$6("div", {
          class: "vxe-form--item-inner"
        }, [
          title || titleSlot ? h$6("div", __assign$7({ class: ["vxe-form--item-title", titleAlign ? "align--".concat(titleAlign) : null, {
            "is--ellipsis": hasEllipsis
          }], style: titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : "".concat(titleWidth, "px")
          } : null, title: showTitle ? getFuncText(title) : null }, ons), renderTitle($xeform, item)) : null,
          h$6("div", {
            class: ["vxe-form--item-content", align ? "align--".concat(align) : null]
          }, contentVNs)
        ])
      ]);
    };
    var $xeformconfigitem = {
      renderVN
    };
    return $xeformconfigitem;
  },
  render: function() {
    return this.renderVN();
  }
});
var __assign$6 = globalThis && globalThis.__assign || function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var Rule = function() {
  function Rule2(rule2) {
    Object.assign(this, {
      $options: rule2,
      required: rule2.required,
      min: rule2.min,
      max: rule2.min,
      type: rule2.type,
      pattern: rule2.pattern,
      validator: rule2.validator,
      trigger: rule2.trigger,
      maxWidth: rule2.maxWidth
    });
  }
  Object.defineProperty(Rule2.prototype, "content", {
    get: function() {
      return getFuncText(this.$options.content || this.$options.message);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Rule2.prototype, "message", {
    get: function() {
      return this.content;
    },
    enumerable: false,
    configurable: true
  });
  return Rule2;
}();
var validErrorRuleValue = function(rule2, val2) {
  var type2 = rule2.type, min3 = rule2.min, max3 = rule2.max, pattern = rule2.pattern;
  var isNumType = type2 === "number";
  var numVal = isNumType ? xeUtils.toNumber(val2) : xeUtils.getSize(val2);
  if (isNumType && isNaN(val2)) {
    return true;
  }
  if (!xeUtils.eqNull(min3) && numVal < xeUtils.toNumber(min3)) {
    return true;
  }
  if (!xeUtils.eqNull(max3) && numVal > xeUtils.toNumber(max3)) {
    return true;
  }
  if (pattern && !(xeUtils.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val2)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (xeUtils.isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
var VxeFormComponent = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: { type: Boolean, default: true },
    loading: Boolean,
    data: Object,
    size: { type: String, default: function() {
      return GlobalConfig.form.size || GlobalConfig.size;
    } },
    span: { type: [String, Number], default: function() {
      return GlobalConfig.form.span;
    } },
    align: { type: String, default: function() {
      return GlobalConfig.form.align;
    } },
    titleAlign: { type: String, default: function() {
      return GlobalConfig.form.titleAlign;
    } },
    titleWidth: { type: [String, Number], default: function() {
      return GlobalConfig.form.titleWidth;
    } },
    titleColon: { type: Boolean, default: function() {
      return GlobalConfig.form.titleColon;
    } },
    titleAsterisk: { type: Boolean, default: function() {
      return GlobalConfig.form.titleAsterisk;
    } },
    titleOverflow: { type: [Boolean, String], default: null },
    className: [String, Function],
    readonly: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: { type: Boolean, default: function() {
      return GlobalConfig.form.preventSubmit;
    } },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: { type: Boolean, default: function() {
      return GlobalConfig.form.customLayout;
    } }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup: function(props, context) {
    var hasUseTooltip = VXETable.tooltip;
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    var internalData = reactive$1({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    var refElem = ref$1();
    var refTooltip = ref$1();
    var formMethods = {};
    var computeValidOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.form.validConfig, props.validConfig);
    });
    var computeTooltipOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.form.tooltipConfig, props.tooltipConfig);
    });
    var refMaps = {
      refElem
    };
    var computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    var $xeform = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      },
      getComputeMaps: function() {
        return computeMaps;
      }
    };
    var callSlot = function(slotFunc, params) {
      if (slotFunc) {
        if (xeUtils.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (xeUtils.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    var loadItem = function(list) {
      if (list.length) {
        reactData.staticItems = xeUtils.mapTree(list, function(item) {
          return createItem($xeform, item);
        }, { children: "children" });
      }
      return nextTick$1();
    };
    var getItems = function() {
      var itemList = [];
      xeUtils.eachTree(reactData.formItems, function(item) {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    var getItemByField = function(field) {
      var rest = xeUtils.findTree(reactData.formItems, function(item) {
        return item.field === field;
      }, { children: "children" });
      return rest ? rest.item : null;
    };
    var getCollapseStatus = function() {
      return reactData.collapseAll;
    };
    var toggleCollapse = function() {
      var status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick$1();
    };
    var toggleCollapseEvent = function(evnt) {
      toggleCollapse();
      var status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    var clearValidate = function(fieldOrItem) {
      if (fieldOrItem) {
        var item = handleFieldOrItem($xeform, fieldOrItem);
        if (item) {
          item.showError = false;
        }
      } else {
        getItems().forEach(function(item2) {
          item2.showError = false;
        });
      }
      return nextTick$1();
    };
    var reset = function() {
      var data5 = props.data;
      var itemList = getItems();
      if (data5) {
        itemList.forEach(function(item) {
          var field = item.field, resetValue = item.resetValue, itemRender = item.itemRender;
          if (isEnableConf(itemRender)) {
            var compConf = VXETable.renderer.get(itemRender.name);
            if (compConf && compConf.itemResetMethod) {
              compConf.itemResetMethod({ data: data5, field, property: field, item, $form: $xeform });
            } else if (field) {
              xeUtils.set(data5, field, resetValue === null ? getResetValue(xeUtils.get(data5, field), void 0) : xeUtils.clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    var resetEvent = function(evnt) {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    var handleFocus = function(fields) {
      var el2 = refElem.value;
      fields.some(function(property2, index) {
        var item = getItemByField(property2);
        if (item && isEnableConf(item.itemRender)) {
          var itemRender = item.itemRender;
          var compConf = VXETable.renderer.get(itemRender.name);
          var inputElem = null;
          if (!index) {
            scrollToView(el2.querySelector(".".concat(item.id)));
          }
          if (itemRender.autofocus) {
            inputElem = el2.querySelector(".".concat(item.id, " ").concat(itemRender.autofocus));
          }
          if (!inputElem && compConf && compConf.autofocus) {
            inputElem = el2.querySelector(".".concat(item.id, " ").concat(compConf.autofocus));
          }
          if (inputElem) {
            inputElem.focus();
            return true;
          }
        }
      });
    };
    var validItemRules = function(validType, property2, val2) {
      var data5 = props.data, formRules = props.rules;
      var errorRules = [];
      var syncVailds = [];
      if (property2 && formRules) {
        var rules_1 = xeUtils.get(formRules, property2);
        if (rules_1) {
          var itemValue_1 = xeUtils.isUndefined(val2) ? xeUtils.get(data5, property2) : val2;
          rules_1.forEach(function(rule2) {
            var type2 = rule2.type, trigger2 = rule2.trigger, required2 = rule2.required;
            if (validType === "all" || !trigger2 || validType === trigger2) {
              if (xeUtils.isFunction(rule2.validator)) {
                var customValid = rule2.validator({
                  itemValue: itemValue_1,
                  rule: rule2,
                  rules: rules_1,
                  data: data5,
                  field: property2,
                  property: property2,
                  $form: $xeform
                });
                if (customValid) {
                  if (xeUtils.isError(customValid)) {
                    errorRules.push(new Rule({ type: "custom", trigger: trigger2, content: customValid.message, rule: new Rule(rule2) }));
                  } else if (customValid.catch) {
                    syncVailds.push(customValid.catch(function(e3) {
                      errorRules.push(new Rule({ type: "custom", trigger: trigger2, content: e3 ? e3.message : rule2.content || rule2.message, rule: new Rule(rule2) }));
                    }));
                  }
                }
              } else {
                var isArrType = type2 === "array";
                var hasEmpty = isArrType || xeUtils.isArray(itemValue_1) ? !xeUtils.isArray(itemValue_1) || !itemValue_1.length : eqEmptyValue(itemValue_1);
                if (required2 ? hasEmpty || validErrorRuleValue(rule2, itemValue_1) : !hasEmpty && validErrorRuleValue(rule2, itemValue_1)) {
                  errorRules.push(new Rule(rule2));
                }
              }
            }
          });
        }
      }
      return Promise.all(syncVailds).then(function() {
        if (errorRules.length) {
          var rest = { rules: errorRules, rule: errorRules[0] };
          return Promise.reject(rest);
        }
      });
    };
    var showErrTime;
    var beginValidate = function(itemList, type2, callback) {
      var data5 = props.data, formRules = props.rules;
      var validOpts = computeValidOpts.value;
      var validRest = {};
      var validFields = [];
      var itemValids = [];
      clearTimeout(showErrTime);
      if (data5 && formRules) {
        itemList.forEach(function(item) {
          var field = item.field;
          if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {
            itemValids.push(validItemRules(type2 || "all", field).then(function() {
              item.errRule = null;
            }).catch(function(_a2) {
              var rule2 = _a2.rule, rules = _a2.rules;
              var rest = { rule: rule2, rules, data: data5, field, property: field, $form: $xeform };
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rule2;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(function() {
          if (callback) {
            callback();
          }
        }).catch(function() {
          return new Promise(function(resolve) {
            showErrTime = window.setTimeout(function() {
              itemList.forEach(function(item) {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick$1(function() {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    var validate2 = function(callback) {
      clearValidate();
      return beginValidate(getItems(), "", callback);
    };
    var validateField2 = function(fieldOrItem, callback) {
      var item = handleFieldOrItem($xeform, fieldOrItem);
      return beginValidate(item ? [item] : [], "", callback);
    };
    var submitEvent = function(evnt) {
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        beginValidate(getItems()).then(function(errMap) {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    var closeTooltip = function() {
      var tooltipStore = internalData.tooltipStore;
      var $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick$1();
    };
    var triggerTitleTipEvent = function(evnt, params) {
      var item = params.item;
      var tooltipStore = internalData.tooltipStore;
      var $tooltip = refTooltip.value;
      var overflowElem = evnt.currentTarget.children[0];
      var content = (overflowElem.textContent || "").trim();
      var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    var handleTitleTipLeaveEvent = function() {
      var tooltipOpts = computeTooltipOpts.value;
      var $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(function() {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    var triggerItemEvent = function(evnt, field, itemValue) {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(function() {
          clearValidate(field);
        }).catch(function(_a2) {
          var rule2 = _a2.rule;
          var item = getItemByField(field);
          if (item) {
            item.showError = true;
            item.errRule = rule2;
          }
        });
      }
      return nextTick$1();
    };
    var updateStatus = function(scope, itemValue) {
      var field = scope.field;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $form: $xeform, $event: evnt }, params));
      },
      reset,
      validate: validate2,
      validateField: validateField2,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    var formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeform, formMethods, formPrivateMethods);
    watch$1(function() {
      return reactData.staticItems;
    }, function(value) {
      reactData.formItems = value;
    });
    watch$1(function() {
      return props.items;
    }, function(value) {
      loadItem(value || []);
    });
    watch$1(function() {
      return props.collapseStatus;
    }, function(value) {
      reactData.collapseAll = !!value;
    });
    onMounted$1(function() {
      nextTick$1(function() {
        loadItem(props.items || []);
      });
    });
    var renderVN = function() {
      var _a2;
      var loading = props.loading, className = props.className, data5 = props.data, customLayout = props.customLayout;
      var formItems = reactData.formItems;
      var vSize = computeSize.value;
      var tooltipOpts = computeTooltipOpts.value;
      var defaultSlot = slots.default;
      return h$6("form", {
        ref: refElem,
        class: ["vxe-form", className ? xeUtils.isFunction(className) ? className({ items: formItems, data: data5, $form: $xeform }) : className : "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--loading"] = loading, _a2)],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h$6("div", {
          class: "vxe-form--wrapper vxe-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map(function(item, index) {
          return h$6(VxeFormConfigItem, {
            key: index,
            itemConfig2: item,
            itemConfig: item
          });
        })),
        h$6("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        h$6(VxeLoading, {
          class: "vxe-form--loading",
          modelValue: loading
        }),
        hasUseTooltip ? h$6(resolveComponent("vxe-tooltip"), __assign$6({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()
      ]);
    };
    $xeform.renderVN = renderVN;
    provide("$xeform", $xeform);
    provide("$xeformgather", null);
    provide("$xeformitem", null);
    provide("$xeformiteminfo", null);
    return $xeform;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeFormComponent, {
  install: function(app) {
    app.component(VxeFormComponent.name, VxeFormComponent);
  }
});
dynamicApp.component(VxeFormComponent.name, VxeFormComponent);
var __assign$5 = globalThis && globalThis.__assign || function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleAlign: String,
  titleWidth: [String, Number],
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  titleOverflow: { type: [Boolean, String], default: null },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: { type: Boolean, default: null },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object
};
var VxeFormItemComponent = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var refElem = ref$1();
    var $xeform = inject("$xeform", {});
    var formGather = inject("$xeformgather", null);
    var formItem = reactive$1(createItem($xeform, props));
    var xeformitem = { formItem };
    var xeformiteminfo = { itemConfig: formItem };
    formItem.slots = slots;
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformitem", xeformitem);
    provide("$xeformgather", null);
    watchItem(props, formItem);
    onMounted$1(function() {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(function() {
      destroyItem($xeform, formItem);
    });
    var renderItem = function($xeform2, item) {
      var props2 = $xeform2.props, reactData = $xeform2.reactData;
      var data5 = props2.data, rules = props2.rules, allTitleOverflow = props2.titleOverflow;
      var collapseAll = reactData.collapseAll;
      var computeValidOpts = $xeform2.getComputeMaps().computeValidOpts;
      var validOpts = computeValidOpts.value;
      var slots2 = item.slots, title = item.title, visible = item.visible, folding = item.folding, field = item.field, collapseNode = item.collapseNode, itemRender = item.itemRender, showError = item.showError, errRule = item.errRule, className = item.className, titleOverflow = item.titleOverflow;
      var compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      var itemClassName = compConf ? compConf.itemClassName : "";
      var defaultSlot = slots2 ? slots2.default : null;
      var titleSlot = slots2 ? slots2.title : null;
      var span = item.span || props2.span;
      var align = item.align || props2.align;
      var titleAlign = item.titleAlign || props2.titleAlign;
      var titleWidth = item.titleWidth || props2.titleWidth;
      var itemOverflow = xeUtils.isUndefined(titleOverflow) || xeUtils.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      var showEllipsis = itemOverflow === "ellipsis";
      var showTitle = itemOverflow === "title";
      var showTooltip2 = itemOverflow === true || itemOverflow === "tooltip";
      var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
      var params = { data: data5, field, property: field, item, $form: $xeform2 };
      var isRequired = false;
      if (visible === false) {
        return createCommentVNode();
      }
      if (rules) {
        var itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some(function(rule2) {
            return rule2.required;
          });
        }
      }
      var contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform2.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = ["".concat(xeUtils.get(data5, field))];
      }
      if (collapseNode) {
        contentVNs.push(h$6("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform2.toggleCollapseEvent
        }, [
          h$6("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? GlobalConfig.i18n("vxe.form.unfolding") : GlobalConfig.i18n("vxe.form.folding")),
          h$6("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? GlobalConfig.icon.FORM_FOLDING : GlobalConfig.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h$6("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: "".concat(errRule.maxWidth, "px")
          } : null
        }, errRule.message));
      }
      var ons = showTooltip2 ? {
        onMouseenter: function(evnt) {
          $xeform2.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform2.handleTitleTipLeaveEvent
      } : {};
      return h$6("div", {
        ref: refElem,
        class: [
          "vxe-form--item",
          item.id,
          span ? "vxe-col--".concat(span, " is--span") : "",
          className ? xeUtils.isFunction(className) ? className(params) : className : "",
          itemClassName ? xeUtils.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform2, item),
            "is--error": showError
          }
        ]
      }, [
        h$6("div", {
          class: "vxe-form--item-inner"
        }, [
          title || titleSlot ? h$6("div", __assign$5({ class: ["vxe-form--item-title", titleAlign ? "align--".concat(titleAlign) : null, {
            "is--ellipsis": hasEllipsis
          }], style: titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : "".concat(titleWidth, "px")
          } : null, title: showTitle ? getFuncText(title) : null }, ons), renderTitle($xeform2, item)) : null,
          h$6("div", {
            class: ["vxe-form--item-content", align ? "align--".concat(align) : null]
          }, contentVNs)
        ])
      ]);
    };
    var renderVN = function() {
      var formProps = $xeform ? $xeform.props : null;
      return formProps && formProps.customLayout ? renderItem($xeform, formItem) : h$6("div", {
        ref: refElem
      });
    };
    var $xeformitem = {
      renderVN
    };
    return $xeformitem;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeFormItemComponent, {
  install: function(app) {
    app.component(VxeFormItemComponent.name, VxeFormItemComponent);
  }
});
dynamicApp.component(VxeFormItemComponent.name, VxeFormItemComponent);
var VxeFormGatherComponent = defineComponent({
  name: "VxeFormGather",
  props: formItemProps,
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var refElem = ref$1();
    var $xeform = inject("$xeform", {});
    var formGather = inject("$xeformgather", null);
    var defaultSlot = slots.default;
    var formItem = reactive$1(createItem($xeform, props));
    var xeformitem = { formItem };
    var xeformiteminfo = { itemConfig: formItem };
    formItem.children = [];
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", xeformitem);
    provide("$xeformitem", null);
    watchItem(props, formItem);
    onMounted$1(function() {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(function() {
      destroyItem($xeform, formItem);
    });
    var renderVN = function() {
      return h$6("div", {
        ref: refElem
      }, defaultSlot ? defaultSlot() : []);
    };
    var $xeformgather = {
      renderVN
    };
    return $xeformgather;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeFormGatherComponent, {
  install: function(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
Object.assign(VxeSelectComponent, {
  install: function(app) {
    app.component(VxeSelectComponent.name, VxeSelectComponent);
  }
});
dynamicApp.component(VxeSelectComponent.name, VxeSelectComponent);
var OptionInfo = function() {
  function OptionInfo2($xeselect, _vm) {
    Object.assign(this, {
      id: xeUtils.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  OptionInfo2.prototype.update = function(name2, value) {
    this[name2] = value;
  };
  return OptionInfo2;
}();
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeselect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeselect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach(function(name2) {
    watch$1(function() {
      return props[name2];
    }, function(value) {
      option.update(name2, value);
    });
  });
}
function assemOption($xeselect, el2, option, optgroup) {
  var reactData = $xeselect.reactData;
  var staticOptions = reactData.staticOptions;
  var parentElem = el2.parentNode;
  var parentOption = optgroup ? optgroup.option : null;
  var parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(xeUtils.arrayIndexOf(parentElem.children, el2), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeselect, option) {
  var reactData = $xeselect.reactData;
  var staticOptions = reactData.staticOptions;
  var matchObj = xeUtils.findTree(staticOptions, function(item) {
    return item.id === option.id;
  }, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}
var VxeOptgroupComponent = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var elem = ref$1();
    var $xeselect = inject("$xeselect", {});
    var option = createOption($xeselect, props);
    var xeoption = { option };
    option.options = [];
    provide("xeoptgroup", xeoption);
    watchOption(props, option);
    onMounted$1(function() {
      assemOption($xeselect, elem.value, option);
    });
    onUnmounted(function() {
      destroyOption($xeselect, option);
    });
    return function() {
      return h$6("div", {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
});
Object.assign(VxeOptgroupComponent, {
  install: function(app) {
    app.component(VxeOptgroupComponent.name, VxeOptgroupComponent);
  }
});
dynamicApp.component(VxeOptgroupComponent.name, VxeOptgroupComponent);
var VxeOptionComponent = defineComponent({
  name: "VxeOption",
  props: {
    value: null,
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup: function(props, _a2) {
    var slots = _a2.slots;
    var elem = ref$1();
    var $xeselect = inject("$xeselect", {});
    var optgroup = inject("xeoptgroup", null);
    var option = createOption($xeselect, props);
    option.slots = slots;
    watchOption(props, option);
    onMounted$1(function() {
      assemOption($xeselect, elem.value, option, optgroup);
    });
    onUnmounted(function() {
      destroyOption($xeselect, option);
    });
    return function() {
      return h$6("div", {
        ref: elem
      });
    };
  }
});
Object.assign(VxeOptionComponent, {
  install: function(app) {
    app.component(VxeOptionComponent.name, VxeOptionComponent);
  }
});
dynamicApp.component(VxeOptionComponent.name, VxeOptionComponent);
var VxeSwitchComponent = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    size: { type: String, default: function() {
      return GlobalConfig.switch.size || GlobalConfig.size;
    } },
    openLabel: String,
    closeLabel: String,
    openValue: { type: [String, Number, Boolean], default: true },
    closeValue: { type: [String, Number, Boolean], default: false },
    openIcon: String,
    closeIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup: function(props, context) {
    var emit = context.emit;
    var $xeform = inject("$xeform", null);
    var $xeformiteminfo = inject("$xeformiteminfo", null);
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    var $xeswitch = {
      xID,
      props,
      context,
      reactData
    };
    var refButton = ref$1();
    var switchMethods = {};
    var computeOnShowLabel = computed$1(function() {
      return getFuncText(props.openLabel);
    });
    var computeOffShowLabel = computed$1(function() {
      return getFuncText(props.closeLabel);
    });
    var computeIsChecked = computed$1(function() {
      return props.modelValue === props.openValue;
    });
    var _atimeout;
    var clickEvent = function(evnt) {
      if (!props.disabled) {
        var isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        var value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit("update:modelValue", value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(function() {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    var focusEvent = function(evnt) {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    var blurEvent = function(evnt) {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $switch: $xeswitch, $event: evnt }, params));
      },
      focus: function() {
        var btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return nextTick$1();
      },
      blur: function() {
        var btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return nextTick$1();
      }
    };
    Object.assign($xeswitch, switchMethods);
    var renderVN = function() {
      var _a2;
      var disabled3 = props.disabled, openIcon = props.openIcon, closeIcon = props.closeIcon;
      var isChecked = computeIsChecked.value;
      var vSize = computeSize.value;
      var onShowLabel = computeOnShowLabel.value;
      var offShowLabel = computeOffShowLabel.value;
      return h$6("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--disabled"] = disabled3, _a2["is--animat"] = reactData.hasAnimat, _a2)]
      }, [
        h$6("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: disabled3,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h$6("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h$6("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h$6("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h$6("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h$6("span", {
            class: "vxe-switch--icon"
          })
        ])
      ]);
    };
    $xeswitch.renderVN = renderVN;
    return $xeswitch;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeSwitchComponent, {
  install: function(app) {
    app.component(VxeSwitchComponent.name, VxeSwitchComponent);
  }
});
dynamicApp.component(VxeSwitchComponent.name, VxeSwitchComponent);
var resizeTimeout;
var eventStore = [];
var defaultInterval = 500;
function eventHandle() {
  if (eventStore.length) {
    eventStore.forEach(function(item) {
      item.tarList.forEach(function(observer) {
        var target = observer.target, width2 = observer.width, heighe = observer.heighe;
        var clientWidth = target.clientWidth;
        var clientHeight = target.clientHeight;
        var rWidth = clientWidth && width2 !== clientWidth;
        var rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, GlobalConfig.resizeInterval || defaultInterval);
}
var XEResizeObserver = function() {
  function XEResizeObserver2(callback) {
    this.tarList = [];
    this.callback = callback;
  }
  XEResizeObserver2.prototype.observe = function(target) {
    var _this = this;
    if (target) {
      var tarList = this.tarList;
      if (!tarList.some(function(observer) {
        return observer.target === target;
      })) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!eventStore.length) {
        eventListener();
      }
      if (!eventStore.some(function(item) {
        return item === _this;
      })) {
        eventStore.push(this);
      }
    }
  };
  XEResizeObserver2.prototype.unobserve = function(target) {
    xeUtils.remove(eventStore, function(item) {
      return item.tarList.some(function(observer) {
        return observer.target === target;
      });
    });
  };
  XEResizeObserver2.prototype.disconnect = function() {
    var _this = this;
    xeUtils.remove(eventStore, function(item) {
      return item === _this;
    });
  };
  return XEResizeObserver2;
}();
function createResizeEvent(callback) {
  if (window.ResizeObserver) {
    return new window.ResizeObserver(callback);
  }
  return new XEResizeObserver(callback);
}
var VxeListComponent = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: function() {
      return GlobalConfig.list.size || GlobalConfig.size;
    } },
    autoResize: { type: Boolean, default: function() {
      return GlobalConfig.list.autoResize;
    } },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    var refElem = ref$1();
    var refVirtualWrapper = ref$1();
    var refVirtualBody = ref$1();
    var internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    var refMaps = {
      refElem
    };
    var $xelist = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var listMethods = {};
    var computeSYOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.list.scrollY, props.scrollY);
    });
    var computeStyles = computed$1(function() {
      var height2 = props.height, maxHeight = props.maxHeight;
      var style = {};
      if (height2) {
        style.height = "".concat(isNaN(height2) ? height2 : "".concat(height2, "px"));
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = "".concat(isNaN(maxHeight) ? maxHeight : "".concat(maxHeight, "px"));
      }
      return style;
    });
    var updateYSpace = function() {
      var scrollYLoad = reactData.scrollYLoad;
      var scrollYStore = internalData.scrollYStore, fullData = internalData.fullData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    var handleData = function() {
      var scrollYLoad = reactData.scrollYLoad;
      var fullData = internalData.fullData, scrollYStore = internalData.scrollYStore;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick$1();
    };
    var updateYData = function() {
      handleData();
      updateYSpace();
    };
    var computeScrollLoad = function() {
      return nextTick$1().then(function() {
        var scrollYLoad = reactData.scrollYLoad;
        var scrollYStore = internalData.scrollYStore;
        var virtualBodyElem = refVirtualBody.value;
        var sYOpts = computeSYOpts.value;
        var rowHeight = 0;
        var firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          var scrollBodyElem = refVirtualWrapper.value;
          var visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          var offsetYSize = sYOpts.oSize ? xeUtils.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    var clearScroll = function() {
      var scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick$1();
    };
    var scrollTo = function(scrollLeft, scrollTop) {
      var scrollBodyElem = refVirtualWrapper.value;
      if (xeUtils.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (xeUtils.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise(function(resolve) {
          return setTimeout(function() {
            return resolve(nextTick$1());
          }, 50);
        });
      }
      return nextTick$1();
    };
    var refreshScroll = function() {
      var lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;
      return clearScroll().then(function() {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    var recalculate = function() {
      var el2 = refElem.value;
      if (el2.clientWidth && el2.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    var loadYData = function(evnt) {
      var scrollYStore = internalData.scrollYStore;
      var startIndex = scrollYStore.startIndex, endIndex = scrollYStore.endIndex, visibleSize = scrollYStore.visibleSize, offsetSize = scrollYStore.offsetSize, rowHeight = scrollYStore.rowHeight;
      var scrollBodyElem = evnt.target;
      var scrollTop = scrollBodyElem.scrollTop;
      var toVisibleIndex = Math.floor(scrollTop / rowHeight);
      var offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      var offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    var scrollEvent = function(evnt) {
      var scrollBodyElem = evnt.target;
      var scrollTop = scrollBodyElem.scrollTop;
      var scrollLeft = scrollBodyElem.scrollLeft;
      var isX = scrollLeft !== internalData.lastScrollLeft;
      var isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    listMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $list: $xelist, $event: evnt }, params));
      },
      loadData: function(datas) {
        var scrollYStore = internalData.scrollYStore;
        var sYOpts = computeSYOpts.value;
        var fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && sYOpts.gt <= fullData.length;
        handleData();
        return computeScrollLoad().then(function() {
          refreshScroll();
        });
      },
      reloadData: function(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xelist, listMethods);
    watch$1(function() {
      return props.data;
    }, function(value) {
      listMethods.loadData(value || []);
    });
    watch$1(function() {
      return props.syncResize;
    }, function(value) {
      if (value) {
        recalculate();
        nextTick$1(function() {
          return setTimeout(function() {
            return recalculate();
          });
        });
      }
    });
    var resizeObserver;
    nextTick$1(function() {
      GlobalEvent.on($xelist, "resize", function() {
        recalculate();
      });
      if (props.autoResize) {
        var el2 = refElem.value;
        resizeObserver = createResizeEvent(function() {
          return recalculate();
        });
        resizeObserver.observe(el2);
      }
      listMethods.loadData(props.data || []);
    });
    onUnmounted(function() {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      GlobalEvent.off($xelist, "resize");
    });
    var renderVN = function() {
      var _a2;
      var className = props.className, loading = props.loading;
      var bodyHeight = reactData.bodyHeight, topSpaceHeight = reactData.topSpaceHeight, items = reactData.items;
      var vSize = computeSize.value;
      var styles = computeStyles.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-list", className ? xeUtils.isFunction(className) ? className({ $list: $xelist }) : className : "", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--loading"] = loading, _a2)]
      }, [
        h$6("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h$6("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? "".concat(bodyHeight, "px") : ""
            }
          }),
          h$6("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? "".concat(topSpaceHeight, "px") : ""
            }
          }, slots.default ? slots.default({ items, $list: $xelist }) : [])
        ]),
        h$6(VxeLoading, {
          class: "vxe-list--loading",
          modelValue: loading
        })
      ]);
    };
    $xelist.renderVN = renderVN;
    return $xelist;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeListComponent, {
  install: function(app) {
    app.component(VxeListComponent.name, VxeListComponent);
  }
});
dynamicApp.component(VxeListComponent.name, VxeListComponent);
var VxePulldownComponent = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    size: { type: String, default: function() {
      return GlobalConfig.size;
    } },
    destroyOnClose: Boolean,
    transfer: Boolean
  },
  emits: [
    "update:modelValue",
    "hide-panel"
  ],
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var reactData = reactive$1({
      inited: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    var refElem = ref$1();
    var refPulldowContent = ref$1();
    var refPulldowPnanel = ref$1();
    var refMaps = {
      refElem
    };
    var $xepulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: function() {
        return refMaps;
      }
    };
    var pulldownMethods = {};
    var updateZindex = function() {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    var isPanelVisible = function() {
      return reactData.visiblePanel;
    };
    var updatePlacement = function() {
      return nextTick$1().then(function() {
        var transfer = props.transfer, placement = props.placement;
        var panelIndex = reactData.panelIndex, visiblePanel = reactData.visiblePanel;
        if (visiblePanel) {
          var targetElem = refPulldowContent.value;
          var panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            var targetHeight = targetElem.offsetHeight;
            var targetWidth = targetElem.offsetWidth;
            var panelHeight = panelElem.offsetHeight;
            var panelWidth = panelElem.offsetWidth;
            var marginSize = 5;
            var panelStyle = {
              zIndex: panelIndex
            };
            var _a2 = getAbsolutePos(targetElem), boundingTop = _a2.boundingTop, boundingLeft = _a2.boundingLeft, visibleHeight = _a2.visibleHeight, visibleWidth = _a2.visibleWidth;
            var panelPlacement = "bottom";
            if (transfer) {
              var left = boundingLeft;
              var top_1 = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top_1 = boundingTop - panelHeight;
              } else if (!placement) {
                if (top_1 + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top_1 = boundingTop - panelHeight;
                }
                if (top_1 < marginSize) {
                  panelPlacement = "bottom";
                  top_1 = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: "".concat(left, "px"),
                top: "".concat(top_1, "px"),
                minWidth: "".concat(targetWidth, "px")
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = "".concat(targetHeight, "px");
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = "".concat(targetHeight, "px");
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick$1();
      });
    };
    var hidePanelTimeout;
    var showPanel = function() {
      if (!reactData.inited) {
        reactData.inited = true;
      }
      return new Promise(function(resolve) {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(function() {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(function() {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          resolve(nextTick$1());
        }
      });
    };
    var hidePanel = function() {
      reactData.visiblePanel = false;
      emit("update:modelValue", false);
      return new Promise(function(resolve) {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(function() {
            reactData.animatVisible = false;
            resolve(nextTick$1());
          }, 350);
        } else {
          resolve(nextTick$1());
        }
      });
    };
    var togglePanel = function() {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    var handleGlobalMousewheelEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      var panelElem = refPulldowPnanel.value;
      if (!disabled3) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
          }
        }
      }
    };
    var handleGlobalMousedownEvent = function(evnt) {
      var disabled3 = props.disabled;
      var visiblePanel = reactData.visiblePanel;
      var el2 = refElem.value;
      var panelElem = refPulldowPnanel.value;
      if (!disabled3) {
        reactData.isActivated = getEventTargetNode(evnt, el2).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
        }
      }
    };
    var handleGlobalBlurEvent = function(evnt) {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
      }
    };
    pulldownMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $pulldown: $xepulldown, $event: evnt }, params));
      },
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xepulldown, pulldownMethods);
    watch$1(function() {
      return props.modelValue;
    }, function(value) {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick$1(function() {
      GlobalEvent.on($xepulldown, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xepulldown, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xepulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(function() {
      GlobalEvent.off($xepulldown, "mousewheel");
      GlobalEvent.off($xepulldown, "mousedown");
      GlobalEvent.off($xepulldown, "blur");
    });
    var renderVN = function() {
      var _a2, _b2;
      var destroyOnClose = props.destroyOnClose, transfer = props.transfer, disabled3 = props.disabled;
      var inited = reactData.inited, isActivated = reactData.isActivated, animatVisible = reactData.animatVisible, visiblePanel = reactData.visiblePanel, panelStyle = reactData.panelStyle, panelPlacement = reactData.panelPlacement;
      var vSize = computeSize.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-pulldown", (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["is--visivle"] = visiblePanel, _a2["is--disabled"] = disabled3, _a2["is--active"] = isActivated, _a2)]
      }, [
        h$6("div", {
          ref: refPulldowContent,
          class: "vxe-pulldown--content"
        }, slots.default ? slots.default({ $pulldown: $xepulldown }) : []),
        h$6(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h$6("div", {
            ref: refPulldowPnanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", (_b2 = {}, _b2["size--".concat(vSize)] = vSize, _b2["is--transfer"] = transfer, _b2["animat--leave"] = animatVisible, _b2["animat--enter"] = visiblePanel, _b2)],
            placement: panelPlacement,
            style: panelStyle
          }, slots.dropdown ? [
            h$6("div", {
              class: "vxe-pulldown--wrapper"
            }, !inited || destroyOnClose && !visiblePanel && !animatVisible ? [] : slots.dropdown({ $pulldown: $xepulldown }))
          ] : [])
        ])
      ]);
    };
    $xepulldown.renderVN = renderVN;
    return $xepulldown;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxePulldownComponent, {
  install: function(app) {
    app.component(VxePulldownComponent.name, VxePulldownComponent);
  }
});
dynamicApp.component(VxePulldownComponent.name, VxePulldownComponent);
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var renderType$2 = "body";
var lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
var TableBodyComponent = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var xesize = inject("xesize", null);
    var xID = $xetable.xID, tableProps2 = $xetable.props, tableContext = $xetable.context, tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;
    var _a2 = $xetable.getRefMaps(), refTableHeader = _a2.refTableHeader, refTableBody = _a2.refTableBody, refTableFooter = _a2.refTableFooter, refTableLeftBody = _a2.refTableLeftBody, refTableRightBody = _a2.refTableRightBody, refValidTooltip = _a2.refValidTooltip;
    var _b2 = $xetable.getComputeMaps(), computeEditOpts = _b2.computeEditOpts, computeMouseOpts = _b2.computeMouseOpts, computeSYOpts = _b2.computeSYOpts, computeEmptyOpts = _b2.computeEmptyOpts, computeKeyboardOpts = _b2.computeKeyboardOpts, computeTooltipOpts = _b2.computeTooltipOpts, computeRadioOpts = _b2.computeRadioOpts, computeExpandOpts = _b2.computeExpandOpts, computeTreeOpts = _b2.computeTreeOpts, computeCheckboxOpts = _b2.computeCheckboxOpts, computeValidOpts = _b2.computeValidOpts, computeRowOpts = _b2.computeRowOpts, computeColumnOpts = _b2.computeColumnOpts;
    var refElem = ref$1();
    var refBodyTable = ref$1();
    var refBodyColgroup = ref$1();
    var refBodyTBody = ref$1();
    var refBodyXSpace = ref$1();
    var refBodyYSpace = ref$1();
    var refBodyEmptyBlock = ref$1();
    var getOffsetSize = function() {
      if (xesize) {
        var vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    var countTreeExpand = function(prevRow, params) {
      var count = 1;
      if (!prevRow) {
        return count;
      }
      var treeOpts = computeTreeOpts.value;
      var rowChildren = prevRow[treeOpts.children];
      if ($xetable.isTreeExpandByRow(prevRow)) {
        for (var index = 0; index < rowChildren.length; index++) {
          count += countTreeExpand(rowChildren[index]);
        }
      }
      return count;
    };
    var calcTreeLine = function(params, items, rIndex) {
      var expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1]);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    var isOperateMouse = function() {
      var delayHover = tableProps2.delayHover;
      var lastScrollTime = tableInternalData.lastScrollTime, _isResize = tableInternalData._isResize;
      return _isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover;
    };
    var renderLine = function(params) {
      var row2 = params.row, column2 = params.column;
      var treeConfig = tableProps2.treeConfig;
      var treeOpts = computeTreeOpts.value;
      var slots = column2.slots, treeNode = column2.treeNode;
      var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;
      var rowid = getRowid($xetable, row2);
      var rest = fullAllDataRowIdData[rowid];
      var rLevel = 0;
      var rIndex = 0;
      var items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xetable.callSlot(slots.line, params);
      }
      if (treeConfig && treeNode && treeOpts.line) {
        return [
          h$6("div", {
            class: "vxe-tree--line-wrapper"
          }, [
            h$6("div", {
              class: "vxe-tree--line",
              style: {
                height: "".concat(calcTreeLine(params, items, rIndex), "px"),
                left: "".concat(rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16, "px")
              }
            })
          ])
        ];
      }
      return [];
    };
    var renderColumn = function(seq, rowid, fixedType, rowLevel, row2, rowIndex, $rowIndex, _rowIndex, column2, $columnIndex, columns, items) {
      var _a3;
      var columnKey = tableProps2.columnKey, height2 = tableProps2.height, allColumnOverflow = tableProps2.showOverflow, allCellClassName = tableProps2.cellClassName, cellStyle = tableProps2.cellStyle, allAlign = tableProps2.align, spanMethod = tableProps2.spanMethod, mouseConfig = tableProps2.mouseConfig, editConfig = tableProps2.editConfig, editRules = tableProps2.editRules, tooltipConfig = tableProps2.tooltipConfig;
      var tableData = tableReactData.tableData, overflowX = tableReactData.overflowX, scrollYLoad = tableReactData.scrollYLoad, currentColumn = tableReactData.currentColumn, mergeList = tableReactData.mergeList, editStore = tableReactData.editStore, validStore = tableReactData.validStore, isAllOverflow = tableReactData.isAllOverflow;
      var afterFullData = tableInternalData.afterFullData;
      var validOpts = computeValidOpts.value;
      var checkboxOpts = computeCheckboxOpts.value;
      var editOpts = computeEditOpts.value;
      var tooltipOpts = computeTooltipOpts.value;
      var rowOpts = computeRowOpts.value;
      var sYOpts = computeSYOpts.value;
      var columnOpts = computeColumnOpts.value;
      var type2 = column2.type, cellRender = column2.cellRender, editRender = column2.editRender, align = column2.align, showOverflow = column2.showOverflow, className = column2.className, treeNode = column2.treeNode;
      var actived = editStore.actived;
      var scrollYRHeight = sYOpts.rHeight;
      var rowHeight = rowOpts.height;
      var renderOpts = editRender || cellRender;
      var compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;
      var cellClassName = compConf ? compConf.cellClassName : "";
      var showAllTip = tooltipOpts.showAll;
      var columnIndex = $xetable.getColumnIndex(column2);
      var _columnIndex = $xetable.getVTColumnIndex(column2);
      var isEdit = isEnableConf(editRender);
      var fixedHiddenColumn = fixedType ? column2.fixed !== fixedType : column2.fixed && overflowX;
      var cellOverflow = xeUtils.isUndefined(showOverflow) || xeUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;
      var showEllipsis = cellOverflow === "ellipsis";
      var showTitle = cellOverflow === "title";
      var showTooltip2 = cellOverflow === true || cellOverflow === "tooltip";
      var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
      var isDirty;
      var tdOns = {};
      var cellAlign = align || allAlign;
      var hasValidError = validStore.row === row2 && validStore.column === column2;
      var showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height2 || tableData.length > 1 : validOpts.message === "inline");
      var attrs2 = { colid: column2.id };
      var params = { $table: $xetable, seq, rowid, row: row2, rowIndex, $rowIndex, _rowIndex, column: column2, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType$2, isHidden: fixedHiddenColumn, level: rowLevel, visibleData: afterFullData, data: tableData, items };
      if (scrollYLoad && !hasEllipsis) {
        showEllipsis = hasEllipsis = true;
      }
      if (showTitle || showTooltip2 || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = function(evnt) {
          if (isOperateMouse()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column2);
          } else if (showTooltip2 || showAllTip) {
            $xetable.triggerBodyTooltipEvent(evnt, params);
          }
          $xetable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (showTooltip2 || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = function(evnt) {
          if (isOperateMouse()) {
            return;
          }
          if (showTooltip2 || showAllTip) {
            $xetable.handleTargetLeaveEvent(evnt);
          }
          $xetable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = function(evnt) {
          $xetable.triggerCellMousedownEvent(evnt, params);
        };
      }
      tdOns.onClick = function(evnt) {
        $xetable.triggerCellClickEvent(evnt, params);
      };
      tdOns.onDblclick = function(evnt) {
        $xetable.triggerCellDblclickEvent(evnt, params);
      };
      if (mergeList.length) {
        var spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          var rowspan = spanRest.rowspan, colspan = spanRest.colspan;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs2.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs2.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        var _b3 = spanMethod(params) || {}, _c2 = _b3.rowspan, rowspan = _c2 === void 0 ? 1 : _c2, _d2 = _b3.colspan, colspan = _d2 === void 0 ? 1 : _d2;
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs2.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs2.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (attrs2.colspan > 1 || attrs2.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xetable.isUpdateByRow(row2, column2.field);
      }
      var tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push(h$6("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip2,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? "".concat(scrollYRHeight || rowHeight, "px") : ""
          }
        }));
      } else {
        tdVNs.push.apply(tdVNs, __spreadArray$1(__spreadArray$1([], renderLine(params), false), [h$6("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip2,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? "".concat(scrollYRHeight || rowHeight, "px") : ""
          },
          title: showTitle ? $xetable.getCellLabel(row2, column2) : null
        }, column2.renderCell(params))], false));
        if (showValidTip && hasValidError) {
          tdVNs.push(h$6("div", {
            class: "vxe-cell--valid",
            style: validStore.rule && validStore.rule.maxWidth ? {
              width: "".concat(validStore.rule.maxWidth, "px")
            } : null
          }, [
            h$6("span", {
              class: "vxe-cell--valid-msg"
            }, validStore.content)
          ]));
        }
      }
      return h$6("td", __assign$4(__assign$4(__assign$4({ class: [
        "vxe-body--column",
        column2.id,
        (_a3 = {}, _a3["col--".concat(cellAlign)] = cellAlign, _a3["col--".concat(type2)] = type2, _a3["col--last"] = $columnIndex === columns.length - 1, _a3["col--tree-node"] = treeNode, _a3["col--edit"] = isEdit, _a3["col--ellipsis"] = hasEllipsis, _a3["fixed--hidden"] = fixedHiddenColumn, _a3["col--dirty"] = isDirty, _a3["col--actived"] = editConfig && isEdit && (actived.row === row2 && (actived.column === column2 || editOpts.mode === "row")), _a3["col--valid-error"] = hasValidError, _a3["col--current"] = currentColumn === column2, _a3),
        getPropClass(cellClassName, params),
        getPropClass(className, params),
        getPropClass(allCellClassName, params)
      ], key: columnKey || columnOpts.useKey ? column2.id : $columnIndex }, attrs2), { style: Object.assign({
        height: hasEllipsis && (scrollYRHeight || rowHeight) ? "".concat(scrollYRHeight || rowHeight, "px") : ""
      }, cellStyle ? xeUtils.isFunction(cellStyle) ? cellStyle(params) : cellStyle : null) }), tdOns), tdVNs);
    };
    var renderRows = function(fixedType, tableData, tableColumn) {
      var stripe = tableProps2.stripe, rowKey = tableProps2.rowKey, highlightHoverRow = tableProps2.highlightHoverRow, rowClassName = tableProps2.rowClassName, rowStyle = tableProps2.rowStyle, allColumnOverflow = tableProps2.showOverflow, editConfig = tableProps2.editConfig, treeConfig = tableProps2.treeConfig;
      var hasFixedColumn = tableReactData.hasFixedColumn, treeExpandeds = tableReactData.treeExpandeds, scrollYLoad = tableReactData.scrollYLoad, editStore = tableReactData.editStore, rowExpandeds = tableReactData.rowExpandeds, expandColumn = tableReactData.expandColumn, selectRow = tableReactData.selectRow;
      var fullAllDataRowIdData = tableInternalData.fullAllDataRowIdData;
      var checkboxOpts = computeCheckboxOpts.value;
      var radioOpts = computeRadioOpts.value;
      var treeOpts = computeTreeOpts.value;
      var editOpts = computeEditOpts.value;
      var rowOpts = computeRowOpts.value;
      var transform = treeOpts.transform;
      var rows = [];
      tableData.forEach(function(row2, $rowIndex) {
        var trOn = {};
        var rowIndex = $rowIndex;
        rowIndex = $xetable.getRowIndex(row2);
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = function(evnt) {
            if (isOperateMouse()) {
              return;
            }
            $xetable.triggerHoverEvent(evnt, { row: row2, rowIndex });
          };
          trOn.onMouseleave = function() {
            if (isOperateMouse()) {
              return;
            }
            $xetable.clearHoverRow();
          };
        }
        var rowid = getRowid($xetable, row2);
        var rest = fullAllDataRowIdData[rowid];
        var rowLevel = 0;
        var seq = -1;
        var _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          seq = rest.seq;
          _rowIndex = rest._index;
        }
        var params = { $table: $xetable, seq, rowid, fixed: fixedType, type: renderType$2, level: rowLevel, row: row2, rowIndex, $rowIndex, _rowIndex };
        var isExpandRow = expandColumn && rowExpandeds.length && $xetable.findRowIndexOf(rowExpandeds, row2) > -1;
        var isExpandTree = false;
        var rowChildren = [];
        var isNewRow = false;
        if (editConfig) {
          isNewRow = $xetable.findRowIndexOf(editStore.insertList, row2) > -1;
        }
        if (treeConfig && !scrollYLoad && !transform && treeExpandeds.length) {
          rowChildren = row2[treeOpts.children];
          isExpandTree = rowChildren && rowChildren.length && $xetable.findRowIndexOf(treeExpandeds, row2) > -1;
        }
        rows.push(h$6("tr", __assign$4({ class: [
          "vxe-body--row",
          treeConfig ? "row--level-".concat(rowLevel) : "",
          {
            "row--stripe": stripe && ($xetable.getVTRowIndex(row2) + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && selectRow === row2,
            "row--checked": checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row2)
          },
          getPropClass(rowClassName, params)
        ], rowid, style: rowStyle ? xeUtils.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || treeConfig ? rowid : $rowIndex }, trOn), tableColumn.map(function(column2, $columnIndex) {
          return renderColumn(seq, rowid, fixedType, rowLevel, row2, rowIndex, $rowIndex, _rowIndex, column2, $columnIndex, tableColumn, tableData);
        })));
        if (isExpandRow) {
          var expandOpts = computeExpandOpts.value;
          var expandHeight = expandOpts.height;
          var cellStyle = {};
          if (expandHeight) {
            cellStyle.height = "".concat(expandHeight, "px");
          }
          if (treeConfig) {
            cellStyle.paddingLeft = "".concat(rowLevel * treeOpts.indent + 30, "px");
          }
          var showOverflow = expandColumn.showOverflow;
          var hasEllipsis = xeUtils.isUndefined(showOverflow) || xeUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          var expandParams = { $table: $xetable, seq, column: expandColumn, fixed: fixedType, type: renderType$2, level: rowLevel, row: row2, rowIndex, $rowIndex, _rowIndex };
          rows.push(h$6("tr", __assign$4({ class: "vxe-body--expanded-row", key: "expand_".concat(rowid), style: rowStyle ? xeUtils.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null }, trOn), [
            h$6("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": fixedType && !hasFixedColumn,
                "col--ellipsis": hasEllipsis
              },
              colspan: tableColumn.length
            }, [
              h$6("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": expandHeight
                },
                style: cellStyle
              }, [
                expandColumn.renderData(expandParams)
              ])
            ])
          ]));
        }
        if (treeConfig && !scrollYLoad && !transform && treeExpandeds.length) {
          var rowChildren_1 = row2[treeOpts.children];
          if (rowChildren_1 && rowChildren_1.length && $xetable.findRowIndexOf(treeExpandeds, row2) > -1) {
            rows.push.apply(rows, renderRows(fixedType, rowChildren_1, tableColumn));
          }
        }
      });
      return rows;
    };
    var scrollProcessTimeout;
    var syncBodyScroll = function(fixedType, scrollTop, elem1, elem2) {
      if (elem1 || elem2) {
        if (elem1) {
          removeScrollListener(elem1);
          elem1.scrollTop = scrollTop;
        }
        if (elem2) {
          removeScrollListener(elem2);
          elem2.scrollTop = scrollTop;
        }
        clearTimeout(scrollProcessTimeout);
        scrollProcessTimeout = setTimeout(function() {
          restoreScrollListener(elem1);
          restoreScrollListener(elem2);
        }, 300);
      }
    };
    var scrollEvent = function(evnt) {
      var fixedType = props.fixedType;
      var highlightHoverRow = tableProps2.highlightHoverRow;
      var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;
      var elemStore = tableInternalData.elemStore, lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;
      var rowOpts = computeRowOpts.value;
      var tableHeader = refTableHeader.value;
      var tableBody = refTableBody.value;
      var tableFooter = refTableFooter.value;
      var leftBody = refTableLeftBody.value;
      var rightBody = refTableRightBody.value;
      var validTip = refValidTooltip.value;
      var scrollBodyElem = refElem.value;
      var headerElem = tableHeader ? tableHeader.$el : null;
      var footerElem = tableFooter ? tableFooter.$el : null;
      var bodyElem = tableBody.$el;
      var leftElem = leftBody ? leftBody.$el : null;
      var rightElem = rightBody ? rightBody.$el : null;
      var bodyYRef = elemStore["main-body-ySpace"];
      var bodyYElem = bodyYRef ? bodyYRef.value : null;
      var bodyXRef = elemStore["main-body-xSpace"];
      var bodyXElem = bodyXRef ? bodyXRef.value : null;
      var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      var scrollTop = scrollBodyElem.scrollTop;
      var scrollLeft = bodyElem.scrollLeft;
      var isRollX = scrollLeft !== lastScrollLeft;
      var isRollY = scrollTop !== lastScrollTop;
      tableInternalData.lastScrollTop = scrollTop;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableInternalData.lastScrollTime = Date.now();
      if (rowOpts.isHover || highlightHoverRow) {
        $xetable.clearHoverRow();
      }
      if (leftElem && fixedType === "left") {
        scrollTop = leftElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);
      } else if (rightElem && fixedType === "right") {
        scrollTop = rightElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);
      } else {
        if (isRollX) {
          if (headerElem) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
          if (footerElem) {
            footerElem.scrollLeft = bodyElem.scrollLeft;
          }
        }
        if (leftElem || rightElem) {
          $xetable.checkScrolling();
          if (isRollY) {
            syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);
          }
        }
      }
      if (scrollXLoad && isRollX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (scrollYLoad && isRollY) {
        $xetable.triggerScrollYEvent(evnt);
      }
      if (isRollX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", {
        type: renderType$2,
        fixed: fixedType,
        scrollTop,
        scrollLeft,
        scrollHeight: bodyElem.scrollHeight,
        scrollWidth: bodyElem.scrollWidth,
        bodyHeight,
        bodyWidth,
        isX: isRollX,
        isY: isRollY
      }, evnt);
    };
    var wheelTime;
    var wheelYSize = 0;
    var wheelYInterval = 0;
    var wheelYTotal = 0;
    var isPrevWheelTop = false;
    var handleWheel = function(evnt, isTopWheel, deltaTop, isRollX, isRollY) {
      var elemStore = tableInternalData.elemStore;
      var scrollXLoad = tableReactData.scrollXLoad, scrollYLoad = tableReactData.scrollYLoad;
      var tableBody = refTableBody.value;
      var leftBody = refTableLeftBody.value;
      var rightBody = refTableRightBody.value;
      var leftElem = leftBody ? leftBody.$el : null;
      var rightElem = rightBody ? rightBody.$el : null;
      var bodyElem = tableBody.$el;
      var bodyYRef = elemStore["main-body-ySpace"];
      var bodyYElem = bodyYRef ? bodyYRef.value : null;
      var bodyXRef = elemStore["main-body-xSpace"];
      var bodyXElem = bodyXRef ? bodyXRef.value : null;
      var bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      var bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      var remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      var handleSmooth = function() {
        if (wheelYTotal < wheelYSize) {
          var fixedType = props.fixedType;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          var scrollTop = bodyElem.scrollTop, clientHeight = bodyElem.clientHeight, scrollHeight = bodyElem.scrollHeight;
          var targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xetable.dispatchEvent("scroll", {
            type: renderType$2,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    var wheelEvent = function(evnt) {
      var deltaY = evnt.deltaY, deltaX = evnt.deltaX;
      var highlightHoverRow = tableProps2.highlightHoverRow;
      var scrollYLoad = tableReactData.scrollYLoad;
      var lastScrollTop = tableInternalData.lastScrollTop, lastScrollLeft = tableInternalData.lastScrollLeft;
      var rowOpts = computeRowOpts.value;
      var tableBody = refTableBody.value;
      var scrollBodyElem = refElem.value;
      var bodyElem = tableBody.$el;
      var deltaTop = deltaY;
      var deltaLeft = deltaX;
      var isTopWheel = deltaTop < 0;
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      var scrollTop = scrollBodyElem.scrollTop + deltaTop;
      var scrollLeft = bodyElem.scrollLeft + deltaLeft;
      var isRollX = scrollLeft !== lastScrollLeft;
      var isRollY = scrollTop !== lastScrollTop;
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableInternalData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xetable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xetable.triggerScrollYEvent(evnt);
        }
      }
    };
    onMounted$1(function() {
      nextTick$1(function() {
        var fixedType = props.fixedType;
        var elemStore = tableInternalData.elemStore;
        var prefix = "".concat(fixedType || "main", "-body-");
        var el2 = refElem.value;
        elemStore["".concat(prefix, "wrapper")] = refElem;
        elemStore["".concat(prefix, "table")] = refBodyTable;
        elemStore["".concat(prefix, "colgroup")] = refBodyColgroup;
        elemStore["".concat(prefix, "list")] = refBodyTBody;
        elemStore["".concat(prefix, "xSpace")] = refBodyXSpace;
        elemStore["".concat(prefix, "ySpace")] = refBodyYSpace;
        elemStore["".concat(prefix, "emptyBlock")] = refBodyEmptyBlock;
        el2.onscroll = scrollEvent;
        el2._onscroll = scrollEvent;
      });
    });
    onBeforeUnmount(function() {
      var el2 = refElem.value;
      clearTimeout(wheelTime);
      el2._onscroll = null;
      el2.onscroll = null;
    });
    onUnmounted(function() {
      var fixedType = props.fixedType;
      var elemStore = tableInternalData.elemStore;
      var prefix = "".concat(fixedType || "main", "-body-");
      elemStore["".concat(prefix, "wrapper")] = null;
      elemStore["".concat(prefix, "table")] = null;
      elemStore["".concat(prefix, "colgroup")] = null;
      elemStore["".concat(prefix, "list")] = null;
      elemStore["".concat(prefix, "xSpace")] = null;
      elemStore["".concat(prefix, "ySpace")] = null;
      elemStore["".concat(prefix, "emptyBlock")] = null;
    });
    var renderVN = function() {
      var fixedColumn = props.fixedColumn, fixedType = props.fixedType, tableColumn = props.tableColumn;
      var keyboardConfig = tableProps2.keyboardConfig, allColumnOverflow = tableProps2.showOverflow, spanMethod = tableProps2.spanMethod, mouseConfig = tableProps2.mouseConfig;
      var tableData = tableReactData.tableData, mergeList = tableReactData.mergeList, scrollYLoad = tableReactData.scrollYLoad, isAllOverflow = tableReactData.isAllOverflow;
      var visibleColumn = tableInternalData.visibleColumn;
      var slots = tableContext.slots;
      var sYOpts = computeSYOpts.value;
      var emptyOpts = computeEmptyOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var mouseOpts = computeMouseOpts.value;
      if (fixedType) {
        if (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      var emptyContent;
      if (slots.empty) {
        emptyContent = $xetable.callSlot(slots.empty, { $table: $xetable });
      } else {
        var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        var renderEmpty = compConf ? compConf.renderEmpty : null;
        if (renderEmpty) {
          emptyContent = renderEmpty(emptyOpts, { $table: $xetable });
        } else {
          emptyContent = tableProps2.emptyText || GlobalConfig.i18n("vxe.table.emptyText");
        }
      }
      return h$6("div", __assign$4({ ref: refElem, class: ["vxe-table--body-wrapper", fixedType ? "fixed-".concat(fixedType, "--wrapper") : "body--wrapper"], xid: xID }, sYOpts.mode === "wheel" ? { onWheel: wheelEvent } : {}), [
        fixedType ? createCommentVNode() : h$6("div", {
          ref: refBodyXSpace,
          class: "vxe-body--x-space"
        }),
        h$6("div", {
          ref: refBodyYSpace,
          class: "vxe-body--y-space"
        }),
        h$6("table", {
          ref: refBodyTable,
          class: "vxe-table--body",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("colgroup", {
            ref: refBodyColgroup
          }, tableColumn.map(function(column2, $columnIndex) {
            return h$6("col", {
              name: column2.id,
              key: $columnIndex
            });
          })),
          h$6("tbody", {
            ref: refBodyTBody
          }, renderRows(fixedType, tableData, tableColumn))
        ]),
        h$6("div", {
          class: "vxe-table--checkbox-range"
        }),
        mouseConfig && mouseOpts.area ? h$6("div", {
          class: "vxe-table--cell-area"
        }, [
          h$6("span", {
            class: "vxe-table--cell-main-area"
          }, mouseOpts.extension ? [
            h$6("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown: function(evnt) {
                $xetable.triggerCellExtendMousedownEvent(evnt, { $table: $xetable, fixed: fixedType, type: renderType$2 });
              }
            })
          ] : []),
          h$6("span", {
            class: "vxe-table--cell-copy-area"
          }),
          h$6("span", {
            class: "vxe-table--cell-extend-area"
          }),
          h$6("span", {
            class: "vxe-table--cell-multi-area"
          }),
          h$6("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : null,
        !fixedType ? h$6("div", {
          class: "vxe-table--empty-block",
          ref: refBodyEmptyBlock
        }, [
          h$6("div", {
            class: "vxe-table--empty-content"
          }, emptyContent)
        ]) : null
      ]);
    };
    return renderVN;
  }
});
var getAllColumns = function(columns, parentColumn) {
  var result = [];
  columns.forEach(function(column2) {
    column2.parentId = parentColumn ? parentColumn.id : null;
    if (column2.visible) {
      if (column2.children && column2.children.length && column2.children.some(function(column3) {
        return column3.visible;
      })) {
        result.push(column2);
        result.push.apply(result, getAllColumns(column2.children, column2));
      } else {
        result.push(column2);
      }
    }
  });
  return result;
};
var convertToRows = function(originColumns) {
  var maxLevel = 1;
  var traverse = function(column2, parent2) {
    if (parent2) {
      column2.level = parent2.level + 1;
      if (maxLevel < column2.level) {
        maxLevel = column2.level;
      }
    }
    if (column2.children && column2.children.length && column2.children.some(function(column3) {
      return column3.visible;
    })) {
      var colSpan_1 = 0;
      column2.children.forEach(function(subColumn) {
        if (subColumn.visible) {
          traverse(subColumn, column2);
          colSpan_1 += subColumn.colSpan;
        }
      });
      column2.colSpan = colSpan_1;
    } else {
      column2.colSpan = 1;
    }
  };
  originColumns.forEach(function(column2) {
    column2.level = 1;
    traverse(column2);
  });
  var rows = [];
  for (var i2 = 0; i2 < maxLevel; i2++) {
    rows.push([]);
  }
  var allColumns = getAllColumns(originColumns);
  allColumns.forEach(function(column2) {
    if (column2.children && column2.children.length && column2.children.some(function(column3) {
      return column3.visible;
    })) {
      column2.rowSpan = 1;
    } else {
      column2.rowSpan = maxLevel - column2.level + 1;
    }
    rows[column2.level - 1].push(column2);
  });
  return rows;
};
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var renderType$1 = "header";
var VxeTableHeader = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var xID = $xetable.xID, tableProps2 = $xetable.props, tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;
    var _a2 = $xetable.getRefMaps(), tableRefElem = _a2.refElem, refTableBody = _a2.refTableBody, refLeftContainer = _a2.refLeftContainer, refRightContainer = _a2.refRightContainer, refCellResizeBar = _a2.refCellResizeBar;
    var computeColumnOpts = $xetable.getComputeMaps().computeColumnOpts;
    var headerColumn = ref$1([]);
    var refElem = ref$1();
    var refHeaderTable = ref$1();
    var refHeaderColgroup = ref$1();
    var refHeaderTHead = ref$1();
    var refHeaderXSpace = ref$1();
    var refHeaderBorderRepair = ref$1();
    var uploadColumn = function() {
      var isGroup = tableReactData.isGroup;
      headerColumn.value = isGroup ? convertToRows(props.tableGroupColumn) : [];
    };
    var resizeMousedown = function(evnt, params) {
      var column2 = params.column;
      var fixedType = props.fixedType;
      var tableBody = refTableBody.value;
      var leftContainerElem = refLeftContainer.value;
      var rightContainerElem = refRightContainer.value;
      var resizeBarElem = refCellResizeBar.value;
      var dragClientX = evnt.clientX;
      var wrapperElem = refElem.value;
      var dragBtnElem = evnt.target;
      var cell = params.cell = dragBtnElem.parentNode;
      var dragLeft = 0;
      var tableBodyElem = tableBody.$el;
      var pos = getOffsetPos(dragBtnElem, wrapperElem);
      var dragBtnWidth = dragBtnElem.clientWidth;
      var dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      var minInterval = getColMinWidth(params) - dragBtnOffsetWidth;
      var dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      var dragPosLeft = pos.left + dragBtnOffsetWidth;
      var domMousemove = document.onmousemove;
      var domMouseup = document.onmouseup;
      var isLeftFixed = fixedType === "left";
      var isRightFixed = fixedType === "right";
      var tableEl = tableRefElem.value;
      var fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        var siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
        var tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass$1(tempCellElem, "fixed--hidden")) {
            break;
          } else if (!hasClass$1(tempCellElem, "col--group")) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      var updateEvent = function(evnt2) {
        evnt2.stopPropagation();
        evnt2.preventDefault();
        var offsetX = evnt2.clientX - dragClientX;
        var left = dragPosLeft + offsetX;
        var scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
        }
        dragLeft = Math.max(left, dragMinLeft);
        resizeBarElem.style.left = "".concat(dragLeft - scrollLeft, "px");
      };
      tableInternalData._isResize = true;
      addClass$2(tableEl, "drag--resize");
      resizeBarElem.style.display = "block";
      document.onmousemove = updateEvent;
      document.onmouseup = function(evnt2) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        var resizeWidth = column2.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column2.resizeWidth = resizeWidth;
        resizeBarElem.style.display = "none";
        tableInternalData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xetable.analyColumnWidth();
        $xetable.recalculate(true).then(function() {
          $xetable.saveCustomResizable();
          $xetable.updateCellAreas();
          $xetable.dispatchEvent("resizable-change", __assign$3(__assign$3({}, params), { resizeWidth }), evnt2);
        });
        removeClass$2(tableEl, "drag--resize");
      };
      updateEvent(evnt);
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    watch$1(function() {
      return props.tableColumn;
    }, uploadColumn);
    onMounted$1(function() {
      nextTick$1(function() {
        var fixedType = props.fixedType;
        var internalData = $xetable.internalData;
        var elemStore = internalData.elemStore;
        var prefix = "".concat(fixedType || "main", "-header-");
        elemStore["".concat(prefix, "wrapper")] = refElem;
        elemStore["".concat(prefix, "table")] = refHeaderTable;
        elemStore["".concat(prefix, "colgroup")] = refHeaderColgroup;
        elemStore["".concat(prefix, "list")] = refHeaderTHead;
        elemStore["".concat(prefix, "xSpace")] = refHeaderXSpace;
        elemStore["".concat(prefix, "repair")] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(function() {
      var fixedType = props.fixedType;
      var internalData = $xetable.internalData;
      var elemStore = internalData.elemStore;
      var prefix = "".concat(fixedType || "main", "-header-");
      elemStore["".concat(prefix, "wrapper")] = null;
      elemStore["".concat(prefix, "table")] = null;
      elemStore["".concat(prefix, "colgroup")] = null;
      elemStore["".concat(prefix, "list")] = null;
      elemStore["".concat(prefix, "xSpace")] = null;
      elemStore["".concat(prefix, "repair")] = null;
    });
    var renderVN = function() {
      var fixedType = props.fixedType, fixedColumn = props.fixedColumn, tableColumn = props.tableColumn;
      var resizable = tableProps2.resizable, border = tableProps2.border, columnKey = tableProps2.columnKey, headerRowClassName = tableProps2.headerRowClassName, headerCellClassName = tableProps2.headerCellClassName, headerRowStyle = tableProps2.headerRowStyle, headerCellStyle = tableProps2.headerCellStyle, allColumnHeaderOverflow = tableProps2.showHeaderOverflow, allHeaderAlign = tableProps2.headerAlign, allAlign = tableProps2.align, mouseConfig = tableProps2.mouseConfig;
      var isGroup = tableReactData.isGroup, currentColumn = tableReactData.currentColumn, scrollXLoad = tableReactData.scrollXLoad, overflowX = tableReactData.overflowX, scrollbarWidth = tableReactData.scrollbarWidth;
      var columnOpts = computeColumnOpts.value;
      var headerGroups = headerColumn.value;
      if (!isGroup) {
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            tableColumn = fixedColumn;
          }
        }
        headerGroups = [tableColumn];
      }
      return h$6("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? "fixed-".concat(fixedType, "--wrapper") : "body--wrapper"],
        xid: xID
      }, [
        fixedType ? createCommentVNode() : h$6("div", {
          ref: refHeaderXSpace,
          class: "vxe-body--x-space"
        }),
        h$6("table", {
          ref: refHeaderTable,
          class: "vxe-table--header",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("colgroup", {
            ref: refHeaderColgroup
          }, tableColumn.map(function(column2, $columnIndex) {
            return h$6("col", {
              name: column2.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h$6("col", {
              name: "col_gutter"
            })
          ] : [])),
          h$6("thead", {
            ref: refHeaderTHead
          }, headerGroups.map(function(cols, $rowIndex) {
            return h$6("tr", {
              class: ["vxe-header--row", headerRowClassName ? xeUtils.isFunction(headerRowClassName) ? headerRowClassName({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType$1 }) : headerRowClassName : ""],
              style: headerRowStyle ? xeUtils.isFunction(headerRowStyle) ? headerRowStyle({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType$1 }) : headerRowStyle : null
            }, cols.map(function(column2, $columnIndex) {
              var _a3;
              var type2 = column2.type, showHeaderOverflow = column2.showHeaderOverflow, headerAlign = column2.headerAlign, align = column2.align, headerClassName = column2.headerClassName;
              var isColGroup = column2.children && column2.children.length;
              var fixedHiddenColumn = fixedType ? column2.fixed !== fixedType && !isColGroup : !!column2.fixed && overflowX;
              var headOverflow = xeUtils.isUndefined(showHeaderOverflow) || xeUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
              var headAlign = headerAlign || align || allHeaderAlign || allAlign;
              var showEllipsis = headOverflow === "ellipsis";
              var showTitle = headOverflow === "title";
              var showTooltip2 = headOverflow === true || headOverflow === "tooltip";
              var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
              var hasFilter = column2.filters && column2.filters.some(function(item) {
                return item.checked;
              });
              var columnIndex = $xetable.getColumnIndex(column2);
              var _columnIndex = $xetable.getVTColumnIndex(column2);
              var params = { $table: $xetable, $rowIndex, column: column2, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType$1, isHidden: fixedHiddenColumn, hasFilter };
              var thOns = {
                onClick: function(evnt) {
                  return $xetable.triggerHeaderCellClickEvent(evnt, params);
                },
                onDblclick: function(evnt) {
                  return $xetable.triggerHeaderCellDblclickEvent(evnt, params);
                }
              };
              if (scrollXLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (mouseConfig) {
                thOns.onMousedown = function(evnt) {
                  return $xetable.triggerHeaderCellMousedownEvent(evnt, params);
                };
              }
              return h$6("th", __assign$3(__assign$3({ class: [
                "vxe-header--column",
                column2.id,
                (_a3 = {}, _a3["col--".concat(headAlign)] = headAlign, _a3["col--".concat(type2)] = type2, _a3["col--last"] = $columnIndex === cols.length - 1, _a3["col--fixed"] = column2.fixed, _a3["col--group"] = isColGroup, _a3["col--ellipsis"] = hasEllipsis, _a3["fixed--hidden"] = fixedHiddenColumn, _a3["is--sortable"] = column2.sortable, _a3["col--filter"] = !!column2.filters, _a3["is--filter-active"] = hasFilter, _a3["col--current"] = currentColumn === column2, _a3),
                headerClassName ? xeUtils.isFunction(headerClassName) ? headerClassName(params) : headerClassName : "",
                headerCellClassName ? xeUtils.isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ""
              ], colid: column2.id, colspan: column2.colSpan > 1 ? column2.colSpan : null, rowspan: column2.rowSpan > 1 ? column2.rowSpan : null, style: headerCellStyle ? xeUtils.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null }, thOns), { key: columnKey || columnOpts.useKey || isColGroup ? column2.id : $columnIndex }), [
                h$6("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip2,
                    "c--ellipsis": showEllipsis
                  }]
                }, column2.renderHeader(params)),
                !fixedHiddenColumn && !isColGroup && (xeUtils.isBoolean(column2.resizable) ? column2.resizable : columnOpts.resizable || resizable) ? h$6("div", {
                  class: ["vxe-resizable", {
                    "is--line": !border || border === "none"
                  }],
                  onMousedown: function(evnt) {
                    return resizeMousedown(evnt, params);
                  }
                }) : null
              ]);
            }).concat(scrollbarWidth ? [
              h$6("th", {
                class: "vxe-header--gutter col--gutter"
              })
            ] : []));
          }))
        ]),
        h$6("div", {
          ref: refHeaderBorderRepair,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    return renderVN;
  }
});
var Header = Object.assign(VxeTableHeader, {
  install: function(app) {
    app.component(VxeTableHeader.name, VxeTableHeader);
  }
});
dynamicApp.component(VxeTableHeader.name, VxeTableHeader);
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var renderType = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (var mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    var _a2 = mergeFooterList[mIndex], mergeRowIndex = _a2.row, mergeColIndex = _a2.col, mergeRowspan = _a2.rowspan, mergeColspan = _a2.colspan;
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var VxeTableFooterComponent = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: { type: Array, default: function() {
      return [];
    } },
    tableColumn: { type: Array, default: function() {
      return [];
    } },
    fixedColumn: { type: Array, default: function() {
      return [];
    } },
    fixedType: { type: String, default: null }
  },
  setup: function(props) {
    var $xetable = inject("$xetable", {});
    var xID = $xetable.xID, tableProps2 = $xetable.props, tableReactData = $xetable.reactData, tableInternalData = $xetable.internalData;
    var _a2 = $xetable.getRefMaps(), refTableHeader = _a2.refTableHeader, refTableBody = _a2.refTableBody, refValidTooltip = _a2.refValidTooltip;
    var _b2 = $xetable.getComputeMaps(), computeTooltipOpts = _b2.computeTooltipOpts, computeColumnOpts = _b2.computeColumnOpts;
    var refElem = ref$1();
    var refFooterTable = ref$1();
    var refFooterColgroup = ref$1();
    var refFooterTFoot = ref$1();
    var refFooterXSpace = ref$1();
    var scrollEvent = function(evnt) {
      var fixedType = props.fixedType;
      var scrollXLoad = tableReactData.scrollXLoad;
      var lastScrollLeft = tableInternalData.lastScrollLeft;
      var validTip = refValidTooltip.value;
      var tableHeader = refTableHeader.value;
      var tableBody = refTableBody.value;
      var headerElem = tableHeader ? tableHeader.$el : null;
      var footerElem = refElem.value;
      var bodyElem = tableBody.$el;
      var scrollLeft = footerElem.scrollLeft;
      var isX = scrollLeft !== lastScrollLeft;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableInternalData.lastScrollTime = Date.now();
      if (headerElem) {
        headerElem.scrollLeft = scrollLeft;
      }
      if (bodyElem) {
        bodyElem.scrollLeft = scrollLeft;
      }
      if (scrollXLoad && isX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (isX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", { type: renderType, fixed: fixedType, scrollTop: bodyElem.scrollTop, scrollLeft, isX, isY: false }, evnt);
    };
    onMounted$1(function() {
      nextTick$1(function() {
        var fixedType = props.fixedType;
        var elemStore = tableInternalData.elemStore;
        var prefix = "".concat(fixedType || "main", "-footer-");
        elemStore["".concat(prefix, "wrapper")] = refElem;
        elemStore["".concat(prefix, "table")] = refFooterTable;
        elemStore["".concat(prefix, "colgroup")] = refFooterColgroup;
        elemStore["".concat(prefix, "list")] = refFooterTFoot;
        elemStore["".concat(prefix, "xSpace")] = refFooterXSpace;
      });
    });
    onUnmounted(function() {
      var fixedType = props.fixedType;
      var elemStore = tableInternalData.elemStore;
      var prefix = "".concat(fixedType || "main", "-footer-");
      elemStore["".concat(prefix, "wrapper")] = null;
      elemStore["".concat(prefix, "table")] = null;
      elemStore["".concat(prefix, "colgroup")] = null;
      elemStore["".concat(prefix, "list")] = null;
      elemStore["".concat(prefix, "xSpace")] = null;
    });
    var renderVN = function() {
      var fixedType = props.fixedType, fixedColumn = props.fixedColumn, tableColumn = props.tableColumn, footerTableData = props.footerTableData;
      var footerRowClassName = tableProps2.footerRowClassName, footerCellClassName = tableProps2.footerCellClassName, footerRowStyle = tableProps2.footerRowStyle, footerCellStyle = tableProps2.footerCellStyle, allFooterAlign = tableProps2.footerAlign, footerSpanMethod = tableProps2.footerSpanMethod, allAlign = tableProps2.align, columnKey = tableProps2.columnKey, allColumnFooterOverflow = tableProps2.showFooterOverflow;
      var visibleColumn = tableInternalData.visibleColumn;
      var scrollYLoad = tableReactData.scrollYLoad, overflowX = tableReactData.overflowX, scrollbarWidth = tableReactData.scrollbarWidth, currentColumn = tableReactData.currentColumn, mergeFooterList = tableReactData.mergeFooterList;
      var tooltipOpts = computeTooltipOpts.value;
      var columnOpts = computeColumnOpts.value;
      if (fixedType) {
        if (scrollYLoad || allColumnFooterOverflow) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      return h$6("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? "fixed-".concat(fixedType, "--wrapper") : "body--wrapper"],
        xid: xID,
        onScroll: scrollEvent
      }, [
        fixedType ? createCommentVNode() : h$6("div", {
          ref: refFooterXSpace,
          class: "vxe-body--x-space"
        }),
        h$6("table", {
          ref: refFooterTable,
          class: "vxe-table--footer",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h$6("colgroup", {
            ref: refFooterColgroup
          }, tableColumn.map(function(column2, $columnIndex) {
            return h$6("col", {
              name: column2.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h$6("col", {
              name: "col_gutter"
            })
          ] : [])),
          h$6("tfoot", {
            ref: refFooterTFoot
          }, footerTableData.map(function(list, _rowIndex) {
            var $rowIndex = _rowIndex;
            return h$6("tr", {
              class: ["vxe-footer--row", footerRowClassName ? xeUtils.isFunction(footerRowClassName) ? footerRowClassName({ $table: $xetable, _rowIndex, $rowIndex, fixed: fixedType, type: renderType }) : footerRowClassName : ""],
              style: footerRowStyle ? xeUtils.isFunction(footerRowStyle) ? footerRowStyle({ $table: $xetable, _rowIndex, $rowIndex, fixed: fixedType, type: renderType }) : footerRowStyle : null
            }, tableColumn.map(function(column2, $columnIndex) {
              var _a3;
              var type2 = column2.type, showFooterOverflow = column2.showFooterOverflow, footerAlign = column2.footerAlign, align = column2.align, footerClassName = column2.footerClassName;
              var showAllTip = tooltipOpts.showAll;
              var isColGroup = column2.children && column2.children.length;
              var fixedHiddenColumn = fixedType ? column2.fixed !== fixedType && !isColGroup : column2.fixed && overflowX;
              var footOverflow = xeUtils.isUndefined(showFooterOverflow) || xeUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
              var footAlign = footerAlign || align || allFooterAlign || allAlign;
              var showEllipsis = footOverflow === "ellipsis";
              var showTitle = footOverflow === "title";
              var showTooltip2 = footOverflow === true || footOverflow === "tooltip";
              var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
              var attrs2 = { colid: column2.id };
              var tfOns = {};
              var columnIndex = $xetable.getColumnIndex(column2);
              var _columnIndex = $xetable.getVTColumnIndex(column2);
              var itemIndex = _columnIndex;
              var params = { $table: $xetable, _rowIndex, $rowIndex, column: column2, columnIndex, $columnIndex, _columnIndex, itemIndex, items: list, fixed: fixedType, type: renderType, data: footerTableData };
              if (scrollYLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (showTitle || showTooltip2 || showAllTip) {
                tfOns.onMouseenter = function(evnt) {
                  if (showTitle) {
                    updateCellTitle(evnt.currentTarget, column2);
                  } else if (showTooltip2 || showAllTip) {
                    $xetable.triggerFooterTooltipEvent(evnt, params);
                  }
                };
              }
              if (showTooltip2 || showAllTip) {
                tfOns.onMouseleave = function(evnt) {
                  if (showTooltip2 || showAllTip) {
                    $xetable.handleTargetLeaveEvent(evnt);
                  }
                };
              }
              tfOns.onClick = function(evnt) {
                $xetable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, params), evnt);
              };
              tfOns.onDblclick = function(evnt) {
                $xetable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
              };
              if (mergeFooterList.length) {
                var spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
                if (spanRest) {
                  var rowspan = spanRest.rowspan, colspan = spanRest.colspan;
                  if (!rowspan || !colspan) {
                    return null;
                  }
                  if (rowspan > 1) {
                    attrs2.rowspan = rowspan;
                  }
                  if (colspan > 1) {
                    attrs2.colspan = colspan;
                  }
                }
              } else if (footerSpanMethod) {
                var _b3 = footerSpanMethod(params) || {}, _c2 = _b3.rowspan, rowspan = _c2 === void 0 ? 1 : _c2, _d2 = _b3.colspan, colspan = _d2 === void 0 ? 1 : _d2;
                if (!rowspan || !colspan) {
                  return null;
                }
                if (rowspan > 1) {
                  attrs2.rowspan = rowspan;
                }
                if (colspan > 1) {
                  attrs2.colspan = colspan;
                }
              }
              return h$6("td", __assign$2(__assign$2(__assign$2(__assign$2({ class: ["vxe-footer--column", column2.id, (_a3 = {}, _a3["col--".concat(footAlign)] = footAlign, _a3["col--".concat(type2)] = type2, _a3["col--last"] = $columnIndex === tableColumn.length - 1, _a3["fixed--hidden"] = fixedHiddenColumn, _a3["col--ellipsis"] = hasEllipsis, _a3["col--current"] = currentColumn === column2, _a3), getPropClass(footerClassName, params), getPropClass(footerCellClassName, params)] }, attrs2), { style: footerCellStyle ? xeUtils.isFunction(footerCellStyle) ? footerCellStyle(params) : footerCellStyle : null }), tfOns), { key: columnKey || columnOpts.useKey ? column2.id : $columnIndex }), [
                h$6("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip2,
                    "c--ellipsis": showEllipsis
                  }]
                }, column2.renderFooter(params))
              ]);
            }).concat(scrollbarWidth ? [
              h$6("td", {
                class: "vxe-footer--gutter col--gutter"
              })
            ] : []));
          }))
        ])
      ]);
    };
    return renderVN;
  }
});
var Footer = Object.assign(VxeTableFooterComponent, {
  install: function(app) {
    app.component(VxeTableFooterComponent.name, VxeTableFooterComponent);
  }
});
dynamicApp.component(VxeTableFooterComponent.name, VxeTableFooterComponent);
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var isWebkit = browse["-webkit"] && !browse.edge;
var resizableStorageKey = "VXE_TABLE_CUSTOM_COLUMN_WIDTH";
var visibleStorageKey = "VXE_TABLE_CUSTOM_COLUMN_VISIBLE";
var VxeTableComponent = defineComponent({
  name: "VxeTable",
  props: tableProps,
  emits: tableEmits,
  setup: function(props, context) {
    var slots = context.slots, emit = context.emit;
    var hasUseTooltip = VXETable.tooltip;
    var xID = xeUtils.uniqueId();
    var computeSize = useSize$1(props);
    var instance2 = getCurrentInstance$1();
    var reactData = reactive$1({
      staticColumns: [],
      tableGroupColumn: [],
      tableColumn: [],
      tableData: [],
      scrollXLoad: false,
      scrollYLoad: false,
      overflowY: true,
      overflowX: false,
      scrollbarWidth: 0,
      scrollbarHeight: 0,
      rowHeight: 0,
      parentHeight: 0,
      isGroup: false,
      isAllOverflow: false,
      isAllSelected: false,
      isIndeterminate: false,
      selection: [],
      currentRow: null,
      currentColumn: null,
      selectRow: null,
      footerTableData: [],
      expandColumn: null,
      treeNodeColumn: null,
      hasFixedColumn: false,
      rowExpandeds: [],
      expandLazyLoadeds: [],
      treeExpandeds: [],
      treeLazyLoadeds: [],
      treeIndeterminates: [],
      mergeList: [],
      mergeFooterList: [],
      initStore: {
        filter: false,
        import: false,
        export: false
      },
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: []
      },
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        selected: {
          row: null,
          column: null
        },
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        actived: {
          row: null,
          column: null
        },
        insertList: [],
        removeList: []
      },
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: null
      },
      validStore: {
        visible: false,
        row: null,
        column: null,
        content: "",
        rule: null,
        isArrow: false
      },
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      }
    });
    var internalData = {
      tZindex: 0,
      elemStore: {},
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      tableWidth: 0,
      tableHeight: 0,
      headerHeight: 0,
      footerHeight: 0,
      customHeight: 0,
      customMaxHeight: 0,
      hoverRow: null,
      lastScrollLeft: 0,
      lastScrollTop: 0,
      lastScrollTime: 0,
      radioReserveRow: null,
      checkboxReserveRowMap: {},
      rowExpandedReserveRowMap: {},
      treeExpandedReserveRowMap: {},
      tableFullData: [],
      afterFullData: [],
      tableFullTreeData: [],
      afterTreeFullData: [],
      tableSynchData: [],
      tableSourceData: [],
      collectColumn: [],
      tableFullColumn: [],
      visibleColumn: [],
      fullAllDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    var tableMethods = {};
    var tablePrivateMethods = {};
    var refElem = ref$1();
    var refTooltip = ref$1();
    var refCommTooltip = ref$1();
    var refValidTooltip = ref$1();
    var refTableFilter = ref$1();
    var refTableMenu = ref$1();
    var refTableHeader = ref$1();
    var refTableBody = ref$1();
    var refTableFooter = ref$1();
    var refTableLeftHeader = ref$1();
    var refTableLeftBody = ref$1();
    var refTableLeftFooter = ref$1();
    var refTableRightHeader = ref$1();
    var refTableRightBody = ref$1();
    var refTableRightFooter = ref$1();
    var refLeftContainer = ref$1();
    var refRightContainer = ref$1();
    var refCellResizeBar = ref$1();
    var refEmptyPlaceholder = ref$1();
    var $xegrid = inject("$xegrid", null);
    var $xetoolbar;
    var computeValidOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.validConfig, props.validConfig);
    });
    var computeSXOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.scrollX, props.scrollX);
    });
    var computeSYOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.scrollY, props.scrollY);
    });
    var computeRowHeightMaps = computed$1(function() {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    var computeColumnOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.columnConfig, props.columnConfig);
    });
    var computeRowOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.rowConfig, props.rowConfig);
    });
    var computeResizableOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.resizableConfig, props.resizableConfig);
    });
    var computeSeqOpts = computed$1(function() {
      return Object.assign({ startIndex: 0 }, GlobalConfig.table.seqConfig, props.seqConfig);
    });
    var computeRadioOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.radioConfig, props.radioConfig);
    });
    var computeCheckboxOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.checkboxConfig, props.checkboxConfig);
    });
    var computeTooltipOpts = ref$1();
    computeTooltipOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.tooltip, GlobalConfig.table.tooltipConfig, props.tooltipConfig);
    });
    var computeTipConfig = computed$1(function() {
      var tooltipStore = reactData.tooltipStore;
      var tooltipOpts = computeTooltipOpts.value;
      return __assign$1(__assign$1({}, tooltipOpts), tooltipStore.currOpts);
    });
    var computeValidTipOpts = computed$1(function() {
      var tooltipOpts = computeTooltipOpts.value;
      return Object.assign({ isArrow: false }, tooltipOpts);
    });
    var computeEditOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.editConfig, props.editConfig);
    });
    var computeSortOpts = computed$1(function() {
      return Object.assign({ orders: ["asc", "desc", null] }, GlobalConfig.table.sortConfig, props.sortConfig);
    });
    var computeFilterOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.filterConfig, props.filterConfig);
    });
    var computeMouseOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.mouseConfig, props.mouseConfig);
    });
    var computeAreaOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.areaConfig, props.areaConfig);
    });
    var computeKeyboardOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.keyboardConfig, props.keyboardConfig);
    });
    var computeClipOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.clipConfig, props.clipConfig);
    });
    var computeFNROpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.fnrConfig, props.fnrConfig);
    });
    var computeMenuOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.menuConfig, props.menuConfig);
    });
    var computeHeaderMenu = computed$1(function() {
      var menuOpts = computeMenuOpts.value;
      var headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    var computeBodyMenu = computed$1(function() {
      var menuOpts = computeMenuOpts.value;
      var bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    var computeFooterMenu = computed$1(function() {
      var menuOpts = computeMenuOpts.value;
      var footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    var computeIsMenu = computed$1(function() {
      var menuOpts = computeMenuOpts.value;
      var headerMenu = computeHeaderMenu.value;
      var bodyMenu = computeBodyMenu.value;
      var footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    var computeMenuList = computed$1(function() {
      var ctxMenuStore = reactData.ctxMenuStore;
      var rest = [];
      ctxMenuStore.list.forEach(function(list) {
        list.forEach(function(item) {
          rest.push(item);
        });
      });
      return rest;
    });
    var computeExportOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.exportConfig, props.exportConfig);
    });
    var computeImportOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.importConfig, props.importConfig);
    });
    var computePrintOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.printConfig, props.printConfig);
    });
    var computeExpandOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.expandConfig, props.expandConfig);
    });
    var computeTreeOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.treeConfig, props.treeConfig);
    });
    var computeEmptyOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.emptyRender, props.emptyRender);
    });
    var computeLoadingOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.loadingConfig, props.loadingConfig);
    });
    var computeCellOffsetWidth = computed$1(function() {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    var computeCustomOpts = computed$1(function() {
      return Object.assign({}, GlobalConfig.table.customConfig, props.customConfig);
    });
    var computeTableBorder = computed$1(function() {
      var border = props.border;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    var computeIsAllCheckboxDisabled = computed$1(function() {
      props.treeConfig;
      var tableData = reactData.tableData;
      var tableFullData = internalData.tableFullData;
      var checkboxOpts = computeCheckboxOpts.value;
      var strict = checkboxOpts.strict, checkMethod = checkboxOpts.checkMethod;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            return tableFullData.every(function(row2) {
              return !checkMethod({ row: row2 });
            });
          }
          return false;
        }
        return true;
      }
      return false;
    });
    var refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar
    };
    var computeMaps = {
      computeSize,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeRowOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeIsAllCheckboxDisabled
    };
    var $xetable = {
      xID,
      props,
      context,
      instance: instance2,
      reactData,
      internalData,
      getRefMaps: function() {
        return refMaps;
      },
      getComputeMaps: function() {
        return computeMaps;
      },
      xegrid: $xegrid
    };
    var eqCellValue = function(row1, row2, field) {
      var val1 = xeUtils.get(row1, field);
      var val2 = xeUtils.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (xeUtils.isString(val1) || xeUtils.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return xeUtils.isEqual(val1, val2);
    };
    var getNextSortOrder = function(column2) {
      var sortOpts = computeSortOpts.value;
      var orders = sortOpts.orders;
      var currOrder = column2.order || null;
      var oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    var getCustomStorageMap = function(key) {
      var version2 = GlobalConfig.version;
      var rest = xeUtils.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    var getRecoverRow = function(list) {
      var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
      return list.filter(function(row2) {
        var rowid = getRowid($xetable, row2);
        return !!fullAllDataRowIdData[rowid];
      });
    };
    var handleReserveRow = function(reserveRowMap) {
      var fullDataRowIdData = internalData.fullDataRowIdData;
      var reserveList = [];
      xeUtils.each(reserveRowMap, function(item, rowid) {
        if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    var computeVirtualX = function() {
      var visibleColumn = internalData.visibleColumn;
      var tableBody = refTableBody.value;
      var tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        var scrollLeft = tableBodyElem.scrollLeft, clientWidth = tableBodyElem.clientWidth;
        var endWidth = scrollLeft + clientWidth;
        var toVisibleIndex = -1;
        var cWidth = 0;
        var visibleSize = 0;
        for (var colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    };
    var computeVirtualY = function() {
      var tableHeader = refTableHeader.value;
      var tableBody = refTableBody.value;
      var tableBodyElem = tableBody ? tableBody.$el : null;
      var vSize = computeSize.value;
      var rowHeightMaps = computeRowHeightMaps.value;
      if (tableBodyElem) {
        var tableHeaderElem = tableHeader ? tableHeader.$el : null;
        var rowHeight = 0;
        var firstTrElem = void 0;
        firstTrElem = tableBodyElem.querySelector("tr");
        if (!firstTrElem && tableHeaderElem) {
          firstTrElem = tableHeaderElem.querySelector("tr");
        }
        if (firstTrElem) {
          rowHeight = firstTrElem.clientHeight;
        }
        if (!rowHeight) {
          rowHeight = rowHeightMaps[vSize || "default"];
        }
        var visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);
        return { rowHeight, visibleSize };
      }
      return { rowHeight: 0, visibleSize: 8 };
    };
    var calculateMergerOffserIndex = function(list, offsetItem, type2) {
      for (var mcIndex = 0, len2 = list.length; mcIndex < len2; mcIndex++) {
        var mergeItem = list[mcIndex];
        var startIndex = offsetItem.startIndex, endIndex = offsetItem.endIndex;
        var mergeStartIndex = mergeItem[type2];
        var mergeSpanNumber = mergeItem[type2 + "span"];
        var mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    var setMerges = function(merges, mList, rowList) {
      if (merges) {
        var treeConfig = props.treeConfig;
        var visibleColumn_1 = internalData.visibleColumn;
        if (!xeUtils.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach(function(item) {
          var row2 = item.row, col = item.col, rowspan = item.rowspan, colspan = item.colspan;
          if (rowList && xeUtils.isNumber(row2)) {
            row2 = rowList[row2];
          }
          if (xeUtils.isNumber(col)) {
            col = visibleColumn_1[col];
          }
          if ((rowList ? row2 : xeUtils.isNumber(row2)) && col && (rowspan || colspan)) {
            rowspan = xeUtils.toNumber(rowspan) || 1;
            colspan = xeUtils.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              var mcIndex = xeUtils.findIndexOf(mList, function(item2) {
                return (item2._row === row2 || getRowid($xetable, item2._row) === getRowid($xetable, row2)) && (item2._col.id === col || item2._col.id === col.id);
              });
              var mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                var mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row2) : row2;
                var mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row2,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    var removeMerges = function(merges, mList, rowList) {
      var rest = [];
      if (merges) {
        var treeConfig = props.treeConfig;
        var visibleColumn_2 = internalData.visibleColumn;
        if (!xeUtils.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach(function(item) {
          var row2 = item.row, col = item.col;
          if (rowList && xeUtils.isNumber(row2)) {
            row2 = rowList[row2];
          }
          if (xeUtils.isNumber(col)) {
            col = visibleColumn_2[col];
          }
          var mcIndex = xeUtils.findIndexOf(mList, function(item2) {
            return (item2._row === row2 || getRowid($xetable, item2._row) === getRowid($xetable, row2)) && (item2._col.id === col || item2._col.id === col.id);
          });
          if (mcIndex > -1) {
            var rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    var clearAllSort = function() {
      var tableFullColumn = internalData.tableFullColumn;
      tableFullColumn.forEach(function(column2) {
        column2.order = null;
      });
    };
    var calcHeight = function(key) {
      var parentHeight = reactData.parentHeight;
      var val2 = props[key];
      var num = 0;
      if (val2) {
        if (val2 === "auto") {
          num = parentHeight;
        } else {
          var excludeHeight = $xetable.getExcludeHeight();
          if (isScale(val2)) {
            num = Math.floor((xeUtils.toInteger(val2) || 1) / 100 * parentHeight);
          } else {
            num = xeUtils.toNumber(val2);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    var restoreCustomStorage = function() {
      var id2 = props.id, customConfig = props.customConfig;
      var collectColumn = internalData.collectColumn;
      var customOpts = computeCustomOpts.value;
      var storage = customOpts.storage;
      var isResizable = storage === true || storage && storage.resizable;
      var isVisible = storage === true || storage && storage.visible;
      if (customConfig && (isResizable || isVisible)) {
        var customMap_1 = {};
        if (!id2) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        if (isResizable) {
          var columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id2];
          if (columnWidthStorage) {
            xeUtils.each(columnWidthStorage, function(resizeWidth, field) {
              customMap_1[field] = { field, resizeWidth };
            });
          }
        }
        if (isVisible) {
          var columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id2];
          if (columnVisibleStorage) {
            var colVisibles = columnVisibleStorage.split("|");
            var colHides = colVisibles[0] ? colVisibles[0].split(",") : [];
            var colShows = colVisibles[1] ? colVisibles[1].split(",") : [];
            colHides.forEach(function(field) {
              if (customMap_1[field]) {
                customMap_1[field].visible = false;
              } else {
                customMap_1[field] = { field, visible: false };
              }
            });
            colShows.forEach(function(field) {
              if (customMap_1[field]) {
                customMap_1[field].visible = true;
              } else {
                customMap_1[field] = { field, visible: true };
              }
            });
          }
        }
        var keyMap_1 = {};
        xeUtils.eachTree(collectColumn, function(column2) {
          var colKey = column2.getKey();
          if (colKey) {
            keyMap_1[colKey] = column2;
          }
        });
        xeUtils.each(customMap_1, function(_a2, field) {
          var visible = _a2.visible, resizeWidth = _a2.resizeWidth;
          var column2 = keyMap_1[field];
          if (column2) {
            if (xeUtils.isNumber(resizeWidth)) {
              column2.resizeWidth = resizeWidth;
            }
            if (xeUtils.isBoolean(visible)) {
              column2.visible = visible;
            }
          }
        });
      }
    };
    var cacheColumnMap = function() {
      var tableFullColumn = internalData.tableFullColumn, collectColumn = internalData.collectColumn;
      var fullColumnIdData = internalData.fullColumnIdData = {};
      var fullColumnFieldData = internalData.fullColumnFieldData = {};
      computeMouseOpts.value;
      var isGroup = collectColumn.some(hasChildrenList);
      var isAllOverflow = !!props.showOverflow;
      var expandColumn;
      var treeNodeColumn;
      var handleFunc = function(column2, index, items, path, parent2) {
        var colid = column2.id, field = column2.field;
        column2.fixed;
        var type2 = column2.type, treeNode = column2.treeNode;
        var rest = { column: column2, colid, index, items, parent: parent2 };
        if (field) {
          fullColumnFieldData[field] = rest;
        }
        if (treeNode) {
          if (!treeNodeColumn) {
            treeNodeColumn = column2;
          }
        } else if (type2 === "expand") {
          if (!expandColumn) {
            expandColumn = column2;
          }
        }
        if (isAllOverflow && column2.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        xeUtils.eachTree(collectColumn, function(column2, index, items, path, parent2, nodes) {
          column2.level = nodes.length;
          handleFunc(column2, index, items, path, parent2);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    var updateHeight = function() {
      internalData.customHeight = calcHeight("height");
      internalData.customMaxHeight = calcHeight("maxHeight");
    };
    var autoCellWidth = function() {
      var tableHeader = refTableHeader.value;
      var tableBody = refTableBody.value;
      var tableFooter = refTableFooter.value;
      var bodyElem = tableBody ? tableBody.$el : null;
      var headerElem = tableHeader ? tableHeader.$el : null;
      var footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      var tableWidth = 0;
      var minCellWidth = 40;
      var bodyWidth = bodyElem.clientWidth - 1;
      var remainWidth = bodyWidth;
      var meanWidth = remainWidth / 100;
      var fit = props.fit;
      var columnStore = reactData.columnStore;
      var resizeList = columnStore.resizeList, pxMinList = columnStore.pxMinList, pxList = columnStore.pxList, scaleList = columnStore.scaleList, scaleMinList = columnStore.scaleMinList, autoList = columnStore.autoList;
      pxMinList.forEach(function(column2) {
        var minWidth = parseInt(column2.minWidth);
        tableWidth += minWidth;
        column2.renderWidth = minWidth;
      });
      scaleMinList.forEach(function(column2) {
        var scaleWidth = Math.floor(parseInt(column2.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column2.renderWidth = scaleWidth;
      });
      scaleList.forEach(function(column2) {
        var scaleWidth = Math.floor(parseInt(column2.width) * meanWidth);
        tableWidth += scaleWidth;
        column2.renderWidth = scaleWidth;
      });
      pxList.forEach(function(column2) {
        var width2 = parseInt(column2.width);
        tableWidth += width2;
        column2.renderWidth = width2;
      });
      resizeList.forEach(function(column2) {
        var width2 = parseInt(column2.resizeWidth);
        tableWidth += width2;
        column2.renderWidth = width2;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).forEach(function(column2) {
            tableWidth += meanWidth;
            column2.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      autoList.forEach(function(column2) {
        var width2 = Math.max(meanWidth, minCellWidth);
        column2.renderWidth = width2;
        tableWidth += width2;
      });
      if (fit) {
        var dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);
        var dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          var odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      var tableHeight = bodyElem.offsetHeight;
      var overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      var scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      var headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        nextTick$1(function() {
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      var overflowX = false;
      var footerHeight2 = 0;
      var scrollbarHeight = 0;
      if (footerElem) {
        footerHeight2 = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(footerHeight2 - footerElem.clientHeight, 0);
        }
      } else {
        overflowX = tableWidth > bodyWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
        }
      }
      internalData.footerHeight = footerHeight2;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight2 + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    var getOrderField = function(column2) {
      var sortBy2 = column2.sortBy, sortType = column2.sortType;
      return function(row2) {
        var cellValue;
        if (sortBy2) {
          cellValue = xeUtils.isFunction(sortBy2) ? sortBy2({ row: row2, column: column2 }) : xeUtils.get(row2, sortBy2);
        } else {
          cellValue = tablePrivateMethods.getCellLabel(row2, column2);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : xeUtils.toNumber(cellValue);
        } else if (sortType === "number") {
          return xeUtils.toNumber(cellValue);
        } else if (sortType === "string") {
          return xeUtils.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    var updateAfterDataIndex = function() {
      var treeConfig = props.treeConfig;
      var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;
      var afterTreeFullData = internalData.afterTreeFullData;
      var treeOpts = computeTreeOpts.value;
      if (treeConfig) {
        xeUtils.eachTree(afterTreeFullData, function(row2, index, items, path) {
          var rowid = getRowid($xetable, row2);
          var allrest = fullAllDataRowIdData[rowid];
          var seq = path.map(function(num, i2) {
            return i2 % 2 === 0 ? Number(num) + 1 : ".";
          }).join("");
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            var rest = { row: row2, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
        }, { children: treeOpts.transform ? treeOpts.mapChildren : treeOpts.children });
      } else {
        afterFullData.forEach(function(row2, index) {
          var rowid = getRowid($xetable, row2);
          var allrest = fullAllDataRowIdData[rowid];
          var seq = index + 1;
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            var rest = { row: row2, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
        });
      }
    };
    var handleVirtualTreeToList = function() {
      var treeConfig = props.treeConfig;
      var treeExpandeds = reactData.treeExpandeds;
      var treeOpts = computeTreeOpts.value;
      if (treeConfig && treeOpts.transform) {
        var fullData_1 = [];
        var expandMaps_1 = /* @__PURE__ */ new Map();
        xeUtils.eachTree(internalData.afterTreeFullData, function(row2, index, items, path, parent2) {
          if (!parent2 || expandMaps_1.has(parent2) && $xetable.findRowIndexOf(treeExpandeds, parent2) > -1) {
            expandMaps_1.set(row2, 1);
            fullData_1.push(row2);
          }
        }, { children: treeOpts.mapChildren });
        internalData.afterFullData = fullData_1;
        updateScrollYStatus(fullData_1);
        return fullData_1;
      }
      return internalData.afterFullData;
    };
    var updateAfterFullData = function() {
      var treeConfig = props.treeConfig;
      var tableFullColumn = internalData.tableFullColumn, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;
      var filterOpts = computeFilterOpts.value;
      var sortOpts = computeSortOpts.value;
      var treeOpts = computeTreeOpts.value;
      var transform = treeOpts.transform;
      var allRemoteFilter = filterOpts.remote, allFilterMethod = filterOpts.filterMethod;
      var allRemoteSort = sortOpts.remote, allSortMethod = sortOpts.sortMethod, sortMultiple = sortOpts.multiple, chronological = sortOpts.chronological;
      var tableData = [];
      var tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        var filterColumns_1 = [];
        var orderColumns_1 = [];
        tableFullColumn.forEach(function(column2) {
          var field = column2.field, sortable = column2.sortable, order = column2.order, filters = column2.filters;
          if (!allRemoteFilter && filters && filters.length) {
            var valueList_1 = [];
            var itemList_1 = [];
            filters.forEach(function(item) {
              if (item.checked) {
                itemList_1.push(item);
                valueList_1.push(item.value);
              }
            });
            if (itemList_1.length) {
              filterColumns_1.push({ column: column2, valueList: valueList_1, itemList: itemList_1 });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns_1.push({ column: column2, field, property: field, order, sortTime: column2.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns_1.length > 1) {
          orderColumns_1 = xeUtils.orderBy(orderColumns_1, "sortTime");
        }
        if (!allRemoteFilter && filterColumns_1.length) {
          var handleFilter = function(row2) {
            return filterColumns_1.every(function(_a2) {
              var column2 = _a2.column, valueList = _a2.valueList, itemList = _a2.itemList;
              var filterMethod = column2.filterMethod, filterRender = column2.filterRender;
              var compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
              var compFilterMethod = compConf ? compConf.filterMethod : null;
              var defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;
              var cellValue = getCellValue(row2, column2);
              if (filterMethod) {
                return itemList.some(function(item) {
                  return filterMethod({ value: item.value, option: item, cellValue, row: row2, column: column2, $table: $xetable });
                });
              } else if (compFilterMethod) {
                return itemList.some(function(item) {
                  return compFilterMethod({ value: item.value, option: item, cellValue, row: row2, column: column2, $table: $xetable });
                });
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row: row2, column: column2 });
              } else if (defaultFilterMethod) {
                return itemList.some(function(item) {
                  return defaultFilterMethod({ value: item.value, option: item, cellValue, row: row2, column: column2, $table: $xetable });
                });
              }
              return valueList.indexOf(xeUtils.get(row2, column2.field)) > -1;
            });
          };
          if (treeConfig && transform) {
            tableTree = xeUtils.searchTree(tableFullTreeData, handleFilter, __assign$1(__assign$1({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform) {
            tableTree = xeUtils.searchTree(tableFullTreeData, function() {
              return true;
            }, __assign$1(__assign$1({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns_1.length) {
          if (treeConfig && transform) {
            if (allSortMethod) {
              var sortRests = allSortMethod({ data: tableTree, sortList: orderColumns_1, $table: $xetable });
              tableTree = xeUtils.isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = xeUtils.orderBy(tableTree, orderColumns_1.map(function(_a2) {
                var column2 = _a2.column, order = _a2.order;
                return [getOrderField(column2), order];
              }));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              var sortRests = allSortMethod({ data: tableData, sortList: orderColumns_1, $table: $xetable });
              tableData = xeUtils.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = xeUtils.orderBy(tableData, orderColumns_1.map(function(_a2) {
                var column2 = _a2.column, order = _a2.order;
                return [getOrderField(column2), order];
              }));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform) {
          tableTree = xeUtils.searchTree(tableFullTreeData, function() {
            return true;
          }, __assign$1(__assign$1({}, treeOpts), { original: true }));
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    var updateStyle2 = function() {
      var border = props.border, showFooter = props.showFooter, allColumnOverflow = props.showOverflow, allColumnHeaderOverflow = props.showHeaderOverflow, allColumnFooterOverflow = props.showFooterOverflow, mouseConfig = props.mouseConfig, spanMethod = props.spanMethod, footerSpanMethod = props.footerSpanMethod, keyboardConfig = props.keyboardConfig;
      var isGroup = reactData.isGroup, currentRow = reactData.currentRow, tableColumn = reactData.tableColumn, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarWidth = reactData.scrollbarWidth, scrollbarHeight = reactData.scrollbarHeight, columnStore = reactData.columnStore, editStore = reactData.editStore, mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList, isAllOverflow = reactData.isAllOverflow;
      var visibleColumn = internalData.visibleColumn, fullColumnIdData = internalData.fullColumnIdData, tableHeight = internalData.tableHeight, tableWidth = internalData.tableWidth, headerHeight = internalData.headerHeight, footerHeight2 = internalData.footerHeight, elemStore = internalData.elemStore, customHeight = internalData.customHeight, customMaxHeight = internalData.customMaxHeight;
      var containerList = ["main", "left", "right"];
      var emptyPlaceholderElem = refEmptyPlaceholder.value;
      var cellOffsetWidth = computeCellOffsetWidth.value;
      var mouseOpts = computeMouseOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var bodyWrapperRef = elemStore["main-body-wrapper"];
      var bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = "".concat(headerHeight, "px");
        emptyPlaceholderElem.style.height = bodyWrapperElem ? "".concat(bodyWrapperElem.offsetHeight - scrollbarHeight, "px") : "";
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      containerList.forEach(function(name2, index) {
        var fixedType = index > 0 ? name2 : "";
        var layoutList = ["header", "body", "footer"];
        var isFixedLeft = fixedType === "left";
        var fixedColumn = [];
        var fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach(function(layout2) {
          var wrapperRef = elemStore["".concat(name2, "-").concat(layout2, "-wrapper")];
          var wrapperElem = wrapperRef ? wrapperRef.value : null;
          var tableRef = elemStore["".concat(name2, "-").concat(layout2, "-table")];
          var tableElem = tableRef ? tableRef.value : null;
          if (layout2 === "header") {
            var tWidth = tableWidth;
            var isOptimize = false;
            if (!isGroup) {
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  isOptimize = true;
                }
              }
            }
            if (isOptimize) {
              tableColumn = fixedColumn;
            }
            tWidth = tableColumn.reduce(function(previous, column2) {
              return previous + column2.renderWidth;
            }, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? "".concat(tWidth + scrollbarWidth, "px") : "";
              if (browse.msie) {
                xeUtils.arrayEach(tableElem.querySelectorAll(".vxe-resizable"), function(resizeElem) {
                  resizeElem.style.height = "".concat(resizeElem.parentNode.offsetHeight, "px");
                });
              }
            }
            var repairRef = elemStore["".concat(name2, "-").concat(layout2, "-repair")];
            var repairElem = repairRef ? repairRef.value : null;
            if (repairElem) {
              repairElem.style.width = "".concat(tableWidth, "px");
            }
            var listRef = elemStore["".concat(name2, "-").concat(layout2, "-list")];
            var listElem = listRef ? listRef.value : null;
            if (isGroup && listElem) {
              xeUtils.arrayEach(listElem.querySelectorAll(".col--group"), function(thElem) {
                var colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  var column_1 = colNode.item;
                  var showHeaderOverflow = column_1.showHeaderOverflow;
                  var cellOverflow = xeUtils.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  var showEllipsis = cellOverflow === "ellipsis";
                  var showTitle = cellOverflow === "title";
                  var showTooltip2 = cellOverflow === true || cellOverflow === "tooltip";
                  var hasEllipsis = showTitle || showTooltip2 || showEllipsis;
                  var childWidth_1 = 0;
                  var countChild_1 = 0;
                  if (hasEllipsis) {
                    xeUtils.eachTree(column_1.children, function(item) {
                      if (!item.children || !column_1.children.length) {
                        countChild_1++;
                      }
                      childWidth_1 += item.renderWidth;
                    }, { children: "children" });
                  }
                  thElem.style.width = hasEllipsis ? "".concat(childWidth_1 - countChild_1 - (border ? 2 : 0), "px") : "";
                }
              });
            }
          } else if (layout2 === "body") {
            var emptyBlockRef = elemStore["".concat(name2, "-").concat(layout2, "-emptyBlock")];
            var emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;
            if (isNodeElement(wrapperElem)) {
              if (customMaxHeight) {
                wrapperElem.style.maxHeight = "".concat(fixedType ? customMaxHeight - headerHeight - (showFooter ? 0 : scrollbarHeight) : customMaxHeight - headerHeight, "px");
              } else {
                if (customHeight > 0) {
                  wrapperElem.style.height = "".concat(fixedType ? (customHeight > 0 ? customHeight - headerHeight - footerHeight2 : tableHeight) - (showFooter ? 0 : scrollbarHeight) : customHeight - headerHeight - footerHeight2, "px");
                } else {
                  wrapperElem.style.height = "";
                }
              }
            }
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = "".concat(headerHeight, "px");
              }
              fixedWrapperElem.style.height = "".concat((customHeight > 0 ? customHeight - headerHeight - footerHeight2 : tableHeight) + headerHeight + footerHeight2 - scrollbarHeight * (showFooter ? 2 : 1), "px");
              fixedWrapperElem.style.width = "".concat(fixedColumn.reduce(function(previous, column2) {
                return previous + column2.renderWidth;
              }, isFixedLeft ? 0 : scrollbarWidth), "px");
            }
            var tWidth = tableWidth;
            if (fixedType) {
              if (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  tableColumn = fixedColumn;
                } else {
                  tableColumn = visibleColumn;
                }
              } else {
                tableColumn = visibleColumn;
              }
            }
            tWidth = tableColumn.reduce(function(previous, column2) {
              return previous + column2.renderWidth;
            }, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? "".concat(tWidth, "px") : "";
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse["-moz"] || browse.safari) ? "".concat(scrollbarWidth, "px") : "";
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? "".concat(tWidth, "px") : "";
            }
          } else if (layout2 === "footer") {
            var tWidth = tableWidth;
            if (fixedType) {
              if (scrollXLoad || allColumnFooterOverflow) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  tableColumn = fixedColumn;
                } else {
                  tableColumn = visibleColumn;
                }
              } else {
                tableColumn = visibleColumn;
              }
            }
            tWidth = tableColumn.reduce(function(previous, column2) {
              return previous + column2.renderWidth;
            }, 0);
            if (isNodeElement(wrapperElem)) {
              if (fixedWrapperElem) {
                wrapperElem.style.top = "".concat(customHeight > 0 ? customHeight - footerHeight2 : tableHeight + headerHeight, "px");
              }
              wrapperElem.style.marginTop = "".concat(-Math.max(1, scrollbarHeight), "px");
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? "".concat(tWidth + scrollbarWidth, "px") : "";
            }
          }
          var colgroupRef = elemStore["".concat(name2, "-").concat(layout2, "-colgroup")];
          var colgroupElem = colgroupRef ? colgroupRef.value : null;
          if (colgroupElem) {
            xeUtils.arrayEach(colgroupElem.children, function(colElem) {
              var colid = colElem.getAttribute("name");
              if (colid === "col_gutter") {
                colElem.style.width = "".concat(scrollbarWidth, "px");
              }
              if (fullColumnIdData[colid]) {
                var column_2 = fullColumnIdData[colid].column;
                var showHeaderOverflow = column_2.showHeaderOverflow, showFooterOverflow = column_2.showFooterOverflow, showOverflow = column_2.showOverflow;
                var cellOverflow = void 0;
                colElem.style.width = "".concat(column_2.renderWidth, "px");
                if (layout2 === "header") {
                  cellOverflow = xeUtils.isUndefined(showHeaderOverflow) || xeUtils.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout2 === "footer") {
                  cellOverflow = xeUtils.isUndefined(showFooterOverflow) || xeUtils.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = xeUtils.isUndefined(showOverflow) || xeUtils.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                var showEllipsis = cellOverflow === "ellipsis";
                var showTitle = cellOverflow === "title";
                var showTooltip2 = cellOverflow === true || cellOverflow === "tooltip";
                var hasEllipsis_1 = showTitle || showTooltip2 || showEllipsis;
                var listRef2 = elemStore["".concat(name2, "-").concat(layout2, "-list")];
                var listElem2 = listRef2 ? listRef2.value : null;
                if (scrollYLoad && !hasEllipsis_1) {
                  hasEllipsis_1 = true;
                }
                if (listElem2) {
                  xeUtils.arrayEach(listElem2.querySelectorAll(".".concat(column_2.id)), function(elem) {
                    var colspan = parseInt(elem.getAttribute("colspan") || 1);
                    var cellElem = elem.querySelector(".vxe-cell");
                    var colWidth = column_2.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        var columnIndex = tableMethods.getColumnIndex(column_2);
                        for (var index_1 = 1; index_1 < colspan; index_1++) {
                          var nextColumn = tableMethods.getColumns(columnIndex + index_1);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis_1 ? "".concat(colWidth - cellOffsetWidth * colspan, "px") : "";
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xetable.addCellSelectedClass();
      }
      return nextTick$1();
    };
    var checkValidate = function(type2) {
      if ($xetable.triggerValidate) {
        return $xetable.triggerValidate(type2);
      }
      return nextTick$1();
    };
    var handleChangeCell = function(evnt, params) {
      checkValidate("blur").catch(function(e3) {
        return e3;
      }).then(function() {
        $xetable.handleActived(params, evnt).then(function() {
          return checkValidate("change");
        }).catch(function(e3) {
          return e3;
        });
      });
    };
    var handleDefaultSort = function() {
      var sortConfig = props.sortConfig;
      if (sortConfig) {
        var sortOpts = computeSortOpts.value;
        var defaultSort = sortOpts.defaultSort;
        if (defaultSort) {
          if (!xeUtils.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach(function(item, index) {
              var field = item.field, order = item.order;
              if (field && order) {
                var column2 = tableMethods.getColumnByField(field);
                if (column2 && column2.sortable) {
                  column2.order = order;
                  column2.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle2);
            }
          }
        }
      }
    };
    var handleDefaultSelectionChecked = function() {
      var checkboxConfig = props.checkboxConfig;
      if (checkboxConfig) {
        var fullDataRowIdData_1 = internalData.fullDataRowIdData;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkAll = checkboxOpts.checkAll, checkRowKeys = checkboxOpts.checkRowKeys;
        if (checkAll) {
          tableMethods.setAllCheckboxRow(true);
        } else if (checkRowKeys) {
          var defSelection_1 = [];
          checkRowKeys.forEach(function(rowid) {
            if (fullDataRowIdData_1[rowid]) {
              defSelection_1.push(fullDataRowIdData_1[rowid].row);
            }
          });
          tableMethods.setCheckboxRow(defSelection_1, true);
        }
      }
    };
    var handleDefaultRadioChecked = function() {
      var _a2;
      var radioConfig = props.radioConfig;
      if (radioConfig) {
        var fullDataRowIdData = internalData.fullDataRowIdData;
        var radioOpts = computeRadioOpts.value;
        var rowid = radioOpts.checkRowKey, reserve = radioOpts.reserve;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            tableMethods.setRadioRow(fullDataRowIdData[rowid].row);
          }
          if (reserve) {
            var rowkey = getRowkey($xetable);
            internalData.radioReserveRow = (_a2 = {}, _a2[rowkey] = rowid, _a2);
          }
        }
      }
    };
    var handleDefaultRowExpand = function() {
      var expandConfig = props.expandConfig;
      if (expandConfig) {
        var fullDataRowIdData_2 = internalData.fullDataRowIdData;
        var expandOpts = computeExpandOpts.value;
        var expandAll = expandOpts.expandAll, expandRowKeys = expandOpts.expandRowKeys;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          var defExpandeds_1 = [];
          expandRowKeys.forEach(function(rowid) {
            if (fullDataRowIdData_2[rowid]) {
              defExpandeds_1.push(fullDataRowIdData_2[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds_1, true);
        }
      }
    };
    var handleRadioReserveRow = function(row2) {
      var radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row2;
      }
    };
    var handleCheckboxReserveRow = function(row2, checked) {
      var checkboxReserveRowMap = internalData.checkboxReserveRowMap;
      var checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        var rowid = getRowid($xetable, row2);
        if (checked) {
          checkboxReserveRowMap[rowid] = row2;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    var handleReserveStatus = function() {
      var treeConfig = props.treeConfig;
      var expandColumn = reactData.expandColumn, currentRow = reactData.currentRow, selectRow = reactData.selectRow, selection = reactData.selection, rowExpandeds = reactData.rowExpandeds, treeExpandeds = reactData.treeExpandeds;
      var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, radioReserveRow = internalData.radioReserveRow;
      var expandOpts = computeExpandOpts.value;
      var treeOpts = computeTreeOpts.value;
      var radioOpts = computeRadioOpts.value;
      var checkboxOpts = computeCheckboxOpts.value;
      if (selectRow && !fullAllDataRowIdData[getRowid($xetable, selectRow)]) {
        reactData.selectRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        var rowid = getRowid($xetable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          tableMethods.setRadioRow(fullDataRowIdData[rowid].row);
        }
      }
      reactData.selection = getRecoverRow(selection);
      if (checkboxOpts.reserve) {
        tableMethods.setCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {
        reactData.currentRow = null;
      }
      reactData.rowExpandeds = expandColumn ? getRecoverRow(rowExpandeds) : [];
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      reactData.treeExpandeds = treeConfig ? getRecoverRow(treeExpandeds) : [];
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    var handleDefaultTreeExpand = function() {
      var treeConfig = props.treeConfig;
      if (treeConfig) {
        var tableFullData_1 = internalData.tableFullData;
        var treeOpts_1 = computeTreeOpts.value;
        var expandAll = treeOpts_1.expandAll, expandRowKeys = treeOpts_1.expandRowKeys;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          var defExpandeds_2 = [];
          var rowkey_1 = getRowkey($xetable);
          expandRowKeys.forEach(function(rowid) {
            var matchObj = xeUtils.findTree(tableFullData_1, function(item) {
              return rowid === xeUtils.get(item, rowkey_1);
            }, treeOpts_1);
            if (matchObj) {
              defExpandeds_2.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds_2, true);
        }
      }
    };
    var handleAsyncTreeExpandChilds = function(row2) {
      var treeExpandeds = reactData.treeExpandeds, treeLazyLoadeds = reactData.treeLazyLoadeds;
      var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
      var treeOpts = computeTreeOpts.value;
      var checkboxOpts = computeCheckboxOpts.value;
      var transform = treeOpts.transform, loadMethod = treeOpts.loadMethod;
      var checkStrictly = checkboxOpts.checkStrictly;
      var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
      return new Promise(function(resolve) {
        if (loadMethod) {
          treeLazyLoadeds.push(row2);
          loadMethod({ $table: $xetable, row: row2 }).then(function(childRecords) {
            rest.treeLoaded = true;
            xeUtils.remove(treeLazyLoadeds, function(item) {
              return $xetable.eqRow(item, row2);
            });
            if (!xeUtils.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row2, childRecords).then(function(childRows) {
                if (childRows.length && $xetable.findRowIndexOf(treeExpandeds, row2) === -1) {
                  treeExpandeds.push(row2);
                }
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row2)) {
                  tableMethods.setCheckboxRow(childRows, true);
                }
                return nextTick$1().then(function() {
                  if (transform) {
                    return tablePrivateMethods.handleTableData();
                  }
                });
              });
            }
          }).catch(function() {
            rest.treeLoaded = false;
            xeUtils.remove(treeLazyLoadeds, function(item) {
              return $xetable.eqRow(item, row2);
            });
          }).finally(function() {
            nextTick$1().then(function() {
              return tableMethods.recalculate();
            }).then(function() {
              return resolve();
            });
          });
        } else {
          resolve();
        }
      });
    };
    var handleTreeExpandReserve = function(row2, expanded) {
      var treeExpandedReserveRowMap = internalData.treeExpandedReserveRowMap;
      var treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        var rowid = getRowid($xetable, row2);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row2;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    var handleAsyncRowExpand = function(row2) {
      var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
      return new Promise(function(resolve) {
        var expandOpts = computeExpandOpts.value;
        var loadMethod = expandOpts.loadMethod;
        if (loadMethod) {
          var rest_1 = fullAllDataRowIdData[getRowid($xetable, row2)];
          reactData.expandLazyLoadeds.push(row2);
          loadMethod({ $table: $xetable, row: row2, rowIndex: tableMethods.getRowIndex(row2), $rowIndex: tableMethods.getVMRowIndex(row2) }).then(function() {
            rest_1.expandLoaded = true;
            reactData.rowExpandeds.push(row2);
          }).catch(function() {
            rest_1.expandLoaded = false;
          }).finally(function() {
            xeUtils.remove(reactData.expandLazyLoadeds, function(item) {
              return $xetable.eqRow(item, row2);
            });
            resolve(nextTick$1().then(function() {
              return tableMethods.recalculate();
            }));
          });
        } else {
          resolve();
        }
      });
    };
    var handleRowExpandReserve = function(row2, expanded) {
      var rowExpandedReserveRowMap = internalData.rowExpandedReserveRowMap;
      var expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        var rowid = getRowid($xetable, row2);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row2;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    var handleDefaultMergeCells = function() {
      var mergeCells = props.mergeCells;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    var handleDefaultMergeFooterItems = function() {
      var mergeFooterItems = props.mergeFooterItems;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    var computeScrollLoad = function() {
      return nextTick$1().then(function() {
        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;
        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;
        var sYOpts = computeSYOpts.value;
        var sXOpts = computeSXOpts.value;
        if (scrollXLoad) {
          var visibleXSize = computeVirtualX().visibleSize;
          var offsetXSize = sXOpts.oSize ? xeUtils.toNumber(sXOpts.oSize) : browse.msie ? 10 : browse.edge ? 5 : 0;
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        var _a2 = computeVirtualY(), rowHeight = _a2.rowHeight, visibleYSize = _a2.visibleSize;
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          var offsetYSize = sYOpts.oSize ? xeUtils.toNumber(sYOpts.oSize) : browse.msie ? 20 : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        reactData.rowHeight = rowHeight;
        nextTick$1(updateStyle2);
      });
    };
    var loadTableData = function(datas) {
      var keepSource = props.keepSource, treeConfig = props.treeConfig;
      var editStore = reactData.editStore, oldScrollYLoad = reactData.scrollYLoad;
      var scrollYStore = internalData.scrollYStore, scrollXStore = internalData.scrollXStore, lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;
      var treeOpts = computeTreeOpts.value;
      var transform = treeOpts.transform;
      var treeData = [];
      var fullData = datas ? datas.slice(0) : [];
      if (treeConfig) {
        if (transform) {
          treeData = xeUtils.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: treeOpts.children,
            mapChildren: treeOpts.mapChildren
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      editStore.insertList = [];
      editStore.removeList = [];
      var sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      tablePrivateMethods.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (keepSource) {
        internalData.tableSourceData = xeUtils.clone(fullData, true);
      }
      if ($xetable.clearCellAreas && props.mouseConfig) {
        $xetable.clearCellAreas();
        $xetable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return nextTick$1().then(function() {
        updateHeight();
        updateStyle2();
      }).then(function() {
        computeScrollLoad();
      }).then(function() {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise(function(resolve) {
          nextTick$1().then(function() {
            return tableMethods.recalculate();
          }).then(function() {
            var targetScrollLeft = lastScrollLeft;
            var targetScrollTop = lastScrollTop;
            var sXOpts = computeSXOpts.value;
            var sYOpts = computeSYOpts.value;
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(function() {
                return restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);
              });
            }
          });
        });
      });
    };
    var handleLoadDefaults = function() {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick$1(function() {
        return setTimeout(function() {
          return tableMethods.recalculate();
        });
      });
    };
    var handleInitDefaults = function() {
      handleDefaultSort();
    };
    var handleTableColumn = function() {
      var scrollXLoad = reactData.scrollXLoad;
      var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;
      var tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach(function(column2, $index) {
        var colid = column2.id;
        var rest = fullColumnIdData[colid];
        if (rest) {
          rest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    var loadScrollXData = function() {
      var mergeList = reactData.mergeList, mergeFooterList = reactData.mergeFooterList;
      var scrollXStore = internalData.scrollXStore;
      var startIndex = scrollXStore.startIndex, endIndex = scrollXStore.endIndex, offsetSize = scrollXStore.offsetSize;
      var _a2 = computeVirtualX(), toVisibleIndex = _a2.toVisibleIndex, visibleSize = _a2.visibleSize;
      var offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    var getColumnList = function(columns) {
      var result = [];
      columns.forEach(function(column2) {
        result.push.apply(result, column2.children && column2.children.length ? getColumnList(column2.children) : [column2]);
      });
      return result;
    };
    var parseColumns = function() {
      var leftList = [];
      var centerList = [];
      var rightList = [];
      var isGroup = reactData.isGroup, columnStore = reactData.columnStore;
      var sXOpts = computeSXOpts.value;
      var collectColumn = internalData.collectColumn, tableFullColumn = internalData.tableFullColumn, scrollXStore = internalData.scrollXStore, fullColumnIdData = internalData.fullColumnIdData;
      if (isGroup) {
        var leftGroupList_1 = [];
        var centerGroupList_1 = [];
        var rightGroupList_1 = [];
        xeUtils.eachTree(collectColumn, function(column2, index, items, path, parent2) {
          var isColGroup = hasChildrenList(column2);
          if (parent2 && parent2.fixed) {
            column2.fixed = parent2.fixed;
          }
          if (parent2 && column2.fixed !== parent2.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column2.visible = !!xeUtils.findTree(column2.children, function(subColumn) {
              return hasChildrenList(subColumn) ? false : subColumn.visible;
            });
          } else if (column2.visible) {
            if (column2.fixed === "left") {
              leftList.push(column2);
            } else if (column2.fixed === "right") {
              rightList.push(column2);
            } else {
              centerList.push(column2);
            }
          }
        });
        collectColumn.forEach(function(column2) {
          if (column2.visible) {
            if (column2.fixed === "left") {
              leftGroupList_1.push(column2);
            } else if (column2.fixed === "right") {
              rightGroupList_1.push(column2);
            } else {
              centerGroupList_1.push(column2);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList_1.concat(centerGroupList_1).concat(rightGroupList_1);
      } else {
        tableFullColumn.forEach(function(column2) {
          if (column2.visible) {
            if (column2.fixed === "left") {
              leftList.push(column2);
            } else if (column2.fixed === "right") {
              rightList.push(column2);
            } else {
              centerList.push(column2);
            }
          }
        });
      }
      var visibleColumn = leftList.concat(centerList).concat(rightList);
      var scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && sXOpts.gt < tableFullColumn.length;
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad && isGroup) {
        scrollXLoad = false;
      }
      if (scrollXLoad) {
        var visibleSize = computeVirtualX().visibleSize;
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every(function(column2, index) {
        return column2 === visibleColumn[index];
      })) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach(function(column2, index) {
        var colid = column2.id;
        var rest = fullColumnIdData[colid];
        if (rest) {
          rest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(function() {
        return tableMethods.recalculate();
      }).then(function() {
        tablePrivateMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    var handleColumn = function(collectColumn) {
      internalData.collectColumn = collectColumn;
      var tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      cacheColumnMap();
      restoreCustomStorage();
      parseColumns().then(function() {
        if (reactData.scrollXLoad) {
          loadScrollXData();
        }
      });
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      return nextTick$1().then(function() {
        if ($xetoolbar) {
          $xetoolbar.syncUpdate({ collectColumn, $table: $xetable });
        }
        return tableMethods.recalculate();
      });
    };
    var updateScrollYStatus = function(fullData) {
      var treeConfig = props.treeConfig;
      var sYOpts = computeSYOpts.value;
      var treeOpts = computeTreeOpts.value;
      var transform = treeOpts.transform;
      var scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && sYOpts.gt < fullData.length;
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    var handleBaseTreeExpand = function(rows, expanded) {
      var treeExpandeds = reactData.treeExpandeds, treeLazyLoadeds = reactData.treeLazyLoadeds, treeNodeColumn = reactData.treeNodeColumn;
      var fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData;
      var treeOpts = computeTreeOpts.value;
      var reserve = treeOpts.reserve, lazy = treeOpts.lazy, hasChild = treeOpts.hasChild, children2 = treeOpts.children, accordion = treeOpts.accordion, toggleMethod = treeOpts.toggleMethod;
      var result = [];
      var columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      var $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      var validRows = toggleMethod ? rows.filter(function(row2) {
        return toggleMethod({ $table: $xetable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row: row2 });
      }) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        var matchObj_1 = xeUtils.findTree(tableFullData, function(item) {
          return item === validRows[0];
        }, treeOpts);
        if (matchObj_1) {
          xeUtils.remove(treeExpandeds, function(item) {
            return matchObj_1.items.indexOf(item) > -1;
          });
        }
      }
      if (expanded) {
        validRows.forEach(function(row2) {
          if ($xetable.findRowIndexOf(treeExpandeds, row2) === -1) {
            var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
            var isLoad = lazy && row2[hasChild] && !rest.treeLoaded && $xetable.findRowIndexOf(treeLazyLoadeds, row2) === -1;
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(row2));
            } else {
              if (row2[children2] && row2[children2].length) {
                treeExpandeds.push(row2);
              }
            }
          }
        });
      } else {
        xeUtils.remove(treeExpandeds, function(row2) {
          return $xetable.findRowIndexOf(validRows, row2) > -1;
        });
      }
      if (reserve) {
        validRows.forEach(function(row2) {
          return handleTreeExpandReserve(row2, expanded);
        });
      }
      return Promise.all(result).then(function() {
        return tableMethods.recalculate();
      });
    };
    var handleVirtualTreeExpand = function(rows, expanded) {
      return handleBaseTreeExpand(rows, expanded).then(function() {
        handleVirtualTreeToList();
        return tablePrivateMethods.handleTableData();
      }).then(function() {
        return tableMethods.recalculate();
      });
    };
    var loadScrollYData = function(evnt) {
      var mergeList = reactData.mergeList;
      var scrollYStore = internalData.scrollYStore;
      var startIndex = scrollYStore.startIndex, endIndex = scrollYStore.endIndex, visibleSize = scrollYStore.visibleSize, offsetSize = scrollYStore.offsetSize, rowHeight = scrollYStore.rowHeight;
      var scrollBodyElem = evnt.currentTarget || evnt.target;
      var scrollTop = scrollBodyElem.scrollTop;
      var toVisibleIndex = Math.floor(scrollTop / rowHeight);
      var offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList, offsetItem, "row");
      var offsetStartIndex = offsetItem.startIndex, offsetEndIndex = offsetItem.endIndex;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    var createGetRowCacheProp = function(prop) {
      return function(row2) {
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        if (row2) {
          var rowid = getRowid($xetable, row2);
          var rest = fullAllDataRowIdData[rowid];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    var createGetColumnCacheProp = function(prop) {
      return function(column2) {
        var fullColumnIdData = internalData.fullColumnIdData;
        if (column2) {
          var rest = fullColumnIdData[column2.id];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    var debounceScrollY = xeUtils.debounce(function(evnt) {
      loadScrollYData(evnt);
    }, 20, { leading: false, trailing: true });
    var keyCtxTimeout;
    tableMethods = {
      dispatchEvent: function(type2, params, evnt) {
        emit(type2, Object.assign({ $table: $xetable, $event: evnt }, params));
      },
      clearAll: function() {
        return clearTableAllStatus($xetable);
      },
      syncData: function() {
        return nextTick$1().then(function() {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick$1();
        });
      },
      updateData: function() {
        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;
        return tablePrivateMethods.handleTableData(true).then(function() {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(function() {
          tablePrivateMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(function() {
          setTimeout(function() {
            return $xetable.recalculate();
          }, 50);
        });
      },
      loadData: function(datas) {
        var inited = internalData.inited, initStatus = internalData.initStatus;
        return loadTableData(datas).then(function() {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      reloadData: function(datas) {
        var inited = internalData.inited;
        return tableMethods.clearAll().then(function() {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(function() {
          handleLoadDefaults();
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      reloadRow: function(row2, record, field) {
        var keepSource = props.keepSource;
        var tableData = reactData.tableData;
        var tableSourceData = internalData.tableSourceData;
        if (keepSource) {
          var rowIndex = tableMethods.getRowIndex(row2);
          var oRow = tableSourceData[rowIndex];
          if (oRow && row2) {
            if (field) {
              var newValue = xeUtils.get(record || row2, field);
              xeUtils.set(row2, field, newValue);
              xeUtils.set(oRow, field, newValue);
            } else {
              var newRecord = xeUtils.clone(__assign$1({}, record), true);
              xeUtils.destructuring(oRow, Object.assign(row2, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        }
        return nextTick$1();
      },
      loadTreeChildren: function(row2, childRecords) {
        var keepSource = props.keepSource;
        var tableSourceData = internalData.tableSourceData, fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform, children2 = treeOpts.children, mapChildren = treeOpts.mapChildren;
        var parentRest = fullAllDataRowIdData[getRowid($xetable, row2)];
        var parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then(function(rows) {
          if (keepSource) {
            var rowid_1 = getRowid($xetable, row2);
            var matchObj = xeUtils.findTree(tableSourceData, function(item) {
              return rowid_1 === getRowid($xetable, item);
            }, treeOpts);
            if (matchObj) {
              matchObj.item[children2] = xeUtils.clone(rows, true);
            }
          }
          xeUtils.eachTree(rows, function(childRow, index, items, path, parent2, nodes) {
            var rowid = getRowid($xetable, childRow);
            var rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, items, parent: parent2, level: parentLevel + nodes.length };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, treeOpts);
          row2[children2] = rows;
          if (transform) {
            row2[mapChildren] = rows;
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      loadColumn: function(columns) {
        var collectColumn = xeUtils.mapTree(columns, function(column2) {
          return reactive$1(Cell.createColumn($xetable, column2));
        });
        return handleColumn(collectColumn);
      },
      reloadColumn: function(columns) {
        return tableMethods.clearAll().then(function() {
          return tableMethods.loadColumn(columns);
        });
      },
      getRowNode: function(tr2) {
        if (tr2) {
          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
          var rowid = tr2.getAttribute("rowid");
          if (rowid) {
            var rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      getColumnNode: function(cell) {
        if (cell) {
          var fullColumnIdData = internalData.fullColumnIdData;
          var colid = cell.getAttribute("colid");
          if (colid) {
            var rest = fullColumnIdData[colid];
            if (rest) {
              return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      getRowSeq: createGetRowCacheProp("seq"),
      getRowIndex: createGetRowCacheProp("index"),
      getVTRowIndex: createGetRowCacheProp("_index"),
      getVMRowIndex: createGetRowCacheProp("$index"),
      getColumnIndex: createGetColumnCacheProp("index"),
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      createData: function(records) {
        var treeConfig = props.treeConfig;
        var treeOpts = computeTreeOpts.value;
        var handleRrecord = function(record) {
          return reactive$1(tablePrivateMethods.defineField(record || {}));
        };
        var rows = treeConfig ? xeUtils.mapTree(records, handleRrecord, treeOpts) : records.map(handleRrecord);
        return nextTick$1().then(function() {
          return rows;
        });
      },
      createRow: function(records) {
        var isArr = xeUtils.isArray(records);
        if (!isArr) {
          records = [records];
        }
        return nextTick$1().then(function() {
          return tableMethods.createData(records).then(function(rows) {
            return isArr ? rows : rows[0];
          });
        });
      },
      revertData: function(rows, field) {
        var keepSource = props.keepSource;
        var tableSourceData = internalData.tableSourceData, tableFullData = internalData.tableFullData;
        if (!keepSource) {
          return nextTick$1();
        }
        var targetRows = rows;
        if (rows) {
          if (!xeUtils.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = xeUtils.toArray($xetable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach(function(row2) {
            if (!tableMethods.isInsertByRow(row2)) {
              var rowIndex = $xetable.findRowIndexOf(tableFullData, row2);
              var oRow = tableSourceData[rowIndex];
              if (oRow && row2) {
                if (field) {
                  xeUtils.set(row2, field, xeUtils.clone(xeUtils.get(oRow, field), true));
                } else {
                  xeUtils.destructuring(row2, xeUtils.clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return nextTick$1();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      clearData: function(rows, field) {
        var tableFullData = internalData.tableFullData, visibleColumn = internalData.visibleColumn;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !xeUtils.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach(function(row2) {
            return xeUtils.set(row2, field, null);
          });
        } else {
          rows.forEach(function(row2) {
            visibleColumn.forEach(function(column2) {
              if (column2.field) {
                setCellValue(row2, column2, null);
              }
            });
          });
        }
        return nextTick$1();
      },
      isInsertByRow: function(row2) {
        var editStore = reactData.editStore;
        return $xetable.findRowIndexOf(editStore.insertList, row2) > -1;
      },
      removeInsertRow: function() {
        var editStore = reactData.editStore;
        return $xetable.remove(editStore.insertList);
      },
      isUpdateByRow: function(row2, field) {
        var _a2, _b2;
        var keepSource = props.keepSource, treeConfig = props.treeConfig;
        var visibleColumn = internalData.visibleColumn, tableSourceData = internalData.tableSourceData, fullDataRowIdData = internalData.fullDataRowIdData;
        var treeOpts = computeTreeOpts.value;
        if (keepSource) {
          var oRow = void 0, property2 = void 0;
          var rowid_2 = getRowid($xetable, row2);
          if (!fullDataRowIdData[rowid_2]) {
            return false;
          }
          if (treeConfig) {
            var children2 = treeOpts.children;
            var matchObj = xeUtils.findTree(tableSourceData, function(item) {
              return rowid_2 === getRowid($xetable, item);
            }, treeOpts);
            row2 = Object.assign({}, row2, (_a2 = {}, _a2[children2] = null, _a2));
            if (matchObj) {
              oRow = Object.assign({}, matchObj.item, (_b2 = {}, _b2[children2] = null, _b2));
            }
          } else {
            var oRowIndex = fullDataRowIdData[rowid_2].index;
            oRow = tableSourceData[oRowIndex];
          }
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row2, field);
            }
            for (var index = 0, len2 = visibleColumn.length; index < len2; index++) {
              property2 = visibleColumn[index].field;
              if (property2 && !eqCellValue(oRow, row2, property2)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      getColumns: function(columnIndex) {
        var columns = internalData.visibleColumn;
        return xeUtils.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      getColumnById: function(colid) {
        var fullColumnIdData = internalData.fullColumnIdData;
        return fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      getColumnByField: function(field) {
        var fullColumnFieldData = internalData.fullColumnFieldData;
        return fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getTableColumn: function() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      getData: function(rowIndex) {
        var tableSynchData = props.data || internalData.tableSynchData;
        return xeUtils.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      getCheckboxRecords: function(isFull) {
        var treeConfig = props.treeConfig;
        var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData, afterTreeFullData = internalData.afterTreeFullData, tableFullTreeData = internalData.tableFullTreeData;
        var treeOpts = computeTreeOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var transform = treeOpts.transform, children2 = treeOpts.children, mapChildren = treeOpts.mapChildren;
        var checkField = checkboxOpts.checkField;
        var rowList = [];
        var currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = xeUtils.filterTree(currTableData, function(row2) {
              return xeUtils.get(row2, checkField);
            }, { children: transform ? mapChildren : children2 });
          } else {
            rowList = currTableData.filter(function(row2) {
              return xeUtils.get(row2, checkField);
            });
          }
        } else {
          var selection_1 = reactData.selection;
          if (treeConfig) {
            rowList = xeUtils.filterTree(currTableData, function(row2) {
              return $xetable.findRowIndexOf(selection_1, row2) > -1;
            }, { children: transform ? mapChildren : children2 });
          } else {
            rowList = currTableData.filter(function(row2) {
              return $xetable.findRowIndexOf(selection_1, row2) > -1;
            });
          }
        }
        return rowList;
      },
      getParentRow: function(rowOrRowid) {
        var treeConfig = props.treeConfig;
        var fullDataRowIdData = internalData.fullDataRowIdData;
        if (rowOrRowid && treeConfig) {
          var rowid = void 0;
          if (xeUtils.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xetable, rowOrRowid);
          }
          if (rowid) {
            return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].parent : null;
          }
        }
        return null;
      },
      getRowById: function(cellValue) {
        var fullDataRowIdData = internalData.fullDataRowIdData;
        var rowid = xeUtils.eqNull(cellValue) ? "" : encodeURIComponent(cellValue);
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      getRowid: function(row2) {
        return getRowid($xetable, row2);
      },
      getTableData: function() {
        var tableData = reactData.tableData, footerTableData = reactData.footerTableData;
        var tableFullData = internalData.tableFullData, afterFullData = internalData.afterFullData;
        return {
          fullData: tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      hideColumn: function(fieldOrColumn) {
        var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column2) {
          column2.visible = false;
        }
        return tablePrivateMethods.handleCustom();
      },
      showColumn: function(fieldOrColumn) {
        var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column2) {
          column2.visible = true;
        }
        return tablePrivateMethods.handleCustom();
      },
      resetColumn: function(options) {
        var tableFullColumn = internalData.tableFullColumn;
        var customOpts = computeCustomOpts.value;
        var checkMethod = customOpts.checkMethod;
        var opts = Object.assign({ visible: true, resizable: options === true }, options);
        tableFullColumn.forEach(function(column2) {
          if (opts.resizable) {
            column2.resizeWidth = 0;
          }
          if (!checkMethod || checkMethod({ column: column2 })) {
            column2.visible = column2.defaultVisible;
          }
        });
        if (opts.resizable) {
          tablePrivateMethods.saveCustomResizable(true);
        }
        return tablePrivateMethods.handleCustom();
      },
      refreshColumn: function() {
        return parseColumns().then(function() {
          return tableMethods.refreshScroll();
        }).then(function() {
          return tableMethods.recalculate();
        });
      },
      refreshScroll: function() {
        var lastScrollLeft = internalData.lastScrollLeft, lastScrollTop = internalData.lastScrollTop;
        var tableBody = refTableBody.value;
        var tableFooter = refTableFooter.value;
        var leftBody = refTableLeftBody.value;
        var rightBody = refTableRightBody.value;
        var tableBodyElem = tableBody ? tableBody.$el : null;
        var leftBodyElem = leftBody ? leftBody.$el : null;
        var rightBodyElem = rightBody ? rightBody.$el : null;
        var tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise(function(resolve) {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then(resolve).then(function() {
              setTimeout(resolve, 30);
            });
          }
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          setTimeout(resolve, 30);
        });
      },
      recalculate: function(refull) {
        autoCellWidth();
        if (refull === true) {
          return computeScrollLoad().then(function() {
            autoCellWidth();
            return computeScrollLoad();
          });
        }
        return computeScrollLoad();
      },
      openTooltip: function(target, content) {
        var $commTip = refCommTooltip.value;
        if ($commTip) {
          return $commTip.open(target, content);
        }
        return nextTick$1();
      },
      closeTooltip: function() {
        var tooltipStore = reactData.tooltipStore;
        var $tooltip = refTooltip.value;
        var $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false
          });
          if ($tooltip) {
            $tooltip.close();
          }
        }
        if ($commTip) {
          $commTip.close();
        }
        return nextTick$1();
      },
      isAllCheckboxChecked: function() {
        return reactData.isAllSelected;
      },
      isAllCheckboxIndeterminate: function() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      getCheckboxIndeterminateRecords: function(isFull) {
        var treeConfig = props.treeConfig;
        var afterFullData = internalData.afterFullData;
        var treeIndeterminates = reactData.treeIndeterminates;
        if (treeConfig) {
          return isFull ? treeIndeterminates.slice(0) : treeIndeterminates.filter(function(row2) {
            return $xetable.findRowIndexOf(afterFullData, row2) > -1;
          });
        }
        return [];
      },
      setCheckboxRow: function(rows, value) {
        if (rows && !xeUtils.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach(function(row2) {
          return tablePrivateMethods.handleSelectRow({ row: row2 }, !!value);
        });
        return nextTick$1();
      },
      isCheckedByCheckboxRow: function(row2) {
        var selection = reactData.selection;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField;
        if (checkField) {
          return xeUtils.get(row2, checkField);
        }
        return $xetable.findRowIndexOf(selection, row2) > -1;
      },
      isIndeterminateByCheckboxRow: function(row2) {
        var treeIndeterminates = reactData.treeIndeterminates;
        return $xetable.findRowIndexOf(treeIndeterminates, row2) > -1 && !tableMethods.isCheckedByCheckboxRow(row2);
      },
      toggleCheckboxRow: function(row2) {
        tablePrivateMethods.handleToggleCheckRowEvent(null, { row: row2 });
        return nextTick$1();
      },
      setAllCheckboxRow: function(value) {
        var treeConfig = props.treeConfig;
        var selection = reactData.selection;
        var afterFullData = internalData.afterFullData, checkboxReserveRowMap = internalData.checkboxReserveRowMap;
        var treeOpts = computeTreeOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;
        var selectRows = [];
        var beforeSelection = treeConfig ? [] : selection.filter(function(row2) {
          return $xetable.findRowIndexOf(afterFullData, row2) === -1;
        });
        if (checkStrictly) {
          reactData.isAllSelected = value;
        } else {
          if (checkField) {
            var checkValFn = function(row2) {
              if (!checkMethod || checkMethod({ row: row2 })) {
                if (value) {
                  selectRows.push(row2);
                }
                xeUtils.set(row2, checkField, value);
              }
            };
            if (treeConfig) {
              xeUtils.eachTree(afterFullData, checkValFn, treeOpts);
            } else {
              afterFullData.forEach(checkValFn);
            }
          } else {
            if (treeConfig) {
              if (value) {
                xeUtils.eachTree(afterFullData, function(row2) {
                  if (!checkMethod || checkMethod({ row: row2 })) {
                    selectRows.push(row2);
                  }
                }, treeOpts);
              } else {
                if (checkMethod) {
                  xeUtils.eachTree(afterFullData, function(row2) {
                    if (checkMethod({ row: row2 }) ? 0 : $xetable.findRowIndexOf(selection, row2) > -1) {
                      selectRows.push(row2);
                    }
                  }, treeOpts);
                }
              }
            } else {
              if (value) {
                if (checkMethod) {
                  selectRows = afterFullData.filter(function(row2) {
                    return $xetable.findRowIndexOf(selection, row2) > -1 || checkMethod({ row: row2 });
                  });
                } else {
                  selectRows = afterFullData.slice(0);
                }
              } else {
                if (checkMethod) {
                  selectRows = afterFullData.filter(function(row2) {
                    return checkMethod({ row: row2 }) ? 0 : $xetable.findRowIndexOf(selection, row2) > -1;
                  });
                }
              }
            }
          }
          if (reserve) {
            if (value) {
              selectRows.forEach(function(row2) {
                checkboxReserveRowMap[getRowid($xetable, row2)] = row2;
              });
            } else {
              afterFullData.forEach(function(row2) {
                return handleCheckboxReserveRow(row2, false);
              });
            }
          }
          reactData.selection = checkField ? [] : beforeSelection.concat(selectRows);
        }
        reactData.treeIndeterminates = [];
        tablePrivateMethods.checkSelectionStatus();
        return nextTick$1();
      },
      getRadioReserveRecord: function(isFull) {
        var treeConfig = props.treeConfig;
        var fullDataRowIdData = internalData.fullDataRowIdData, radioReserveRow = internalData.radioReserveRow, afterFullData = internalData.afterFullData;
        var radioOpts = computeRadioOpts.value;
        var treeOpts = computeTreeOpts.value;
        if (radioOpts.reserve && radioReserveRow) {
          var rowid_3 = getRowid($xetable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid_3]) {
              return radioReserveRow;
            }
          } else {
            var rowkey_2 = getRowkey($xetable);
            if (treeConfig) {
              var matchObj = xeUtils.findTree(afterFullData, function(row2) {
                return rowid_3 === xeUtils.get(row2, rowkey_2);
              }, treeOpts);
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some(function(row2) {
                return rowid_3 === xeUtils.get(row2, rowkey_2);
              })) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve: function() {
        internalData.radioReserveRow = null;
        return nextTick$1();
      },
      getCheckboxReserveRecords: function(isFull) {
        var treeConfig = props.treeConfig;
        var afterFullData = internalData.afterFullData, fullDataRowIdData = internalData.fullDataRowIdData, checkboxReserveRowMap = internalData.checkboxReserveRowMap;
        var checkboxOpts = computeCheckboxOpts.value;
        var treeOpts = computeTreeOpts.value;
        var reserveSelection = [];
        if (checkboxOpts.reserve) {
          var afterFullIdMaps_1 = {};
          if (treeConfig) {
            xeUtils.eachTree(afterFullData, function(row2) {
              afterFullIdMaps_1[getRowid($xetable, row2)] = 1;
            }, treeOpts);
          } else {
            afterFullData.forEach(function(row2) {
              afterFullIdMaps_1[getRowid($xetable, row2)] = 1;
            });
          }
          xeUtils.each(checkboxReserveRowMap, function(oldRow, oldRowid) {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps_1[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve: function() {
        internalData.checkboxReserveRowMap = {};
        return nextTick$1();
      },
      toggleAllCheckboxRow: function() {
        tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick$1();
      },
      clearCheckboxRow: function() {
        var treeConfig = props.treeConfig;
        var tableFullData = internalData.tableFullData;
        var treeOpts = computeTreeOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField, reserve = checkboxOpts.reserve;
        if (checkField) {
          if (treeConfig) {
            xeUtils.eachTree(tableFullData, function(item) {
              return xeUtils.set(item, checkField, false);
            }, treeOpts);
          } else {
            tableFullData.forEach(function(item) {
              return xeUtils.set(item, checkField, false);
            });
          }
        }
        if (reserve) {
          tableFullData.forEach(function(row2) {
            return handleCheckboxReserveRow(row2, false);
          });
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selection = [];
        reactData.treeIndeterminates = [];
        return nextTick$1();
      },
      setCurrentRow: function(row2) {
        var rowOpts = computeRowOpts.value;
        var el2 = refElem.value;
        tableMethods.clearCurrentRow();
        tableMethods.clearCurrentColumn();
        reactData.currentRow = row2;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el2) {
            xeUtils.arrayEach(el2.querySelectorAll('[rowid="'.concat(getRowid($xetable, row2), '"]')), function(elem) {
              return addClass$2(elem, "row--current");
            });
          }
        }
        return nextTick$1();
      },
      isCheckedByRadioRow: function(row2) {
        return $xetable.eqRow(reactData.selectRow, row2);
      },
      setRadioRow: function(row2) {
        var radioOpts = computeRadioOpts.value;
        var checkMethod = radioOpts.checkMethod;
        if (row2 && (!checkMethod || checkMethod({ row: row2 }))) {
          reactData.selectRow = row2;
          handleRadioReserveRow(row2);
        }
        return nextTick$1();
      },
      clearCurrentRow: function() {
        var el2 = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el2) {
          xeUtils.arrayEach(el2.querySelectorAll(".row--current"), function(elem) {
            return removeClass$2(elem, "row--current");
          });
        }
        return nextTick$1();
      },
      clearRadioRow: function() {
        reactData.selectRow = null;
        return nextTick$1();
      },
      getCurrentRecord: function() {
        var rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      getRadioRecord: function(isFull) {
        var treeConfig = props.treeConfig;
        var fullDataRowIdData = internalData.fullDataRowIdData, afterFullData = internalData.afterFullData;
        var selectRow = reactData.selectRow;
        var treeOpts = computeTreeOpts.value;
        if (selectRow) {
          var rowid_4 = getRowid($xetable, selectRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid_4]) {
              return selectRow;
            }
          } else {
            if (treeConfig) {
              var rowkey_3 = getRowkey($xetable);
              var matchObj = xeUtils.findTree(afterFullData, function(row2) {
                return rowid_4 === xeUtils.get(row2, rowkey_3);
              }, treeOpts);
              if (matchObj) {
                return selectRow;
              }
            } else {
              if ($xetable.findRowIndexOf(afterFullData, selectRow) > -1) {
                return selectRow;
              }
            }
          }
        }
        return null;
      },
      getCurrentColumn: function() {
        var columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      setCurrentColumn: function(fieldOrColumn) {
        var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column2) {
          tableMethods.clearCurrentRow();
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column2;
        }
        return nextTick$1();
      },
      clearCurrentColumn: function() {
        reactData.currentColumn = null;
        return nextTick$1();
      },
      sort: function(sortConfs, sortOrder) {
        var sortOpts = computeSortOpts.value;
        var multiple = sortOpts.multiple, remote = sortOpts.remote, orders = sortOpts.orders;
        if (sortConfs) {
          if (xeUtils.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!xeUtils.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach(function(confs, index) {
            var field = confs.field, order = confs.order;
            var column2 = field;
            if (xeUtils.isString(field)) {
              column2 = tableMethods.getColumnByField(field);
            }
            if (column2 && column2.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column2);
              }
              if (column2.order !== order) {
                column2.order = order;
              }
              column2.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick$1().then(updateStyle2);
        }
        return nextTick$1();
      },
      clearSort: function(fieldOrColumn) {
        var sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column2) {
            column2.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick$1().then(updateStyle2);
      },
      isSort: function(fieldOrColumn) {
        if (fieldOrColumn) {
          var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
          return column2 ? column2.sortable && !!column2.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns: function() {
        var sortOpts = computeSortOpts.value;
        var multiple = sortOpts.multiple, chronological = sortOpts.chronological;
        var sortList = [];
        var tableFullColumn = internalData.tableFullColumn;
        tableFullColumn.forEach(function(column2) {
          var field = column2.field, order = column2.order;
          if (column2.sortable && order) {
            sortList.push({ column: column2, field, property: field, order, sortTime: column2.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return xeUtils.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      closeFilter: function() {
        var filterStore = reactData.filterStore;
        var column2 = filterStore.column, visible = filterStore.visible;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          $xetable.dispatchEvent("filter-visible", { column: column2, property: column2.field, field: column2.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);
        }
        return nextTick$1();
      },
      isFilter: function(fieldOrColumn) {
        var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column2) {
          return column2.filters && column2.filters.some(function(option) {
            return option.checked;
          });
        }
        return $xetable.getCheckedFilters().length > 0;
      },
      isRowExpandLoaded: function(row2) {
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
        return rest && !!rest.expandLoaded;
      },
      clearRowExpandLoaded: function(row2) {
        var expandLazyLoadeds = reactData.expandLazyLoadeds;
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var expandOpts = computeExpandOpts.value;
        var lazy = expandOpts.lazy;
        var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
        if (lazy && rest) {
          rest.expandLoaded = false;
          xeUtils.remove(expandLazyLoadeds, function(item) {
            return $xetable.eqRow(item, row2);
          });
        }
        return nextTick$1();
      },
      reloadRowExpand: function(row2) {
        var expandLazyLoadeds = reactData.expandLazyLoadeds;
        var expandOpts = computeExpandOpts.value;
        var lazy = expandOpts.lazy;
        if (lazy && $xetable.findRowIndexOf(expandLazyLoadeds, row2) === -1) {
          tableMethods.clearRowExpandLoaded(row2).then(function() {
            return handleAsyncRowExpand(row2);
          });
        }
        return nextTick$1();
      },
      reloadExpandContent: function(row2) {
        return tableMethods.reloadRowExpand(row2);
      },
      toggleRowExpand: function(row2) {
        return tableMethods.setRowExpand(row2, !tableMethods.isExpandByRow(row2));
      },
      setAllRowExpand: function(expanded) {
        var expandOpts = computeExpandOpts.value;
        return tableMethods.setRowExpand(expandOpts.lazy ? reactData.tableData : internalData.tableFullData, expanded);
      },
      setRowExpand: function(rows, expanded) {
        var rowExpandeds = reactData.rowExpandeds, expandLazyLoadeds = reactData.expandLazyLoadeds, column2 = reactData.expandColumn;
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var expandOpts = computeExpandOpts.value;
        var reserve = expandOpts.reserve, lazy = expandOpts.lazy, accordion = expandOpts.accordion, toggleMethod = expandOpts.toggleMethod;
        var lazyRests = [];
        var columnIndex = tableMethods.getColumnIndex(column2);
        var $columnIndex = tableMethods.getVMColumnIndex(column2);
        if (rows) {
          if (!xeUtils.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rowExpandeds = [];
            rows = rows.slice(rows.length - 1, rows.length);
          }
          var validRows_1 = toggleMethod ? rows.filter(function(row2) {
            return toggleMethod({ $table: $xetable, expanded, column: column2, columnIndex, $columnIndex, row: row2, rowIndex: tableMethods.getRowIndex(row2), $rowIndex: tableMethods.getVMRowIndex(row2) });
          }) : rows;
          if (expanded) {
            validRows_1.forEach(function(row2) {
              if ($xetable.findRowIndexOf(rowExpandeds, row2) === -1) {
                var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
                var isLoad = lazy && !rest.expandLoaded && $xetable.findRowIndexOf(expandLazyLoadeds, row2) === -1;
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row2));
                } else {
                  rowExpandeds.push(row2);
                }
              }
            });
          } else {
            xeUtils.remove(rowExpandeds, function(row2) {
              return $xetable.findRowIndexOf(validRows_1, row2) > -1;
            });
          }
          if (reserve) {
            validRows_1.forEach(function(row2) {
              return handleRowExpandReserve(row2, expanded);
            });
          }
        }
        reactData.rowExpandeds = rowExpandeds;
        return Promise.all(lazyRests).then(function() {
          return tableMethods.recalculate();
        });
      },
      isExpandByRow: function(row2) {
        var rowExpandeds = reactData.rowExpandeds;
        return $xetable.findRowIndexOf(rowExpandeds, row2) > -1;
      },
      clearRowExpand: function() {
        var rowExpandeds = reactData.rowExpandeds;
        var tableFullData = internalData.tableFullData;
        var expandOpts = computeExpandOpts.value;
        var reserve = expandOpts.reserve;
        var isExists = rowExpandeds.length;
        reactData.rowExpandeds = [];
        if (reserve) {
          tableFullData.forEach(function(row2) {
            return handleRowExpandReserve(row2, false);
          });
        }
        return nextTick$1().then(function() {
          if (isExists) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve: function() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick$1();
      },
      getRowExpandRecords: function() {
        return reactData.rowExpandeds.slice(0);
      },
      getTreeExpandRecords: function() {
        return reactData.treeExpandeds.slice(0);
      },
      isTreeExpandLoaded: function(row2) {
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
        return rest && !!rest.treeLoaded;
      },
      clearTreeExpandLoaded: function(row2) {
        var treeExpandeds = reactData.treeExpandeds;
        var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform, lazy = treeOpts.lazy;
        var rest = fullAllDataRowIdData[getRowid($xetable, row2)];
        if (lazy && rest) {
          rest.treeLoaded = false;
          xeUtils.remove(treeExpandeds, function(item) {
            return $xetable.eqRow(item, row2);
          });
        }
        if (transform) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return nextTick$1();
      },
      reloadTreeExpand: function(row2) {
        var treeLazyLoadeds = reactData.treeLazyLoadeds;
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform, lazy = treeOpts.lazy, hasChild = treeOpts.hasChild;
        if (lazy && row2[hasChild] && $xetable.findRowIndexOf(treeLazyLoadeds, row2) === -1) {
          tableMethods.clearTreeExpandLoaded(row2).then(function() {
            return handleAsyncTreeExpandChilds(row2);
          }).then(function() {
            if (transform) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(function() {
            return tableMethods.recalculate();
          });
        }
        return nextTick$1();
      },
      reloadTreeChilds: function(row2) {
        return tableMethods.reloadTreeExpand(row2);
      },
      toggleTreeExpand: function(row2) {
        return tableMethods.setTreeExpand(row2, !tableMethods.isTreeExpandByRow(row2));
      },
      setAllTreeExpand: function(expanded) {
        var tableFullData = internalData.tableFullData;
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform, lazy = treeOpts.lazy, children2 = treeOpts.children;
        var expandeds = [];
        xeUtils.eachTree(tableFullData, function(row2) {
          var rowChildren = row2[children2];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row2);
          }
        }, treeOpts);
        return tableMethods.setTreeExpand(expandeds, expanded).then(function() {
          if (transform) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      setTreeExpand: function(rows, expanded) {
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform;
        if (rows) {
          if (!xeUtils.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick$1();
      },
      isTreeExpandByRow: function(row2) {
        var treeExpandeds = reactData.treeExpandeds;
        return $xetable.findRowIndexOf(treeExpandeds, row2) > -1;
      },
      clearTreeExpand: function() {
        var treeExpandeds = reactData.treeExpandeds;
        var tableFullTreeData = internalData.tableFullTreeData;
        var treeOpts = computeTreeOpts.value;
        var transform = treeOpts.transform, reserve = treeOpts.reserve;
        var isExists = treeExpandeds.length;
        reactData.treeExpandeds = [];
        if (reserve) {
          xeUtils.eachTree(tableFullTreeData, function(row2) {
            return handleTreeExpandReserve(row2, false);
          }, treeOpts);
        }
        return tablePrivateMethods.handleTableData().then(function() {
          if (transform) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(function() {
          if (isExists) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve: function() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick$1();
      },
      getScroll: function() {
        var scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad;
        var tableBody = refTableBody.value;
        var bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      scrollTo: function(scrollLeft, scrollTop) {
        var tableBody = refTableBody.value;
        var tableFooter = refTableFooter.value;
        var rightBody = refTableRightBody.value;
        var tableBodyElem = tableBody ? tableBody.$el : null;
        var rightBodyElem = rightBody ? rightBody.$el : null;
        var tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (xeUtils.isNumber(scrollLeft)) {
          setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);
        }
        if (xeUtils.isNumber(scrollTop)) {
          setScrollTop(rightBodyElem || tableBodyElem, scrollTop);
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise(function(resolve) {
            return setTimeout(function() {
              return resolve(nextTick$1());
            }, 50);
          });
        }
        return nextTick$1();
      },
      scrollToRow: function(row2, fieldOrColumn) {
        var rest = [];
        if (row2) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row2));
          } else {
            rest.push(rowToVisible($xetable, row2));
          }
        }
        if (fieldOrColumn) {
          rest.push(tableMethods.scrollToColumn(fieldOrColumn));
        }
        return Promise.all(rest);
      },
      scrollToColumn: function(fieldOrColumn) {
        var fullColumnIdData = internalData.fullColumnIdData;
        var column2 = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column2 && fullColumnIdData[column2.id]) {
          return colToVisible($xetable, column2);
        }
        return nextTick$1();
      },
      clearScroll: function() {
        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;
        var tableBody = refTableBody.value;
        var tableFooter = refTableFooter.value;
        var rightBody = refTableRightBody.value;
        var tableBodyElem = tableBody ? tableBody.$el : null;
        var rightBodyElem = rightBody ? rightBody.$el : null;
        var tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (rightBodyElem) {
          restoreScrollListener(rightBodyElem);
          rightBodyElem.scrollTop = 0;
        }
        if (tableFooterElem) {
          tableFooterElem.scrollLeft = 0;
        }
        if (tableBodyElem) {
          restoreScrollListener(tableBodyElem);
          tableBodyElem.scrollTop = 0;
          tableBodyElem.scrollLeft = 0;
        }
        scrollXStore.startIndex = 0;
        scrollYStore.startIndex = 0;
        return nextTick$1();
      },
      updateFooter: function() {
        var showFooter = props.showFooter, footerMethod = props.footerMethod;
        var visibleColumn = internalData.visibleColumn, afterFullData = internalData.afterFullData;
        if (showFooter && footerMethod) {
          reactData.footerTableData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];
        }
        return nextTick$1();
      },
      updateStatus: function(scope, cellValue) {
        var customVal = !xeUtils.isUndefined(cellValue);
        return nextTick$1().then(function() {
          var editRules = props.editRules;
          var validStore = reactData.validStore;
          var tableBody = refTableBody.value;
          if (scope && tableBody && editRules) {
            var row_1 = scope.row, column_3 = scope.column;
            var type2 = "change";
            if ($xetable.hasCellRules) {
              if ($xetable.hasCellRules(type2, row_1, column_3)) {
                var cell_1 = tablePrivateMethods.getCell(row_1, column_3);
                if (cell_1) {
                  return $xetable.validCellRules(type2, row_1, column_3, cellValue).then(function() {
                    if (customVal && validStore.visible) {
                      setCellValue(row_1, column_3, cellValue);
                    }
                    $xetable.clearValidate();
                  }).catch(function(_a2) {
                    var rule2 = _a2.rule;
                    if (customVal) {
                      setCellValue(row_1, column_3, cellValue);
                    }
                    $xetable.showValidTooltip({ rule: rule2, row: row_1, column: column_3, cell: cell_1 });
                  });
                }
              }
            }
          }
        });
      },
      setMergeCells: function(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick$1().then(function() {
          return tablePrivateMethods.updateCellAreas();
        });
      },
      removeMergeCells: function(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        var rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick$1().then(function() {
          tablePrivateMethods.updateCellAreas();
          return rest;
        });
      },
      getMergeCells: function() {
        return reactData.mergeList.slice(0);
      },
      clearMergeCells: function() {
        reactData.mergeList = [];
        return nextTick$1();
      },
      setMergeFooterItems: function(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick$1().then(function() {
          return tablePrivateMethods.updateCellAreas();
        });
      },
      removeMergeFooterItems: function(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        var rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick$1().then(function() {
          tablePrivateMethods.updateCellAreas();
          return rest;
        });
      },
      getMergeFooterItems: function() {
        return reactData.mergeFooterList.slice(0);
      },
      clearMergeFooterItems: function() {
        reactData.mergeFooterList = [];
        return nextTick$1();
      },
      focus: function() {
        internalData.isActivated = true;
        return nextTick$1();
      },
      blur: function() {
        internalData.isActivated = false;
        return nextTick$1();
      },
      connect: function($toolbar) {
        if ($toolbar) {
          $xetoolbar = $toolbar;
          $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick$1();
      }
    };
    var handleGlobalMousedownEvent = function(evnt) {
      var editStore = reactData.editStore, ctxMenuStore = reactData.ctxMenuStore, filterStore = reactData.filterStore;
      var mouseConfig = props.mouseConfig;
      var el2 = refElem.value;
      var editOpts = computeEditOpts.value;
      var actived = editStore.actived;
      var $validTooltip = refValidTooltip.value;
      var tableFilter = refTableFilter.value;
      var tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el2, "vxe-cell--filter").flag)
          ;
        else if (getEventTargetNode(evnt, tableFilter.$el).flag)
          ;
        else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          var cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag)
              ;
            else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearActived", actived.args, function() {
                  var isClear;
                  if (editOpts.mode === "row") {
                    var rowTargetNode = getEventTargetNode(evnt, el2, "vxe-body--row");
                    var rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el2, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    var bodyWrapperElem = evnt.target;
                    if (hasClass$1(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || !getEventTargetNode(evnt, el2).flag) {
                    setTimeout(function() {
                      return $xetable.clearEdit(evnt);
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el2).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {
          $xetable.clearSelected();
          if ($xetable.clearCellAreas) {
            if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
              tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, function() {
                $xetable.clearCellAreas();
                $xetable.clearCopyCellArea();
              });
            }
          }
        }
      }
      if ($xetable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xetable.closeMenu();
        }
      }
      internalData.isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el2).flag;
    };
    var handleGlobalBlurEvent = function() {
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    var handleGlobalMousewheelEvent = function() {
      tableMethods.closeTooltip();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    var keydownEvent = function(evnt) {
      var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig;
      var filterStore = reactData.filterStore, ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore;
      var mouseOpts = computeMouseOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var actived = editStore.actived;
      var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, function() {
          tableMethods.dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                var params_1 = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick$1(function() {
                    return $xetable.handleSelected(params_1, evnt);
                  });
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
          tableMethods.dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    var handleGlobalKeydownEvent = function(evnt) {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, function() {
          var mouseConfig = props.mouseConfig, keyboardConfig = props.keyboardConfig, treeConfig = props.treeConfig, editConfig = props.editConfig, highlightCurrentRow = props.highlightCurrentRow;
          var ctxMenuStore = reactData.ctxMenuStore, editStore = reactData.editStore, currentRow = reactData.currentRow;
          var isMenu = computeIsMenu.value;
          var bodyMenu = computeBodyMenu.value;
          var keyboardOpts = computeKeyboardOpts.value;
          var mouseOpts = computeMouseOpts.value;
          var editOpts = computeEditOpts.value;
          var treeOpts = computeTreeOpts.value;
          var menuList = computeMenuList.value;
          var rowOpts = computeRowOpts.value;
          var selected = editStore.selected, actived = editStore.actived;
          var keyCode = evnt.keyCode;
          var isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
          var isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);
          var isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
          var isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
          var isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
          var isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
          var isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
          var isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
          var isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
          var isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
          var isF2 = hasEventKey(evnt, EVENT_KEYS.F2);
          var isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);
          var hasMetaKey = evnt.metaKey;
          var hasCtrlKey = evnt.ctrlKey;
          var hasShiftKey = evnt.shiftKey;
          var isAltKey = evnt.altKey;
          var operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          var operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          var isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          var params;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (isEsc) {
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                var params_2 = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick$1(function() {
                    return $xetable.handleSelected(params_2, evnt);
                  });
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xetable.handleActived(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(function() {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            if (hasCtrlKey) {
              if (actived.row) {
                params = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick$1(function() {
                    return $xetable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                var targetArgs = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                var childrens = currentRow[treeOpts.children];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  var targetRow_1 = childrens[0];
                  params = {
                    $table: $xetable,
                    row: targetRow_1,
                    rowIndex: tableMethods.getRowIndex(targetRow_1),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow_1)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(function() {
                    return tableMethods.scrollToRow(targetRow_1);
                  }).then(function() {
                    return tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
                  });
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {
            if (!isEditStatus) {
              var delMethod = keyboardOpts.delMethod, backMethod = keyboardOpts.backMethod;
              if (keyboardOpts.isDel && (selected.row || selected.column)) {
                if (delMethod) {
                  delMethod({
                    row: selected.row,
                    rowIndex: tableMethods.getRowIndex(selected.row),
                    column: selected.column,
                    columnIndex: tableMethods.getColumnIndex(selected.column),
                    $table: $xetable
                  });
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                if (isBack) {
                  if (backMethod) {
                    backMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable
                    });
                  } else {
                    $xetable.handleActived(selected.args, evnt);
                  }
                } else if (isDel) {
                  tableMethods.updateFooter();
                }
              } else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                var parentRow_1 = xeUtils.findTree(internalData.afterFullData, function(item) {
                  return item === currentRow;
                }, treeOpts).parent;
                if (parentRow_1) {
                  evnt.preventDefault();
                  params = {
                    $table: $xetable,
                    row: parentRow_1,
                    rowIndex: tableMethods.getRowIndex(parentRow_1),
                    $rowIndex: tableMethods.getVMRowIndex(parentRow_1)
                  };
                  tableMethods.setTreeExpand(parentRow_1, false).then(function() {
                    return tableMethods.scrollToRow(parentRow_1);
                  }).then(function() {
                    return tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
                  });
                }
              }
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            var editMethod = keyboardOpts.editMethod;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              var beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
              if (!beforeEditMethod || beforeEditMethod(__assign$1(__assign$1({}, selected.args), { $table: $xetable }))) {
                if (editMethod) {
                  editMethod({
                    row: selected.row,
                    rowIndex: tableMethods.getRowIndex(selected.row),
                    column: selected.column,
                    columnIndex: tableMethods.getColumnIndex(selected.column),
                    $table: $xetable,
                    $grid: $xegrid
                  });
                } else {
                  setCellValue(selected.row, selected.column, null);
                  $xetable.handleActived(selected.args, evnt);
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    var handleGlobalPasteEvent = function(evnt) {
      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;
      var editStore = reactData.editStore, filterStore = reactData.filterStore;
      var isActivated = internalData.isActivated;
      var mouseOpts = computeMouseOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var actived = editStore.actived;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {
            $xetable.handlePasteCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("paste", {}, evnt);
      }
    };
    var handleGlobalCopyEvent = function(evnt) {
      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;
      var editStore = reactData.editStore, filterStore = reactData.filterStore;
      var isActivated = internalData.isActivated;
      var mouseOpts = computeMouseOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var actived = editStore.actived;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {
            $xetable.handleCopyCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("copy", {}, evnt);
      }
    };
    var handleGlobalCutEvent = function(evnt) {
      var keyboardConfig = props.keyboardConfig, mouseConfig = props.mouseConfig;
      var editStore = reactData.editStore, filterStore = reactData.filterStore;
      var isActivated = internalData.isActivated;
      var mouseOpts = computeMouseOpts.value;
      var keyboardOpts = computeKeyboardOpts.value;
      var actived = editStore.actived;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {
            $xetable.handleCutCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("cut", {}, evnt);
      }
    };
    var handleGlobalResizeEvent = function() {
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tablePrivateMethods.updateCellAreas();
      tableMethods.recalculate(true);
    };
    var handleTargetEnterEvent = function(isClear) {
      var $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip) {
          $tooltip.setActived(true);
        }
      }
    };
    var handleTooltip = function(evnt, cell, overflowElem, tipElem, params) {
      params.cell = cell;
      var tooltipStore = reactData.tooltipStore;
      var tooltipOpts = computeTooltipOpts.value;
      var column2 = params.column, row2 = params.row;
      var showAll = tooltipOpts.showAll, contentMethod = tooltipOpts.contentMethod;
      var customContent = contentMethod ? contentMethod(params) : null;
      var useCustom = contentMethod && !xeUtils.eqNull(customContent);
      var content = useCustom ? customContent : (column2.type === "html" ? overflowElem.innerText : overflowElem.textContent).trim();
      var isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row: row2,
          column: column2,
          visible: true,
          currOpts: null
        });
        nextTick$1(function() {
          var $tooltip = refTooltip.value;
          if ($tooltip) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return nextTick$1();
    };
    tablePrivateMethods = {
      getSetupOptions: function() {
        return GlobalConfig;
      },
      updateAfterDataIndex,
      callSlot: function(slotFunc, params) {
        if (slotFunc) {
          if ($xegrid) {
            return $xegrid.callSlot(slotFunc, params);
          }
          if (xeUtils.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      getParentElem: function() {
        var el2 = refElem.value;
        if ($xegrid) {
          var gridEl = $xegrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el2 ? el2.parentNode : null;
      },
      getParentHeight: function() {
        var height2 = props.height;
        var el2 = refElem.value;
        if (el2) {
          var parentElem = el2.parentNode;
          var parentPaddingSize = height2 === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xegrid ? $xegrid.getParentHeight() : xeUtils.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      getExcludeHeight: function() {
        return $xegrid ? $xegrid.getExcludeHeight() : 0;
      },
      defineField: function(record) {
        var treeConfig = props.treeConfig;
        var expandOpts = computeExpandOpts.value;
        var treeOpts = computeTreeOpts.value;
        var radioOpts = computeRadioOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var rowkey = getRowkey($xetable);
        internalData.tableFullColumn.forEach(function(column2) {
          var field = column2.field, editRender = column2.editRender;
          if (field && !xeUtils.has(record, field) && !record[field]) {
            var cellValue = null;
            if (editRender) {
              var defaultValue = editRender.defaultValue;
              if (xeUtils.isFunction(defaultValue)) {
                cellValue = defaultValue({ column: column2 });
              } else if (!xeUtils.isUndefined(defaultValue)) {
                cellValue = defaultValue;
              }
            }
            xeUtils.set(record, field, cellValue);
          }
        });
        var otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
        otherFields.forEach(function(key) {
          if (key && eqEmptyValue(xeUtils.get(record, key))) {
            xeUtils.set(record, key, null);
          }
        });
        if (treeConfig && treeOpts.lazy && xeUtils.isUndefined(record[treeOpts.children])) {
          record[treeOpts.children] = null;
        }
        if (eqEmptyValue(xeUtils.get(record, rowkey))) {
          xeUtils.set(record, rowkey, getRowUniqueId());
        }
        return record;
      },
      handleTableData: function(force) {
        var scrollYLoad = reactData.scrollYLoad;
        var scrollYStore = internalData.scrollYStore, fullDataRowIdData = internalData.fullDataRowIdData;
        var fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        var tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach(function(row2, $index) {
          var rowid = getRowid($xetable, row2);
          var rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick$1();
      },
      cacheRowMap: function(isSource) {
        var treeConfig = props.treeConfig;
        var treeOpts = computeTreeOpts.value;
        var fullDataRowIdData = internalData.fullDataRowIdData, fullAllDataRowIdData = internalData.fullAllDataRowIdData, tableFullData = internalData.tableFullData, tableFullTreeData = internalData.tableFullTreeData;
        var rowkey = getRowkey($xetable);
        var isLazy = treeConfig && treeOpts.lazy;
        var handleCache = function(row2, index, items, path, parent2, nodes) {
          var rowid = getRowid($xetable, row2);
          var seq = treeConfig && path ? toTreePathSeq(path) : index + 1;
          var level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            xeUtils.set(row2, rowkey, rowid);
          }
          if (isLazy && row2[treeOpts.hasChild] && xeUtils.isUndefined(row2[treeOpts.children])) {
            row2[treeOpts.children] = null;
          }
          var rest = { row: row2, rowid, seq, index: treeConfig && parent2 ? -1 : index, _index: -1, $index: -1, items, parent: parent2, level };
          if (isSource) {
            fullDataRowIdData[rowid] = rest;
          }
          fullAllDataRowIdData[rowid] = rest;
        };
        if (isSource) {
          fullDataRowIdData = internalData.fullDataRowIdData = {};
        }
        fullAllDataRowIdData = internalData.fullAllDataRowIdData = {};
        if (treeConfig) {
          xeUtils.eachTree(tableFullTreeData, handleCache, treeOpts);
        } else {
          tableFullData.forEach(handleCache);
        }
      },
      analyColumnWidth: function() {
        var tableFullColumn = internalData.tableFullColumn;
        var columnOpts = computeColumnOpts.value;
        var defaultWidth = columnOpts.width, defaultMinWidth = columnOpts.minWidth;
        var resizeList = [];
        var pxList = [];
        var pxMinList = [];
        var scaleList = [];
        var scaleMinList = [];
        var autoList = [];
        tableFullColumn.forEach(function(column2) {
          if (defaultWidth && !column2.width) {
            column2.width = defaultWidth;
          }
          if (defaultMinWidth && !column2.minWidth) {
            column2.minWidth = defaultMinWidth;
          }
          if (column2.visible) {
            if (column2.resizeWidth) {
              resizeList.push(column2);
            } else if (isPx(column2.width)) {
              pxList.push(column2);
            } else if (isScale(column2.width)) {
              scaleList.push(column2);
            } else if (isPx(column2.minWidth)) {
              pxMinList.push(column2);
            } else if (isScale(column2.minWidth)) {
              scaleMinList.push(column2);
            } else {
              autoList.push(column2);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, scaleList, scaleMinList, autoList });
      },
      saveCustomResizable: function(isReset) {
        var id2 = props.id, customConfig = props.customConfig;
        var customOpts = computeCustomOpts.value;
        var collectColumn = internalData.collectColumn;
        var storage = customOpts.storage;
        var isResizable = storage === true || storage && storage.resizable;
        if (customConfig && isResizable) {
          var columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);
          var columnWidthStorage_1;
          if (!id2) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          if (!isReset) {
            columnWidthStorage_1 = xeUtils.isPlainObject(columnWidthStorageMap[id2]) ? columnWidthStorageMap[id2] : {};
            xeUtils.eachTree(collectColumn, function(column2) {
              if (column2.resizeWidth) {
                var colKey = column2.getKey();
                if (colKey) {
                  columnWidthStorage_1[colKey] = column2.renderWidth;
                }
              }
            });
          }
          columnWidthStorageMap[id2] = xeUtils.isEmpty(columnWidthStorage_1) ? void 0 : columnWidthStorage_1;
          localStorage.setItem(resizableStorageKey, xeUtils.toJSONString(columnWidthStorageMap));
        }
      },
      saveCustomVisible: function() {
        var id2 = props.id, customConfig = props.customConfig;
        var collectColumn = internalData.collectColumn;
        var customOpts = computeCustomOpts.value;
        var checkMethod = customOpts.checkMethod, storage = customOpts.storage;
        var isVisible = storage === true || storage && storage.visible;
        if (customConfig && isVisible) {
          var columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);
          var colHides_1 = [];
          var colShows_1 = [];
          if (!id2) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          xeUtils.eachTree(collectColumn, function(column2) {
            if (!checkMethod || checkMethod({ column: column2 })) {
              if (!column2.visible && column2.defaultVisible) {
                var colKey = column2.getKey();
                if (colKey) {
                  colHides_1.push(colKey);
                }
              } else if (column2.visible && !column2.defaultVisible) {
                var colKey = column2.getKey();
                if (colKey) {
                  colShows_1.push(colKey);
                }
              }
            }
          });
          columnVisibleStorageMap[id2] = [colHides_1.join(",")].concat(colShows_1.length ? [colShows_1.join(",")] : []).join("|") || void 0;
          localStorage.setItem(visibleStorageKey, xeUtils.toJSONString(columnVisibleStorageMap));
        }
      },
      handleCustom: function() {
        tablePrivateMethods.saveCustomVisible();
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn();
      },
      preventEvent: function(evnt, type2, args, next, end2) {
        var evntList = VXETable.interceptor.get(type2);
        var rest;
        if (!evntList.some(function(func) {
          return func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false;
        })) {
          if (next) {
            rest = next();
          }
        }
        if (end2) {
          end2();
        }
        return rest;
      },
      checkSelectionStatus: function() {
        var treeConfig = props.treeConfig;
        var selection = reactData.selection, treeIndeterminates = reactData.treeIndeterminates;
        var afterFullData = internalData.afterFullData;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField, halfField = checkboxOpts.halfField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;
        if (!checkStrictly) {
          var disableRows_1 = [];
          var checkRows_1 = [];
          var isAllResolve = false;
          var isAllSelected = false;
          var isIndeterminate = false;
          if (checkField) {
            isAllResolve = afterFullData.every(checkMethod ? function(row2) {
              if (!checkMethod({ row: row2 })) {
                disableRows_1.push(row2);
                return true;
              }
              if (xeUtils.get(row2, checkField)) {
                checkRows_1.push(row2);
                return true;
              }
              return false;
            } : function(row2) {
              return xeUtils.get(row2, checkField);
            });
            isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;
            if (treeConfig) {
              if (halfField) {
                isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                  return xeUtils.get(row2, checkField) || xeUtils.get(row2, halfField) || $xetable.findRowIndexOf(treeIndeterminates, row2) > -1;
                });
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                  return xeUtils.get(row2, checkField) || $xetable.findRowIndexOf(treeIndeterminates, row2) > -1;
                });
              }
            } else {
              if (halfField) {
                isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                  return xeUtils.get(row2, checkField) || xeUtils.get(row2, halfField);
                });
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                  return xeUtils.get(row2, checkField);
                });
              }
            }
          } else {
            isAllResolve = afterFullData.every(checkMethod ? function(row2) {
              if (!checkMethod({ row: row2 })) {
                disableRows_1.push(row2);
                return true;
              }
              if ($xetable.findRowIndexOf(selection, row2) > -1) {
                checkRows_1.push(row2);
                return true;
              }
              return false;
            } : function(row2) {
              return $xetable.findRowIndexOf(selection, row2) > -1;
            });
            isAllSelected = isAllResolve && afterFullData.length !== disableRows_1.length;
            if (treeConfig) {
              isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                return $xetable.findRowIndexOf(treeIndeterminates, row2) > -1 || $xetable.findRowIndexOf(selection, row2) > -1;
              });
            } else {
              isIndeterminate = !isAllSelected && afterFullData.some(function(row2) {
                return $xetable.findRowIndexOf(selection, row2) > -1;
              });
            }
          }
          reactData.isAllSelected = isAllSelected;
          reactData.isIndeterminate = isIndeterminate;
        }
      },
      handleSelectRow: function(_a2, value) {
        var row2 = _a2.row;
        var treeConfig = props.treeConfig;
        var selection = reactData.selection, treeIndeterminates = reactData.treeIndeterminates;
        var afterFullData = internalData.afterFullData;
        var treeOpts = computeTreeOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField, checkStrictly = checkboxOpts.checkStrictly, checkMethod = checkboxOpts.checkMethod;
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if ($xetable.findRowIndexOf(treeIndeterminates, row2) === -1) {
                treeIndeterminates.push(row2);
              }
              xeUtils.set(row2, checkField, false);
            } else {
              xeUtils.eachTree([row2], function(item) {
                if ($xetable.eqRow(item, row2) || (!checkMethod || checkMethod({ row: item }))) {
                  xeUtils.set(item, checkField, value);
                  xeUtils.remove(treeIndeterminates, function(half) {
                    return $xetable.eqRow(half, item);
                  });
                  handleCheckboxReserveRow(row2, value);
                }
              }, treeOpts);
            }
            var matchObj = xeUtils.findTree(afterFullData, function(item) {
              return $xetable.eqRow(item, row2);
            }, treeOpts);
            if (matchObj && matchObj.parent) {
              var parentStatus = void 0;
              var vItems_1 = checkMethod ? matchObj.items.filter(function(item) {
                return checkMethod({ row: item });
              }) : matchObj.items;
              var indeterminatesItem = xeUtils.find(matchObj.items, function(item) {
                return $xetable.findRowIndexOf(treeIndeterminates, item) > -1;
              });
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                var selectItems = matchObj.items.filter(function(item) {
                  return xeUtils.get(item, checkField);
                });
                parentStatus = selectItems.filter(function(item) {
                  return $xetable.findRowIndexOf(vItems_1, item) > -1;
                }).length === vItems_1.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus);
            }
          } else {
            if (!checkMethod || checkMethod({ row: row2 })) {
              xeUtils.set(row2, checkField, value);
              handleCheckboxReserveRow(row2, value);
            }
          }
        } else {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if ($xetable.findRowIndexOf(treeIndeterminates, row2) === -1) {
                treeIndeterminates.push(row2);
              }
              xeUtils.remove(selection, function(item) {
                return $xetable.eqRow(item, row2);
              });
            } else {
              xeUtils.eachTree([row2], function(item) {
                if ($xetable.eqRow(item, row2) || (!checkMethod || checkMethod({ row: item }))) {
                  if (value) {
                    selection.push(item);
                  } else {
                    xeUtils.remove(selection, function(select2) {
                      return $xetable.eqRow(select2, item);
                    });
                  }
                  xeUtils.remove(treeIndeterminates, function(half) {
                    return $xetable.eqRow(half, item);
                  });
                  handleCheckboxReserveRow(row2, value);
                }
              }, treeOpts);
            }
            var matchObj = xeUtils.findTree(afterFullData, function(item) {
              return $xetable.eqRow(item, row2);
            }, treeOpts);
            if (matchObj && matchObj.parent) {
              var parentStatus = void 0;
              var vItems_2 = checkMethod ? matchObj.items.filter(function(item) {
                return checkMethod({ row: item });
              }) : matchObj.items;
              var indeterminatesItem = xeUtils.find(matchObj.items, function(item) {
                return $xetable.findRowIndexOf(treeIndeterminates, item) > -1;
              });
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                var selectItems = matchObj.items.filter(function(item) {
                  return $xetable.findRowIndexOf(selection, item) > -1;
                });
                parentStatus = selectItems.filter(function(item) {
                  return $xetable.findRowIndexOf(vItems_2, item) > -1;
                }).length === vItems_2.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus);
            }
          } else {
            if (!checkMethod || checkMethod({ row: row2 })) {
              if (value) {
                if ($xetable.findRowIndexOf(selection, row2) === -1) {
                  selection.push(row2);
                }
              } else {
                xeUtils.remove(selection, function(item) {
                  return $xetable.eqRow(item, row2);
                });
              }
              handleCheckboxReserveRow(row2, value);
            }
          }
        }
        tablePrivateMethods.checkSelectionStatus();
      },
      triggerHeaderHelpEvent: function(evnt, params) {
        var column2 = params.column;
        var titlePrefix = column2.titlePrefix || column2.titleHelp;
        if (titlePrefix.content || titlePrefix.message) {
          var tooltipStore = reactData.tooltipStore;
          var content_1 = getFuncText(titlePrefix.content || titlePrefix.message);
          handleTargetEnterEvent(true);
          tooltipStore.visible = true;
          tooltipStore.currOpts = __assign$1(__assign$1({}, titlePrefix), { content: null });
          nextTick$1(function() {
            var $tooltip = refTooltip.value;
            if ($tooltip) {
              $tooltip.open(evnt.currentTarget, content_1);
            }
          });
        }
      },
      triggerHeaderTooltipEvent: function(evnt, params) {
        var tooltipStore = reactData.tooltipStore;
        var column2 = params.column;
        var titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column2 || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      triggerBodyTooltipEvent: function(evnt, params) {
        var editConfig = props.editConfig;
        var editStore = reactData.editStore;
        var tooltipStore = reactData.tooltipStore;
        var editOpts = computeEditOpts.value;
        var actived = editStore.actived;
        var row2 = params.row, column2 = params.column;
        var cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column2 || tooltipStore.row !== row2);
        if (isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row2 || actived.row === row2 && actived.column === column2) {
            return;
          }
        }
        if (tooltipStore.column !== column2 || tooltipStore.row !== row2 || !tooltipStore.visible) {
          var overflowElem = void 0;
          var tipElem = void 0;
          if (column2.treeNode) {
            overflowElem = cell.querySelector(".vxe-tree-cell");
            if (column2.type === "html") {
              tipElem = cell.querySelector(".vxe-cell--html");
            }
          } else {
            tipElem = cell.querySelector(column2.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      triggerFooterTooltipEvent: function(evnt, params) {
        var column2 = params.column;
        var tooltipStore = reactData.tooltipStore;
        var cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column2 || tooltipStore.row);
        if (tooltipStore.column !== column2 || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector(".vxe-cell--item") || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent: function() {
        var tooltipOpts = computeTooltipOpts.value;
        var $tooltip = refTooltip.value;
        if ($tooltip) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(function() {
            $tooltip = refTooltip.value;
            if ($tooltip && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent: function(evnt, params) {
        var _lastResizeTime = internalData._lastResizeTime;
        var sortOpts = computeSortOpts.value;
        var columnOpts = computeColumnOpts.value;
        var column2 = params.column;
        var cell = evnt.currentTarget;
        var triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        var triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        var triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column2, getNextSortOrder(column2));
        }
        tableMethods.dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tableMethods.setCurrentColumn(column2);
        }
      },
      triggerHeaderCellDblclickEvent: function(evnt, params) {
        tableMethods.dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      triggerCellClickEvent: function(evnt, params) {
        var highlightCurrentRow = props.highlightCurrentRow, editConfig = props.editConfig;
        var editStore = reactData.editStore;
        var expandOpts = computeExpandOpts.value;
        var editOpts = computeEditOpts.value;
        var treeOpts = computeTreeOpts.value;
        var radioOpts = computeRadioOpts.value;
        var checkboxOpts = computeCheckboxOpts.value;
        var rowOpts = computeRowOpts.value;
        var actived = editStore.actived;
        var row2 = params.row, column2 = params.column;
        var type2 = column2.type, treeNode = column2.treeNode;
        var isRadioType = type2 === "radio";
        var isCheckboxType = type2 === "checkbox";
        var isExpandType = type2 === "expand";
        var cell = evnt.currentTarget;
        var triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        var triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        var triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        var triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row2 && column2 !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row2 !== actived.row || column2 !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row2) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        tableMethods.dispatchEvent("cell-click", params, evnt);
      },
      triggerCellDblclickEvent: function(evnt, params) {
        var editConfig = props.editConfig;
        var editStore = reactData.editStore;
        var editOpts = computeEditOpts.value;
        var actived = editStore.actived;
        var cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch(function(e3) {
                return e3;
              }).then(function() {
                $xetable.handleActived(params, evnt).then(function() {
                  return checkValidate("change");
                }).catch(function(e3) {
                  return e3;
                });
              });
            } else if (editOpts.mode === "cell") {
              $xetable.handleActived(params, evnt).then(function() {
                return checkValidate("change");
              }).catch(function(e3) {
                return e3;
              });
            }
          }
        }
        tableMethods.dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent: function(evnt, params) {
        var selection = reactData.selection;
        var checkboxOpts = computeCheckboxOpts.value;
        var checkField = checkboxOpts.checkField;
        var row2 = params.row;
        var value = checkField ? !xeUtils.get(row2, checkField) : $xetable.findRowIndexOf(selection, row2) === -1;
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);
        } else {
          tablePrivateMethods.handleSelectRow(params, value);
        }
      },
      triggerCheckRowEvent: function(evnt, params, value) {
        var checkboxOpts = computeCheckboxOpts.value;
        var checkMethod = checkboxOpts.checkMethod;
        if (!checkMethod || checkMethod({ row: params.row })) {
          tablePrivateMethods.handleSelectRow(params, value);
          tableMethods.dispatchEvent("checkbox-change", Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, params), evnt);
        }
      },
      triggerCheckAllEvent: function(evnt, value) {
        tableMethods.setAllCheckboxRow(value);
        if (evnt) {
          tableMethods.dispatchEvent("checkbox-all", {
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, evnt);
        }
      },
      triggerRadioRowEvent: function(evnt, params) {
        var oldValue = reactData.selectRow;
        var row2 = params.row;
        var radioOpts = computeRadioOpts.value;
        var newValue = row2;
        var isChange = oldValue !== newValue;
        if (isChange) {
          tableMethods.setRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          tableMethods.dispatchEvent("radio-change", __assign$1({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentRowEvent: function(evnt, params) {
        var oldValue = reactData.currentRow;
        var newValue = params.row;
        var isChange = oldValue !== newValue;
        tableMethods.setCurrentRow(newValue);
        if (isChange) {
          tableMethods.dispatchEvent("current-change", __assign$1({ oldValue, newValue }, params), evnt);
        }
      },
      triggerRowExpandEvent: function(evnt, params) {
        var expandLazyLoadeds = reactData.expandLazyLoadeds, column2 = reactData.expandColumn;
        var expandOpts = computeExpandOpts.value;
        var row2 = params.row;
        var lazy = expandOpts.lazy;
        if (!lazy || $xetable.findRowIndexOf(expandLazyLoadeds, row2) === -1) {
          var expanded = !tableMethods.isExpandByRow(row2);
          var columnIndex = tableMethods.getColumnIndex(column2);
          var $columnIndex = tableMethods.getVMColumnIndex(column2);
          tableMethods.setRowExpand(row2, expanded);
          tableMethods.dispatchEvent("toggle-row-expand", {
            expanded,
            column: column2,
            columnIndex,
            $columnIndex,
            row: row2,
            rowIndex: tableMethods.getRowIndex(row2),
            $rowIndex: tableMethods.getVMRowIndex(row2)
          }, evnt);
        }
      },
      triggerTreeExpandEvent: function(evnt, params) {
        var treeLazyLoadeds = reactData.treeLazyLoadeds;
        var treeOpts = computeTreeOpts.value;
        var row2 = params.row, column2 = params.column;
        var lazy = treeOpts.lazy;
        if (!lazy || $xetable.findRowIndexOf(treeLazyLoadeds, row2) === -1) {
          var expanded = !tableMethods.isTreeExpandByRow(row2);
          var columnIndex = tableMethods.getColumnIndex(column2);
          var $columnIndex = tableMethods.getVMColumnIndex(column2);
          tableMethods.setTreeExpand(row2, expanded);
          tableMethods.dispatchEvent("toggle-tree-expand", { expanded, column: column2, columnIndex, $columnIndex, row: row2 }, evnt);
        }
      },
      triggerSortEvent: function(evnt, column2, order) {
        var sortOpts = computeSortOpts.value;
        var field = column2.field, sortable = column2.sortable;
        if (sortable) {
          if (!order || column2.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column2 : null);
          } else {
            tableMethods.sort({ field, order });
          }
          var params = { column: column2, field, property: field, order: column2.order, sortList: tableMethods.getSortColumns() };
          tableMethods.dispatchEvent("sort-change", params, evnt);
        }
      },
      triggerScrollXEvent: function() {
        loadScrollXData();
      },
      triggerScrollYEvent: function(evnt) {
        var scrollYStore = internalData.scrollYStore;
        var adaptive = scrollYStore.adaptive, offsetSize = scrollYStore.offsetSize, visibleSize = scrollYStore.visibleSize;
        if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {
          loadScrollYData(evnt);
        } else {
          debounceScrollY(evnt);
        }
      },
      scrollToTreeRow: function(row2) {
        var treeConfig = props.treeConfig;
        var tableFullData = internalData.tableFullData;
        var rests = [];
        if (treeConfig) {
          var treeOpts = computeTreeOpts.value;
          var matchObj = xeUtils.findTree(tableFullData, function(item) {
            return $xetable.eqRow(item, row2);
          }, treeOpts);
          if (matchObj) {
            var nodes_1 = matchObj.nodes;
            nodes_1.forEach(function(row3, index) {
              if (index < nodes_1.length - 1 && !tableMethods.isTreeExpandByRow(row3)) {
                rests.push(tableMethods.setTreeExpand(row3, true));
              }
            });
          }
        }
        return Promise.all(rests).then(function() {
          return rowToVisible($xetable, row2);
        });
      },
      updateScrollXSpace: function() {
        var scrollXLoad = reactData.scrollXLoad, scrollbarWidth = reactData.scrollbarWidth;
        var visibleColumn = internalData.visibleColumn, scrollXStore = internalData.scrollXStore, elemStore = internalData.elemStore, tableWidth = internalData.tableWidth;
        var tableHeader = refTableHeader.value;
        var tableBody = refTableBody.value;
        var tableFooter = refTableFooter.value;
        var tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          var tableHeaderElem = tableHeader ? tableHeader.$el : null;
          var tableFooterElem = tableFooter ? tableFooter.$el : null;
          var headerElem = tableHeaderElem ? tableHeaderElem.querySelector(".vxe-table--header") : null;
          var bodyElem = tableBodyElem.querySelector(".vxe-table--body");
          var footerElem = tableFooterElem ? tableFooterElem.querySelector(".vxe-table--footer") : null;
          var leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce(function(previous, column2) {
            return previous + column2.renderWidth;
          }, 0);
          var marginLeft = "";
          if (scrollXLoad) {
            marginLeft = "".concat(leftSpaceWidth, "px");
          }
          if (headerElem) {
            headerElem.style.marginLeft = marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          var containerList = ["main"];
          containerList.forEach(function(name2) {
            var layoutList = ["header", "body", "footer"];
            layoutList.forEach(function(layout2) {
              var xSpaceRef = elemStore["".concat(name2, "-").concat(layout2, "-xSpace")];
              var xSpaceElem = xSpaceRef ? xSpaceRef.value : null;
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? "".concat(tableWidth + (layout2 === "header" ? scrollbarWidth : 0), "px") : "";
              }
            });
          });
          nextTick$1(updateStyle2);
        }
      },
      updateScrollYSpace: function() {
        var scrollYLoad = reactData.scrollYLoad;
        var scrollYStore = internalData.scrollYStore, elemStore = internalData.elemStore, afterFullData = internalData.afterFullData;
        var startIndex = scrollYStore.startIndex, rowHeight = scrollYStore.rowHeight;
        var bodyHeight = afterFullData.length * rowHeight;
        var topSpaceHeight = Math.max(0, startIndex * rowHeight);
        var containerList = ["main", "left", "right"];
        var marginTop = "";
        var ySpaceHeight = "";
        if (scrollYLoad) {
          marginTop = "".concat(topSpaceHeight, "px");
          ySpaceHeight = "".concat(bodyHeight, "px");
        }
        containerList.forEach(function(name2) {
          var layoutList = ["header", "body", "footer"];
          var tableRef = elemStore["".concat(name2, "-body-table")];
          var tableElem = tableRef ? tableRef.value : null;
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach(function(layout2) {
            var ySpaceRef = elemStore["".concat(name2, "-").concat(layout2, "-ySpace")];
            var ySpaceElem = ySpaceRef ? ySpaceRef.value : null;
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        nextTick$1(updateStyle2);
      },
      updateScrollXData: function() {
        nextTick$1(function() {
          handleTableColumn();
          tablePrivateMethods.updateScrollXSpace();
        });
      },
      updateScrollYData: function() {
        nextTick$1(function() {
          tablePrivateMethods.handleTableData();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      checkScrolling: function() {
        var leftContainerElem = refLeftContainer.value;
        var rightContainerElem = refRightContainer.value;
        var tableBody = refTableBody.value;
        var bodyElem = tableBody ? tableBody.$el : null;
        if (bodyElem) {
          if (leftContainerElem) {
            if (bodyElem.scrollLeft > 0) {
              addClass$2(leftContainerElem, "scrolling--middle");
            } else {
              removeClass$2(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {
              addClass$2(rightContainerElem, "scrolling--middle");
            } else {
              removeClass$2(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex: function() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      updateCellAreas: function() {
        var mouseConfig = props.mouseConfig;
        var mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {
          $xetable.handleUpdateCellAreas();
        }
      },
      triggerHoverEvent: function(evnt, _a2) {
        var row2 = _a2.row;
        tablePrivateMethods.setHoverRow(row2);
      },
      setHoverRow: function(row2) {
        var rowid = getRowid($xetable, row2);
        var el2 = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el2) {
          xeUtils.arrayEach(el2.querySelectorAll('[rowid="'.concat(rowid, '"]')), function(elem) {
            return addClass$2(elem, "row--hover");
          });
        }
        internalData.hoverRow = row2;
      },
      clearHoverRow: function() {
        var el2 = refElem.value;
        if (el2) {
          xeUtils.arrayEach(el2.querySelectorAll(".vxe-body--row.row--hover"), function(elem) {
            return removeClass$2(elem, "row--hover");
          });
        }
        internalData.hoverRow = null;
      },
      getCell: function(row2, column2) {
        var rowid = getRowid($xetable, row2);
        var tableBody = refTableBody.value;
        var leftBody = refTableLeftBody.value;
        var rightBody = refTableRightBody.value;
        var bodyElem;
        if (column2.fixed) {
          if (column2.fixed === "left") {
            if (leftBody) {
              bodyElem = leftBody.$el;
            }
          } else {
            if (rightBody) {
              bodyElem = rightBody.$el;
            }
          }
        }
        if (!bodyElem) {
          bodyElem = tableBody.$el;
        }
        if (bodyElem) {
          return bodyElem.querySelector('.vxe-body--row[rowid="'.concat(rowid, '"] .').concat(column2.id));
        }
        return null;
      },
      getCellLabel: function(row2, column2) {
        var formatter = column2.formatter;
        var cellValue = getCellValue(row2, column2);
        var cellLabel = cellValue;
        if (formatter) {
          var formatData = void 0;
          var fullAllDataRowIdData = internalData.fullAllDataRowIdData;
          var rowid = getRowid($xetable, row2);
          var colid = column2.id;
          var rest = fullAllDataRowIdData[rowid];
          if (rest) {
            formatData = rest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          var formatParams = { cellValue, row: row2, rowIndex: tableMethods.getRowIndex(row2), column: column2, columnIndex: tableMethods.getColumnIndex(column2) };
          if (xeUtils.isString(formatter)) {
            var globalFunc = VXETable.formats.get(formatter);
            cellLabel = globalFunc ? globalFunc(formatParams) : "";
          } else if (xeUtils.isArray(formatter)) {
            var globalFunc = VXETable.formats.get(formatter[0]);
            cellLabel = globalFunc ? globalFunc.apply(void 0, __spreadArray([formatParams], formatter.slice(1), false)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      findRowIndexOf: function(list, row2) {
        return row2 ? xeUtils.findIndexOf(list, function(item) {
          return $xetable.eqRow(item, row2);
        }) : -1;
      },
      eqRow: function(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xetable, row1) === getRowid($xetable, row2);
        }
        return false;
      }
    };
    Object.assign($xetable, tableMethods, tablePrivateMethods);
    var renderFixed = function(fixedType) {
      var showHeader = props.showHeader, showFooter = props.showFooter;
      var tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, columnStore = reactData.columnStore, footerTableData = reactData.footerTableData;
      var isFixedLeft = fixedType === "left";
      var fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h$6("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: "vxe-table--fixed-".concat(fixedType, "-wrapper")
      }, [
        showHeader ? h$6(Header, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : createCommentVNode(),
        h$6(TableBodyComponent, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h$6(Footer, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : createCommentVNode()
      ]);
    };
    var renderEmptyContenet = function() {
      var emptyOpts = computeEmptyOpts.value;
      var params = { $table: $xetable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        var compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        var renderEmpty = compConf ? compConf.renderEmpty : null;
        if (renderEmpty) {
          return renderEmpty(emptyOpts, params);
        }
      }
      return getFuncText(props.emptyText) || GlobalConfig.i18n("vxe.table.emptyText");
    };
    function handleUupdateResize() {
      var el2 = refElem.value;
      if (el2 && el2.clientWidth && el2.clientHeight) {
        tableMethods.recalculate();
      }
    }
    watch$1(function() {
      return props.data;
    }, function(value) {
      var inited = internalData.inited, initStatus = internalData.initStatus;
      loadTableData(value || []).then(function() {
        reactData.scrollXLoad;
        reactData.scrollYLoad;
        reactData.expandColumn;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (!inited) {
          handleInitDefaults();
        }
        tableMethods.recalculate();
      });
    });
    watch$1(function() {
      return reactData.staticColumns;
    }, function(value) {
      handleColumn(value);
    });
    watch$1(function() {
      return reactData.tableColumn;
    }, function() {
      tablePrivateMethods.analyColumnWidth();
    });
    watch$1(function() {
      return props.showHeader;
    }, function() {
      nextTick$1(function() {
        tableMethods.recalculate(true).then(function() {
          return tableMethods.refreshScroll();
        });
      });
    });
    watch$1(function() {
      return props.showFooter;
    }, function() {
      nextTick$1(function() {
        tableMethods.recalculate(true).then(function() {
          return tableMethods.refreshScroll();
        });
      });
    });
    watch$1(function() {
      return props.height;
    }, function() {
      nextTick$1(function() {
        return tableMethods.recalculate(true);
      });
    });
    watch$1(function() {
      return props.maxHeight;
    }, function() {
      nextTick$1(function() {
        return tableMethods.recalculate(true);
      });
    });
    watch$1(function() {
      return props.syncResize;
    }, function(value) {
      if (value) {
        handleUupdateResize();
        nextTick$1(function() {
          handleUupdateResize();
          setTimeout(function() {
            return handleUupdateResize();
          });
        });
      }
    });
    watch$1(function() {
      return props.mergeCells;
    }, function(value) {
      tableMethods.clearMergeCells();
      nextTick$1(function() {
        if (value) {
          tableMethods.setMergeCells(value);
        }
      });
    });
    watch$1(function() {
      return props.mergeFooterItems;
    }, function(value) {
      tableMethods.clearMergeFooterItems();
      nextTick$1(function() {
        if (value) {
          tableMethods.setMergeFooterItems(value);
        }
      });
    });
    VXETable.hooks.forEach(function(options) {
      var setupTable = options.setupTable;
      if (setupTable) {
        var hookRest = setupTable($xetable);
        if (hookRest && xeUtils.isObject(hookRest)) {
          Object.assign($xetable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xetable });
    var resizeObserver;
    onActivated(function() {
      tableMethods.recalculate().then(function() {
        return tableMethods.refreshScroll();
      });
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xetable });
    });
    onDeactivated(function() {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xetable });
    });
    onMounted$1(function() {
      nextTick$1(function() {
        var data5 = props.data;
        props.treeConfig;
        props.showOverflow;
        var scrollXStore = internalData.scrollXStore, scrollYStore = internalData.scrollYStore;
        var sYOpts = computeSYOpts.value;
        computeEditOpts.value;
        computeTreeOpts.value;
        computeRadioOpts.value;
        computeCheckboxOpts.value;
        computeExpandOpts.value;
        computeRowOpts.value;
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data5 || []).then(function() {
          if (data5 && data5.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
            handleInitDefaults();
          }
          updateStyle2();
        });
        if (props.autoResize) {
          var el2 = refElem.value;
          var parentEl = tablePrivateMethods.getParentElem();
          resizeObserver = createResizeEvent(function() {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el2) {
            resizeObserver.observe(el2);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      GlobalEvent.on($xetable, "paste", handleGlobalPasteEvent);
      GlobalEvent.on($xetable, "copy", handleGlobalCopyEvent);
      GlobalEvent.on($xetable, "cut", handleGlobalCutEvent);
      GlobalEvent.on($xetable, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xetable, "blur", handleGlobalBlurEvent);
      GlobalEvent.on($xetable, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xetable, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xetable, "resize", handleGlobalResizeEvent);
      if ($xetable.handleGlobalContextmenuEvent) {
        GlobalEvent.on($xetable, "contextmenu", $xetable.handleGlobalContextmenuEvent);
      }
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xetable });
    });
    onBeforeUnmount(function() {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xetable });
    });
    onUnmounted(function() {
      GlobalEvent.off($xetable, "paste");
      GlobalEvent.off($xetable, "copy");
      GlobalEvent.off($xetable, "cut");
      GlobalEvent.off($xetable, "mousedown");
      GlobalEvent.off($xetable, "blur");
      GlobalEvent.off($xetable, "mousewheel");
      GlobalEvent.off($xetable, "keydown");
      GlobalEvent.off($xetable, "resize");
      GlobalEvent.off($xetable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xetable });
    });
    var renderVN = function() {
      var _a2;
      var loading = props.loading, stripe = props.stripe, showHeader = props.showHeader, height2 = props.height, treeConfig = props.treeConfig, mouseConfig = props.mouseConfig, showFooter = props.showFooter, highlightCell = props.highlightCell, highlightHoverRow = props.highlightHoverRow, highlightHoverColumn = props.highlightHoverColumn, editConfig = props.editConfig;
      var isGroup = reactData.isGroup, overflowX = reactData.overflowX, overflowY = reactData.overflowY, scrollXLoad = reactData.scrollXLoad, scrollYLoad = reactData.scrollYLoad, scrollbarHeight = reactData.scrollbarHeight, tableData = reactData.tableData, tableColumn = reactData.tableColumn, tableGroupColumn = reactData.tableGroupColumn, footerTableData = reactData.footerTableData, initStore = reactData.initStore, columnStore = reactData.columnStore, filterStore = reactData.filterStore;
      var leftList = columnStore.leftList, rightList = columnStore.rightList;
      var tipConfig = computeTipConfig.value;
      var treeOpts = computeTreeOpts.value;
      var rowOpts = computeRowOpts.value;
      var columnOpts = computeColumnOpts.value;
      var vSize = computeSize.value;
      var tableBorder = computeTableBorder.value;
      var mouseOpts = computeMouseOpts.value;
      var validOpts = computeValidOpts.value;
      var validTipOpts = computeValidTipOpts.value;
      var loadingOpts = computeLoadingOpts.value;
      var isMenu = computeIsMenu.value;
      return h$6("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", "tid_".concat(xID), "border--".concat(tableBorder), (_a2 = {}, _a2["size--".concat(vSize)] = vSize, _a2["vxe-editable"] = !!editConfig, _a2["cell--highlight"] = highlightCell, _a2["cell--selected"] = mouseConfig && mouseOpts.selected, _a2["cell--area"] = mouseConfig && mouseOpts.area, _a2["row--highlight"] = rowOpts.isHover || highlightHoverRow, _a2["column--highlight"] = columnOpts.isHover || highlightHoverColumn, _a2["is--header"] = showHeader, _a2["is--footer"] = showFooter, _a2["is--group"] = isGroup, _a2["is--tree-line"] = treeConfig && treeOpts.line, _a2["is--fixed-left"] = leftList.length, _a2["is--fixed-right"] = rightList.length, _a2["is--animat"] = !!props.animat, _a2["is--round"] = props.round, _a2["is--stripe"] = !treeConfig && stripe, _a2["is--loading"] = loading, _a2["is--empty"] = !loading && !tableData.length, _a2["is--scroll-y"] = overflowY, _a2["is--scroll-x"] = overflowX, _a2["is--virtual-x"] = scrollXLoad, _a2["is--virtual-y"] = scrollYLoad, _a2)],
        onKeydown: keydownEvent
      }, [
        h$6("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h$6("div", {
          class: "vxe-table--render-wrapper"
        }, [
          h$6("div", {
            class: "vxe-table--main-wrapper"
          }, [
            showHeader ? h$6(Header, {
              ref: refTableHeader,
              tableData,
              tableColumn,
              tableGroupColumn
            }) : createCommentVNode(),
            h$6(TableBodyComponent, {
              ref: refTableBody,
              tableData,
              tableColumn
            }),
            showFooter ? h$6(Footer, {
              ref: refTableFooter,
              footerTableData,
              tableColumn
            }) : createCommentVNode()
          ]),
          h$6("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            leftList && leftList.length && overflowX ? renderFixed("left") : createCommentVNode(),
            rightList && rightList.length && overflowX ? renderFixed("right") : createCommentVNode()
          ])
        ]),
        h$6("div", {
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h$6("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyContenet())
        ]),
        h$6("div", {
          class: "vxe-table--border-line"
        }),
        h$6("div", {
          ref: refCellResizeBar,
          class: "vxe-table--resizable-bar",
          style: overflowX ? {
            "padding-bottom": "".concat(scrollbarHeight, "px")
          } : null
        }),
        h$6(VxeLoading, {
          class: "vxe-table--loading",
          modelValue: loading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }),
        initStore.filter ? h$6(resolveComponent("vxe-table-filter"), {
          ref: refTableFilter,
          filterStore
        }) : createCommentVNode(),
        initStore.import && props.importConfig ? h$6(resolveComponent("vxe-import-panel"), {
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : createCommentVNode(),
        initStore.export && (props.exportConfig || props.printConfig) ? h$6(resolveComponent("vxe-export-panel"), {
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : createCommentVNode(),
        isMenu ? h$6(resolveComponent("vxe-table-context-menu"), {
          ref: refTableMenu
        }) : createCommentVNode(),
        hasUseTooltip ? h$6(resolveComponent("vxe-tooltip"), {
          ref: refCommTooltip,
          isArrow: false,
          enterable: false
        }) : createCommentVNode(),
        hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height2 : validOpts.message === "tooltip") ? h$6(resolveComponent("vxe-tooltip"), __assign$1({ ref: refValidTooltip, class: "vxe-table--valid-error" }, validOpts.message === "tooltip" || tableData.length === 1 ? validTipOpts : {})) : createCommentVNode(),
        hasUseTooltip ? h$6(resolveComponent("vxe-tooltip"), __assign$1({ ref: refTooltip }, tipConfig)) : createCommentVNode()
      ]);
    };
    $xetable.renderVN = renderVN;
    provide("xecolgroup", null);
    provide("$xetable", $xetable);
    return $xetable;
  },
  render: function() {
    return this.renderVN();
  }
});
Object.assign(VxeTableComponent, {
  install: function(app) {
    app.component(VxeTableComponent.name, VxeTableComponent);
  }
});
dynamicApp.component(VxeTableComponent.name, VxeTableComponent);
var zhCN = {
  vxe: {
    loading: {
      text: "\u52A0\u8F7D\u4E2D..."
    },
    error: {
      groupFixed: "\u5982\u679C\u4F7F\u7528\u5206\u7EC4\u8868\u5934\uFF0C\u56FA\u5B9A\u5217\u5FC5\u987B\u6309\u7EC4\u8BBE\u7F6E",
      groupMouseRange: '\u5206\u7EC4\u8868\u5934\u4E0E "{0}" \u4E0D\u80FD\u540C\u65F6\u4F7F\u7528\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u51FA\u73B0\u9519\u8BEF',
      groupTag: '\u5206\u7EC4\u5217\u5934\u5E94\u8BE5\u4F7F\u7528 "{0}" \u800C\u4E0D\u662F "{1}"\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u51FA\u73B0\u9519\u8BEF',
      scrollErrProp: '\u542F\u7528\u865A\u62DF\u6EDA\u52A8\u540E\u4E0D\u652F\u6301\u8BE5\u53C2\u6570 "{0}"',
      scrollXNotGroup: '\u6A2A\u5411\u865A\u62DF\u6EDA\u52A8\u4E0D\u652F\u6301\u5206\u7EC4\u8868\u5934\uFF0C\u9700\u8981\u8BBE\u7F6E "scroll-x.enabled=false" \u53C2\u6570\uFF0C\u5426\u5219\u53EF\u80FD\u4F1A\u5BFC\u81F4\u51FA\u73B0\u9519\u8BEF',
      errConflicts: '\u53C2\u6570 "{0}" \u4E0E "{1}" \u6709\u51B2\u7A81',
      unableInsert: "\u65E0\u6CD5\u63D2\u5165\u5230\u6307\u5B9A\u4F4D\u7F6E\uFF0C\u8BF7\u68C0\u67E5\u53C2\u6570\u662F\u5426\u6B63\u786E",
      useErr: '\u5B89\u88C5 "{0}" \u6A21\u5757\u65F6\u53D1\u751F\u9519\u8BEF\uFF0C\u53EF\u80FD\u987A\u5E8F\u4E0D\u6B63\u786E\uFF0C\u4F9D\u8D56\u7684\u6A21\u5757\u9700\u8981\u5728 Table \u4E4B\u524D\u5B89\u88C5',
      barUnableLink: "\u5DE5\u5177\u680F\u65E0\u6CD5\u5173\u8054\u8868\u683C",
      expandContent: '\u5C55\u5F00\u884C\u7684\u63D2\u69FD\u5E94\u8BE5\u662F "content"\uFF0C\u8BF7\u68C0\u67E5\u662F\u5426\u6B63\u786E',
      reqModule: '\u7F3A\u5C11 "{0}" \u6A21\u5757',
      reqProp: '\u7F3A\u5C11\u5FC5\u8981\u7684 "{0}" \u53C2\u6570\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u5BFC\u81F4\u51FA\u73B0\u9519\u8BEF',
      emptyProp: '\u53C2\u6570 "{0}" \u4E0D\u5141\u8BB8\u4E3A\u7A7A',
      errProp: '\u4E0D\u652F\u6301\u7684\u53C2\u6570 "{0}"\uFF0C\u53EF\u80FD\u4E3A "{1}"',
      colRepet: 'column.{0}="{1}" \u91CD\u590D\u4E86\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u5BFC\u81F4\u67D0\u4E9B\u529F\u80FD\u65E0\u6CD5\u4F7F\u7528',
      notFunc: '\u65B9\u6CD5 "{0}" \u4E0D\u5B58\u5728',
      notSlot: '\u63D2\u69FD "{0}" \u4E0D\u5B58\u5728',
      noTree: '\u6811\u7ED3\u6784\u4E0D\u652F\u6301 "{0}"',
      notProp: '\u4E0D\u652F\u6301\u7684\u53C2\u6570 "{0}"',
      coverProp: '"{0}" \u7684\u53C2\u6570 "{1}" \u88AB\u8986\u76D6\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u51FA\u73B0\u9519\u8BEF',
      delFunc: '\u65B9\u6CD5 "{0}" \u5DF2\u5E9F\u5F03\uFF0C\u8BF7\u4F7F\u7528 "{1}"',
      delProp: '\u53C2\u6570 "{0}" \u5DF2\u5E9F\u5F03\uFF0C\u8BF7\u4F7F\u7528 "{1}"',
      delEvent: '\u4E8B\u4EF6 "{0}" \u5DF2\u5E9F\u5F03\uFF0C\u8BF7\u4F7F\u7528 "{1}"',
      removeProp: '\u53C2\u6570 "{0}" \u5DF2\u5E9F\u5F03\uFF0C\u4E0D\u5EFA\u8BAE\u4F7F\u7528\uFF0C\u8FD9\u53EF\u80FD\u4F1A\u5BFC\u81F4\u51FA\u73B0\u9519\u8BEF',
      errFormat: '\u5168\u5C40\u7684\u683C\u5F0F\u5316\u5185\u5BB9\u5E94\u8BE5\u4F7F\u7528 "VXETable.formats" \u5B9A\u4E49\uFF0C\u6302\u8F7D "formatter={0}" \u7684\u65B9\u5F0F\u5DF2\u4E0D\u5EFA\u8BAE\u4F7F\u7528',
      notType: '\u4E0D\u652F\u6301\u7684\u6587\u4EF6\u7C7B\u578B "{0}"',
      notExp: "\u8BE5\u6D4F\u89C8\u5668\u4E0D\u652F\u6301\u5BFC\u5165/\u5BFC\u51FA\u529F\u80FD",
      impFields: "\u5BFC\u5165\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u5B57\u6BB5\u540D\u548C\u6570\u636E\u683C\u5F0F\u662F\u5426\u6B63\u786E",
      treeNotImp: "\u6811\u8868\u683C\u4E0D\u652F\u6301\u5BFC\u5165"
    },
    renderer: {
      search: "\u641C\u7D22",
      cases: {
        equal: "\u7B49\u4E8E",
        unequal: "\u4E0D\u7B49\u4E8E",
        gt: "\u5927\u4E8E",
        ge: "\u5927\u4E8E\u6216\u7B49\u4E8E",
        lt: "\u5C0F\u4E8E",
        le: "\u5C0F\u4E8E\u6216\u7B49\u4E8E",
        begin: "\u5F00\u5934\u662F",
        notbegin: "\u5F00\u5934\u4E0D\u662F",
        endin: "\u7ED3\u5C3E\u662F",
        notendin: "\u7ED3\u5C3E\u4E0D\u662F",
        include: "\u5305\u542B",
        exclude: "\u4E0D\u5305\u542B",
        between: "\u4ECB\u4E8E",
        custom: "\u81EA\u5B9A\u4E49\u7B5B\u9009",
        insensitive: "\u4E0D\u533A\u5206\u5927\u5C0F\u5199",
        isSensitive: "\u533A\u5206\u5927\u5C0F\u5199"
      },
      combination: {
        menus: {
          sortAsc: "\u5347\u5E8F",
          sortDesc: "\u964D\u5E8F",
          fixedColumn: "\u9501\u5B9A\u5217",
          fixedGroup: "\u9501\u5B9A\u7EC4",
          cancelFixed: "\u53D6\u6D88\u9501\u5B9A",
          fixedLeft: "\u9501\u5B9A\u5DE6\u4FA7",
          fixedRight: "\u9501\u5B9A\u53F3\u4FA7",
          clearFilter: "\u6E05\u9664\u7B5B\u9009",
          textOption: "\u6587\u672C\u7B5B\u9009",
          numberOption: "\u6570\u503C\u7B5B\u9009"
        },
        popup: {
          title: "\u81EA\u5B9A\u4E49\u7B5B\u9009\u7684\u65B9\u5F0F",
          currColumnTitle: "\u5F53\u524D\u5217\uFF1A",
          and: "\u4E0E",
          or: "\u6216",
          describeHtml: "\u53EF\u7528 ? \u4EE3\u8868\u5355\u4E2A\u5B57\u7B26<br/>\u7528 * \u4EE3\u8868\u4EFB\u610F\u591A\u4E2A\u5B57\u7B26"
        },
        empty: "(\u7A7A\u767D)",
        notData: "\u65E0\u5339\u914D\u9879"
      }
    },
    pro: {
      area: {
        mergeErr: "\u65E0\u6CD5\u5BF9\u5408\u5E76\u5355\u5143\u683C\u8FDB\u884C\u8BE5\u64CD\u4F5C",
        multiErr: "\u65E0\u6CD5\u5BF9\u591A\u91CD\u9009\u62E9\u533A\u57DF\u8FDB\u884C\u8BE5\u64CD\u4F5C",
        extendErr: "\u5982\u679C\u5EF6\u4F38\u7684\u533A\u57DF\u5305\u542B\u88AB\u5408\u5E76\u7684\u5355\u5143\u683C\uFF0C\u6240\u6709\u5408\u5E76\u7684\u5355\u5143\u683C\u9700\u5927\u5C0F\u76F8\u540C",
        pasteMultiErr: "\u65E0\u6CD5\u7C98\u8D34\uFF0C\u9700\u8981\u76F8\u540C\u5927\u5C0F\u7684\u590D\u5236\u7684\u533A\u57DF\u548C\u7C98\u8D34\u7684\u533A\u57DF\u624D\u80FD\u6267\u884C\u6B64\u64CD\u4F5C"
      },
      fnr: {
        title: "\u67E5\u627E\u548C\u66FF\u6362",
        findLabel: "\u67E5\u627E",
        replaceLabel: "\u66FF\u6362",
        findTitle: "\u67E5\u627E\u5185\u5BB9\uFF1A",
        replaceTitle: "\u66FF\u6362\u4E3A\uFF1A",
        tabs: {
          find: "\u67E5\u627E",
          replace: "\u66FF\u6362"
        },
        filter: {
          re: "\u6B63\u5219\u8868\u8FBE\u5F0F",
          whole: "\u5168\u8BCD\u5339\u914D",
          sensitive: "\u533A\u5206\u5927\u5C0F\u5199"
        },
        btns: {
          findNext: "\u67E5\u627E\u4E0B\u4E00\u4E2A",
          findAll: "\u67E5\u627E\u5168\u90E8",
          replace: "\u66FF\u6362",
          replaceAll: "\u66FF\u6362\u5168\u90E8",
          cancel: "\u53D6\u6D88"
        },
        header: {
          seq: "#",
          cell: "\u5355\u5143\u683C",
          value: "\u503C"
        },
        empty: "(\u7A7A\u503C)",
        reError: "\u65E0\u6548\u7684\u6B63\u5219\u8868\u8FBE\u5F0F",
        recordCount: "\u5DF2\u627E\u5230 {0} \u4E2A\u5355\u5143\u683C",
        notCell: "\u627E\u4E0D\u5230\u5339\u914D\u7684\u5355\u5143\u683C",
        replaceSuccess: "\u6210\u529F\u66FF\u6362 {0} \u4E2A\u5355\u5143\u683C"
      }
    },
    table: {
      emptyText: "\u6682\u65E0\u6570\u636E",
      allTitle: "\u5168\u9009/\u53D6\u6D88",
      seqTitle: "#",
      confirmFilter: "\u7B5B\u9009",
      resetFilter: "\u91CD\u7F6E",
      allFilter: "\u5168\u90E8",
      sortAsc: "\u5347\u5E8F\uFF1A\u6700\u4F4E\u5230\u6700\u9AD8",
      sortDesc: "\u964D\u5E8F\uFF1A\u6700\u9AD8\u5230\u6700\u4F4E",
      filter: "\u5BF9\u6240\u9009\u7684\u5217\u542F\u7528\u7B5B\u9009",
      impSuccess: "\u6210\u529F\u5BFC\u5165 {0} \u6761\u8BB0\u5F55",
      expLoading: "\u6B63\u5728\u5BFC\u51FA\u4E2D",
      expSuccess: "\u5BFC\u51FA\u6210\u529F",
      expFilename: "\u5BFC\u51FA_{0}",
      expOriginFilename: "\u5BFC\u51FA_\u6E90_{0}",
      customTitle: "\u5217\u8BBE\u7F6E",
      customAll: "\u5168\u90E8",
      customConfirm: "\u786E\u8BA4",
      customRestore: "\u8FD8\u539F"
    },
    grid: {
      selectOneRecord: "\u8BF7\u81F3\u5C11\u9009\u62E9\u4E00\u6761\u8BB0\u5F55\uFF01",
      deleteSelectRecord: "\u60A8\u786E\u5B9A\u8981\u5220\u9664\u6240\u9009\u8BB0\u5F55\u5417\uFF1F",
      removeSelectRecord: "\u60A8\u786E\u5B9A\u8981\u79FB\u9664\u6240\u9009\u8BB0\u5F55\u5417\uFF1F",
      dataUnchanged: "\u6570\u636E\u672A\u6539\u52A8\uFF01",
      delSuccess: "\u6210\u529F\u5220\u9664\u6240\u9009\u8BB0\u5F55\uFF01",
      saveSuccess: "\u4FDD\u5B58\u6210\u529F\uFF01",
      operError: "\u53D1\u751F\u9519\u8BEF\uFF0C\u64CD\u4F5C\u5931\u8D25\uFF01"
    },
    select: {
      search: "\u641C\u7D22",
      loadingText: "\u52A0\u8F7D\u4E2D",
      emptyText: "\u6682\u65E0\u6570\u636E"
    },
    pager: {
      goto: "\u524D\u5F80",
      pagesize: "{0}\u6761/\u9875",
      total: "\u5171 {0} \u6761\u8BB0\u5F55",
      pageClassifier: "\u9875",
      prevPage: "\u4E0A\u4E00\u9875",
      nextPage: "\u4E0B\u4E00\u9875",
      prevJump: "\u5411\u4E0A\u8DF3\u9875",
      nextJump: "\u5411\u4E0B\u8DF3\u9875"
    },
    alert: {
      title: "\u6D88\u606F\u63D0\u793A"
    },
    button: {
      confirm: "\u786E\u8BA4",
      cancel: "\u53D6\u6D88"
    },
    import: {
      modes: {
        covering: "\u8986\u76D6",
        insert: "\u65B0\u589E"
      },
      impTitle: "\u5BFC\u5165\u6570\u636E",
      impFile: "\u6587\u4EF6\u540D",
      impSelect: "\u9009\u62E9\u6587\u4EF6",
      impType: "\u6587\u4EF6\u7C7B\u578B",
      impOpts: "\u53C2\u6570\u8BBE\u7F6E",
      impConfirm: "\u5BFC\u5165",
      impCancel: "\u53D6\u6D88"
    },
    export: {
      types: {
        csv: "CSV (\u9017\u53F7\u5206\u9694)(*.csv)",
        html: "\u7F51\u9875(*.html)",
        xml: "XML \u6570\u636E(*.xml)",
        txt: "\u6587\u672C\u6587\u4EF6(\u5236\u8868\u7B26\u5206\u9694)(*.txt)",
        xls: "Excel 97-2003 \u5DE5\u4F5C\u7C3F(*.xls)",
        xlsx: "Excel \u5DE5\u4F5C\u7C3F(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "\u5F53\u524D\u6570\u636E\uFF08\u5F53\u524D\u9875\u7684\u6570\u636E\uFF09",
        selected: "\u9009\u4E2D\u6570\u636E\uFF08\u5F53\u524D\u9875\u9009\u4E2D\u7684\u6570\u636E\uFF09",
        all: "\u5168\u91CF\u6570\u636E\uFF08\u5305\u62EC\u6240\u6709\u5206\u9875\u7684\u6570\u636E\uFF09"
      },
      printTitle: "\u6253\u5370\u6570\u636E",
      expTitle: "\u5BFC\u51FA\u6570\u636E",
      expName: "\u6587\u4EF6\u540D",
      expNamePlaceholder: "\u8BF7\u8F93\u5165\u6587\u4EF6\u540D",
      expSheetName: "\u6807\u9898",
      expSheetNamePlaceholder: "\u8BF7\u8F93\u5165\u6807\u9898",
      expType: "\u4FDD\u5B58\u7C7B\u578B",
      expMode: "\u9009\u62E9\u6570\u636E",
      expCurrentColumn: "\u5168\u90E8\u5B57\u6BB5",
      expColumn: "\u9009\u62E9\u5B57\u6BB5",
      expOpts: "\u53C2\u6570\u8BBE\u7F6E",
      expOptHeader: "\u8868\u5934",
      expHeaderTitle: "\u662F\u5426\u9700\u8981\u8868\u5934",
      expOptFooter: "\u8868\u5C3E",
      expFooterTitle: "\u662F\u5426\u9700\u8981\u8868\u5C3E",
      expOptColgroup: "\u5206\u7EC4\u8868\u5934",
      expColgroupTitle: "\u5982\u679C\u5B58\u5728\uFF0C\u5219\u652F\u6301\u5E26\u6709\u5206\u7EC4\u7ED3\u6784\u7684\u8868\u5934",
      expOptMerge: "\u5408\u5E76",
      expMergeTitle: "\u5982\u679C\u5B58\u5728\uFF0C\u5219\u652F\u6301\u5E26\u6709\u5408\u5E76\u7ED3\u6784\u7684\u5355\u5143\u683C",
      expOptAllExpand: "\u5C55\u5F00\u5C42\u7EA7",
      expAllExpandTitle: "\u5982\u679C\u5B58\u5728\uFF0C\u5219\u652F\u6301\u5C06\u5E26\u6709\u5C42\u7EA7\u7ED3\u6784\u7684\u6570\u636E\u5168\u90E8\u5C55\u5F00",
      expOptUseStyle: "\u6837\u5F0F",
      expUseStyleTitle: "\u5982\u679C\u5B58\u5728\uFF0C\u5219\u652F\u6301\u5E26\u6837\u5F0F\u7684\u5355\u5143\u683C",
      expOptOriginal: "\u6E90\u6570\u636E",
      expOriginalTitle: "\u5982\u679C\u4E3A\u6E90\u6570\u636E\uFF0C\u5219\u652F\u6301\u5BFC\u5165\u5230\u8868\u683C\u4E2D",
      expPrint: "\u6253\u5370",
      expConfirm: "\u5BFC\u51FA",
      expCancel: "\u53D6\u6D88"
    },
    modal: {
      zoomIn: "\u6700\u5927\u5316",
      zoomOut: "\u8FD8\u539F",
      close: "\u5173\u95ED"
    },
    form: {
      folding: "\u6536\u8D77",
      unfolding: "\u5C55\u5F00"
    },
    toolbar: {
      import: "\u5BFC\u5165",
      export: "\u5BFC\u51FA",
      print: "\u6253\u5370",
      refresh: "\u5237\u65B0",
      zoomIn: "\u5168\u5C4F",
      zoomOut: "\u8FD8\u539F",
      custom: "\u5217\u8BBE\u7F6E",
      customAll: "\u5168\u90E8",
      customConfirm: "\u786E\u8BA4",
      customRestore: "\u8FD8\u539F"
    },
    input: {
      date: {
        m1: "01 \u6708",
        m2: "02 \u6708",
        m3: "03 \u6708",
        m4: "04 \u6708",
        m5: "05 \u6708",
        m6: "06 \u6708",
        m7: "07 \u6708",
        m8: "08 \u6708",
        m9: "09 \u6708",
        m10: "10 \u6708",
        m11: "11 \u6708",
        m12: "12 \u6708",
        quarterLabel: "{0} \u5E74",
        monthLabel: "{0} \u5E74",
        dayLabel: "{0} \u5E74 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy \u5E74\u7B2C WW \u5468",
          month: "yyyy-MM",
          quarter: "yyyy \u5E74\u7B2C q \u5B63\u5EA6",
          year: "yyyy"
        },
        weeks: {
          w: "\u5468",
          w0: "\u5468\u65E5",
          w1: "\u5468\u4E00",
          w2: "\u5468\u4E8C",
          w3: "\u5468\u4E09",
          w4: "\u5468\u56DB",
          w5: "\u5468\u4E94",
          w6: "\u5468\u516D"
        },
        months: {
          m0: "\u4E00\u6708",
          m1: "\u4E8C\u6708",
          m2: "\u4E09\u6708",
          m3: "\u56DB\u6708",
          m4: "\u4E94\u6708",
          m5: "\u516D\u6708",
          m6: "\u4E03\u6708",
          m7: "\u516B\u6708",
          m8: "\u4E5D\u6708",
          m9: "\u5341\u6708",
          m10: "\u5341\u4E00\u6708",
          m11: "\u5341\u4E8C\u6708"
        },
        quarters: {
          q1: "\u7B2C\u4E00\u5B63\u5EA6",
          q2: "\u7B2C\u4E8C\u5B63\u5EA6",
          q3: "\u7B2C\u4E09\u5B63\u5EA6",
          q4: "\u7B2C\u56DB\u5B63\u5EA6"
        }
      }
    }
  }
};
setup({
  i18n: function(key, args) {
    return xeUtils.toFormatString(xeUtils.get(zhCN, key), args);
  }
});
var freeGlobal$4 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$5 = freeGlobal$4;
var freeSelf$4 = typeof self == "object" && self && self.Object === Object && self;
var root$4 = freeGlobal$5 || freeSelf$4 || Function("return this")();
var root$5 = root$4;
var Symbol$3 = root$5.Symbol;
var Symbol$4 = Symbol$3;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var nativeObjectToString$1 = objectProto$9.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$8 = Object.prototype;
var nativeObjectToString = objectProto$8.toString;
function objectToString$6(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$6(value);
}
function isObjectLike$5(value) {
  return value != null && typeof value == "object";
}
var symbolTag$3 = "[object Symbol]";
function isSymbol$3(value) {
  return typeof value == "symbol" || isObjectLike$5(value) && baseGetTag$1(value) == symbolTag$3;
}
function arrayMap$1(array2, iteratee) {
  var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
var isArray$3 = Array.isArray;
var isArray$4 = isArray$3;
var INFINITY$2 = 1 / 0;
var symbolProto$1 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$4(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject$7(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var NAN$2 = 0 / 0;
var reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$2 = /^0b[01]+$/i;
var reIsOctal$2 = /^0o[0-7]+$/i;
var freeParseInt$2 = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$3(value)) {
    return NAN$2;
  }
  if (isObject$7(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$7(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary$2.test(value);
  return isBinary || reIsOctal$2.test(value) ? freeParseInt$2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$2.test(value) ? NAN$2 : +value;
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$7(value)) {
    return false;
  }
  var tag = baseGetTag$1(value);
  return tag == funcTag$2 || tag == genTag$2 || tag == asyncTag || tag == proxyTag;
}
var coreJsData$1 = root$5["__core-js_shared__"];
var coreJsData$2 = coreJsData$1;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$3(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$4(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative$1(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function hashGet(key) {
  var data5 = this.__data__;
  if (nativeCreate$1) {
    var result = data5[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$5.call(data5, key) ? data5[key] : void 0;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashHas(key) {
  var data5 = this.__data__;
  return nativeCreate$1 ? data5[key] !== void 0 : hasOwnProperty$4.call(data5, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data5 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data5[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data5 = this.__data__, index = assocIndexOf(data5, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data5.length - 1;
  if (index == lastIndex) {
    data5.pop();
  } else {
    splice.call(data5, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data5 = this.__data__, index = assocIndexOf(data5, key);
  return index < 0 ? void 0 : data5[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data5 = this.__data__, index = assocIndexOf(data5, key);
  if (index < 0) {
    ++this.size;
    data5.push([key, value]);
  } else {
    data5[index][1] = value;
  }
  return this;
}
function ListCache(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$2 = getNative$1(root$5, "Map");
var Map$3 = Map$2;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data5 = map2.__data__;
  return isKeyable(key) ? data5[typeof key == "string" ? "string" : "hash"] : data5.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data5 = getMapData(this, key), size = data5.size;
  data5.set(key, value);
  this.size += data5.size == size ? 0 : 1;
  return this;
}
function MapCache(entries2) {
  var index = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length2) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$4 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$4);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString$1(value) {
  return value == null ? "" : baseToString$1(value);
}
function castPath(value, object) {
  if (isArray$4(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString$1(value));
}
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol$3(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0, length2 = path.length;
  while (object != null && index < length2) {
    object = object[toKey(path[index++])];
  }
  return index && index == length2 ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var now$2 = function() {
  return root$5.Date.now();
};
var now$3 = now$2;
var FUNC_ERROR_TEXT$3 = "Expected a function";
var nativeMax$2 = Math.max, nativeMin$2 = Math.min;
function debounce$3(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  wait = toNumber$2(wait) || 0;
  if (isObject$7(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$2(toNumber$2(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$3();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$3());
  }
  function debounced() {
    var time2 = now$3(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function fromPairs(pairs) {
  var index = -1, length2 = pairs == null ? 0 : pairs.length, result = {};
  while (++index < length2) {
    var pair = pairs[index];
    result[pair[0]] = pair[1];
  }
  return result;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
function throttle$1(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  if (isObject$7(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$3(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var _a$5;
const isClient = typeof window !== "undefined";
const isBoolean = (val2) => typeof val2 === "boolean";
const isNumber = (val2) => typeof val2 === "number";
const isString$2 = (val2) => typeof val2 === "string";
const noop = () => {
};
isClient && ((_a$5 = window == null ? void 0 : window.navigator) == null ? void 0 : _a$5.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref$1(r2);
}
function identity$1(arg) {
  return arg;
}
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
function tryOnMounted(fn2, sync = true) {
  if (getCurrentInstance$1())
    onMounted$1(fn2);
  else if (sync)
    fn2();
  else
    nextTick$1(fn2);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref$1(false);
  let timer = null;
  function clear2() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear2();
  }
  function start2(...args) {
    clear2();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, resolveUnref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start2();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start: start2,
    stop: stop2
  };
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString$2(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch$1(() => unrefElement(target), (el2) => {
    cleanup();
    if (!el2)
      return;
    el2.addEventListener(event, listener, options);
    cleanup = () => {
      el2.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function useSupported(callback, sync = false) {
  const isSupported = ref$1();
  const update5 = () => isSupported.value = Boolean(callback());
  update5();
  tryOnMounted(update5, sync);
  return isSupported;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver$1(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch$1(() => unrefElement(target), (el2) => {
    cleanup();
    if (isSupported.value && window2 && el2) {
      observer = new ResizeObserver(callback);
      observer.observe(el2, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues$1({
  linear: identity$1
}, _TransitionPresets);
const NOOP = () => {
};
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn = (val2, key) => hasOwnProperty$3.call(val2, key);
const isArray$2 = Array.isArray;
const isFunction$2 = (val2) => typeof val2 === "function";
const isString$1 = (val2) => typeof val2 === "string";
const isObject$6 = (val2) => val2 !== null && typeof val2 === "object";
const objectToString$5 = Object.prototype.toString;
const toTypeString = (value) => objectToString$5.call(value);
const isUndefined = (val2) => val2 === void 0;
const isElement$2 = (e3) => {
  if (typeof Element === "undefined")
    return false;
  return e3 instanceof Element;
};
const keysOf = (arr) => Object.keys(arr);
function debugWarn(scope, message2) {
}
const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
const addClass$1 = (el2, cls) => {
  if (!el2 || !cls.trim())
    return;
  el2.classList.add(...classNameToArray(cls));
};
const removeClass$1 = (el2, cls) => {
  if (!el2 || !cls.trim())
    return;
  el2.classList.remove(...classNameToArray(cls));
};
function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isString$1(value)) {
    return value;
  } else if (isNumber(value)) {
    return `${value}${defaultUnit}`;
  }
}
/*! Element Plus Icons Vue v2.0.9 */
var export_helper_default = (sfc, props) => {
  let target = sfc.__vccOpts || sfc;
  for (let [key, val2] of props)
    target[key] = val2;
  return target;
};
var _sfc_main8 = {
  name: "ArrowLeft"
}, _hoisted_18 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_28 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1), _hoisted_38 = [
  _hoisted_28
];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_18, _hoisted_38);
}
var arrow_left_default = /* @__PURE__ */ export_helper_default(_sfc_main8, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
var _sfc_main10 = {
  name: "ArrowRight"
}, _hoisted_110 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_210 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1), _hoisted_310 = [
  _hoisted_210
];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
}
var arrow_right_default = /* @__PURE__ */ export_helper_default(_sfc_main10, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
var _sfc_main34 = {
  name: "CaretRight"
}, _hoisted_134 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_234 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M384 192v640l384-320.064z"
}, null, -1), _hoisted_333 = [
  _hoisted_234
];
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_134, _hoisted_333);
}
var caret_right_default = /* @__PURE__ */ export_helper_default(_sfc_main34, [["render", _sfc_render34], ["__file", "caret-right.vue"]]);
var _sfc_main50 = {
  name: "CircleCloseFilled"
}, _hoisted_150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_250 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1), _hoisted_349 = [
  _hoisted_250
];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_349);
}
var circle_close_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main50, [["render", _sfc_render50], ["__file", "circle-close-filled.vue"]]);
var _sfc_main56 = {
  name: "Close"
}, _hoisted_156 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_256 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1), _hoisted_355 = [
  _hoisted_256
];
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_156, _hoisted_355);
}
var close_default = /* @__PURE__ */ export_helper_default(_sfc_main56, [["render", _sfc_render56], ["__file", "close.vue"]]);
var _sfc_main118 = {
  name: "FullScreen"
}, _hoisted_1118 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2118 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64v.064zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64l-192 .192zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64l192-.192zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64v-.064z"
}, null, -1), _hoisted_3117 = [
  _hoisted_2118
];
function _sfc_render118(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1118, _hoisted_3117);
}
var full_screen_default = /* @__PURE__ */ export_helper_default(_sfc_main118, [["render", _sfc_render118], ["__file", "full-screen.vue"]]);
var _sfc_main143 = {
  name: "InfoFilled"
}, _hoisted_1143 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2143 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1), _hoisted_3142 = [
  _hoisted_2143
];
function _sfc_render143(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1143, _hoisted_3142);
}
var info_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main143, [["render", _sfc_render143], ["__file", "info-filled.vue"]]);
var _sfc_main150 = {
  name: "Loading"
}, _hoisted_1150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2150 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1), _hoisted_3149 = [
  _hoisted_2150
];
function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_3149);
}
var loading_default = /* @__PURE__ */ export_helper_default(_sfc_main150, [["render", _sfc_render150], ["__file", "loading.vue"]]);
var _sfc_main215 = {
  name: "RefreshLeft"
}, _hoisted_1215 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2215 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
}, null, -1), _hoisted_3214 = [
  _hoisted_2215
];
function _sfc_render215(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1215, _hoisted_3214);
}
var refresh_left_default = /* @__PURE__ */ export_helper_default(_sfc_main215, [["render", _sfc_render215], ["__file", "refresh-left.vue"]]);
var _sfc_main216 = {
  name: "RefreshRight"
}, _hoisted_1216 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2216 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88z"
}, null, -1), _hoisted_3215 = [
  _hoisted_2216
];
function _sfc_render216(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1216, _hoisted_3215);
}
var refresh_right_default = /* @__PURE__ */ export_helper_default(_sfc_main216, [["render", _sfc_render216], ["__file", "refresh-right.vue"]]);
var _sfc_main222 = {
  name: "ScaleToOriginal"
}, _hoisted_1222 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2222 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zm-361.412 0a30.118 30.118 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.118 30.118 0 0 0-30.118-30.118zM512 361.412a30.118 30.118 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.118 30.118 0 0 0 512 361.412zM512 512a30.118 30.118 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.118 30.118 0 0 0 512 512z"
}, null, -1), _hoisted_3221 = [
  _hoisted_2222
];
function _sfc_render222(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1222, _hoisted_3221);
}
var scale_to_original_default = /* @__PURE__ */ export_helper_default(_sfc_main222, [["render", _sfc_render222], ["__file", "scale-to-original.vue"]]);
var _sfc_main249 = {
  name: "SuccessFilled"
}, _hoisted_1249 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2249 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1), _hoisted_3248 = [
  _hoisted_2249
];
function _sfc_render249(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1249, _hoisted_3248);
}
var success_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main249, [["render", _sfc_render249], ["__file", "success-filled.vue"]]);
var _sfc_main287 = {
  name: "WarningFilled"
}, _hoisted_1287 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2287 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1), _hoisted_3286 = [
  _hoisted_2287
];
function _sfc_render287(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1287, _hoisted_3286);
}
var warning_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main287, [["render", _sfc_render287], ["__file", "warning-filled.vue"]]);
var _sfc_main292 = {
  name: "ZoomIn"
}, _hoisted_1292 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2292 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zm-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64h96z"
}, null, -1), _hoisted_3291 = [
  _hoisted_2292
];
function _sfc_render292(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1292, _hoisted_3291);
}
var zoom_in_default = /* @__PURE__ */ export_helper_default(_sfc_main292, [["render", _sfc_render292], ["__file", "zoom-in.vue"]]);
var _sfc_main293 = {
  name: "ZoomOut"
}, _hoisted_1293 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2293 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704zM352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64z"
}, null, -1), _hoisted_3292 = [
  _hoisted_2293
];
function _sfc_render293(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1293, _hoisted_3292);
}
var zoom_out_default = /* @__PURE__ */ export_helper_default(_sfc_main293, [["render", _sfc_render293], ["__file", "zoom-out.vue"]]);
const epPropKey = "__epPropKey";
const definePropType = (val2) => val2;
const isEpProp = (val2) => isObject$6(val2) && !!val2[epPropKey];
const buildProp = (prop, key) => {
  if (!isObject$6(prop) || isEpProp(prop))
    return prop;
  const { values: values2, required: required2, default: defaultValue, type: type2, validator } = prop;
  const _validator = values2 || validator ? (val2) => {
    let valid2 = false;
    let allowedValues = [];
    if (values2) {
      allowedValues = Array.from(values2);
      if (hasOwn(prop, "default")) {
        allowedValues.push(defaultValue);
      }
      valid2 || (valid2 = allowedValues.includes(val2));
    }
    if (validator)
      valid2 || (valid2 = validator(val2));
    if (!valid2 && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val2)}.`);
    }
    return valid2;
  } : void 0;
  const epProp = {
    type: type2,
    required: !!required2,
    validator: _validator,
    [epPropKey]: true
  };
  if (hasOwn(prop, "default"))
    epProp.default = defaultValue;
  return epProp;
};
const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
  key,
  buildProp(option, key)
]));
const iconPropType = definePropType([
  String,
  Object,
  Function
]);
const TypeComponents = {
  Close: close_default,
  SuccessFilled: success_filled_default,
  InfoFilled: info_filled_default,
  WarningFilled: warning_filled_default,
  CircleCloseFilled: circle_close_filled_default
};
const TypeComponentsMap = {
  success: success_filled_default,
  warning: warning_filled_default,
  error: circle_close_filled_default,
  info: info_filled_default
};
const withInstall = (main, extra) => {
  main.install = (app) => {
    for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      main[key] = comp;
    }
  }
  return main;
};
const withInstallFunction = (fn2, name2) => {
  fn2.install = (app) => {
    fn2._context = app._context;
    app.config.globalProperties[name2] = fn2;
  };
  return fn2;
};
const withNoopInstall = (component) => {
  component.install = NOOP;
  return component;
};
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};
const UPDATE_MODEL_EVENT = "update:modelValue";
const componentSizes = ["", "default", "small", "large"];
const isFirefox = () => isClient && /firefox/i.test(window.navigator.userAgent);
const mutable = (val2) => val2;
const configProviderContextKey = Symbol();
const formContextKey = Symbol("formContextKey");
const formItemContextKey = Symbol("formItemContextKey");
const useProp = (name2) => {
  const vm = getCurrentInstance$1();
  return computed$1(() => {
    var _a2, _b2;
    return (_b2 = ((_a2 = vm.proxy) == null ? void 0 : _a2.$props)[name2]) != null ? _b2 : void 0;
  });
};
const globalConfig = ref$1();
function useGlobalConfig(key, defaultValue = void 0) {
  const config2 = getCurrentInstance$1() ? inject(configProviderContextKey, globalConfig) : globalConfig;
  if (key) {
    return computed$1(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = config2.value) == null ? void 0 : _a2[key]) != null ? _b2 : defaultValue;
    });
  } else {
    return config2;
  }
}
const provideGlobalConfig = (config2, app, global2 = false) => {
  var _a2;
  const inSetup = !!getCurrentInstance$1();
  const oldConfig = inSetup ? useGlobalConfig() : void 0;
  const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? provide : void 0;
  if (!provideFn) {
    return;
  }
  const context = computed$1(() => {
    const cfg = unref$1(config2);
    if (!(oldConfig == null ? void 0 : oldConfig.value))
      return cfg;
    return mergeConfig(oldConfig.value, cfg);
  });
  provideFn(configProviderContextKey, context);
  if (global2 || !globalConfig.value) {
    globalConfig.value = context.value;
  }
  return context;
};
const mergeConfig = (a2, b2) => {
  var _a2;
  const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a2), ...keysOf(b2)])];
  const obj = {};
  for (const key of keys2) {
    obj[key] = (_a2 = b2[key]) != null ? _a2 : a2[key];
  }
  return obj;
};
const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
const useSize = (fallback, ignore = {}) => {
  const emptyRef = ref$1(void 0);
  const size = ignore.prop ? emptyRef : useProp("size");
  const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
  const form2 = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
  const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
  return computed$1(() => size.value || unref$1(fallback) || (formItem == null ? void 0 : formItem.size) || (form2 == null ? void 0 : form2.size) || globalConfig2.value || "");
};
const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
const useNamespace = (block) => {
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const b2 = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
  const e3 = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
  const m2 = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
  const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
  const is2 = (name2, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name2 && state ? `${statePrefix}${name2}` : "";
  };
  const cssVar = (object) => {
    const styles = {};
    for (const key in object) {
      if (object[key]) {
        styles[`--${namespace.value}-${key}`] = object[key];
      }
    }
    return styles;
  };
  const cssVarBlock = (object) => {
    const styles = {};
    for (const key in object) {
      if (object[key]) {
        styles[`--${namespace.value}-${block}-${key}`] = object[key];
      }
    }
    return styles;
  };
  const cssVarName = (name2) => `--${namespace.value}-${name2}`;
  const cssVarBlockName = (name2) => `--${namespace.value}-${block}-${name2}`;
  return {
    namespace,
    b: b2,
    e: e3,
    m: m2,
    be: be2,
    em,
    bm,
    bem,
    is: is2,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};
const defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");
const useId = (deterministicId) => {
  const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection);
  const namespace = useGlobalConfig("namespace", defaultNamespace);
  const idRef = computed$1(() => unref$1(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};
const useFormItem = () => {
  const form2 = inject(formContextKey, void 0);
  const formItem = inject(formItemContextKey, void 0);
  return {
    form: form2,
    formItem
  };
};
const useFormItemInputId = (props, {
  formItemContext,
  disableIdGeneration,
  disableIdManagement
}) => {
  if (!disableIdGeneration) {
    disableIdGeneration = ref$1(false);
  }
  if (!disableIdManagement) {
    disableIdManagement = ref$1(false);
  }
  const inputId = ref$1();
  let idUnwatch = void 0;
  const isLabeledByFormItem = computed$1(() => {
    var _a2;
    return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
  });
  onMounted$1(() => {
    idUnwatch = watch$1([toRef(props, "id"), disableIdGeneration], ([id2, disableIdGeneration2]) => {
      const newId = id2 != null ? id2 : !disableIdGeneration2 ? useId().value : void 0;
      if (newId !== inputId.value) {
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
          if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
            formItemContext.addInputId(newId);
          }
        }
        inputId.value = newId;
      }
    }, { immediate: true });
  });
  onUnmounted(() => {
    idUnwatch && idUnwatch();
    if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
      inputId.value && formItemContext.removeInputId(inputId.value);
    }
  });
  return {
    isLabeledByFormItem,
    inputId
  };
};
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const buildTranslator = (locale2) => (path, option) => translate(path, option, unref$1(locale2));
const translate = (path, option, locale2) => get(locale2, path, path).replace(/\{(\w+)\}/g, (_2, key) => {
  var _a2;
  return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
});
const buildLocaleContext = (locale2) => {
  const lang = computed$1(() => unref$1(locale2).name);
  const localeRef = isRef(locale2) ? locale2 : ref$1(locale2);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale2)
  };
};
const useLocale = () => {
  const locale2 = useGlobalConfig("locale");
  return buildLocaleContext(computed$1(() => locale2.value || English));
};
const zIndex = ref$1(0);
const useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = computed$1(() => initialZIndex.value + zIndex.value);
  const nextZIndex2 = () => {
    zIndex.value++;
    return currentZIndex.value;
  };
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex: nextZIndex2
  };
};
var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val2] of props) {
    target[key] = val2;
  }
  return target;
};
const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});
const __default__$7 = {
  name: "ElIcon",
  inheritAttrs: false
};
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  ...__default__$7,
  props: iconProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("icon");
    const style = computed$1(() => {
      const { size, color: color2 } = props;
      if (!size && !color2)
        return {};
      return {
        fontSize: isUndefined(size) ? void 0 : addUnit(size),
        "--color": color2
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", mergeProps$1({
        class: unref$1(ns2).b(),
        style: unref$1(style)
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default")
      ], 16);
    };
  }
});
var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const ElIcon = withInstall(Icon);
const badgeProps = buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
});
const _hoisted_1$a = ["textContent"];
const __default__$6 = {
  name: "ElBadge"
};
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  ...__default__$6,
  props: badgeProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("badge");
    const content = computed$1(() => {
      if (props.isDot)
        return "";
      if (isNumber(props.value) && isNumber(props.max)) {
        return props.max < props.value ? `${props.max}+` : `${props.value}`;
      }
      return `${props.value}`;
    });
    expose({
      content
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref$1(ns2).b())
      }, [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, {
          name: `${unref$1(ns2).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("sup", {
              class: normalizeClass([
                unref$1(ns2).e("content"),
                unref$1(ns2).em("content", _ctx.type),
                unref$1(ns2).is("fixed", !!_ctx.$slots.default),
                unref$1(ns2).is("dot", _ctx.isDot)
              ]),
              textContent: toDisplayString(unref$1(content))
            }, null, 10, _hoisted_1$a), [
              [vShow, !_ctx.hidden && (unref$1(content) || _ctx.isDot)]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ], 2);
    };
  }
});
var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const ElBadge = withInstall(Badge);
const nodeList = /* @__PURE__ */ new Map();
let startClick;
if (isClient) {
  document.addEventListener("mousedown", (e3) => startClick = e3);
  document.addEventListener("mouseup", (e3) => {
    for (const handlers of nodeList.values()) {
      for (const { documentHandler } of handlers) {
        documentHandler(e3, startClick);
      }
    }
  });
}
function createDocumentHandler(el2, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement$2(binding.arg)) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el2.contains(mouseUpTarget) || el2.contains(mouseDownTarget);
    const isSelf = el2 === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el2, binding) {
    if (!nodeList.has(el2)) {
      nodeList.set(el2, []);
    }
    nodeList.get(el2).push({
      documentHandler: createDocumentHandler(el2, binding),
      bindingFn: binding.value
    });
  },
  updated(el2, binding) {
    if (!nodeList.has(el2)) {
      nodeList.set(el2, []);
    }
    const handlers = nodeList.get(el2);
    const oldHandlerIndex = handlers.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el2, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers.push(newHandler);
    }
  },
  unmounted(el2) {
    nodeList.delete(el2);
  }
};
const useCheckboxGroupProps = {
  modelValue: {
    type: Array,
    default: () => []
  },
  disabled: Boolean,
  min: {
    type: Number,
    default: void 0
  },
  max: {
    type: Number,
    default: void 0
  },
  size: useSizeProp,
  id: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  fill: {
    type: String,
    default: void 0
  },
  textColor: {
    type: String,
    default: void 0
  },
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: true
  }
};
const checkboxProps = {
  modelValue: {
    type: [Number, String, Boolean],
    default: () => void 0
  },
  label: {
    type: [String, Boolean, Number, Object]
  },
  indeterminate: Boolean,
  disabled: Boolean,
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  controls: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: useSizeProp,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: true
  }
};
const useCheckboxGroup = () => {
  const { form: elForm, formItem: elFormItem } = useFormItem();
  const checkboxGroup = inject("CheckboxGroup", {});
  const isGroup = computed$1(() => checkboxGroup && (checkboxGroup == null ? void 0 : checkboxGroup.name) === "ElCheckboxGroup");
  const elFormItemSize = computed$1(() => {
    return elFormItem == null ? void 0 : elFormItem.size;
  });
  return {
    isGroup,
    checkboxGroup,
    elForm,
    elFormItemSize,
    elFormItem
  };
};
const useCheckboxGroupId = (props, { elFormItem }) => {
  const { inputId: groupId, isLabeledByFormItem } = useFormItemInputId(props, {
    formItemContext: elFormItem
  });
  return {
    isLabeledByFormItem,
    groupId
  };
};
const useModel = (props) => {
  const selfModel = ref$1(false);
  const { emit } = getCurrentInstance$1();
  const { isGroup, checkboxGroup, elFormItem } = useCheckboxGroup();
  const isLimitExceeded = ref$1(false);
  const model = computed$1({
    get() {
      var _a2, _b2;
      return isGroup.value ? (_a2 = checkboxGroup.modelValue) == null ? void 0 : _a2.value : (_b2 = props.modelValue) != null ? _b2 : selfModel.value;
    },
    set(val2) {
      var _a2;
      if (isGroup.value && Array.isArray(val2)) {
        isLimitExceeded.value = checkboxGroup.max !== void 0 && val2.length > checkboxGroup.max.value;
        isLimitExceeded.value === false && ((_a2 = checkboxGroup == null ? void 0 : checkboxGroup.changeEvent) == null ? void 0 : _a2.call(checkboxGroup, val2));
      } else {
        emit(UPDATE_MODEL_EVENT, val2);
        selfModel.value = val2;
      }
    }
  });
  return {
    model,
    isGroup,
    isLimitExceeded,
    elFormItem
  };
};
const useCheckboxStatus = (props, slots, { model }) => {
  const { isGroup, checkboxGroup } = useCheckboxGroup();
  const focus2 = ref$1(false);
  const size = useSize(checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize, { prop: true });
  const isChecked = computed$1(() => {
    const value = model.value;
    if (toTypeString(value) === "[object Boolean]") {
      return value;
    } else if (Array.isArray(value)) {
      return value.map(toRaw).includes(props.label);
    } else if (value !== null && value !== void 0) {
      return value === props.trueLabel;
    } else {
      return !!value;
    }
  });
  const checkboxSize = useSize(computed$1(() => {
    var _a2;
    return isGroup.value ? (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.checkboxGroupSize) == null ? void 0 : _a2.value : void 0;
  }));
  const hasOwnLabel = computed$1(() => {
    return !!(slots.default || props.label);
  });
  return {
    isChecked,
    focus: focus2,
    size,
    checkboxSize,
    hasOwnLabel
  };
};
const useDisabled = (props, {
  model,
  isChecked
}) => {
  const { elForm, isGroup, checkboxGroup } = useCheckboxGroup();
  const isLimitDisabled = computed$1(() => {
    var _a2, _b2;
    const max3 = (_a2 = checkboxGroup.max) == null ? void 0 : _a2.value;
    const min3 = (_b2 = checkboxGroup.min) == null ? void 0 : _b2.value;
    return !!(max3 || min3) && model.value.length >= max3 && !isChecked.value || model.value.length <= min3 && isChecked.value;
  });
  const isDisabled = computed$1(() => {
    var _a2, _b2;
    const disabled3 = props.disabled || (elForm == null ? void 0 : elForm.disabled);
    return (_b2 = isGroup.value ? ((_a2 = checkboxGroup.disabled) == null ? void 0 : _a2.value) || disabled3 || isLimitDisabled.value : disabled3) != null ? _b2 : false;
  });
  return {
    isDisabled,
    isLimitDisabled
  };
};
const setStoreValue = (props, { model }) => {
  function addToStore() {
    if (Array.isArray(model.value) && !model.value.includes(props.label)) {
      model.value.push(props.label);
    } else {
      model.value = props.trueLabel || true;
    }
  }
  props.checked && addToStore();
};
const useEvent = (props, {
  model,
  isLimitExceeded,
  hasOwnLabel,
  isDisabled,
  isLabeledByFormItem
}) => {
  const { elFormItem, checkboxGroup } = useCheckboxGroup();
  const { emit } = getCurrentInstance$1();
  function getLabeledValue(value) {
    var _a2, _b2;
    return value === props.trueLabel || value === true ? (_a2 = props.trueLabel) != null ? _a2 : true : (_b2 = props.falseLabel) != null ? _b2 : false;
  }
  function emitChangeEvent(checked, e3) {
    emit("change", getLabeledValue(checked), e3);
  }
  function handleChange2(e3) {
    if (isLimitExceeded.value)
      return;
    const target = e3.target;
    emit("change", getLabeledValue(target.checked), e3);
  }
  async function onClickRoot(e3) {
    if (isLimitExceeded.value)
      return;
    if (!hasOwnLabel.value && !isDisabled.value && isLabeledByFormItem.value) {
      model.value = getLabeledValue([false, props.falseLabel].includes(model.value));
      await nextTick$1();
      emitChangeEvent(model.value, e3);
    }
  }
  const validateEvent = computed$1(() => {
    var _a2;
    return ((_a2 = checkboxGroup.validateEvent) == null ? void 0 : _a2.value) || props.validateEvent;
  });
  watch$1(() => props.modelValue, () => {
    if (validateEvent.value) {
      elFormItem == null ? void 0 : elFormItem.validate("change").catch((err2) => debugWarn());
    }
  });
  return {
    handleChange: handleChange2,
    onClickRoot
  };
};
const checkboxEmits = {
  [UPDATE_MODEL_EVENT]: (val2) => isString$1(val2) || isNumber(val2) || isBoolean(val2),
  change: (val2) => isString$1(val2) || isNumber(val2) || isBoolean(val2)
};
const checkboxGroupEmits = {
  [UPDATE_MODEL_EVENT]: (val2) => isArray$2(val2),
  change: (val2) => isArray$2(val2)
};
const useCheckbox = (props, slots) => {
  const { model, isGroup, isLimitExceeded, elFormItem } = useModel(props);
  const { focus: focus2, size, isChecked, checkboxSize, hasOwnLabel } = useCheckboxStatus(props, slots, {
    model
  });
  const { isDisabled } = useDisabled(props, { model, isChecked });
  const { inputId, isLabeledByFormItem } = useFormItemInputId(props, {
    formItemContext: elFormItem,
    disableIdGeneration: hasOwnLabel,
    disableIdManagement: isGroup
  });
  const { handleChange: handleChange2, onClickRoot } = useEvent(props, {
    model,
    isLimitExceeded,
    hasOwnLabel,
    isDisabled,
    isLabeledByFormItem
  });
  setStoreValue(props, { model });
  return {
    elFormItem,
    inputId,
    isLabeledByFormItem,
    isChecked,
    isDisabled,
    isGroup,
    checkboxSize,
    hasOwnLabel,
    model,
    handleChange: handleChange2,
    onClickRoot,
    focus: focus2,
    size
  };
};
const _hoisted_1$9 = ["tabindex", "role", "aria-checked"];
const _hoisted_2$5 = ["id", "aria-hidden", "name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_3$2 = ["id", "aria-hidden", "disabled", "value", "name", "tabindex"];
const __default__$5 = {
  name: "ElCheckbox"
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  ...__default__$5,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const {
      inputId,
      isLabeledByFormItem,
      isChecked,
      isDisabled,
      checkboxSize,
      hasOwnLabel,
      model,
      handleChange: handleChange2,
      onClickRoot,
      focus: focus2
    } = useCheckbox(props, slots);
    const ns2 = useNamespace("checkbox");
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(!unref$1(hasOwnLabel) && unref$1(isLabeledByFormItem) ? "span" : "label"), {
        class: normalizeClass([
          unref$1(ns2).b(),
          unref$1(ns2).m(unref$1(checkboxSize)),
          unref$1(ns2).is("disabled", unref$1(isDisabled)),
          unref$1(ns2).is("bordered", _ctx.border),
          unref$1(ns2).is("checked", unref$1(isChecked))
        ]),
        "aria-controls": _ctx.indeterminate ? _ctx.controls : null,
        onClick: unref$1(onClickRoot)
      }, {
        default: withCtx(() => [
          createElementVNode("span", {
            class: normalizeClass([
              unref$1(ns2).e("input"),
              unref$1(ns2).is("disabled", unref$1(isDisabled)),
              unref$1(ns2).is("checked", unref$1(isChecked)),
              unref$1(ns2).is("indeterminate", _ctx.indeterminate),
              unref$1(ns2).is("focus", unref$1(focus2))
            ]),
            tabindex: _ctx.indeterminate ? 0 : void 0,
            role: _ctx.indeterminate ? "checkbox" : void 0,
            "aria-checked": _ctx.indeterminate ? "mixed" : void 0
          }, [
            _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
              key: 0,
              id: unref$1(inputId),
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref$1(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              disabled: unref$1(isDisabled),
              "true-value": _ctx.trueLabel,
              "false-value": _ctx.falseLabel,
              onChange: _cache[1] || (_cache[1] = (...args) => unref$1(handleChange2) && unref$1(handleChange2)(...args)),
              onFocus: _cache[2] || (_cache[2] = ($event) => focus2.value = true),
              onBlur: _cache[3] || (_cache[3] = ($event) => focus2.value = false)
            }, null, 42, _hoisted_2$5)), [
              [vModelCheckbox, unref$1(model)]
            ]) : withDirectives((openBlock(), createElementBlock("input", {
              key: 1,
              id: unref$1(inputId),
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
              class: normalizeClass(unref$1(ns2).e("original")),
              type: "checkbox",
              "aria-hidden": _ctx.indeterminate ? "true" : "false",
              disabled: unref$1(isDisabled),
              value: _ctx.label,
              name: _ctx.name,
              tabindex: _ctx.tabindex,
              onChange: _cache[5] || (_cache[5] = (...args) => unref$1(handleChange2) && unref$1(handleChange2)(...args)),
              onFocus: _cache[6] || (_cache[6] = ($event) => focus2.value = true),
              onBlur: _cache[7] || (_cache[7] = ($event) => focus2.value = false)
            }, null, 42, _hoisted_3$2)), [
              [vModelCheckbox, unref$1(model)]
            ]),
            createElementVNode("span", {
              class: normalizeClass(unref$1(ns2).e("inner"))
            }, null, 2)
          ], 10, _hoisted_1$9),
          unref$1(hasOwnLabel) ? (openBlock(), createElementBlock("span", {
            key: 0,
            class: normalizeClass(unref$1(ns2).e("label"))
          }, [
            renderSlot(_ctx.$slots, "default"),
            !_ctx.$slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64)) : createCommentVNode("v-if", true)
          ], 2)) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]);
    };
  }
});
var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const _hoisted_1$8 = ["name", "tabindex", "disabled", "true-value", "false-value"];
const _hoisted_2$4 = ["name", "tabindex", "disabled", "value"];
const __default__$4 = {
  name: "ElCheckboxButton"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  ...__default__$4,
  props: checkboxProps,
  emits: checkboxEmits,
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const { focus: focus2, isChecked, isDisabled, size, model, handleChange: handleChange2 } = useCheckbox(props, slots);
    const { checkboxGroup } = useCheckboxGroup();
    const ns2 = useNamespace("checkbox");
    const activeStyle = computed$1(() => {
      var _a2, _b2, _c2, _d2;
      const fillValue = (_b2 = (_a2 = checkboxGroup == null ? void 0 : checkboxGroup.fill) == null ? void 0 : _a2.value) != null ? _b2 : "";
      return {
        backgroundColor: fillValue,
        borderColor: fillValue,
        color: (_d2 = (_c2 = checkboxGroup == null ? void 0 : checkboxGroup.textColor) == null ? void 0 : _c2.value) != null ? _d2 : "",
        boxShadow: fillValue ? `-1px 0 0 0 ${fillValue}` : void 0
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass([
          unref$1(ns2).b("button"),
          unref$1(ns2).bm("button", unref$1(size)),
          unref$1(ns2).is("disabled", unref$1(isDisabled)),
          unref$1(ns2).is("checked", unref$1(isChecked)),
          unref$1(ns2).is("focus", unref$1(focus2))
        ])
      }, [
        _ctx.trueLabel || _ctx.falseLabel ? withDirectives((openBlock(), createElementBlock("input", {
          key: 0,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(model) ? model.value = $event : null),
          class: normalizeClass(unref$1(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: unref$1(isDisabled),
          "true-value": _ctx.trueLabel,
          "false-value": _ctx.falseLabel,
          onChange: _cache[1] || (_cache[1] = (...args) => unref$1(handleChange2) && unref$1(handleChange2)(...args)),
          onFocus: _cache[2] || (_cache[2] = ($event) => focus2.value = true),
          onBlur: _cache[3] || (_cache[3] = ($event) => focus2.value = false)
        }, null, 42, _hoisted_1$8)), [
          [vModelCheckbox, unref$1(model)]
        ]) : withDirectives((openBlock(), createElementBlock("input", {
          key: 1,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => isRef(model) ? model.value = $event : null),
          class: normalizeClass(unref$1(ns2).be("button", "original")),
          type: "checkbox",
          name: _ctx.name,
          tabindex: _ctx.tabindex,
          disabled: unref$1(isDisabled),
          value: _ctx.label,
          onChange: _cache[5] || (_cache[5] = (...args) => unref$1(handleChange2) && unref$1(handleChange2)(...args)),
          onFocus: _cache[6] || (_cache[6] = ($event) => focus2.value = true),
          onBlur: _cache[7] || (_cache[7] = ($event) => focus2.value = false)
        }, null, 42, _hoisted_2$4)), [
          [vModelCheckbox, unref$1(model)]
        ]),
        _ctx.$slots.default || _ctx.label ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(unref$1(ns2).be("button", "inner")),
          style: normalizeStyle$1(unref$1(isChecked) ? unref$1(activeStyle) : void 0)
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ], 6)) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var CheckboxButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const __default__$3 = {
  name: "ElCheckboxGroup"
};
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: useCheckboxGroupProps,
  emits: checkboxGroupEmits,
  setup(__props, { emit }) {
    const props = __props;
    const { elFormItem } = useCheckboxGroup();
    const { groupId, isLabeledByFormItem } = useCheckboxGroupId(props, {
      elFormItem
    });
    const checkboxGroupSize = useSize();
    const ns2 = useNamespace("checkbox");
    const changeEvent = (value) => {
      emit(UPDATE_MODEL_EVENT, value);
      nextTick$1(() => {
        emit("change", value);
      });
    };
    const modelValue5 = computed$1({
      get() {
        return props.modelValue;
      },
      set(val2) {
        changeEvent(val2);
      }
    });
    provide("CheckboxGroup", {
      name: "ElCheckboxGroup",
      ...toRefs$1(props),
      modelValue: modelValue5,
      checkboxGroupSize,
      changeEvent
    });
    watch$1(() => props.modelValue, () => {
      if (props.validateEvent) {
        elFormItem == null ? void 0 : elFormItem.validate("change").catch((err2) => debugWarn());
      }
    });
    return (_ctx, _cache) => {
      var _a2;
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        id: unref$1(groupId),
        class: normalizeClass(unref$1(ns2).b("group")),
        role: "group",
        "aria-label": !unref$1(isLabeledByFormItem) ? _ctx.label || "checkbox-group" : void 0,
        "aria-labelledby": unref$1(isLabeledByFormItem) ? (_a2 = unref$1(elFormItem)) == null ? void 0 : _a2.labelId : void 0
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var CheckboxGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const ElCheckbox = withInstall(Checkbox, {
  CheckboxButton,
  CheckboxGroup
});
withNoopInstall(CheckboxButton);
withNoopInstall(CheckboxGroup);
const __default__$2 = {
  name: "ElCollapseTransition"
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  setup(__props) {
    const ns2 = useNamespace("collapse-transition");
    const on2 = {
      beforeEnter(el2) {
        if (!el2.dataset)
          el2.dataset = {};
        el2.dataset.oldPaddingTop = el2.style.paddingTop;
        el2.dataset.oldPaddingBottom = el2.style.paddingBottom;
        el2.style.maxHeight = 0;
        el2.style.paddingTop = 0;
        el2.style.paddingBottom = 0;
      },
      enter(el2) {
        el2.dataset.oldOverflow = el2.style.overflow;
        if (el2.scrollHeight !== 0) {
          el2.style.maxHeight = `${el2.scrollHeight}px`;
          el2.style.paddingTop = el2.dataset.oldPaddingTop;
          el2.style.paddingBottom = el2.dataset.oldPaddingBottom;
        } else {
          el2.style.maxHeight = 0;
          el2.style.paddingTop = el2.dataset.oldPaddingTop;
          el2.style.paddingBottom = el2.dataset.oldPaddingBottom;
        }
        el2.style.overflow = "hidden";
      },
      afterEnter(el2) {
        el2.style.maxHeight = "";
        el2.style.overflow = el2.dataset.oldOverflow;
      },
      beforeLeave(el2) {
        if (!el2.dataset)
          el2.dataset = {};
        el2.dataset.oldPaddingTop = el2.style.paddingTop;
        el2.dataset.oldPaddingBottom = el2.style.paddingBottom;
        el2.dataset.oldOverflow = el2.style.overflow;
        el2.style.maxHeight = `${el2.scrollHeight}px`;
        el2.style.overflow = "hidden";
      },
      leave(el2) {
        if (el2.scrollHeight !== 0) {
          el2.style.maxHeight = 0;
          el2.style.paddingTop = 0;
          el2.style.paddingBottom = 0;
        }
      },
      afterLeave(el2) {
        el2.style.maxHeight = "";
        el2.style.overflow = el2.dataset.oldOverflow;
        el2.style.paddingTop = el2.dataset.oldPaddingTop;
        el2.style.paddingBottom = el2.dataset.oldPaddingBottom;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, mergeProps$1({
        name: unref$1(ns2).b()
      }, toHandlers(on2)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["name"]);
    };
  }
});
var CollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
CollapseTransition.install = (app) => {
  app.component(CollapseTransition.name, CollapseTransition);
};
const _CollapseTransition = CollapseTransition;
const messageConfig = {};
const configProviderProps = buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: useSizeProp,
  button: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
});
defineComponent({
  name: "ElConfigProvider",
  props: configProviderProps,
  setup(props, { slots }) {
    watch$1(() => props.message, (val2) => {
      Object.assign(messageConfig, val2 != null ? val2 : {});
    }, { immediate: true, deep: true });
    const config2 = provideGlobalConfig(props);
    return () => renderSlot(slots, "default", { config: config2 == null ? void 0 : config2.value });
  }
});
const imageViewerProps = buildProps({
  urlList: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: true
  },
  hideOnClickModal: {
    type: Boolean,
    default: false
  },
  teleported: {
    type: Boolean,
    default: false
  },
  closeOnPressEscape: {
    type: Boolean,
    default: true
  }
});
const imageViewerEmits = {
  close: () => true,
  switch: (index) => isNumber(index)
};
const _hoisted_1$7 = ["src"];
const __default__$1 = {
  name: "ElImageViewer"
};
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: imageViewerProps,
  emits: imageViewerEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const modes = {
      CONTAIN: {
        name: "contain",
        icon: markRaw(full_screen_default)
      },
      ORIGINAL: {
        name: "original",
        icon: markRaw(scale_to_original_default)
      }
    };
    const mousewheelEventName = isFirefox() ? "DOMMouseScroll" : "mousewheel";
    const { t: t2 } = useLocale();
    const ns2 = useNamespace("image-viewer");
    const { nextZIndex: nextZIndex2 } = useZIndex();
    const wrapper = ref$1();
    const imgRefs = ref$1([]);
    const scopeEventListener = effectScope();
    const loading = ref$1(true);
    const activeIndex = ref$1(props.initialIndex);
    const mode = shallowRef$1(modes.CONTAIN);
    const transform = ref$1({
      scale: 1,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: false
    });
    const isSingle = computed$1(() => {
      const { urlList } = props;
      return urlList.length <= 1;
    });
    const isFirst = computed$1(() => {
      return activeIndex.value === 0;
    });
    const isLast = computed$1(() => {
      return activeIndex.value === props.urlList.length - 1;
    });
    const currentImg = computed$1(() => {
      return props.urlList[activeIndex.value];
    });
    const imgStyle = computed$1(() => {
      const { scale: scale2, deg, offsetX, offsetY, enableTransition } = transform.value;
      let translateX = offsetX / scale2;
      let translateY = offsetY / scale2;
      switch (deg % 360) {
        case 90:
        case -270:
          [translateX, translateY] = [translateY, -translateX];
          break;
        case 180:
        case -180:
          [translateX, translateY] = [-translateX, -translateY];
          break;
        case 270:
        case -90:
          [translateX, translateY] = [-translateY, translateX];
          break;
      }
      const style = {
        transform: `scale(${scale2}) rotate(${deg}deg) translate(${translateX}px, ${translateY}px)`,
        transition: enableTransition ? "transform .3s" : ""
      };
      if (mode.value.name === modes.CONTAIN.name) {
        style.maxWidth = style.maxHeight = "100%";
      }
      return style;
    });
    const computedZIndex = computed$1(() => {
      return isNumber(props.zIndex) ? props.zIndex : nextZIndex2();
    });
    function hide2() {
      unregisterEventListener();
      emit("close");
    }
    function registerEventListener() {
      const keydownHandler = throttle$1((e3) => {
        switch (e3.code) {
          case EVENT_CODE.esc:
            props.closeOnPressEscape && hide2();
            break;
          case EVENT_CODE.space:
            toggleMode();
            break;
          case EVENT_CODE.left:
            prev();
            break;
          case EVENT_CODE.up:
            handleActions("zoomIn");
            break;
          case EVENT_CODE.right:
            next();
            break;
          case EVENT_CODE.down:
            handleActions("zoomOut");
            break;
        }
      });
      const mousewheelHandler = throttle$1((e3) => {
        const delta = e3.wheelDelta ? e3.wheelDelta : -e3.detail;
        if (delta > 0) {
          handleActions("zoomIn", {
            zoomRate: 1.2,
            enableTransition: false
          });
        } else {
          handleActions("zoomOut", {
            zoomRate: 1.2,
            enableTransition: false
          });
        }
      });
      scopeEventListener.run(() => {
        useEventListener(document, "keydown", keydownHandler);
        useEventListener(document, mousewheelEventName, mousewheelHandler);
      });
    }
    function unregisterEventListener() {
      scopeEventListener.stop();
    }
    function handleImgLoad() {
      loading.value = false;
    }
    function handleImgError(e3) {
      loading.value = false;
      e3.target.alt = t2("el.image.error");
    }
    function handleMouseDown(e3) {
      if (loading.value || e3.button !== 0 || !wrapper.value)
        return;
      transform.value.enableTransition = false;
      const { offsetX, offsetY } = transform.value;
      const startX = e3.pageX;
      const startY = e3.pageY;
      const dragHandler = throttle$1((ev) => {
        transform.value = {
          ...transform.value,
          offsetX: offsetX + ev.pageX - startX,
          offsetY: offsetY + ev.pageY - startY
        };
      });
      const removeMousemove = useEventListener(document, "mousemove", dragHandler);
      useEventListener(document, "mouseup", () => {
        removeMousemove();
      });
      e3.preventDefault();
    }
    function reset() {
      transform.value = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      };
    }
    function toggleMode() {
      if (loading.value)
        return;
      const modeNames = keysOf(modes);
      const modeValues = Object.values(modes);
      const currentMode = mode.value.name;
      const index = modeValues.findIndex((i2) => i2.name === currentMode);
      const nextIndex = (index + 1) % modeNames.length;
      mode.value = modes[modeNames[nextIndex]];
      reset();
    }
    function setActiveItem(index) {
      const len2 = props.urlList.length;
      activeIndex.value = (index + len2) % len2;
    }
    function prev() {
      if (isFirst.value && !props.infinite)
        return;
      setActiveItem(activeIndex.value - 1);
    }
    function next() {
      if (isLast.value && !props.infinite)
        return;
      setActiveItem(activeIndex.value + 1);
    }
    function handleActions(action, options = {}) {
      if (loading.value)
        return;
      const { zoomRate, rotateDeg, enableTransition } = {
        zoomRate: 1.4,
        rotateDeg: 90,
        enableTransition: true,
        ...options
      };
      switch (action) {
        case "zoomOut":
          if (transform.value.scale > 0.2) {
            transform.value.scale = Number.parseFloat((transform.value.scale / zoomRate).toFixed(3));
          }
          break;
        case "zoomIn":
          if (transform.value.scale < 7) {
            transform.value.scale = Number.parseFloat((transform.value.scale * zoomRate).toFixed(3));
          }
          break;
        case "clockwise":
          transform.value.deg += rotateDeg;
          break;
        case "anticlockwise":
          transform.value.deg -= rotateDeg;
          break;
      }
      transform.value.enableTransition = enableTransition;
    }
    watch$1(currentImg, () => {
      nextTick$1(() => {
        const $img = imgRefs.value[0];
        if (!($img == null ? void 0 : $img.complete)) {
          loading.value = true;
        }
      });
    });
    watch$1(activeIndex, (val2) => {
      reset();
      emit("switch", val2);
    });
    onMounted$1(() => {
      var _a2, _b2;
      registerEventListener();
      (_b2 = (_a2 = wrapper.value) == null ? void 0 : _a2.focus) == null ? void 0 : _b2.call(_a2);
    });
    expose({
      setActiveItem
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Teleport, {
        to: "body",
        disabled: !_ctx.teleported
      }, [
        createVNode(Transition, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: withCtx(() => [
            createElementVNode("div", {
              ref_key: "wrapper",
              ref: wrapper,
              tabindex: -1,
              class: normalizeClass(unref$1(ns2).e("wrapper")),
              style: normalizeStyle$1({ zIndex: unref$1(computedZIndex) })
            }, [
              createElementVNode("div", {
                class: normalizeClass(unref$1(ns2).e("mask")),
                onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.hideOnClickModal && hide2(), ["self"]))
              }, null, 2),
              createCommentVNode(" CLOSE "),
              createElementVNode("span", {
                class: normalizeClass([unref$1(ns2).e("btn"), unref$1(ns2).e("close")]),
                onClick: hide2
              }, [
                createVNode(unref$1(ElIcon), null, {
                  default: withCtx(() => [
                    createVNode(unref$1(close_default))
                  ]),
                  _: 1
                })
              ], 2),
              createCommentVNode(" ARROW "),
              !unref$1(isSingle) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createElementVNode("span", {
                  class: normalizeClass([
                    unref$1(ns2).e("btn"),
                    unref$1(ns2).e("prev"),
                    unref$1(ns2).is("disabled", !_ctx.infinite && unref$1(isFirst))
                  ]),
                  onClick: prev
                }, [
                  createVNode(unref$1(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref$1(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                createElementVNode("span", {
                  class: normalizeClass([
                    unref$1(ns2).e("btn"),
                    unref$1(ns2).e("next"),
                    unref$1(ns2).is("disabled", !_ctx.infinite && unref$1(isLast))
                  ]),
                  onClick: next
                }, [
                  createVNode(unref$1(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref$1(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 64)) : createCommentVNode("v-if", true),
              createCommentVNode(" ACTIONS "),
              createElementVNode("div", {
                class: normalizeClass([unref$1(ns2).e("btn"), unref$1(ns2).e("actions")])
              }, [
                createElementVNode("div", {
                  class: normalizeClass(unref$1(ns2).e("actions__inner"))
                }, [
                  createVNode(unref$1(ElIcon), {
                    onClick: _cache[1] || (_cache[1] = ($event) => handleActions("zoomOut"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref$1(zoom_out_default))
                    ]),
                    _: 1
                  }),
                  createVNode(unref$1(ElIcon), {
                    onClick: _cache[2] || (_cache[2] = ($event) => handleActions("zoomIn"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref$1(zoom_in_default))
                    ]),
                    _: 1
                  }),
                  createElementVNode("i", {
                    class: normalizeClass(unref$1(ns2).e("actions__divider"))
                  }, null, 2),
                  createVNode(unref$1(ElIcon), { onClick: toggleMode }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(unref$1(mode).icon)))
                    ]),
                    _: 1
                  }),
                  createElementVNode("i", {
                    class: normalizeClass(unref$1(ns2).e("actions__divider"))
                  }, null, 2),
                  createVNode(unref$1(ElIcon), {
                    onClick: _cache[3] || (_cache[3] = ($event) => handleActions("anticlockwise"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref$1(refresh_left_default))
                    ]),
                    _: 1
                  }),
                  createVNode(unref$1(ElIcon), {
                    onClick: _cache[4] || (_cache[4] = ($event) => handleActions("clockwise"))
                  }, {
                    default: withCtx(() => [
                      createVNode(unref$1(refresh_right_default))
                    ]),
                    _: 1
                  })
                ], 2)
              ], 2),
              createCommentVNode(" CANVAS "),
              createElementVNode("div", {
                class: normalizeClass(unref$1(ns2).e("canvas"))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.urlList, (url, i2) => {
                  return withDirectives((openBlock(), createElementBlock("img", {
                    ref_for: true,
                    ref: (el2) => imgRefs.value[i2] = el2,
                    key: url,
                    src: url,
                    style: normalizeStyle$1(unref$1(imgStyle)),
                    class: normalizeClass(unref$1(ns2).e("img")),
                    onLoad: handleImgLoad,
                    onError: handleImgError,
                    onMousedown: handleMouseDown
                  }, null, 46, _hoisted_1$7)), [
                    [vShow, i2 === activeIndex.value]
                  ]);
                }), 128))
              ], 2),
              renderSlot(_ctx.$slots, "default")
            ], 6)
          ]),
          _: 3
        })
      ], 8, ["disabled"]);
    };
  }
});
var ImageViewer = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const ElImageViewer = withInstall(ImageViewer);
const NODE_KEY = "$treeNodeId";
const markNodeData = function(node, data5) {
  if (!data5 || data5[NODE_KEY])
    return;
  Object.defineProperty(data5, NODE_KEY, {
    value: node.id,
    enumerable: false,
    configurable: false,
    writable: false
  });
};
const getNodeKey = function(key, data5) {
  if (!key)
    return data5[NODE_KEY];
  return data5[key];
};
const getChildState = (node) => {
  let all = true;
  let none = true;
  let allWithoutDisable = true;
  for (let i2 = 0, j2 = node.length; i2 < j2; i2++) {
    const n2 = node[i2];
    if (n2.checked !== true || n2.indeterminate) {
      all = false;
      if (!n2.disabled) {
        allWithoutDisable = false;
      }
    }
    if (n2.checked !== false || n2.indeterminate) {
      none = false;
    }
  }
  return { all, none, allWithoutDisable, half: !all && !none };
};
const reInitChecked = function(node) {
  if (node.childNodes.length === 0 || node.loading)
    return;
  const { all, none, half } = getChildState(node.childNodes);
  if (all) {
    node.checked = true;
    node.indeterminate = false;
  } else if (half) {
    node.checked = false;
    node.indeterminate = true;
  } else if (none) {
    node.checked = false;
    node.indeterminate = false;
  }
  const parent2 = node.parent;
  if (!parent2 || parent2.level === 0)
    return;
  if (!node.store.checkStrictly) {
    reInitChecked(parent2);
  }
};
const getPropertyFromData = function(node, prop) {
  const props = node.store.props;
  const data5 = node.data || {};
  const config2 = props[prop];
  if (typeof config2 === "function") {
    return config2(data5, node);
  } else if (typeof config2 === "string") {
    return data5[config2];
  } else if (typeof config2 === "undefined") {
    const dataProp = data5[prop];
    return dataProp === void 0 ? "" : dataProp;
  }
};
let nodeIdSeed = 0;
class Node$2 {
  constructor(options) {
    this.id = nodeIdSeed++;
    this.text = null;
    this.checked = false;
    this.indeterminate = false;
    this.data = null;
    this.expanded = false;
    this.parent = null;
    this.visible = true;
    this.isCurrent = false;
    this.canFocus = false;
    for (const name2 in options) {
      if (hasOwn(options, name2)) {
        this[name2] = options[name2];
      }
    }
    this.level = 0;
    this.loaded = false;
    this.childNodes = [];
    this.loading = false;
    if (this.parent) {
      this.level = this.parent.level + 1;
    }
  }
  initialize() {
    const store = this.store;
    if (!store) {
      throw new Error("[Node]store is required!");
    }
    store.registerNode(this);
    const props = store.props;
    if (props && typeof props.isLeaf !== "undefined") {
      const isLeaf = getPropertyFromData(this, "isLeaf");
      if (typeof isLeaf === "boolean") {
        this.isLeafByUser = isLeaf;
      }
    }
    if (store.lazy !== true && this.data) {
      this.setData(this.data);
      if (store.defaultExpandAll) {
        this.expanded = true;
        this.canFocus = true;
      }
    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
      this.expand();
    }
    if (!Array.isArray(this.data)) {
      markNodeData(this, this.data);
    }
    if (!this.data)
      return;
    const defaultExpandedKeys = store.defaultExpandedKeys;
    const key = store.key;
    if (key && defaultExpandedKeys && defaultExpandedKeys.includes(this.key)) {
      this.expand(null, store.autoExpandParent);
    }
    if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {
      store.currentNode = this;
      store.currentNode.isCurrent = true;
    }
    if (store.lazy) {
      store._initDefaultCheckedNode(this);
    }
    this.updateLeafState();
    if (this.parent && (this.level === 1 || this.parent.expanded === true))
      this.canFocus = true;
  }
  setData(data5) {
    if (!Array.isArray(data5)) {
      markNodeData(this, data5);
    }
    this.data = data5;
    this.childNodes = [];
    let children2;
    if (this.level === 0 && Array.isArray(this.data)) {
      children2 = this.data;
    } else {
      children2 = getPropertyFromData(this, "children") || [];
    }
    for (let i2 = 0, j2 = children2.length; i2 < j2; i2++) {
      this.insertChild({ data: children2[i2] });
    }
  }
  get label() {
    return getPropertyFromData(this, "label");
  }
  get key() {
    const nodeKey = this.store.key;
    if (this.data)
      return this.data[nodeKey];
    return null;
  }
  get disabled() {
    return getPropertyFromData(this, "disabled");
  }
  get nextSibling() {
    const parent2 = this.parent;
    if (parent2) {
      const index = parent2.childNodes.indexOf(this);
      if (index > -1) {
        return parent2.childNodes[index + 1];
      }
    }
    return null;
  }
  get previousSibling() {
    const parent2 = this.parent;
    if (parent2) {
      const index = parent2.childNodes.indexOf(this);
      if (index > -1) {
        return index > 0 ? parent2.childNodes[index - 1] : null;
      }
    }
    return null;
  }
  contains(target, deep = true) {
    return (this.childNodes || []).some((child) => child === target || deep && child.contains(target));
  }
  remove() {
    const parent2 = this.parent;
    if (parent2) {
      parent2.removeChild(this);
    }
  }
  insertChild(child, index, batch) {
    if (!child)
      throw new Error("InsertChild error: child is required.");
    if (!(child instanceof Node$2)) {
      if (!batch) {
        const children2 = this.getChildren(true);
        if (!children2.includes(child.data)) {
          if (typeof index === "undefined" || index < 0) {
            children2.push(child.data);
          } else {
            children2.splice(index, 0, child.data);
          }
        }
      }
      Object.assign(child, {
        parent: this,
        store: this.store
      });
      child = reactive$1(new Node$2(child));
      if (child instanceof Node$2) {
        child.initialize();
      }
    }
    child.level = this.level + 1;
    if (typeof index === "undefined" || index < 0) {
      this.childNodes.push(child);
    } else {
      this.childNodes.splice(index, 0, child);
    }
    this.updateLeafState();
  }
  insertBefore(child, ref2) {
    let index;
    if (ref2) {
      index = this.childNodes.indexOf(ref2);
    }
    this.insertChild(child, index);
  }
  insertAfter(child, ref2) {
    let index;
    if (ref2) {
      index = this.childNodes.indexOf(ref2);
      if (index !== -1)
        index += 1;
    }
    this.insertChild(child, index);
  }
  removeChild(child) {
    const children2 = this.getChildren() || [];
    const dataIndex = children2.indexOf(child.data);
    if (dataIndex > -1) {
      children2.splice(dataIndex, 1);
    }
    const index = this.childNodes.indexOf(child);
    if (index > -1) {
      this.store && this.store.deregisterNode(child);
      child.parent = null;
      this.childNodes.splice(index, 1);
    }
    this.updateLeafState();
  }
  removeChildByData(data5) {
    let targetNode = null;
    for (let i2 = 0; i2 < this.childNodes.length; i2++) {
      if (this.childNodes[i2].data === data5) {
        targetNode = this.childNodes[i2];
        break;
      }
    }
    if (targetNode) {
      this.removeChild(targetNode);
    }
  }
  expand(callback, expandParent) {
    const done = () => {
      if (expandParent) {
        let parent2 = this.parent;
        while (parent2.level > 0) {
          parent2.expanded = true;
          parent2 = parent2.parent;
        }
      }
      this.expanded = true;
      if (callback)
        callback();
      this.childNodes.forEach((item) => {
        item.canFocus = true;
      });
    };
    if (this.shouldLoadData()) {
      this.loadData((data5) => {
        if (Array.isArray(data5)) {
          if (this.checked) {
            this.setChecked(true, true);
          } else if (!this.store.checkStrictly) {
            reInitChecked(this);
          }
          done();
        }
      });
    } else {
      done();
    }
  }
  doCreateChildren(array2, defaultProps = {}) {
    array2.forEach((item) => {
      this.insertChild(Object.assign({ data: item }, defaultProps), void 0, true);
    });
  }
  collapse() {
    this.expanded = false;
    this.childNodes.forEach((item) => {
      item.canFocus = false;
    });
  }
  shouldLoadData() {
    return this.store.lazy === true && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== "undefined") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const childNodes = this.childNodes;
    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {
      this.isLeaf = !childNodes || childNodes.length === 0;
      return;
    }
    this.isLeaf = false;
  }
  setChecked(value, deep, recursion, passValue) {
    this.indeterminate = value === "half";
    this.checked = value === true;
    if (this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all, allWithoutDisable } = getChildState(this.childNodes);
      if (!this.isLeaf && !all && allWithoutDisable) {
        this.checked = false;
        value = false;
      }
      const handleDescendants = () => {
        if (deep) {
          const childNodes = this.childNodes;
          for (let i2 = 0, j2 = childNodes.length; i2 < j2; i2++) {
            const child = childNodes[i2];
            passValue = passValue || value !== false;
            const isCheck = child.disabled ? child.checked : passValue;
            child.setChecked(isCheck, deep, true, passValue);
          }
          const { half, all: all2 } = getChildState(childNodes);
          if (!all2) {
            this.checked = all2;
            this.indeterminate = half;
          }
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          handleDescendants();
          reInitChecked(this);
        }, {
          checked: value !== false
        });
        return;
      } else {
        handleDescendants();
      }
    }
    const parent2 = this.parent;
    if (!parent2 || parent2.level === 0)
      return;
    if (!recursion) {
      reInitChecked(parent2);
    }
  }
  getChildren(forceInit = false) {
    if (this.level === 0)
      return this.data;
    const data5 = this.data;
    if (!data5)
      return null;
    const props = this.store.props;
    let children2 = "children";
    if (props) {
      children2 = props.children || "children";
    }
    if (data5[children2] === void 0) {
      data5[children2] = null;
    }
    if (forceInit && !data5[children2]) {
      data5[children2] = [];
    }
    return data5[children2];
  }
  updateChildren() {
    const newData = this.getChildren() || [];
    const oldData = this.childNodes.map((node) => node.data);
    const newDataMap = {};
    const newNodes = [];
    newData.forEach((item, index) => {
      const key = item[NODE_KEY];
      const isNodeExists = !!key && oldData.findIndex((data5) => data5[NODE_KEY] === key) >= 0;
      if (isNodeExists) {
        newDataMap[key] = { index, data: item };
      } else {
        newNodes.push({ index, data: item });
      }
    });
    if (!this.store.lazy) {
      oldData.forEach((item) => {
        if (!newDataMap[item[NODE_KEY]])
          this.removeChildByData(item);
      });
    }
    newNodes.forEach(({ index, data: data5 }) => {
      this.insertChild({ data: data5 }, index);
    });
    this.updateLeafState();
  }
  loadData(callback, defaultProps = {}) {
    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {
      this.loading = true;
      const resolve = (children2) => {
        this.childNodes = [];
        this.doCreateChildren(children2, defaultProps);
        this.loaded = true;
        this.loading = false;
        this.updateLeafState();
        if (callback) {
          callback.call(this, children2);
        }
      };
      this.store.load(this, resolve);
    } else {
      if (callback) {
        callback.call(this);
      }
    }
  }
}
class TreeStore {
  constructor(options) {
    this.currentNode = null;
    this.currentNodeKey = null;
    for (const option in options) {
      if (hasOwn(options, option)) {
        this[option] = options[option];
      }
    }
    this.nodesMap = {};
  }
  initialize() {
    this.root = new Node$2({
      data: this.data,
      store: this
    });
    this.root.initialize();
    if (this.lazy && this.load) {
      const loadFn = this.load;
      loadFn(this.root, (data5) => {
        this.root.doCreateChildren(data5);
        this._initDefaultCheckedNodes();
      });
    } else {
      this._initDefaultCheckedNodes();
    }
  }
  filter(value) {
    const filterNodeMethod = this.filterNodeMethod;
    const lazy = this.lazy;
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        child.visible = filterNodeMethod.call(child, value, child.data, child);
        traverse(child);
      });
      if (!node.visible && childNodes.length) {
        let allHidden = true;
        allHidden = !childNodes.some((child) => child.visible);
        if (node.root) {
          node.root.visible = allHidden === false;
        } else {
          node.visible = allHidden === false;
        }
      }
      if (!value)
        return;
      if (node.visible && !node.isLeaf && !lazy)
        node.expand();
    };
    traverse(this);
  }
  setData(newVal) {
    const instanceChanged = newVal !== this.root.data;
    if (instanceChanged) {
      this.root.setData(newVal);
      this._initDefaultCheckedNodes();
    } else {
      this.root.updateChildren();
    }
  }
  getNode(data5) {
    if (data5 instanceof Node$2)
      return data5;
    const key = isObject$6(data5) ? getNodeKey(this.key, data5) : data5;
    return this.nodesMap[key] || null;
  }
  insertBefore(data5, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertBefore({ data: data5 }, refNode);
  }
  insertAfter(data5, refData) {
    const refNode = this.getNode(refData);
    refNode.parent.insertAfter({ data: data5 }, refNode);
  }
  remove(data5) {
    const node = this.getNode(data5);
    if (node && node.parent) {
      if (node === this.currentNode) {
        this.currentNode = null;
      }
      node.parent.removeChild(node);
    }
  }
  append(data5, parentData) {
    const parentNode2 = parentData ? this.getNode(parentData) : this.root;
    if (parentNode2) {
      parentNode2.insertChild({ data: data5 });
    }
  }
  _initDefaultCheckedNodes() {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    const nodesMap = this.nodesMap;
    defaultCheckedKeys.forEach((checkedKey) => {
      const node = nodesMap[checkedKey];
      if (node) {
        node.setChecked(true, !this.checkStrictly);
      }
    });
  }
  _initDefaultCheckedNode(node) {
    const defaultCheckedKeys = this.defaultCheckedKeys || [];
    if (defaultCheckedKeys.includes(node.key)) {
      node.setChecked(true, !this.checkStrictly);
    }
  }
  setDefaultCheckedKey(newVal) {
    if (newVal !== this.defaultCheckedKeys) {
      this.defaultCheckedKeys = newVal;
      this._initDefaultCheckedNodes();
    }
  }
  registerNode(node) {
    const key = this.key;
    if (!node || !node.data)
      return;
    if (!key) {
      this.nodesMap[node.id] = node;
    } else {
      const nodeKey = node.key;
      if (nodeKey !== void 0)
        this.nodesMap[node.key] = node;
    }
  }
  deregisterNode(node) {
    const key = this.key;
    if (!key || !node || !node.data)
      return;
    node.childNodes.forEach((child) => {
      this.deregisterNode(child);
    });
    delete this.nodesMap[node.key];
  }
  getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
    const checkedNodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {
          checkedNodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return checkedNodes;
  }
  getCheckedKeys(leafOnly = false) {
    return this.getCheckedNodes(leafOnly).map((data5) => (data5 || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const nodes = [];
    const traverse = function(node) {
      const childNodes = node.root ? node.root.childNodes : node.childNodes;
      childNodes.forEach((child) => {
        if (child.indeterminate) {
          nodes.push(child.data);
        }
        traverse(child);
      });
    };
    traverse(this);
    return nodes;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((data5) => (data5 || {})[this.key]);
  }
  _getAllNodes() {
    const allNodes = [];
    const nodesMap = this.nodesMap;
    for (const nodeKey in nodesMap) {
      if (hasOwn(nodesMap, nodeKey)) {
        allNodes.push(nodesMap[nodeKey]);
      }
    }
    return allNodes;
  }
  updateChildren(key, data5) {
    const node = this.nodesMap[key];
    if (!node)
      return;
    const childNodes = node.childNodes;
    for (let i2 = childNodes.length - 1; i2 >= 0; i2--) {
      const child = childNodes[i2];
      this.remove(child.data);
    }
    for (let i2 = 0, j2 = data5.length; i2 < j2; i2++) {
      const child = data5[i2];
      this.append(child, node.data);
    }
  }
  _setCheckedKeys(key, leafOnly = false, checkedKeys) {
    const allNodes = this._getAllNodes().sort((a2, b2) => b2.level - a2.level);
    const cache2 = /* @__PURE__ */ Object.create(null);
    const keys2 = Object.keys(checkedKeys);
    allNodes.forEach((node) => node.setChecked(false, false));
    for (let i2 = 0, j2 = allNodes.length; i2 < j2; i2++) {
      const node = allNodes[i2];
      const nodeKey = node.data[key].toString();
      const checked = keys2.includes(nodeKey);
      if (!checked) {
        if (node.checked && !cache2[nodeKey]) {
          node.setChecked(false, false);
        }
        continue;
      }
      let parent2 = node.parent;
      while (parent2 && parent2.level > 0) {
        cache2[parent2.data[key]] = true;
        parent2 = parent2.parent;
      }
      if (node.isLeaf || this.checkStrictly) {
        node.setChecked(true, false);
        continue;
      }
      node.setChecked(true, true);
      if (leafOnly) {
        node.setChecked(false, false);
        const traverse = function(node2) {
          const childNodes = node2.childNodes;
          childNodes.forEach((child) => {
            if (!child.isLeaf) {
              child.setChecked(false, false);
            }
            traverse(child);
          });
        };
        traverse(node);
      }
    }
  }
  setCheckedNodes(array2, leafOnly = false) {
    const key = this.key;
    const checkedKeys = {};
    array2.forEach((item) => {
      checkedKeys[(item || {})[key]] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setCheckedKeys(keys2, leafOnly = false) {
    this.defaultCheckedKeys = keys2;
    const key = this.key;
    const checkedKeys = {};
    keys2.forEach((key2) => {
      checkedKeys[key2] = true;
    });
    this._setCheckedKeys(key, leafOnly, checkedKeys);
  }
  setDefaultExpandedKeys(keys2) {
    keys2 = keys2 || [];
    this.defaultExpandedKeys = keys2;
    keys2.forEach((key) => {
      const node = this.getNode(key);
      if (node)
        node.expand(null, this.autoExpandParent);
    });
  }
  setChecked(data5, checked, deep) {
    const node = this.getNode(data5);
    if (node) {
      node.setChecked(!!checked, deep);
    }
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(currentNode) {
    const prevCurrentNode = this.currentNode;
    if (prevCurrentNode) {
      prevCurrentNode.isCurrent = false;
    }
    this.currentNode = currentNode;
    this.currentNode.isCurrent = true;
  }
  setUserCurrentNode(node, shouldAutoExpandParent = true) {
    const key = node[this.key];
    const currNode = this.nodesMap[key];
    this.setCurrentNode(currNode);
    if (shouldAutoExpandParent && this.currentNode.level > 1) {
      this.currentNode.parent.expand(null, true);
    }
  }
  setCurrentNodeKey(key, shouldAutoExpandParent = true) {
    if (key === null || key === void 0) {
      this.currentNode && (this.currentNode.isCurrent = false);
      this.currentNode = null;
      return;
    }
    const node = this.getNode(key);
    if (node) {
      this.setCurrentNode(node);
      if (shouldAutoExpandParent && this.currentNode.level > 1) {
        this.currentNode.parent.expand(null, true);
      }
    }
  }
}
const _sfc_main$d = defineComponent({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: true
    },
    renderContent: Function
  },
  setup(props) {
    const ns2 = useNamespace("tree");
    const nodeInstance = inject("NodeInstance");
    const tree = inject("RootTree");
    return () => {
      const node = props.node;
      const { data: data5, store } = node;
      return props.renderContent ? props.renderContent(h$6, { _self: nodeInstance, node, data: data5, store }) : tree.ctx.slots.default ? tree.ctx.slots.default({ node, data: data5 }) : h$6("span", { class: ns2.be("node", "label") }, [node.label]);
    };
  }
});
var NodeContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function useNodeExpandEventBroadcast(props) {
  const parentNodeMap = inject("TreeNodeMap", null);
  const currentNodeMap = {
    treeNodeExpand: (node) => {
      if (props.node !== node) {
        props.node.collapse();
      }
    },
    children: []
  };
  if (parentNodeMap) {
    parentNodeMap.children.push(currentNodeMap);
  }
  provide("TreeNodeMap", currentNodeMap);
  return {
    broadcastExpanded: (node) => {
      if (!props.accordion)
        return;
      for (const childNode of currentNodeMap.children) {
        childNode.treeNodeExpand(node);
      }
    }
  };
}
const dragEventsKey = Symbol("dragEvents");
function useDragNodeHandler({ props, ctx, el$, dropIndicator$, store }) {
  const ns2 = useNamespace("tree");
  const dragState = ref$1({
    showDropIndicator: false,
    draggingNode: null,
    dropNode: null,
    allowDrop: true,
    dropType: null
  });
  const treeNodeDragStart = ({ event, treeNode }) => {
    if (typeof props.allowDrag === "function" && !props.allowDrag(treeNode.node)) {
      event.preventDefault();
      return false;
    }
    event.dataTransfer.effectAllowed = "move";
    try {
      event.dataTransfer.setData("text/plain", "");
    } catch (e3) {
    }
    dragState.value.draggingNode = treeNode;
    ctx.emit("node-drag-start", treeNode.node, event);
  };
  const treeNodeDragOver = ({ event, treeNode }) => {
    const dropNode = treeNode;
    const oldDropNode = dragState.value.dropNode;
    if (oldDropNode && oldDropNode !== dropNode) {
      removeClass$1(oldDropNode.$el, ns2.is("drop-inner"));
    }
    const draggingNode = dragState.value.draggingNode;
    if (!draggingNode || !dropNode)
      return;
    let dropPrev = true;
    let dropInner = true;
    let dropNext = true;
    let userAllowDropInner = true;
    if (typeof props.allowDrop === "function") {
      dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
      userAllowDropInner = dropInner = props.allowDrop(draggingNode.node, dropNode.node, "inner");
      dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
    }
    event.dataTransfer.dropEffect = dropInner || dropPrev || dropNext ? "move" : "none";
    if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
      if (oldDropNode) {
        ctx.emit("node-drag-leave", draggingNode.node, oldDropNode.node, event);
      }
      ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
    }
    if (dropPrev || dropInner || dropNext) {
      dragState.value.dropNode = dropNode;
    }
    if (dropNode.node.nextSibling === draggingNode.node) {
      dropNext = false;
    }
    if (dropNode.node.previousSibling === draggingNode.node) {
      dropPrev = false;
    }
    if (dropNode.node.contains(draggingNode.node, false)) {
      dropInner = false;
    }
    if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {
      dropPrev = false;
      dropInner = false;
      dropNext = false;
    }
    const targetPosition = dropNode.$el.getBoundingClientRect();
    const treePosition = el$.value.getBoundingClientRect();
    let dropType;
    const prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;
    const nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;
    let indicatorTop = -9999;
    const distance2 = event.clientY - targetPosition.top;
    if (distance2 < targetPosition.height * prevPercent) {
      dropType = "before";
    } else if (distance2 > targetPosition.height * nextPercent) {
      dropType = "after";
    } else if (dropInner) {
      dropType = "inner";
    } else {
      dropType = "none";
    }
    const iconPosition = dropNode.$el.querySelector(`.${ns2.be("node", "expand-icon")}`).getBoundingClientRect();
    const dropIndicator = dropIndicator$.value;
    if (dropType === "before") {
      indicatorTop = iconPosition.top - treePosition.top;
    } else if (dropType === "after") {
      indicatorTop = iconPosition.bottom - treePosition.top;
    }
    dropIndicator.style.top = `${indicatorTop}px`;
    dropIndicator.style.left = `${iconPosition.right - treePosition.left}px`;
    if (dropType === "inner") {
      addClass$1(dropNode.$el, ns2.is("drop-inner"));
    } else {
      removeClass$1(dropNode.$el, ns2.is("drop-inner"));
    }
    dragState.value.showDropIndicator = dropType === "before" || dropType === "after";
    dragState.value.allowDrop = dragState.value.showDropIndicator || userAllowDropInner;
    dragState.value.dropType = dropType;
    ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
  };
  const treeNodeDragEnd = (event) => {
    const { draggingNode, dropType, dropNode } = dragState.value;
    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    if (draggingNode && dropNode) {
      const draggingNodeCopy = { data: draggingNode.node.data };
      if (dropType !== "none") {
        draggingNode.node.remove();
      }
      if (dropType === "before") {
        dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
      } else if (dropType === "after") {
        dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
      } else if (dropType === "inner") {
        dropNode.node.insertChild(draggingNodeCopy);
      }
      if (dropType !== "none") {
        store.value.registerNode(draggingNodeCopy);
      }
      removeClass$1(dropNode.$el, ns2.is("drop-inner"));
      ctx.emit("node-drag-end", draggingNode.node, dropNode.node, dropType, event);
      if (dropType !== "none") {
        ctx.emit("node-drop", draggingNode.node, dropNode.node, dropType, event);
      }
    }
    if (draggingNode && !dropNode) {
      ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
    }
    dragState.value.showDropIndicator = false;
    dragState.value.draggingNode = null;
    dragState.value.dropNode = null;
    dragState.value.allowDrop = true;
  };
  provide(dragEventsKey, {
    treeNodeDragStart,
    treeNodeDragOver,
    treeNodeDragEnd
  });
  return {
    dragState
  };
}
const _sfc_main$c = defineComponent({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: _CollapseTransition,
    ElCheckbox,
    NodeContent,
    ElIcon,
    Loading: loading_default
  },
  props: {
    node: {
      type: Node$2,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: false
    }
  },
  emits: ["node-expand"],
  setup(props, ctx) {
    const ns2 = useNamespace("tree");
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const tree = inject("RootTree");
    const expanded = ref$1(false);
    const childNodeRendered = ref$1(false);
    const oldChecked = ref$1(null);
    const oldIndeterminate = ref$1(null);
    const node$ = ref$1(null);
    const dragEvents = inject(dragEventsKey);
    const instance2 = getCurrentInstance$1();
    provide("NodeInstance", instance2);
    if (props.node.expanded) {
      expanded.value = true;
      childNodeRendered.value = true;
    }
    const childrenKey = tree.props["children"] || "children";
    watch$1(() => {
      const children2 = props.node.data[childrenKey];
      return children2 && [...children2];
    }, () => {
      props.node.updateChildren();
    });
    watch$1(() => props.node.indeterminate, (val2) => {
      handleSelectChange(props.node.checked, val2);
    });
    watch$1(() => props.node.checked, (val2) => {
      handleSelectChange(val2, props.node.indeterminate);
    });
    watch$1(() => props.node.expanded, (val2) => {
      nextTick$1(() => expanded.value = val2);
      if (val2) {
        childNodeRendered.value = true;
      }
    });
    const getNodeKey$1 = (node) => {
      return getNodeKey(tree.props.nodeKey, node.data);
    };
    const getNodeClass = (node) => {
      const nodeClassFunc = props.props.class;
      if (!nodeClassFunc) {
        return {};
      }
      let className;
      if (isFunction$2(nodeClassFunc)) {
        const { data: data5 } = node;
        className = nodeClassFunc(data5, node);
      } else {
        className = nodeClassFunc;
      }
      if (isString$1(className)) {
        return { [className]: true };
      } else {
        return className;
      }
    };
    const handleSelectChange = (checked, indeterminate) => {
      if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {
        tree.ctx.emit("check-change", props.node.data, checked, indeterminate);
      }
      oldChecked.value = checked;
      oldIndeterminate.value = indeterminate;
    };
    const handleClick2 = (e3) => {
      const store = tree.store.value;
      store.setCurrentNode(props.node);
      tree.ctx.emit("current-change", store.currentNode ? store.currentNode.data : null, store.currentNode);
      tree.currentNode.value = props.node;
      if (tree.props.expandOnClickNode) {
        handleExpandIconClick();
      }
      if (tree.props.checkOnClickNode && !props.node.disabled) {
        handleCheckChange(null, {
          target: { checked: !props.node.checked }
        });
      }
      tree.ctx.emit("node-click", props.node.data, props.node, instance2, e3);
    };
    const handleContextMenu = (event) => {
      if (tree.instance.vnode.props["onNodeContextmenu"]) {
        event.stopPropagation();
        event.preventDefault();
      }
      tree.ctx.emit("node-contextmenu", event, props.node.data, props.node, instance2);
    };
    const handleExpandIconClick = () => {
      if (props.node.isLeaf)
        return;
      if (expanded.value) {
        tree.ctx.emit("node-collapse", props.node.data, props.node, instance2);
        props.node.collapse();
      } else {
        props.node.expand();
        ctx.emit("node-expand", props.node.data, props.node, instance2);
      }
    };
    const handleCheckChange = (value, ev) => {
      props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
      nextTick$1(() => {
        const store = tree.store.value;
        tree.ctx.emit("check", props.node.data, {
          checkedNodes: store.getCheckedNodes(),
          checkedKeys: store.getCheckedKeys(),
          halfCheckedNodes: store.getHalfCheckedNodes(),
          halfCheckedKeys: store.getHalfCheckedKeys()
        });
      });
    };
    const handleChildNodeExpand = (nodeData, node, instance22) => {
      broadcastExpanded(node);
      tree.ctx.emit("node-expand", nodeData, node, instance22);
    };
    const handleDragStart = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragStart({ event, treeNode: props });
    };
    const handleDragOver = (event) => {
      event.preventDefault();
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragOver({
        event,
        treeNode: { $el: node$.value, node: props.node }
      });
    };
    const handleDrop = (event) => {
      event.preventDefault();
    };
    const handleDragEnd = (event) => {
      if (!tree.props.draggable)
        return;
      dragEvents.treeNodeDragEnd(event);
    };
    return {
      ns: ns2,
      node$,
      tree,
      expanded,
      childNodeRendered,
      oldChecked,
      oldIndeterminate,
      getNodeKey: getNodeKey$1,
      getNodeClass,
      handleSelectChange,
      handleClick: handleClick2,
      handleContextMenu,
      handleExpandIconClick,
      handleCheckChange,
      handleChildNodeExpand,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd,
      CaretRight: caret_right_default
    };
  }
});
const _hoisted_1$6 = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"];
const _hoisted_2$3 = ["aria-expanded"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_loading = resolveComponent("loading");
  const _component_node_content = resolveComponent("node-content");
  const _component_el_tree_node = resolveComponent("el-tree-node");
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
  return withDirectives((openBlock(), createElementBlock("div", {
    ref: "node$",
    class: normalizeClass([
      _ctx.ns.b("node"),
      _ctx.ns.is("expanded", _ctx.expanded),
      _ctx.ns.is("current", _ctx.node.isCurrent),
      _ctx.ns.is("hidden", !_ctx.node.visible),
      _ctx.ns.is("focusable", !_ctx.node.disabled),
      _ctx.ns.is("checked", !_ctx.node.disabled && _ctx.node.checked),
      _ctx.getNodeClass(_ctx.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": _ctx.expanded,
    "aria-disabled": _ctx.node.disabled,
    "aria-checked": _ctx.node.checked,
    draggable: _ctx.tree.props.draggable,
    "data-key": _ctx.getNodeKey(_ctx.node),
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.handleContextMenu && _ctx.handleContextMenu(...args)),
    onDragstart: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args), ["stop"])),
    onDragend: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args), ["stop"])),
    onDrop: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleDrop && _ctx.handleDrop(...args), ["stop"]))
  }, [
    createElementVNode("div", {
      class: normalizeClass(_ctx.ns.be("node", "content")),
      style: normalizeStyle$1({ paddingLeft: (_ctx.node.level - 1) * _ctx.tree.props.indent + "px" })
    }, [
      _ctx.tree.props.icon || _ctx.CaretRight ? (openBlock(), createBlock(_component_el_icon, {
        key: 0,
        class: normalizeClass([
          _ctx.ns.be("node", "expand-icon"),
          _ctx.ns.is("leaf", _ctx.node.isLeaf),
          {
            expanded: !_ctx.node.isLeaf && _ctx.expanded
          }
        ]),
        onClick: withModifiers(_ctx.handleExpandIconClick, ["stop"])
      }, {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.tree.props.icon || _ctx.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true),
      _ctx.showCheckbox ? (openBlock(), createBlock(_component_el_checkbox, {
        key: 1,
        "model-value": _ctx.node.checked,
        indeterminate: _ctx.node.indeterminate,
        disabled: !!_ctx.node.disabled,
        onClick: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"])),
        onChange: _ctx.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : createCommentVNode("v-if", true),
      _ctx.node.loading ? (openBlock(), createBlock(_component_el_icon, {
        key: 2,
        class: normalizeClass([_ctx.ns.be("node", "loading-icon"), _ctx.ns.is("loading")])
      }, {
        default: withCtx(() => [
          createVNode(_component_loading)
        ]),
        _: 1
      }, 8, ["class"])) : createCommentVNode("v-if", true),
      createVNode(_component_node_content, {
        node: _ctx.node,
        "render-content": _ctx.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        !_ctx.renderAfterExpand || _ctx.childNodeRendered ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.ns.be("node", "children")),
          role: "group",
          "aria-expanded": _ctx.expanded
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.childNodes, (child) => {
            return openBlock(), createBlock(_component_el_tree_node, {
              key: _ctx.getNodeKey(child),
              "render-content": _ctx.renderContent,
              "render-after-expand": _ctx.renderAfterExpand,
              "show-checkbox": _ctx.showCheckbox,
              node: child,
              accordion: _ctx.accordion,
              props: _ctx.props,
              onNodeExpand: _ctx.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]);
          }), 128))
        ], 10, _hoisted_2$3)), [
          [vShow, _ctx.expanded]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 1
    })
  ], 42, _hoisted_1$6)), [
    [vShow, _ctx.node.visible]
  ]);
}
var ElTreeNode = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function useKeydown({ el$ }, store) {
  const ns2 = useNamespace("tree");
  const treeItems = shallowRef$1([]);
  const checkboxItems = shallowRef$1([]);
  onMounted$1(() => {
    initTabIndex();
  });
  onUpdated(() => {
    treeItems.value = Array.from(el$.value.querySelectorAll("[role=treeitem]"));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
  });
  watch$1(checkboxItems, (val2) => {
    val2.forEach((checkbox) => {
      checkbox.setAttribute("tabindex", "-1");
    });
  });
  const handleKeydown = (ev) => {
    const currentItem = ev.target;
    if (!currentItem.className.includes(ns2.b("node")))
      return;
    const code = ev.code;
    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
    const currentIndex = treeItems.value.indexOf(currentItem);
    let nextIndex;
    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {
      ev.preventDefault();
      if (code === EVENT_CODE.up) {
        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.value.length - 1;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex--;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex < 0) {
            nextIndex = treeItems.value.length - 1;
          }
        }
      } else {
        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.value.length - 1 ? currentIndex + 1 : 0;
        const startIndex = nextIndex;
        while (true) {
          if (store.value.getNode(treeItems.value[nextIndex].dataset.key).canFocus)
            break;
          nextIndex++;
          if (nextIndex === startIndex) {
            nextIndex = -1;
            break;
          }
          if (nextIndex >= treeItems.value.length) {
            nextIndex = 0;
          }
        }
      }
      nextIndex !== -1 && treeItems.value[nextIndex].focus();
    }
    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {
      ev.preventDefault();
      currentItem.click();
    }
    const hasInput = currentItem.querySelector('[type="checkbox"]');
    if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && hasInput) {
      ev.preventDefault();
      hasInput.click();
    }
  };
  useEventListener(el$, "keydown", handleKeydown);
  const initTabIndex = () => {
    var _a2;
    treeItems.value = Array.from(el$.value.querySelectorAll(`.${ns2.is("focusable")}[role=treeitem]`));
    checkboxItems.value = Array.from(el$.value.querySelectorAll("input[type=checkbox]"));
    const checkedItem = el$.value.querySelectorAll(`.${ns2.is("checked")}[role=treeitem]`);
    if (checkedItem.length) {
      checkedItem[0].setAttribute("tabindex", "0");
      return;
    }
    (_a2 = treeItems.value[0]) == null ? void 0 : _a2.setAttribute("tabindex", "0");
  };
}
const _sfc_main$b = defineComponent({
  name: "ElTree",
  components: { ElTreeNode },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: false
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: false
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: iconPropType
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(props, ctx) {
    const { t: t2 } = useLocale();
    const ns2 = useNamespace("tree");
    const store = ref$1(new TreeStore({
      key: props.nodeKey,
      data: props.data,
      lazy: props.lazy,
      props: props.props,
      load: props.load,
      currentNodeKey: props.currentNodeKey,
      checkStrictly: props.checkStrictly,
      checkDescendants: props.checkDescendants,
      defaultCheckedKeys: props.defaultCheckedKeys,
      defaultExpandedKeys: props.defaultExpandedKeys,
      autoExpandParent: props.autoExpandParent,
      defaultExpandAll: props.defaultExpandAll,
      filterNodeMethod: props.filterNodeMethod
    }));
    store.value.initialize();
    const root2 = ref$1(store.value.root);
    const currentNode = ref$1(null);
    const el$ = ref$1(null);
    const dropIndicator$ = ref$1(null);
    const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
    const { dragState } = useDragNodeHandler({
      props,
      ctx,
      el$,
      dropIndicator$,
      store
    });
    useKeydown({ el$ }, store);
    const isEmpty2 = computed$1(() => {
      const { childNodes } = root2.value;
      return !childNodes || childNodes.length === 0 || childNodes.every(({ visible }) => !visible);
    });
    watch$1(() => props.currentNodeKey, (newVal) => {
      store.value.setCurrentNodeKey(newVal);
    });
    watch$1(() => props.defaultCheckedKeys, (newVal) => {
      store.value.setDefaultCheckedKey(newVal);
    });
    watch$1(() => props.defaultExpandedKeys, (newVal) => {
      store.value.setDefaultExpandedKeys(newVal);
    });
    watch$1(() => props.data, (newVal) => {
      store.value.setData(newVal);
    }, { deep: true });
    watch$1(() => props.checkStrictly, (newVal) => {
      store.value.checkStrictly = newVal;
    });
    const filter2 = (value) => {
      if (!props.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      store.value.filter(value);
    };
    const getNodeKey$1 = (node) => {
      return getNodeKey(props.nodeKey, node.data);
    };
    const getNodePath = (data5) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const node = store.value.getNode(data5);
      if (!node)
        return [];
      const path = [node.data];
      let parent2 = node.parent;
      while (parent2 && parent2 !== root2.value) {
        path.push(parent2.data);
        parent2 = parent2.parent;
      }
      return path.reverse();
    };
    const getCheckedNodes = (leafOnly, includeHalfChecked) => {
      return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
    };
    const getCheckedKeys = (leafOnly) => {
      return store.value.getCheckedKeys(leafOnly);
    };
    const getCurrentNode = () => {
      const currentNode2 = store.value.getCurrentNode();
      return currentNode2 ? currentNode2.data : null;
    };
    const getCurrentKey = () => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const currentNode2 = getCurrentNode();
      return currentNode2 ? currentNode2[props.nodeKey] : null;
    };
    const setCheckedNodes = (nodes, leafOnly) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      store.value.setCheckedNodes(nodes, leafOnly);
    };
    const setCheckedKeys = (keys2, leafOnly) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      store.value.setCheckedKeys(keys2, leafOnly);
    };
    const setChecked = (data5, checked, deep) => {
      store.value.setChecked(data5, checked, deep);
    };
    const getHalfCheckedNodes = () => {
      return store.value.getHalfCheckedNodes();
    };
    const getHalfCheckedKeys = () => {
      return store.value.getHalfCheckedKeys();
    };
    const setCurrentNode = (node, shouldAutoExpandParent = true) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      const preNode = store.value.currentNode;
      store.value.setUserCurrentNode(node, shouldAutoExpandParent);
      const currNode = store.value.currentNode;
      if (preNode !== currNode) {
        ctx.emit("current-change", currNode ? currNode.data : null, currNode);
      }
    };
    const setCurrentKey = (key, shouldAutoExpandParent = true) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      const preNode = store.value.currentNode;
      store.value.setCurrentNodeKey(key, shouldAutoExpandParent);
      const currNode = store.value.currentNode;
      if (preNode !== currNode) {
        ctx.emit("current-change", currNode ? currNode.data : null, currNode);
      }
    };
    const getNode = (data5) => {
      return store.value.getNode(data5);
    };
    const remove2 = (data5) => {
      store.value.remove(data5);
    };
    const append2 = (data5, parentNode2) => {
      store.value.append(data5, parentNode2);
    };
    const insertBefore2 = (data5, refNode) => {
      store.value.insertBefore(data5, refNode);
    };
    const insertAfter = (data5, refNode) => {
      store.value.insertAfter(data5, refNode);
    };
    const handleNodeExpand = (nodeData, node, instance2) => {
      broadcastExpanded(node);
      ctx.emit("node-expand", nodeData, node, instance2);
    };
    const updateKeyChildren = (key, data5) => {
      if (!props.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      store.value.updateChildren(key, data5);
    };
    provide("RootTree", {
      ctx,
      props,
      store,
      root: root2,
      currentNode,
      instance: getCurrentInstance$1()
    });
    provide(formItemContextKey, void 0);
    return {
      ns: ns2,
      store,
      root: root2,
      currentNode,
      dragState,
      el$,
      dropIndicator$,
      isEmpty: isEmpty2,
      filter: filter2,
      getNodeKey: getNodeKey$1,
      getNodePath,
      getCheckedNodes,
      getCheckedKeys,
      getCurrentNode,
      getCurrentKey,
      setCheckedNodes,
      setCheckedKeys,
      setChecked,
      getHalfCheckedNodes,
      getHalfCheckedKeys,
      setCurrentNode,
      setCurrentKey,
      t: t2,
      getNode,
      remove: remove2,
      append: append2,
      insertBefore: insertBefore2,
      insertAfter,
      handleNodeExpand,
      updateKeyChildren
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2;
  const _component_el_tree_node = resolveComponent("el-tree-node");
  return openBlock(), createElementBlock("div", {
    ref: "el$",
    class: normalizeClass([
      _ctx.ns.b(),
      _ctx.ns.is("dragging", !!_ctx.dragState.draggingNode),
      _ctx.ns.is("drop-not-allow", !_ctx.dragState.allowDrop),
      _ctx.ns.is("drop-inner", _ctx.dragState.dropType === "inner"),
      { [_ctx.ns.m("highlight-current")]: _ctx.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.root.childNodes, (child) => {
      return openBlock(), createBlock(_component_el_tree_node, {
        key: _ctx.getNodeKey(child),
        node: child,
        props: _ctx.props,
        accordion: _ctx.accordion,
        "render-after-expand": _ctx.renderAfterExpand,
        "show-checkbox": _ctx.showCheckbox,
        "render-content": _ctx.renderContent,
        onNodeExpand: _ctx.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]);
    }), 128)),
    _ctx.isEmpty ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.ns.e("empty-block"))
    }, [
      createElementVNode("span", {
        class: normalizeClass(_ctx.ns.e("empty-text"))
      }, toDisplayString((_a2 = _ctx.emptyText) != null ? _a2 : _ctx.t("el.tree.emptyText")), 3)
    ], 2)) : createCommentVNode("v-if", true),
    withDirectives(createElementVNode("div", {
      ref: "dropIndicator$",
      class: normalizeClass(_ctx.ns.e("drop-indicator"))
    }, null, 2), [
      [vShow, _ctx.dragState.showDropIndicator]
    ])
  ], 2);
}
var Tree = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
Tree.install = (app) => {
  app.component(Tree.name, Tree);
};
const _Tree = Tree;
const ElTree = _Tree;
const messageTypes = ["success", "info", "warning", "error"];
const messageDefaults = mutable({
  customClass: "",
  center: false,
  dangerouslyUseHTMLString: false,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: false,
  type: "info",
  offset: 16,
  zIndex: 0,
  grouping: false,
  repeatNum: 1,
  appendTo: isClient ? document.body : void 0
});
const messageProps = buildProps({
  customClass: {
    type: String,
    default: messageDefaults.customClass
  },
  center: {
    type: Boolean,
    default: messageDefaults.center
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: messageDefaults.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: messageDefaults.duration
  },
  icon: {
    type: iconPropType,
    default: messageDefaults.icon
  },
  id: {
    type: String,
    default: messageDefaults.id
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: messageDefaults.message
  },
  onClose: {
    type: definePropType(Function),
    required: false
  },
  showClose: {
    type: Boolean,
    default: messageDefaults.showClose
  },
  type: {
    type: String,
    values: messageTypes,
    default: messageDefaults.type
  },
  offset: {
    type: Number,
    default: messageDefaults.offset
  },
  zIndex: {
    type: Number,
    default: messageDefaults.zIndex
  },
  grouping: {
    type: Boolean,
    default: messageDefaults.grouping
  },
  repeatNum: {
    type: Number,
    default: messageDefaults.repeatNum
  }
});
const messageEmits = {
  destroy: () => true
};
const instances = shallowReactive([]);
const getInstance = (id2) => {
  const idx = instances.findIndex((instance2) => instance2.id === id2);
  const current = instances[idx];
  let prev;
  if (idx > 0) {
    prev = instances[idx - 1];
  }
  return { current, prev };
};
const getLastOffset = (id2) => {
  const { prev } = getInstance(id2);
  if (!prev)
    return 0;
  return prev.vm.exposed.bottom.value;
};
const _hoisted_1$5 = ["id"];
const _hoisted_2$2 = ["innerHTML"];
const __default__ = {
  name: "ElMessage"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: messageProps,
  emits: messageEmits,
  setup(__props, { expose }) {
    const props = __props;
    const { Close } = TypeComponents;
    const ns2 = useNamespace("message");
    const messageRef = ref$1();
    const visible = ref$1(false);
    const height2 = ref$1(0);
    let stopTimer = void 0;
    const badgeType = computed$1(() => props.type ? props.type === "error" ? "danger" : props.type : "info");
    const typeClass = computed$1(() => {
      const type2 = props.type;
      return { [ns2.bm("icon", type2)]: type2 && TypeComponentsMap[type2] };
    });
    const iconComponent = computed$1(() => props.icon || TypeComponentsMap[props.type] || "");
    const lastOffset = computed$1(() => getLastOffset(props.id));
    const offset2 = computed$1(() => props.offset + lastOffset.value);
    const bottom = computed$1(() => height2.value + offset2.value);
    const customStyle = computed$1(() => ({
      top: `${offset2.value}px`,
      zIndex: props.zIndex
    }));
    function startTimer() {
      if (props.duration === 0)
        return;
      ({ stop: stopTimer } = useTimeoutFn(() => {
        close2();
      }, props.duration));
    }
    function clearTimer() {
      stopTimer == null ? void 0 : stopTimer();
    }
    function close2() {
      visible.value = false;
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        close2();
      }
    }
    onMounted$1(() => {
      startTimer();
      visible.value = true;
    });
    watch$1(() => props.repeatNum, () => {
      clearTimer();
      startTimer();
    });
    useEventListener(document, "keydown", keydown);
    useResizeObserver$1(messageRef, () => {
      height2.value = messageRef.value.getBoundingClientRect().height;
    });
    expose({
      visible,
      bottom,
      close: close2
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: unref$1(ns2).b("fade"),
        onBeforeLeave: _ctx.onClose,
        onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy")),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", {
            id: _ctx.id,
            ref_key: "messageRef",
            ref: messageRef,
            class: normalizeClass([
              unref$1(ns2).b(),
              { [unref$1(ns2).m(_ctx.type)]: _ctx.type && !_ctx.icon },
              unref$1(ns2).is("center", _ctx.center),
              unref$1(ns2).is("closable", _ctx.showClose),
              _ctx.customClass
            ]),
            style: normalizeStyle$1(unref$1(customStyle)),
            role: "alert",
            onMouseenter: clearTimer,
            onMouseleave: startTimer
          }, [
            _ctx.repeatNum > 1 ? (openBlock(), createBlock(unref$1(ElBadge), {
              key: 0,
              value: _ctx.repeatNum,
              type: unref$1(badgeType),
              class: normalizeClass(unref$1(ns2).e("badge"))
            }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
            unref$1(iconComponent) ? (openBlock(), createBlock(unref$1(ElIcon), {
              key: 1,
              class: normalizeClass([unref$1(ns2).e("icon"), unref$1(typeClass)])
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref$1(iconComponent))))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true),
            renderSlot(_ctx.$slots, "default", {}, () => [
              !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
                key: 0,
                class: normalizeClass(unref$1(ns2).e("content"))
              }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
                createElementVNode("p", {
                  class: normalizeClass(unref$1(ns2).e("content")),
                  innerHTML: _ctx.message
                }, null, 10, _hoisted_2$2)
              ], 2112))
            ]),
            _ctx.showClose ? (openBlock(), createBlock(unref$1(ElIcon), {
              key: 2,
              class: normalizeClass(unref$1(ns2).e("closeBtn")),
              onClick: withModifiers(close2, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref$1(Close))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 46, _hoisted_1$5), [
            [vShow, visible.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave"]);
    };
  }
});
var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let seed = 1;
const normalizeOptions = (params) => {
  const options = !params || isString$1(params) || isVNode(params) || isFunction$2(params) ? { message: params } : params;
  const normalized = {
    ...messageDefaults,
    ...options
  };
  if (!normalized.appendTo) {
    normalized.appendTo = document.body;
  } else if (isString$1(normalized.appendTo)) {
    let appendTo = document.querySelector(normalized.appendTo);
    if (!isElement$2(appendTo)) {
      appendTo = document.body;
    }
    normalized.appendTo = appendTo;
  }
  return normalized;
};
const closeMessage = (instance2) => {
  const idx = instances.indexOf(instance2);
  if (idx === -1)
    return;
  instances.splice(idx, 1);
  const { handler: handler3 } = instance2;
  handler3.close();
};
const createMessage = ({ appendTo, ...options }, context) => {
  const { nextZIndex: nextZIndex2 } = useZIndex();
  const id2 = `message_${seed++}`;
  const userOnClose = options.onClose;
  const container = document.createElement("div");
  const props = {
    ...options,
    zIndex: nextZIndex2() + options.zIndex,
    id: id2,
    onClose: () => {
      userOnClose == null ? void 0 : userOnClose();
      closeMessage(instance2);
    },
    onDestroy: () => {
      render$a(null, container);
    }
  };
  const vnode2 = createVNode(MessageConstructor, props, isFunction$2(props.message) || isVNode(props.message) ? { default: props.message } : null);
  vnode2.appContext = context || message._context;
  render$a(vnode2, container);
  appendTo.appendChild(container.firstElementChild);
  const vm = vnode2.component;
  const handler3 = {
    close: () => {
      vm.exposed.visible.value = false;
    }
  };
  const instance2 = {
    id: id2,
    vnode: vnode2,
    vm,
    handler: handler3,
    props: vnode2.component.props
  };
  return instance2;
};
const message = (options = {}, context) => {
  if (!isClient)
    return { close: () => void 0 };
  if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
    return { close: () => void 0 };
  }
  const normalized = normalizeOptions(options);
  if (normalized.grouping && instances.length) {
    const instance22 = instances.find(({ vnode: vm }) => {
      var _a2;
      return ((_a2 = vm.props) == null ? void 0 : _a2.message) === normalized.message;
    });
    if (instance22) {
      instance22.props.repeatNum += 1;
      instance22.props.type = normalized.type;
      return instance22.handler;
    }
  }
  const instance2 = createMessage(normalized, context);
  instances.push(instance2);
  return instance2.handler;
};
messageTypes.forEach((type2) => {
  message[type2] = (options = {}, appContext) => {
    const normalized = normalizeOptions(options);
    return message({ ...normalized, type: type2 }, appContext);
  };
});
function closeAll(type2) {
  for (const instance2 of instances) {
    if (!type2 || type2 === instance2.props.type) {
      instance2.handler.close();
    }
  }
}
message.closeAll = closeAll;
message._context = null;
const ElMessage = withInstallFunction(message, "$message");
function mitt(n2) {
  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e3) {
    var i2 = n2.get(t2);
    i2 ? i2.push(e3) : n2.set(t2, [e3]);
  }, off: function(t2, e3) {
    var i2 = n2.get(t2);
    i2 && (e3 ? i2.splice(i2.indexOf(e3) >>> 0, 1) : n2.set(t2, []));
  }, emit: function(t2, e3) {
    var i2 = n2.get(t2);
    i2 && i2.slice().map(function(n3) {
      n3(e3);
    }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
      n3(t2, e3);
    });
  } };
}
const emitter = mitt();
const eventBus = {
  on(eventName, callback) {
    if (!emitter.all.has(eventName)) {
      onUnmounted(() => {
        emitter.off(eventName, callback);
      });
    }
    emitter.on(eventName, callback);
  },
  emit(eventName, params) {
    emitter.emit(eventName, params);
  },
  off(eventName, callback) {
    emitter.off(eventName, callback);
  }
};
var ToolbarCustomColumn_vue_vue_type_style_index_0_scoped_true_lang = "";
var ToolbarCustomColumn_vue_vue_type_style_index_1_lang = "";
const _hoisted_1$4 = { class: "custom-column-node" };
const _hoisted_2$1 = { class: "label" };
const _hoisted_3$1 = { class: "popover-footer" };
const _hoisted_4$1 = /* @__PURE__ */ createTextVNode("\u5168\u9009 ");
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarCustomColumn",
  props: {
    msg: null,
    event: null,
    grid: null
  },
  emits: ["CustomColumnData"],
  setup(__props, { emit }) {
    const props = __props;
    const isFullscreen = ref(false);
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    let recoveryData = [];
    const data5 = reactive({
      columns: [],
      checkedList: [],
      disabledcheckedList: [],
      checkAll: false,
      allCheckIDArray: [],
      isIndeterminate: false,
      dragging: false,
      isDragging: false,
      placement: "top"
    });
    const defaultProps = {
      children: "children",
      label: "title",
      disabled: "disabled"
    };
    const treeRef = ref();
    const buttonRef = ref();
    const popoverRef = ref();
    const onClickOutside = () => {
      var _a2, _b2;
      (_b2 = (_a2 = unref(popoverRef).popperRef) == null ? void 0 : _a2.delayHide) == null ? void 0 : _b2.call(_a2);
    };
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        data5.placement = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      eventBus.on("isFullscreen", () => {
        isFullscreen.value = !isFullscreen.value;
        data5.placement = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      setTimeout(() => {
        nextTick(() => {
          recoveryData = xeUtils.clone(props.grid.getTableColumn().collectColumn);
        });
      }, 50);
    });
    function handleClick2() {
      initColumn(props.event.geCustomColumnData());
    }
    function initColumn(customColumnArray = []) {
      var _a2;
      const _checkedList = [];
      data5.columns = customColumnArray.length ? customColumnArray : xeUtils.clone(props.grid.getTableColumn().collectColumn, true);
      const allCheckIDArray = [];
      const disabledcheckedList = [];
      let num = 0;
      xeUtils.eachTree(data5.columns, (item) => {
        if (item.visible) {
          if (!xeUtils.has(item, "children")) {
            _checkedList.push(item.field);
          }
          num++;
        }
        if (handleCheckAndOperation(item)) {
          disabledcheckedList.push(item.field);
        }
        allCheckIDArray.push(item.field);
      });
      xeUtils.eachTree(data5.columns, (item) => {
        item.disabled = handleCheckAndOperation(item);
      });
      data5.checkedList = [..._checkedList];
      data5.allCheckIDArray = [...allCheckIDArray];
      data5.disabledcheckedList = [...disabledcheckedList];
      (_a2 = treeRef.value) == null ? void 0 : _a2.setCheckedKeys(_checkedList);
      data5.checkAll = num === data5.allCheckIDArray.length;
      data5.isIndeterminate = !data5.checkAll;
    }
    function handleCheckAllChange(isAllCheck) {
      var _a2, _b2, _c2, _d2, _e2;
      isAllCheck ? (_a2 = treeRef.value) == null ? void 0 : _a2.setCheckedKeys(data5.allCheckIDArray) : (_b2 = treeRef.value) == null ? void 0 : _b2.setCheckedKeys(data5.disabledcheckedList);
      if (!isAllCheck) {
        const getCheckedKeys = (_d2 = (_c2 = treeRef.value) == null ? void 0 : _c2.getCheckedKeys()) != null ? _d2 : [];
        const checkedCount = getCheckedKeys.length;
        if (checkedCount === 0) {
          ElMessage.error("\u81F3\u5C11\u4FDD\u7559\u4E00\u5217\u6570\u636E");
          (_e2 = treeRef.value) == null ? void 0 : _e2.setCheckedKeys(data5.allCheckIDArray);
          data5.checkAll = true;
          data5.isIndeterminate = false;
          return;
        }
      } else {
        data5.checkAll = true;
        data5.isIndeterminate = false;
      }
      refreshColumn();
    }
    function handleCheckChange(node) {
      var _a2, _b2, _c2;
      const getCheckedKeys = (_b2 = (_a2 = treeRef.value) == null ? void 0 : _a2.getCheckedKeys()) != null ? _b2 : [];
      const checkedCount = getCheckedKeys.length;
      if (checkedCount === 0) {
        ElMessage.error("\u81F3\u5C11\u4FDD\u7559\u4E00\u5217\u6570\u636E");
        (_c2 = treeRef.value) == null ? void 0 : _c2.setChecked(node.field, true, false);
        return;
      }
      data5.checkAll = checkedCount === data5.allCheckIDArray.length;
      data5.isIndeterminate = checkedCount > 0 && checkedCount < data5.allCheckIDArray.length;
      refreshColumn();
    }
    function resetColumn() {
      initColumn(recoveryData);
      props.grid.reloadColumn(recoveryData);
    }
    function refreshColumn() {
      var _a2, _b2;
      const getCheckedKeys = (_b2 = (_a2 = treeRef.value) == null ? void 0 : _a2.getCheckedKeys()) != null ? _b2 : [];
      xeUtils.eachTree(data5.columns, (item) => {
        item.visible = xeUtils.has(item, "field") && getCheckedKeys.includes(item.field);
      });
      props.grid.reloadColumn(data5.columns);
    }
    function allowDrag(draggingNode) {
      return !handleCheckAndOperation(draggingNode.data);
    }
    function allowDrog(draggingNode, dropNode, type2) {
      data5.isDragging = true;
      return type2 !== "inner" && draggingNode.level === dropNode.level && !handleCheckAndOperation(draggingNode.data) && !handleCheckAndOperation(dropNode.data);
    }
    function nodeDropSuccess() {
      props.grid.reloadColumn(data5.columns);
    }
    function dragingCheckChange(node) {
      var _a2;
      if (data5.isDragging) {
        (_a2 = treeRef.value) == null ? void 0 : _a2.setChecked(node.field, true, true);
        data5.isDragging = false;
      }
    }
    function handleCheckAndOperation(item) {
      const target = JSON.parse(JSON.stringify(["Checkbox", "Operation", "Index"]).toLocaleLowerCase());
      return item.field === void 0 || target.includes(item.field.toLocaleLowerCase());
    }
    function closeWindow() {
      emit("CustomColumnData", data5.columns);
    }
    return (_ctx, _cache) => {
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_svg_icon = resolveComponent("svg-icon");
      const _component_el_scrollbar = resolveComponent("el-scrollbar");
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_el_popover = resolveComponent("el-popover");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_el_tooltip, {
          class: "box-item",
          effect: "dark",
          content: props.msg,
          placement: data5.placement,
          "hide-after": 0
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(unref$1(VxeButton), mergeProps$1({
              icon: "vxe-icon-custom-column",
              ref_key: "buttonRef",
              ref: buttonRef
            }, _ctx.$attrs, {
              onClick: _cache[0] || (_cache[0] = ($event) => handleClick2())
            }), null, 16), [
              [unref$1(ClickOutside), onClickOutside]
            ])
          ]),
          _: 1
        }, 8, ["content", "placement"]),
        createVNode(_component_el_popover, mergeProps$1({
          ref_key: "popoverRef",
          ref: popoverRef,
          "virtual-ref": buttonRef.value,
          "popper-class": "toolsPoper",
          trigger: "click",
          "virtual-triggering": "",
          width: "200px"
        }, _ctx.$attrs, { onBeforeLeave: closeWindow }), {
          default: withCtx(() => [
            createVNode(_component_el_scrollbar, { "max-height": "500px" }, {
              default: withCtx(() => [
                createVNode(unref$1(ElTree), {
                  ref_key: "treeRef",
                  ref: treeRef,
                  data: data5.columns,
                  draggable: "",
                  class: "columnBox",
                  "show-checkbox": "",
                  "default-expand-all": "",
                  "expand-on-click-node": false,
                  "node-key": "field",
                  "highlight-current": "",
                  props: defaultProps,
                  "check-on-click-node": true,
                  onCheck: handleCheckChange,
                  onCheckChange: dragingCheckChange,
                  "allow-drag": allowDrag,
                  "allow-drop": allowDrog,
                  onNodeDrop: nodeDropSuccess
                }, {
                  default: withCtx(({ node, data: data22 }) => [
                    createElementVNode("div", _hoisted_1$4, [
                      createElementVNode("div", _hoisted_2$1, toDisplayString(node.label), 1),
                      !handleCheckAndOperation(data22) ? (openBlock(), createBlock(_component_svg_icon, {
                        key: 0,
                        "icon-class": "draggable"
                      })) : createCommentVNode("", true)
                    ])
                  ]),
                  _: 1
                }, 8, ["data"])
              ]),
              _: 1
            }),
            createElementVNode("div", _hoisted_3$1, [
              createVNode(_component_el_checkbox, {
                modelValue: data5.checkAll,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => data5.checkAll = $event),
                indeterminate: data5.isIndeterminate,
                onChange: handleCheckAllChange
              }, {
                default: withCtx(() => [
                  _hoisted_4$1
                ]),
                _: 1
              }, 8, ["modelValue", "indeterminate"]),
              createVNode(unref$1(VxeButton), {
                type: "text",
                status: "primary",
                class: "vxebtn",
                content: "\u6062\u590D\u9884\u8BBE",
                onClick: resetColumn
              })
            ])
          ]),
          _: 1
        }, 16, ["virtual-ref"])
      ], 64);
    };
  }
});
var ToolbarCustomColumn = /* @__PURE__ */ _export_sfc$2(_sfc_main$9, [["__scopeId", "data-v-76fe9652"]]);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarFullscreen",
  props: {
    msg: null,
    event: null,
    grid: null
  },
  setup(__props) {
    const props = __props;
    const icon = ref("vxe-icon-fullscreen");
    const isFullscreen = ref(false);
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    const placement = ref("top");
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
    });
    function handleClick2() {
      isFullscreen.value = !isFullscreen.value;
      console.log(isFullscreen.value);
      isShowSearchForm.value = props.event.get();
      placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      eventBus.emit("isFullscreen");
      props.grid.zoom();
    }
    watch(() => isFullscreen.value, (value) => {
      icon.value = value ? "vxe-icon-minimize" : "vxe-icon-fullscreen";
    });
    return (_ctx, _cache) => {
      const _component_vxe_button = resolveComponent("vxe-button");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      return openBlock(), createBlock(_component_el_tooltip, {
        class: "box-item",
        effect: "dark",
        content: props.msg,
        placement: placement.value,
        "hide-after": 0
      }, {
        default: withCtx(() => [
          createVNode(_component_vxe_button, mergeProps$1({
            icon: icon.value,
            ref: "buttonRef"
          }, _ctx.$attrs, {
            onClick: _cache[0] || (_cache[0] = ($event) => handleClick2())
          }), null, 16, ["icon"])
        ]),
        _: 1
      }, 8, ["content", "placement"]);
    };
  }
});
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarSearch",
  props: {
    msg: null,
    grid: null
  },
  setup(__props) {
    const props = __props;
    const placement = ref("top");
    const isFullscreen = ref(false);
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      eventBus.on("isFullscreen", () => {
        isFullscreen.value = !isFullscreen.value;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
    });
    return (_ctx, _cache) => {
      const _component_vxe_button = resolveComponent("vxe-button");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      return openBlock(), createBlock(_component_el_tooltip, {
        class: "box-item",
        effect: "dark",
        content: props.msg,
        "hide-after": 0,
        placement: placement.value
      }, {
        default: withCtx(() => [
          createVNode(_component_vxe_button, mergeProps$1({ icon: "vxe-icon-search" }, _ctx.$attrs), null, 16)
        ]),
        _: 1
      }, 8, ["content", "placement"]);
    };
  }
});
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarRefresh",
  props: {
    msg: null,
    grid: null
  },
  setup(__props) {
    const props = __props;
    const placement = ref("top");
    const isFullscreen = ref(false);
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      eventBus.on("isFullscreen", () => {
        isFullscreen.value = !isFullscreen.value;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
    });
    return (_ctx, _cache) => {
      const _component_vxe_button = resolveComponent("vxe-button");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      return openBlock(), createBlock(_component_el_tooltip, {
        class: "box-item",
        effect: "dark",
        content: props.msg,
        "hide-after": 0,
        placement: placement.value
      }, {
        default: withCtx(() => [
          createVNode(_component_vxe_button, mergeProps$1({ icon: "vxe-icon-refresh" }, _ctx.$attrs), null, 16)
        ]),
        _: 1
      }, 8, ["content", "placement"]);
    };
  }
});
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarExport",
  props: {
    msg: null,
    grid: null
  },
  setup(__props) {
    const props = __props;
    const placement = ref("top");
    const isFullscreen = ref(false);
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      eventBus.on("isFullscreen", () => {
        isFullscreen.value = !isFullscreen.value;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
    });
    return (_ctx, _cache) => {
      const _component_vxe_button = resolveComponent("vxe-button");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      return openBlock(), createBlock(_component_el_tooltip, {
        class: "box-item",
        effect: "dark",
        content: props.msg,
        "hide-after": 0,
        placement: placement.value
      }, {
        default: withCtx(() => [
          createVNode(_component_vxe_button, mergeProps$1({ icon: "vxe-icon-download" }, _ctx.$attrs), null, 16)
        ]),
        _: 1
      }, 8, ["content", "placement"]);
    };
  }
});
var ToolbarSetting_vue_vue_type_style_index_0_scoped_true_lang = "";
const _withScopeId = (n2) => (pushScopeId("data-v-3b4e91a7"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = { class: "setting-wrap" };
const _hoisted_2 = { class: "queryItem" };
const _hoisted_3 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u5E38\u7528\u67E5\u8BE2\u9879\uFF08\u53CC\u51FB\u7ACB\u5373\u9009\u62E9\uFF09 ", -1));
const _hoisted_4 = { class: "use-query" };
const _hoisted_5 = ["onDblclick"];
const _hoisted_6 = ["onClick"];
const _hoisted_7 = {
  key: 1,
  class: "nodata"
};
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "text" }, "\u6682\u65E0\u6570\u636E", -1));
const _hoisted_9 = { class: "save-query" };
const _hoisted_10 = /* @__PURE__ */ createTextVNode("\u6DFB\u52A0 ");
const _hoisted_11 = { class: "searchItem" };
const _hoisted_12 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "title" }, "\u914D\u7F6E\u67E5\u8BE2\u9879", -1));
const _hoisted_13 = { class: "form-list" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "ToolbarSetting",
  props: {
    msg: null,
    event: null,
    grid: null
  },
  emits: ["ChangFromItemStatus", "SetCustomQueryData", "SetCustomQuerySelected"],
  setup(__props, { emit }) {
    var _a2, _b2;
    const props = __props;
    const placement = ref("top");
    const isFullscreen = ref(false);
    const ruleFormRef = ref();
    const isShowSearchForm = ref(props.grid.props.formConfig ? true : false);
    const state = reactive({
      visible: false,
      dialogProp: {
        title: "\u5E38\u7528\u67E5\u8BE2\u8BBE\u7F6E",
        width: 520,
        draggable: true
      },
      customQuery: [],
      inputValue: "",
      formConfigItem: (_b2 = (_a2 = props.grid.props.formConfig) == null ? void 0 : _a2.items) != null ? _b2 : [],
      rule: {
        inputValue: [{ validator: checkInput, trigger: "blur" }]
      },
      currentSelectedQuery: null
    });
    onMounted(() => {
      eventBus.on("IsShowSearchForm", (_isShowSearchForm) => {
        isShowSearchForm.value = _isShowSearchForm;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
      eventBus.on("isFullscreen", () => {
        isFullscreen.value = !isFullscreen.value;
        placement.value = isFullscreen.value && !isShowSearchForm.value ? "bottom" : "top";
      });
    });
    function handleClick2() {
      state.visible = true;
      state.customQuery = xeUtils.clone(props.event.get(), true);
    }
    function changeFormConfigItems(item) {
      item.visible = !item.visible;
      emit("ChangFromItemStatus", item);
    }
    function selectQuery(item) {
      state.customQuery.forEach((element) => element.isSelected = false);
      item.isSelected = !item.isSelected;
      item.isSelected && (state.currentSelectedQuery = item);
    }
    function checkInput(rule2, value, callback) {
      if (!value) {
        return callback(new Error("\u5E38\u7528\u67E5\u8BE2\u7684\u5173\u952E\u5B57\u4E0D\u80FD\u4E3A\u7A7A"));
      }
      if (xeUtils.find(state.customQuery, (item) => item.name === value)) {
        callback(new Error("\u5F53\u524D\u5173\u952E\u5B57\u5DF2\u5B58\u5728\uFF0C\u8BF7\u91CD\u65B0\u8F93\u5165"));
      } else {
        callback();
      }
    }
    function submitForm(formEl) {
      var _a3;
      if (!formEl)
        return;
      const data5 = (_a3 = props.grid) == null ? void 0 : _a3.getProxyInfo();
      formEl.validate((valid2) => {
        if (valid2) {
          state.customQuery.push({ name: state.inputValue, form: data5 == null ? void 0 : data5.form, isSelected: false });
        }
      });
    }
    function deleteItem(index) {
      xeUtils.remove(state.customQuery, index);
    }
    function dbclick(item) {
      confirmSubmit(true);
      emit("SetCustomQuerySelected", item);
    }
    function confirmSubmit(isConfirm) {
      var _a3;
      state.visible = false;
      state.inputValue = "";
      (_a3 = ruleFormRef.value) == null ? void 0 : _a3.clearValidate("inputValue");
      state.customQuery.forEach((element) => element.isSelected = false);
      isConfirm && emit("SetCustomQueryData", xeUtils.clone(state.customQuery, true));
      if (xeUtils.findIndexOf(state.customQuery, (item) => item.isSelected) > 0 && isConfirm) {
        emit("SetCustomQuerySelected", state.currentSelectedQuery);
      }
      state.currentSelectedQuery = null;
    }
    return (_ctx, _cache) => {
      const _component_vxe_button = resolveComponent("vxe-button");
      const _component_el_tooltip = resolveComponent("el-tooltip");
      const _component_el_button = resolveComponent("el-button");
      const _component_el_popconfirm = resolveComponent("el-popconfirm");
      const _component_SvgIcon = resolveComponent("SvgIcon");
      const _component_el_input = resolveComponent("el-input");
      const _component_el_form_item = resolveComponent("el-form-item");
      const _component_el_form = resolveComponent("el-form");
      const _component_el_checkbox = resolveComponent("el-checkbox");
      const _component_fits_dialog = resolveComponent("fits-dialog");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_el_tooltip, {
          class: "box-item",
          effect: "dark",
          content: props.msg,
          "hide-after": 0,
          placement: placement.value
        }, {
          default: withCtx(() => [
            createVNode(_component_vxe_button, mergeProps$1({ icon: "vxe-icon-setting" }, _ctx.$attrs, {
              onClick: _cache[0] || (_cache[0] = ($event) => handleClick2())
            }), null, 16)
          ]),
          _: 1
        }, 8, ["content", "placement"]),
        createVNode(_component_fits_dialog, mergeProps$1({
          visible: state.visible,
          dialogProp: state.dialogProp,
          onCancel: _cache[3] || (_cache[3] = ($event) => confirmSubmit(false)),
          onSubmit: _cache[4] || (_cache[4] = ($event) => confirmSubmit(true))
        }, _ctx.$attrs), {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_1$3, [
              createElementVNode("div", _hoisted_2, [
                _hoisted_3,
                createElementVNode("div", _hoisted_4, [
                  state.customQuery.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(state.customQuery, (item, index) => {
                    return openBlock(), createElementBlock("div", {
                      class: "query-item",
                      key: index,
                      style: normalizeStyle$1({ background: !item.isSelected ? "transparent" : "#e8f4ff" }),
                      onDblclick: ($event) => dbclick(item)
                    }, [
                      createElementVNode("span", {
                        class: "name clickRipple",
                        onClick: ($event) => selectQuery(item)
                      }, toDisplayString(item.name), 9, _hoisted_6),
                      createVNode(_component_el_popconfirm, {
                        title: "\u662F\u5426\u5220\u9664\u8BE5\u5173\u952E\u5B57",
                        "confirm-button-text": "\u786E\u5B9A",
                        "cancel-button-text": "\u53D6\u6D88",
                        onConfirm: ($event) => deleteItem(index)
                      }, {
                        reference: withCtx(() => [
                          createVNode(_component_el_button, {
                            icon: unref$1(_delete),
                            link: "",
                            text: "",
                            class: "delete"
                          }, null, 8, ["icon"])
                        ]),
                        _: 2
                      }, 1032, ["onConfirm"])
                    ], 44, _hoisted_5);
                  }), 128)) : (openBlock(), createElementBlock("div", _hoisted_7, [
                    createVNode(_component_SvgIcon, { "icon-class": "nodata" }),
                    _hoisted_8
                  ]))
                ]),
                createElementVNode("div", _hoisted_9, [
                  createVNode(_component_el_form, {
                    inline: true,
                    model: state,
                    class: "save-query-form",
                    rules: state.rule,
                    ref_key: "ruleFormRef",
                    ref: ruleFormRef
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_el_form_item, { prop: "inputValue" }, {
                        default: withCtx(() => [
                          createVNode(_component_el_input, {
                            modelValue: state.inputValue,
                            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => state.inputValue = $event),
                            placeholder: "\u8BF7\u8F93\u5165\u67E5\u8BE2\u503C\u540D\u79F0,10\u4E2A\u5B57\u4EE5\u5185",
                            maxLength: "10",
                            "validate-event": false
                          }, null, 8, ["modelValue"])
                        ]),
                        _: 1
                      }),
                      createVNode(_component_el_form_item, null, {
                        default: withCtx(() => [
                          createVNode(_component_el_button, {
                            type: "primary",
                            class: "addBtn",
                            plain: "",
                            onClick: _cache[2] || (_cache[2] = ($event) => submitForm(ruleFormRef.value))
                          }, {
                            default: withCtx(() => [
                              _hoisted_10
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  }, 8, ["model", "rules"])
                ])
              ]),
              createElementVNode("div", _hoisted_11, [
                _hoisted_12,
                createElementVNode("div", _hoisted_13, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(state.formConfigItem, (item, index) => {
                    return openBlock(), createElementBlock("div", {
                      class: "form-item",
                      key: index
                    }, [
                      item.field ? (openBlock(), createBlock(_component_el_checkbox, {
                        key: 0,
                        label: item.title,
                        checked: item.visible,
                        onChange: ($event) => changeFormConfigItems(item)
                      }, null, 8, ["label", "checked", "onChange"])) : createCommentVNode("", true)
                    ]);
                  }), 128))
                ])
              ])
            ])
          ]),
          _: 1
        }, 16, ["visible", "dialogProp"])
      ], 64);
    };
  }
});
var ToolbarSetting = /* @__PURE__ */ _export_sfc$2(_sfc_main$4, [["__scopeId", "data-v-3b4e91a7"]]);
VXETable.renderer.add("ToolbarSearch", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      _sfc_main$7,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u662F\u5426\u663E\u793A\u641C\u7D22\u6761\u4EF6",
        grid: $grid,
        onClick: () => {
          events.click();
        }
      }
    );
  }
});
VXETable.renderer.add("ToolbarRefresh", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      _sfc_main$6,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u5237\u65B0\u6570\u636E",
        grid: $grid,
        onClick: () => {
          events.click();
        }
      }
    );
  }
});
VXETable.renderer.add("ToolbarSetting", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      ToolbarSetting,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u5E38\u7528\u67E5\u8BE2\u8BBE\u7F6E",
        grid: $grid,
        event: events,
        onSetCustomQuerySelected: (formConfigData) => {
          events.setCustomQuerySelected(formConfigData);
        },
        onSetCustomQueryData: (arr) => {
          events.setCustomQueryData(arr);
        },
        onChangFromItemStatus: (target) => {
          events.changFromItemStatus(target);
        }
      }
    );
  }
});
VXETable.renderer.add("ToolbarExport", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      _sfc_main$5,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u5BFC\u51FA\u5F53\u524D\u8868\u683C",
        grid: $grid,
        onClick: () => {
          events.click();
        }
      }
    );
  }
});
VXETable.renderer.add("ToolbarFullscreen", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      _sfc_main$8,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u5168\u5C4F",
        grid: $grid,
        event: events
      }
    );
  }
});
VXETable.renderer.add("ToolbarCustomColumn", {
  renderToolbarTool(renderOpts, params) {
    var _a2;
    const { $grid } = params;
    const { events = {}, props = {} } = renderOpts;
    return h(
      ToolbarCustomColumn,
      {
        msg: (_a2 = props.msg) != null ? _a2 : "\u81EA\u5B9A\u4E49\u5217\u663E\u793A",
        grid: $grid,
        event: events,
        onCustomColumnData: (arr) => {
          events.setCustomColumnData(arr);
        }
      }
    );
  }
});
VXETable.renderer.add("FormBtnGroup", {
  renderItemContent(renderOpts, params) {
    return h(ListSeachBtnGroud);
  }
});
VXETable.renderer.add("FitsTreeSelect", {
  renderItemContent(renderOpts, params) {
    const { data: data5, field } = params;
    const { props } = renderOpts;
    return h(
      FitsTreeSelect,
      {
        modelValue: data5[field],
        ...props
      }
    );
  }
});
VXETable.renderer.add("FitsIconSelect", {
  renderItemContent(renderOpts, params) {
    const { data: data5, field } = params;
    const { props } = renderOpts;
    return h(
      FitsIconSelect,
      {
        modelValue: data5[field],
        ...props
      }
    );
  }
});
const useLogger = () => {
  const typeColor = (type2 = "default") => {
    let color2 = "";
    switch (type2) {
      case "primary":
        color2 = "#2d8cf0";
        break;
      case "success":
        color2 = "#19be6b";
        break;
      case "info":
        color2 = "#909399";
        break;
      case "warning":
        color2 = "#ff9900";
        break;
      case "danger":
        color2 = "#f03f14";
        break;
      case "default":
        color2 = "#35495E";
        break;
      default:
        color2 = type2;
        break;
    }
    return color2;
  };
  const print = (title, content, type2 = "primary") => {
    if (typeof content === "object") {
      console.log(
        `%c ${title} `,
        `background:${typeColor(type2)}; padding: 2px; border-radius: 4px;color: #fff;`,
        content
      );
      return;
    } else {
      console.log(
        `%c ${title} %c ${content} %c`,
        `background:${typeColor(type2)};border:1px solid ${typeColor(type2)}; padding: 1px; border-radius: 4px 0 0 4px; color: #fff;`,
        `border:1px solid ${typeColor(type2)}; padding: 1px; border-radius: 0 4px 4px 0; color: ${typeColor(type2)};`,
        "background:transparent"
      );
    }
  };
  const log = {
    primary: (title, content) => {
      print(title, content);
    },
    success: (title, content) => {
      print(title, content, "success");
    },
    info: (title, content) => {
      print(title, content, "info");
    },
    warning: (title, content) => {
      print(title, content, "warning");
    },
    danger: (title, content) => {
      print(title, content, "danger");
    }
  };
  return { print, log };
};
var FitsTable_vue_vue_type_style_index_0_lang = "";
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "FitsTable",
  props: {
    option: null,
    gridEvents: { default: {} }
  },
  setup(__props, { expose }) {
    const props = __props;
    const fitsTablePro = ref();
    const _gridOption = xeUtils.clone(props.option, true);
    const state = reactive({
      dynamicSlotNameArray: [],
      gridOption: _gridOption
    });
    expose({
      fitsTablePro,
      handleFormItemNumber
    });
    initDefaultConfig();
    function initDefaultConfig() {
      checkAllSlots();
    }
    function checkAllSlots() {
      var _a2;
      const arr = [];
      xeUtils.eachTree(state.gridOption.columns, (column2) => {
        if (column2 == null ? void 0 : column2.slots) {
          xeUtils.each(column2.slots, (value) => {
            arr.push(value);
          });
        }
      });
      xeUtils.eachTree([state.gridOption.toolbarConfig], (config2) => {
        if (config2 == null ? void 0 : config2.slots) {
          xeUtils.each(config2.slots, (value) => {
            arr.push(value);
          });
        }
      });
      xeUtils.eachTree((_a2 = state.gridOption.formConfig) == null ? void 0 : _a2.items, (config2) => {
        if (config2 == null ? void 0 : config2.slots) {
          xeUtils.each(config2.slots, (value) => {
            arr.push(value);
          });
        }
      });
      xeUtils.eachTree([state.gridOption.pagerConfig], (config2) => {
        if (config2 == null ? void 0 : config2.slots) {
          xeUtils.each(config2.slots, (value) => {
            arr.push(value);
          });
        }
      });
      state.dynamicSlotNameArray = [...arr];
      const { log } = useLogger();
      arr.length && log.primary("FitsTable\u7EC4\u4EF6\u5DF2\u6709\u63D2\u69FD", state.dynamicSlotNameArray);
    }
    function handleFormItemNumber(width2) {
      var _a2, _b2, _c2;
      if (xeUtils.isPlainObject(state.gridOption.formConfig) && ((_b2 = (_a2 = state.gridOption.formConfig) == null ? void 0 : _a2.items) == null ? void 0 : _b2.length)) {
        const formItemWidth = parseInt(variables.ListSearchFormItemWidth);
        const lineItem = width2 < 768 ? 2 : Math.ceil(width2 / formItemWidth);
        const items = (_c2 = state.gridOption.formConfig) == null ? void 0 : _c2.items;
        const visibleArray = items.filter((item) => {
          var _a3;
          item.visible = (_a3 = item.visible) != null ? _a3 : true;
          return item.visible === false && item.folding === false;
        });
        let isShowExpand = true;
        state.gridOption.formConfig.items = items.map((element, index) => {
          element.span = Math.floor(24 / lineItem);
          element.className !== "searchBtns" && (element.folding = index >= lineItem - 1 + visibleArray.length);
          element.folding && isShowExpand && (isShowExpand = false);
          element.className === "searchBtns" && isShowExpand && (element.collapseNode = false);
          return element;
        });
      }
    }
    useResizeObserver(document.body, (entries2) => {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g;
      const entry = entries2[0];
      handleFormItemNumber((_a2 = fitsTablePro.value) == null ? void 0 : _a2.$el.clientWidth);
      const padding = parseInt(variables.basePadding);
      const headerHeight = (_c2 = (_b2 = entry.target.querySelector(".fits-head")) == null ? void 0 : _b2.clientHeight) != null ? _c2 : 0;
      const footerHeight2 = (_e2 = (_d2 = entry.target.querySelector(".footeContainer")) == null ? void 0 : _d2.clientHeight) != null ? _e2 : 0;
      state.gridOption.maxHeight = (_g = (_f2 = props.option) == null ? void 0 : _f2.maxHeight) != null ? _g : entry.contentRect.height - headerHeight - padding - footerHeight2;
    });
    watch(() => props.option, (newValue) => {
      state.gridOption = xeUtils.clone(newValue, true);
      initDefaultConfig();
    }, { deep: true });
    return (_ctx, _cache) => {
      const _component_fits_no_data = resolveComponent("fits-no-data");
      const _component_vxe_grid = resolveComponent("vxe-grid");
      return openBlock(), createBlock(_component_vxe_grid, mergeProps$1({
        ref_key: "fitsTablePro",
        ref: fitsTablePro,
        id: "fitstable"
      }, state.gridOption, toHandlers(props.gridEvents), { class: "fits-grid" }), createSlots({
        empty: withCtx(() => [
          createVNode(_component_fits_no_data)
        ]),
        _: 2
      }, [
        renderList(state.dynamicSlotNameArray, (item, index) => {
          return {
            name: item,
            fn: withCtx((slotProps) => [
              renderSlot(_ctx.$slots, item, { slotProps })
            ])
          };
        })
      ]), 1040);
    };
  }
});
var _a$4;
if (typeof global === "undefined") {
  if ("ActiveXObject" in window) {
    var info = "\u62B1\u6B49\uFF0CwangEditor V5+ \u7248\u672C\u5F00\u59CB\uFF0C\u4E0D\u5728\u652F\u6301 IE \u6D4F\u89C8\u5668";
    info += "\n Sorry, wangEditor V5+ versions do not support IE browser.";
    console.error(info);
  }
  globalThisPolyfill();
  AggregateErrorPolyfill();
} else if (global && ((_a$4 = global.navigator) === null || _a$4 === void 0 ? void 0 : _a$4.userAgent.match("QQBrowser"))) {
  globalThisPolyfill();
  AggregateErrorPolyfill();
}
function globalThisPolyfill() {
  if (typeof globalThis === "undefined") {
    window.globalThis = window;
  }
}
function AggregateErrorPolyfill() {
  if (typeof AggregateError === "undefined") {
    window.AggregateError = function(errors, msg) {
      var err2 = new Error(msg);
      err2.errors = errors;
      return err2;
    };
  }
}
if (typeof global === "object") {
  var globalProperty = Object.getOwnPropertyDescriptor(global, "window");
  if (!global.window || globalProperty.set) {
    global.window = global;
    global.requestAnimationFrame = function() {
    };
    global.navigator = {
      userAgent: ""
    };
    global.location = {
      hostname: "0.0.0.0",
      port: 0,
      protocol: "http:"
    };
    global.btoa = function() {
    };
    global.crypto = {
      getRandomValues: function(buffer) {
        return nodeCrypto.randomFillSync(buffer);
      }
    };
  }
  if (global.document != null) {
    if (global.document.getElementsByTagName == null) {
      global.document.getElementsByTagName = function() {
        return [];
      };
    }
  }
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$5(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainObject(o2) {
  var ctor2, prot;
  if (isObject$5(o2) === false)
    return false;
  ctor2 = o2.constructor;
  if (ctor2 === void 0)
    return true;
  prot = ctor2.prototype;
  if (isObject$5(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function n(n2) {
  for (var t2 = arguments.length, r2 = Array(t2 > 1 ? t2 - 1 : 0), e3 = 1; e3 < t2; e3++)
    r2[e3 - 1] = arguments[e3];
  {
    var i2 = Y$6[n2], o2 = i2 ? "function" == typeof i2 ? i2.apply(null, r2) : i2 : "unknown error nr: " + n2;
    throw Error("[Immer] " + o2);
  }
}
function t(n2) {
  return !!n2 && !!n2[Q$6];
}
function r(n2) {
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var t2 = Object.getPrototypeOf(n3);
    if (null === t2)
      return true;
    var r2 = Object.hasOwnProperty.call(t2, "constructor") && t2.constructor;
    return r2 === Object || "function" == typeof r2 && Function.toString.call(r2) === Z$6;
  }(n2) || Array.isArray(n2) || !!n2[L$5] || !!n2.constructor[L$5] || s$1(n2) || v$3(n2));
}
function i(n2, t2, r2) {
  void 0 === r2 && (r2 = false), 0 === o(n2) ? (r2 ? Object.keys : nn$7)(n2).forEach(function(e3) {
    r2 && "symbol" == typeof e3 || t2(e3, n2[e3], n2);
  }) : n2.forEach(function(r3, e3) {
    return t2(e3, r3, n2);
  });
}
function o(n2) {
  var t2 = n2[Q$6];
  return t2 ? t2.i > 3 ? t2.i - 4 : t2.i : Array.isArray(n2) ? 1 : s$1(n2) ? 2 : v$3(n2) ? 3 : 0;
}
function u$1(n2, t2) {
  return 2 === o(n2) ? n2.has(t2) : Object.prototype.hasOwnProperty.call(n2, t2);
}
function a(n2, t2) {
  return 2 === o(n2) ? n2.get(t2) : n2[t2];
}
function f$3(n2, t2, r2) {
  var e3 = o(n2);
  2 === e3 ? n2.set(t2, r2) : 3 === e3 ? (n2.delete(t2), n2.add(r2)) : n2[t2] = r2;
}
function c$1(n2, t2) {
  return n2 === t2 ? 0 !== n2 || 1 / n2 == 1 / t2 : n2 != n2 && t2 != t2;
}
function s$1(n2) {
  return X$6 && n2 instanceof Map;
}
function v$3(n2) {
  return q$6 && n2 instanceof Set;
}
function p$3(n2) {
  return n2.o || n2.t;
}
function l$1(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var t2 = tn$7(n2);
  delete t2[Q$6];
  for (var r2 = nn$7(t2), e3 = 0; e3 < r2.length; e3++) {
    var i2 = r2[e3], o2 = t2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (t2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), t2);
}
function d$3(n2, e3) {
  return void 0 === e3 && (e3 = false), y$3(n2) || t(n2) || !r(n2) ? n2 : (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h$4), Object.freeze(n2), e3 && i(n2, function(n3, t2) {
    return d$3(t2, true);
  }, true), n2);
}
function h$4() {
  n(2);
}
function y$3(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b$3(t2) {
  var r2 = rn$7[t2];
  return r2 || n(18, t2), r2;
}
function _$6() {
  return U$6 || n(0), U$6;
}
function j$5(n2, t2) {
  t2 && (b$3("Patches"), n2.u = [], n2.s = [], n2.v = t2);
}
function O$5(n2) {
  g$3(n2), n2.p.forEach(S$4), n2.p = null;
}
function g$3(n2) {
  n2 === U$6 && (U$6 = n2.l);
}
function w$3(n2) {
  return U$6 = { p: [], l: U$6, h: n2, m: true, _: 0 };
}
function S$4(n2) {
  var t2 = n2[Q$6];
  0 === t2.i || 1 === t2.i ? t2.j() : t2.O = true;
}
function P$5(t2, e3) {
  e3._ = e3.p.length;
  var i2 = e3.p[0], o2 = void 0 !== t2 && t2 !== i2;
  return e3.h.g || b$3("ES5").S(e3, t2, o2), o2 ? (i2[Q$6].P && (O$5(e3), n(4)), r(t2) && (t2 = M$4(e3, t2), e3.l || x$4(e3, t2)), e3.u && b$3("Patches").M(i2[Q$6], t2, e3.u, e3.s)) : t2 = M$4(e3, i2, []), O$5(e3), e3.u && e3.v(e3.u, e3.s), t2 !== H$5 ? t2 : void 0;
}
function M$4(n2, t2, r2) {
  if (y$3(t2))
    return t2;
  var e3 = t2[Q$6];
  if (!e3)
    return i(t2, function(i2, o3) {
      return A$5(n2, e3, t2, i2, o3, r2);
    }, true), t2;
  if (e3.A !== n2)
    return t2;
  if (!e3.P)
    return x$4(n2, e3.t, true), e3.t;
  if (!e3.I) {
    e3.I = true, e3.A._--;
    var o2 = 4 === e3.i || 5 === e3.i ? e3.o = l$1(e3.k) : e3.o;
    i(3 === e3.i ? new Set(o2) : o2, function(t3, i2) {
      return A$5(n2, e3, o2, t3, i2, r2);
    }), x$4(n2, o2, false), r2 && n2.u && b$3("Patches").R(e3, r2, n2.u, n2.s);
  }
  return e3.o;
}
function A$5(e3, i2, o2, a2, c2, s2) {
  if (c2 === o2 && n(5), t(c2)) {
    var v2 = M$4(e3, c2, s2 && i2 && 3 !== i2.i && !u$1(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f$3(o2, a2, v2), !t(v2))
      return;
    e3.m = false;
  }
  if (r(c2) && !y$3(c2)) {
    if (!e3.h.F && e3._ < 1)
      return;
    M$4(e3, c2), i2 && i2.A.l || x$4(e3, c2);
  }
}
function x$4(n2, t2, r2) {
  void 0 === r2 && (r2 = false), n2.h.F && n2.m && d$3(t2, r2);
}
function z$5(n2, t2) {
  var r2 = n2[Q$6];
  return (r2 ? p$3(r2) : n2)[t2];
}
function I$5(n2, t2) {
  if (t2 in n2)
    for (var r2 = Object.getPrototypeOf(n2); r2; ) {
      var e3 = Object.getOwnPropertyDescriptor(r2, t2);
      if (e3)
        return e3;
      r2 = Object.getPrototypeOf(r2);
    }
}
function k$5(n2) {
  n2.P || (n2.P = true, n2.l && k$5(n2.l));
}
function E$4(n2) {
  n2.o || (n2.o = l$1(n2.t));
}
function R$5(n2, t2, r2) {
  var e3 = s$1(t2) ? b$3("MapSet").N(t2, r2) : v$3(t2) ? b$3("MapSet").T(t2, r2) : n2.g ? function(n3, t3) {
    var r3 = Array.isArray(n3), e4 = { i: r3 ? 1 : 0, A: t3 ? t3.A : _$6(), P: false, I: false, D: {}, l: t3, t: n3, k: null, o: null, j: null, C: false }, i2 = e4, o2 = en$7;
    r3 && (i2 = [e4], o2 = on$8);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e4.k = f2, e4.j = a2, f2;
  }(t2, r2) : b$3("ES5").J(t2, r2);
  return (r2 ? r2.A : _$6()).p.push(e3), e3;
}
function D$5(e3) {
  return t(e3) || n(22, e3), function n2(t2) {
    if (!r(t2))
      return t2;
    var e4, u2 = t2[Q$6], c2 = o(t2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b$3("ES5").K(u2)))
        return u2.t;
      u2.I = true, e4 = F$5(t2, c2), u2.I = false;
    } else
      e4 = F$5(t2, c2);
    return i(e4, function(t3, r2) {
      u2 && a(u2.t, t3) === r2 || f$3(e4, t3, n2(r2));
    }), 3 === c2 ? new Set(e4) : e4;
  }(e3);
}
function F$5(n2, t2) {
  switch (t2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l$1(n2);
}
var G$6, U$6, W$6 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X$6 = "undefined" != typeof Map, q$6 = "undefined" != typeof Set, B$5 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H$5 = W$6 ? Symbol.for("immer-nothing") : ((G$6 = {})["immer-nothing"] = true, G$6), L$5 = W$6 ? Symbol.for("immer-draftable") : "__$immer_draftable", Q$6 = W$6 ? Symbol.for("immer-state") : "__$immer_state", Y$6 = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n2) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n2;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n2) {
  return "Cannot apply patch, path doesn't resolve: " + n2;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n2) {
  return "Unsupported patch operation: " + n2;
}, 18: function(n2) {
  return "The plugin for '" + n2 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n2 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n2) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n2 + "'";
}, 22: function(n2) {
  return "'current' expects a draft, got: " + n2;
}, 23: function(n2) {
  return "'original' expects a draft, got: " + n2;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, Z$6 = "" + Object.prototype.constructor, nn$7 = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, tn$7 = Object.getOwnPropertyDescriptors || function(n2) {
  var t2 = {};
  return nn$7(n2).forEach(function(r2) {
    t2[r2] = Object.getOwnPropertyDescriptor(n2, r2);
  }), t2;
}, rn$7 = {}, en$7 = { get: function(n2, t2) {
  if (t2 === Q$6)
    return n2;
  var e3 = p$3(n2);
  if (!u$1(e3, t2))
    return function(n3, t3, r2) {
      var e4, i3 = I$5(t3, r2);
      return i3 ? "value" in i3 ? i3.value : null === (e4 = i3.get) || void 0 === e4 ? void 0 : e4.call(n3.k) : void 0;
    }(n2, e3, t2);
  var i2 = e3[t2];
  return n2.I || !r(i2) ? i2 : i2 === z$5(n2.t, t2) ? (E$4(n2), n2.o[t2] = R$5(n2.A.h, i2, n2)) : i2;
}, has: function(n2, t2) {
  return t2 in p$3(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p$3(n2));
}, set: function(n2, t2, r2) {
  var e3 = I$5(p$3(n2), t2);
  if (null == e3 ? void 0 : e3.set)
    return e3.set.call(n2.k, r2), true;
  if (!n2.P) {
    var i2 = z$5(p$3(n2), t2), o2 = null == i2 ? void 0 : i2[Q$6];
    if (o2 && o2.t === r2)
      return n2.o[t2] = r2, n2.D[t2] = false, true;
    if (c$1(r2, i2) && (void 0 !== r2 || u$1(n2.t, t2)))
      return true;
    E$4(n2), k$5(n2);
  }
  return n2.o[t2] === r2 && "number" != typeof r2 && (void 0 !== r2 || t2 in n2.o) || (n2.o[t2] = r2, n2.D[t2] = true, true);
}, deleteProperty: function(n2, t2) {
  return void 0 !== z$5(n2.t, t2) || t2 in n2.t ? (n2.D[t2] = false, E$4(n2), k$5(n2)) : delete n2.D[t2], n2.o && delete n2.o[t2], true;
}, getOwnPropertyDescriptor: function(n2, t2) {
  var r2 = p$3(n2), e3 = Reflect.getOwnPropertyDescriptor(r2, t2);
  return e3 ? { writable: true, configurable: 1 !== n2.i || "length" !== t2, enumerable: e3.enumerable, value: r2[t2] } : e3;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} }, on$8 = {};
i(en$7, function(n2, t2) {
  on$8[n2] = function() {
    return arguments[0] = arguments[0][0], t2.apply(this, arguments);
  };
}), on$8.deleteProperty = function(t2, r2) {
  return isNaN(parseInt(r2)) && n(13), en$7.deleteProperty.call(this, t2[0], r2);
}, on$8.set = function(t2, r2, e3) {
  return "length" !== r2 && isNaN(parseInt(r2)) && n(14), en$7.set.call(this, t2[0], r2, e3, t2[0]);
};
var un$7 = function() {
  function e3(t2) {
    var e4 = this;
    this.g = B$5, this.F = true, this.produce = function(t3, i3, o2) {
      if ("function" == typeof t3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = t3;
        var a2 = e4;
        return function(n2) {
          var t4 = this;
          void 0 === n2 && (n2 = u2);
          for (var r2 = arguments.length, e5 = Array(r2 > 1 ? r2 - 1 : 0), o3 = 1; o3 < r2; o3++)
            e5[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var r3;
            return (r3 = i3).call.apply(r3, [t4, n3].concat(e5));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), r(t3)) {
        var c2 = w$3(e4), s2 = R$5(e4, t3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O$5(c2) : g$3(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j$5(c2, o2), P$5(n2, c2);
        }, function(n2) {
          throw O$5(c2), n2;
        }) : (j$5(c2, o2), P$5(f2, c2));
      }
      if (!t3 || "object" != typeof t3) {
        if ((f2 = i3(t3)) === H$5)
          return;
        return void 0 === f2 && (f2 = t3), e4.F && d$3(f2, true), f2;
      }
      n(21, t3);
    }, this.produceWithPatches = function(n2, t3) {
      return "function" == typeof n2 ? function(t4) {
        for (var r3 = arguments.length, i4 = Array(r3 > 1 ? r3 - 1 : 0), o2 = 1; o2 < r3; o2++)
          i4[o2 - 1] = arguments[o2];
        return e4.produceWithPatches(t4, function(t5) {
          return n2.apply(void 0, [t5].concat(i4));
        });
      } : [e4.produce(n2, t3, function(n3, t4) {
        r2 = n3, i3 = t4;
      }), r2, i3];
      var r2, i3;
    }, "boolean" == typeof (null == t2 ? void 0 : t2.useProxies) && this.setUseProxies(t2.useProxies), "boolean" == typeof (null == t2 ? void 0 : t2.autoFreeze) && this.setAutoFreeze(t2.autoFreeze);
  }
  var i2 = e3.prototype;
  return i2.createDraft = function(e4) {
    r(e4) || n(8), t(e4) && (e4 = D$5(e4));
    var i3 = w$3(this), o2 = R$5(this, e4, void 0);
    return o2[Q$6].C = true, g$3(i3), o2;
  }, i2.finishDraft = function(t2, r2) {
    var e4 = t2 && t2[Q$6];
    e4 && e4.C || n(9), e4.I && n(10);
    var i3 = e4.A;
    return j$5(i3, r2), P$5(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(t2) {
    t2 && !B$5 && n(20), this.g = t2;
  }, i2.applyPatches = function(n2, r2) {
    var e4;
    for (e4 = r2.length - 1; e4 >= 0; e4--) {
      var i3 = r2[e4];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e4 > -1 && (r2 = r2.slice(e4 + 1));
    var o2 = b$3("Patches").$;
    return t(n2) ? o2(n2, r2) : this.produce(n2, function(n3) {
      return o2(n3, r2);
    });
  }, e3;
}(), an$7 = new un$7(), fn$7 = an$7.produce;
an$7.produceWithPatches.bind(an$7);
an$7.setAutoFreeze.bind(an$7);
an$7.setUseProxies.bind(an$7);
an$7.applyPatches.bind(an$7);
var ln$7 = an$7.createDraft.bind(an$7), dn$7 = an$7.finishDraft.bind(an$7);
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
function ownKeys$9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var createEditor$1 = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    onChange: () => {
    },
    apply: (op2) => {
      for (var ref2 of Editor$1.pathRefs(editor)) {
        PathRef.transform(ref2, op2);
      }
      for (var _ref of Editor$1.pointRefs(editor)) {
        PointRef.transform(_ref, op2);
      }
      for (var _ref2 of Editor$1.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op2);
      }
      var set2 = /* @__PURE__ */ new Set();
      var dirtyPaths = [];
      var add3 = (path2) => {
        if (path2) {
          var key = path2.join(",");
          if (!set2.has(key)) {
            set2.add(key);
            dirtyPaths.push(path2);
          }
        }
      };
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var newDirtyPaths = getDirtyPaths(op2);
      for (var path of oldDirtyPaths) {
        var newPath = Path.transform(path, op2);
        add3(newPath);
      }
      for (var _path of newDirtyPaths) {
        add3(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      Transforms.transform(editor, op2);
      editor.operations.push(op2);
      Editor$1.normalize(editor);
      if (op2.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange();
          editor.operations = [];
        });
      }
    },
    addMark: (key, value) => {
      var {
        selection
      } = editor;
      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.setNodes(editor, {
            [key]: value
          }, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor$1.marks(editor) || {}), {}, {
            [key]: value
          });
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: (direction) => {
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node$1.fragment(editor, selection);
      }
      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: (fragment2) => {
      Transforms.insertFragment(editor, fragment2);
    },
    insertNode: (node) => {
      Transforms.insertNodes(editor, node);
    },
    insertText: (text2) => {
      var {
        selection,
        marks
      } = editor;
      if (selection) {
        if (marks) {
          var node = _objectSpread$9({
            text: text2
          }, marks);
          Transforms.insertNodes(editor, node);
        } else {
          Transforms.insertText(editor, text2);
        }
        editor.marks = null;
      }
    },
    normalizeNode: (entry) => {
      var [node, path] = entry;
      if (Text.isText(node)) {
        return;
      }
      if (Element$1.isElement(node) && node.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor$1.isEditor(node) ? false : Element$1.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));
      var n2 = 0;
      for (var i2 = 0; i2 < node.children.length; i2++, n2++) {
        var currentNode = Node$1.get(editor, path);
        if (Text.isText(currentNode))
          continue;
        var _child = node.children[i2];
        var prev = currentNode.children[n2 - 1];
        var isLast = i2 === node.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element$1.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n2),
            voids: true
          });
          n2--;
        } else if (Element$1.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev == null || !Text.isText(prev)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n2),
                voids: true
              });
              n2++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n2 + 1),
                voids: true
              });
              n2++;
            }
          }
        } else {
          if (prev != null && Text.isText(prev)) {
            if (Text.equals(_child, prev, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n2),
                voids: true
              });
              n2--;
            } else if (prev.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n2 - 1),
                voids: true
              });
              n2--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n2),
                voids: true
              });
              n2--;
            }
          }
        }
      }
    },
    removeMark: (key) => {
      var {
        selection
      } = editor;
      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.unsetNodes(editor, key, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor$1.marks(editor) || {});
          delete marks[key];
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    }
  };
  return editor;
};
var getDirtyPaths = (op2) => {
  switch (op2.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path
      } = op2;
      return Path.levels(path);
    }
    case "insert_node": {
      var {
        node,
        path: _path2
      } = op2;
      var levels = Path.levels(_path2);
      var descendants = Text.isText(node) ? [] : Array.from(Node$1.nodes(node), (_ref3) => {
        var [, p3] = _ref3;
        return _path2.concat(p3);
      });
      return [...levels, ...descendants];
    }
    case "merge_node": {
      var {
        path: _path3
      } = op2;
      var ancestors = Path.ancestors(_path3);
      var previousPath = Path.previous(_path3);
      return [...ancestors, previousPath];
    }
    case "move_node": {
      var {
        path: _path4,
        newPath
      } = op2;
      if (Path.equals(_path4, newPath)) {
        return [];
      }
      var oldAncestors = [];
      var newAncestors = [];
      for (var ancestor of Path.ancestors(_path4)) {
        var p2 = Path.transform(ancestor, op2);
        oldAncestors.push(p2);
      }
      for (var _ancestor of Path.ancestors(newPath)) {
        var _p2 = Path.transform(_ancestor, op2);
        newAncestors.push(_p2);
      }
      var newParent = newAncestors[newAncestors.length - 1];
      var newIndex = newPath[newPath.length - 1];
      var resultPath = newParent.concat(newIndex);
      return [...oldAncestors, ...newAncestors, resultPath];
    }
    case "remove_node": {
      var {
        path: _path5
      } = op2;
      var _ancestors = Path.ancestors(_path5);
      return [..._ancestors];
    }
    case "split_node": {
      var {
        path: _path6
      } = op2;
      var _levels = Path.levels(_path6);
      var nextPath = Path.next(_path6);
      return [..._levels, nextPath];
    }
    default: {
      return [];
    }
  }
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance2 = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char of codepoints) {
    var code = char.codePointAt(0);
    if (!code)
      break;
    var type2 = getCodepointType(char, code);
    [left, right] = isLTR ? [right, type2] : [type2, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance2));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance2));
      }
      if (!gb11)
        break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance2));
        }
      }
      if (!gb12Or13)
        break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance2 += char.length;
  }
  return distance2 || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text2) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist2 = 0;
  var started = false;
  while (text2.length > 0) {
    var charDist = getCharacterDistance(text2, isRTL);
    var [char, remaining] = splitByCharacterDistance(text2, charDist, isRTL);
    if (isWordCharacter(char, remaining, isRTL)) {
      started = true;
      dist2 += charDist;
    } else if (!started) {
      dist2 += charDist;
    } else {
      break;
    }
    text2 = remaining;
  }
  return dist2;
};
var splitByCharacterDistance = (str, dist2, isRTL) => {
  if (isRTL) {
    var at2 = str.length - dist2;
    return [str.slice(at2, str.length), str.slice(0, at2)];
  }
  return [str.slice(0, dist2), str.slice(dist2)];
};
var isWordCharacter = function isWordCharacter2(char, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE.test(char)) {
    return false;
  }
  if (CHAMELEON.test(char)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end2 = str.length - 1;
  for (var i2 = 0; i2 < str.length; i2++) {
    var char1 = str.charAt(end2 - i2);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end2 - i2 - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i2++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char, code) => {
  var type2 = CodepointType.Any;
  if (char.search(reExtend) !== -1) {
    type2 |= CodepointType.Extend;
  }
  if (code === 8205) {
    type2 |= CodepointType.ZWJ;
  }
  if (code >= 127462 && code <= 127487) {
    type2 |= CodepointType.RI;
  }
  if (char.search(rePrepend) !== -1) {
    type2 |= CodepointType.Prepend;
  }
  if (char.search(reSpacingMark) !== -1) {
    type2 |= CodepointType.SpacingMark;
  }
  if (char.search(reL) !== -1) {
    type2 |= CodepointType.L;
  }
  if (char.search(reV) !== -1) {
    type2 |= CodepointType.V;
  }
  if (char.search(reT) !== -1) {
    type2 |= CodepointType.T;
  }
  if (char.search(reLV) !== -1) {
    type2 |= CodepointType.LV;
  }
  if (char.search(reLVT) !== -1) {
    type2 |= CodepointType.LVT;
  }
  if (char.search(reExtPict) !== -1) {
    type2 |= CodepointType.ExtPict;
  }
  return type2;
};
function intersects(x2, y2) {
  return (x2 & y2) !== 0;
}
var NonBoundaryPairs = [
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  [CodepointType.Any, CodepointType.SpacingMark],
  [CodepointType.Prepend, CodepointType.Any],
  [CodepointType.ZWJ, CodepointType.ExtPict],
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r2) => intersects(left, r2[0]) && intersects(right, r2[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match = str.match(endingRIs);
  if (match === null) {
    return false;
  } else {
    var numRIs = match[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var isElement$1 = (value) => {
  return isPlainObject(value) && Node$1.isNodeList(value.children) && !Editor$1.isEditor(value);
};
var Element$1 = {
  isAncestor(value) {
    return isPlainObject(value) && Node$1.isNodeList(value.children);
  },
  isElement: isElement$1,
  isElementList(value) {
    return Array.isArray(value) && value.every((val2) => Element$1.isElement(val2));
  },
  isElementProps(props) {
    return props.children !== void 0;
  },
  isElementType: function isElementType(value, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement$1(value) && value[elementKey] === elementVal;
  },
  matches(element, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$4 = ["text"], _excluded2$3 = ["text"];
function ownKeys$8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var Editor$1 = {
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      voids = false,
      mode = "lowest",
      at: at2 = editor.selection,
      match
    } = options;
    if (!at2) {
      return;
    }
    var path = Editor$1.path(editor, at2);
    var reverse2 = mode === "lowest";
    for (var [n2, p2] of Editor$1.levels(editor, {
      at: path,
      voids,
      match,
      reverse: reverse2
    })) {
      if (!Text.isText(n2) && !Path.equals(path, p2)) {
        return [n2, p2];
      }
    }
  },
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },
  after(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor$1.point(editor, at2, {
      edge: "end"
    });
    var focus2 = Editor$1.end(editor, []);
    var range2 = {
      anchor,
      focus: focus2
    };
    var {
      distance: distance2 = 1
    } = options;
    var d3 = 0;
    var target;
    for (var p2 of Editor$1.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range2
    }))) {
      if (d3 > distance2) {
        break;
      }
      if (d3 !== 0) {
        target = p2;
      }
      d3++;
    }
    return target;
  },
  before(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor$1.start(editor, []);
    var focus2 = Editor$1.point(editor, at2, {
      edge: "start"
    });
    var range2 = {
      anchor,
      focus: focus2
    };
    var {
      distance: distance2 = 1
    } = options;
    var d3 = 0;
    var target;
    for (var p2 of Editor$1.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range2,
      reverse: true
    }))) {
      if (d3 > distance2) {
        break;
      }
      if (d3 !== 0) {
        target = p2;
      }
      d3++;
    }
    return target;
  },
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteBackward(unit);
  },
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteForward(unit);
  },
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      direction = "forward"
    } = options;
    editor.deleteFragment(direction);
  },
  edges(editor, at2) {
    return [Editor$1.start(editor, at2), Editor$1.end(editor, at2)];
  },
  end(editor, at2) {
    return Editor$1.point(editor, at2, {
      edge: "end"
    });
  },
  first(editor, at2) {
    var path = Editor$1.path(editor, at2, {
      edge: "start"
    });
    return Editor$1.node(editor, path);
  },
  fragment(editor, at2) {
    var range2 = Editor$1.range(editor, at2);
    var fragment2 = Node$1.fragment(editor, range2);
    return fragment2;
  },
  hasBlocks(editor, element) {
    return element.children.some((n2) => Editor$1.isBlock(editor, n2));
  },
  hasInlines(editor, element) {
    return element.children.some((n2) => Text.isText(n2) || Editor$1.isInline(editor, n2));
  },
  hasTexts(editor, element) {
    return element.children.every((n2) => Text.isText(n2));
  },
  insertBreak(editor) {
    editor.insertBreak();
  },
  insertFragment(editor, fragment2) {
    editor.insertFragment(fragment2);
  },
  insertNode(editor, node) {
    editor.insertNode(node);
  },
  insertText(editor, text2) {
    editor.insertText(text2);
  },
  isBlock(editor, value) {
    return Element$1.isElement(value) && !editor.isInline(value);
  },
  isEditor(value) {
    if (!isPlainObject(value))
      return false;
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);
    if (cachedIsEditor !== void 0) {
      return cachedIsEditor;
    }
    var isEditor = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteBackward === "function" && typeof value.deleteForward === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isInline === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node$1.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor);
    return isEditor;
  },
  isEnd(editor, point, at2) {
    var end2 = Editor$1.end(editor, at2);
    return Point.equals(point, end2);
  },
  isEdge(editor, point, at2) {
    return Editor$1.isStart(editor, point, at2) || Editor$1.isEnd(editor, point, at2);
  },
  isEmpty(editor, element) {
    var {
      children: children2
    } = element;
    var [first2] = children2;
    return children2.length === 0 || children2.length === 1 && Text.isText(first2) && first2.text === "" && !editor.isVoid(element);
  },
  isInline(editor, value) {
    return Element$1.isElement(value) && editor.isInline(value);
  },
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === void 0 ? true : isNormalizing;
  },
  isStart(editor, point, at2) {
    if (point.offset !== 0) {
      return false;
    }
    var start2 = Editor$1.start(editor, at2);
    return Point.equals(point, start2);
  },
  isVoid(editor, value) {
    return Element$1.isElement(value) && editor.isVoid(value);
  },
  last(editor, at2) {
    var path = Editor$1.path(editor, at2, {
      edge: "end"
    });
    return Editor$1.node(editor, path);
  },
  leaf(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor$1.path(editor, at2, options);
    var node = Node$1.leaf(editor, path);
    return [node, path];
  },
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at: at2 = editor.selection,
      reverse: reverse2 = false,
      voids = false
    } = options;
    var {
      match
    } = options;
    if (match == null) {
      match = () => true;
    }
    if (!at2) {
      return;
    }
    var levels = [];
    var path = Editor$1.path(editor, at2);
    for (var [n2, p2] of Node$1.levels(editor, path)) {
      if (!match(n2, p2)) {
        continue;
      }
      levels.push([n2, p2]);
      if (!voids && Editor$1.isVoid(editor, n2)) {
        break;
      }
    }
    if (reverse2) {
      levels.reverse();
    }
    yield* levels;
  },
  marks(editor) {
    var {
      marks,
      selection
    } = editor;
    if (!selection) {
      return null;
    }
    if (marks) {
      return marks;
    }
    if (Range.isExpanded(selection)) {
      var [match] = Editor$1.nodes(editor, {
        match: Text.isText
      });
      if (match) {
        var [_node] = match;
        var _rest = _objectWithoutProperties(_node, _excluded$4);
        return _rest;
      } else {
        return {};
      }
    }
    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor$1.leaf(editor, path);
    if (anchor.offset === 0) {
      var prev = Editor$1.previous(editor, {
        at: path,
        match: Text.isText
      });
      var block = Editor$1.above(editor, {
        match: (n2) => Editor$1.isBlock(editor, n2)
      });
      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;
        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }
    var rest = _objectWithoutProperties(node, _excluded2$3);
    return rest;
  },
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match,
      at: at2 = editor.selection
    } = options;
    if (!at2) {
      return;
    }
    var pointAfterLocation = Editor$1.after(editor, at2, {
      voids
    });
    if (!pointAfterLocation)
      return;
    var [, to2] = Editor$1.last(editor, []);
    var span = [pointAfterLocation.path, to2];
    if (Path.isPath(at2) && at2.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }
    if (match == null) {
      if (Path.isPath(at2)) {
        var [parent2] = Editor$1.parent(editor, at2);
        match = (n2) => parent2.children.includes(n2);
      } else {
        match = () => true;
      }
    }
    var [next] = Editor$1.nodes(editor, {
      at: span,
      match,
      mode,
      voids
    });
    return next;
  },
  node(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor$1.path(editor, at2, options);
    var node = Node$1.get(editor, path);
    return [node, path];
  },
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at: at2 = editor.selection,
      mode = "all",
      universal = false,
      reverse: reverse2 = false,
      voids = false
    } = options;
    var {
      match
    } = options;
    if (!match) {
      match = () => true;
    }
    if (!at2) {
      return;
    }
    var from;
    var to2;
    if (Span.isSpan(at2)) {
      from = at2[0];
      to2 = at2[1];
    } else {
      var first2 = Editor$1.path(editor, at2, {
        edge: "start"
      });
      var last2 = Editor$1.path(editor, at2, {
        edge: "end"
      });
      from = reverse2 ? last2 : first2;
      to2 = reverse2 ? first2 : last2;
    }
    var nodeEntries = Node$1.nodes(editor, {
      reverse: reverse2,
      from,
      to: to2,
      pass: (_ref) => {
        var [n2] = _ref;
        return voids ? false : Editor$1.isVoid(editor, n2);
      }
    });
    var matches = [];
    var hit;
    for (var [node, path] of nodeEntries) {
      var isLower = hit && Path.compare(path, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match(node, path)) {
        if (universal && !isLower && Text.isText(node)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node, path];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node, path];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node, path];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  },
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      force = false
    } = options;
    var getDirtyPaths2 = (editor2) => {
      return DIRTY_PATHS.get(editor2) || [];
    };
    if (!Editor$1.isNormalizing(editor)) {
      return;
    }
    if (force) {
      var allPaths = Array.from(Node$1.nodes(editor), (_ref2) => {
        var [, p2] = _ref2;
        return p2;
      });
      DIRTY_PATHS.set(editor, allPaths);
    }
    if (getDirtyPaths2(editor).length === 0) {
      return;
    }
    Editor$1.withoutNormalizing(editor, () => {
      for (var dirtyPath of getDirtyPaths2(editor)) {
        if (Node$1.has(editor, dirtyPath)) {
          var entry = Editor$1.node(editor, dirtyPath);
          var [node, _2] = entry;
          if (Element$1.isElement(node) && node.children.length === 0) {
            editor.normalizeNode(entry);
          }
        }
      }
      var max3 = getDirtyPaths2(editor).length * 42;
      var m2 = 0;
      while (getDirtyPaths2(editor).length !== 0) {
        if (m2 > max3) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max3, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }
        var _dirtyPath = getDirtyPaths2(editor).pop();
        if (Node$1.has(editor, _dirtyPath)) {
          var _entry = Editor$1.node(editor, _dirtyPath);
          editor.normalizeNode(_entry);
        }
        m2++;
      }
    });
  },
  parent(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor$1.path(editor, at2, options);
    var parentPath = Path.parent(path);
    var entry = Editor$1.node(editor, parentPath);
    return entry;
  },
  path(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;
    if (Path.isPath(at2)) {
      if (edge === "start") {
        var [, firstPath] = Node$1.first(editor, at2);
        at2 = firstPath;
      } else if (edge === "end") {
        var [, lastPath] = Node$1.last(editor, at2);
        at2 = lastPath;
      }
    }
    if (Range.isRange(at2)) {
      if (edge === "start") {
        at2 = Range.start(at2);
      } else if (edge === "end") {
        at2 = Range.end(at2);
      } else {
        at2 = Path.common(at2.anchor.path, at2.focus.path);
      }
    }
    if (Point.isPoint(at2)) {
      at2 = at2.path;
    }
    if (depth != null) {
      at2 = at2.slice(0, depth);
    }
    return at2;
  },
  hasPath(editor, path) {
    return Node$1.has(editor, path);
  },
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: path,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var pathRefs = Editor$1.pathRefs(editor);
        pathRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor$1.pathRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      PATH_REFS.set(editor, refs);
    }
    return refs;
  },
  point(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      edge = "start"
    } = options;
    if (Path.isPath(at2)) {
      var path;
      if (edge === "end") {
        var [, lastPath] = Node$1.last(editor, at2);
        path = lastPath;
      } else {
        var [, firstPath] = Node$1.first(editor, at2);
        path = firstPath;
      }
      var node = Node$1.get(editor, path);
      if (!Text.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at2, "] because it has no ").concat(edge, " text node."));
      }
      return {
        path,
        offset: edge === "end" ? node.text.length : 0
      };
    }
    if (Range.isRange(at2)) {
      var [start2, end2] = Range.edges(at2);
      return edge === "start" ? start2 : end2;
    }
    return at2;
  },
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: point,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var pointRefs = Editor$1.pointRefs(editor);
        pointRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor$1.pointRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      POINT_REFS.set(editor, refs);
    }
    return refs;
  },
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at: at2 = editor.selection,
      unit = "offset",
      reverse: reverse2 = false,
      voids = false
    } = options;
    if (!at2) {
      return;
    }
    var range2 = Editor$1.range(editor, at2);
    var [start2, end2] = Range.edges(range2);
    var first2 = reverse2 ? end2 : start2;
    var isNewBlock = false;
    var blockText = "";
    var distance2 = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node, path] of Editor$1.nodes(editor, {
      at: at2,
      reverse: reverse2,
      voids
    })) {
      if (Element$1.isElement(node)) {
        if (!voids && editor.isVoid(node)) {
          yield Editor$1.start(editor, path);
          continue;
        }
        if (editor.isInline(node))
          continue;
        if (Editor$1.hasInlines(editor, node)) {
          var e3 = Path.isAncestor(path, end2.path) ? end2 : Editor$1.end(editor, path);
          var s2 = Path.isAncestor(path, start2.path) ? start2 : Editor$1.start(editor, path);
          blockText = Editor$1.string(editor, {
            anchor: s2,
            focus: e3
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text.isText(node)) {
        var isFirst = Path.equals(path, first2.path);
        if (isFirst) {
          leafTextRemaining = reverse2 ? first2.offset : node.text.length - first2.offset;
          leafTextOffset = first2.offset;
        } else {
          leafTextRemaining = node.text.length;
          leafTextOffset = reverse2 ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance2 === 0) {
            if (blockText === "")
              break;
            distance2 = calcDistance(blockText, unit, reverse2);
            blockText = splitByCharacterDistance(blockText, distance2, reverse2)[1];
          }
          leafTextOffset = reverse2 ? leafTextOffset - distance2 : leafTextOffset + distance2;
          leafTextRemaining = leafTextRemaining - distance2;
          if (leafTextRemaining < 0) {
            distance2 = -leafTextRemaining;
            break;
          }
          distance2 = 0;
          yield {
            path,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text2, unit2, reverse3) {
      if (unit2 === "character") {
        return getCharacterDistance(text2, reverse3);
      } else if (unit2 === "word") {
        return getWordDistance(text2, reverse3);
      } else if (unit2 === "line" || unit2 === "block") {
        return text2.length;
      }
      return 1;
    }
  },
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match,
      at: at2 = editor.selection
    } = options;
    if (!at2) {
      return;
    }
    var pointBeforeLocation = Editor$1.before(editor, at2, {
      voids
    });
    if (!pointBeforeLocation) {
      return;
    }
    var [, to2] = Editor$1.first(editor, []);
    var span = [pointBeforeLocation.path, to2];
    if (Path.isPath(at2) && at2.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }
    if (match == null) {
      if (Path.isPath(at2)) {
        var [parent2] = Editor$1.parent(editor, at2);
        match = (n2) => parent2.children.includes(n2);
      } else {
        match = () => true;
      }
    }
    var [previous] = Editor$1.nodes(editor, {
      reverse: true,
      at: span,
      match,
      mode,
      voids
    });
    return previous;
  },
  range(editor, at2, to2) {
    if (Range.isRange(at2) && !to2) {
      return at2;
    }
    var start2 = Editor$1.start(editor, at2);
    var end2 = Editor$1.end(editor, to2 || at2);
    return {
      anchor: start2,
      focus: end2
    };
  },
  rangeRef(editor, range2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: range2,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var rangeRefs = Editor$1.rangeRefs(editor);
        rangeRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor$1.rangeRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      RANGE_REFS.set(editor, refs);
    }
    return refs;
  },
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },
  start(editor, at2) {
    return Editor$1.point(editor, at2, {
      edge: "start"
    });
  },
  string(editor, at2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range2 = Editor$1.range(editor, at2);
    var [start2, end2] = Range.edges(range2);
    var text2 = "";
    for (var [node, path] of Editor$1.nodes(editor, {
      at: range2,
      match: Text.isText,
      voids
    })) {
      var t2 = node.text;
      if (Path.equals(path, end2.path)) {
        t2 = t2.slice(0, end2.offset);
      }
      if (Path.equals(path, start2.path)) {
        t2 = t2.slice(start2.offset);
      }
      text2 += t2;
    }
    return text2;
  },
  unhangRange(editor, range2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start2, end2] = Range.edges(range2);
    if (start2.offset !== 0 || end2.offset !== 0 || Range.isCollapsed(range2)) {
      return range2;
    }
    var endBlock = Editor$1.above(editor, {
      at: end2,
      match: (n2) => Editor$1.isBlock(editor, n2)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first2 = Editor$1.start(editor, []);
    var before2 = {
      anchor: first2,
      focus: end2
    };
    var skip = true;
    for (var [node, path] of Editor$1.nodes(editor, {
      at: before2,
      match: Text.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }
      if (node.text !== "" || Path.isBefore(path, blockPath)) {
        end2 = {
          path,
          offset: node.text.length
        };
        break;
      }
    }
    return {
      anchor: start2,
      focus: end2
    };
  },
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Editor$1.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: (n2) => Editor$1.isVoid(editor, n2)
    }));
  },
  withoutNormalizing(editor, fn2) {
    var value = Editor$1.isNormalizing(editor);
    Editor$1.setNormalizing(editor, false);
    try {
      fn2();
    } finally {
      Editor$1.setNormalizing(editor, value);
    }
    Editor$1.normalize(editor);
  }
};
var Span = {
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }
};
var _excluded$3 = ["children"], _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node$1 = {
  ancestor(root2, path) {
    var node = Node$1.get(root2, path);
    if (Text.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(node));
    }
    return node;
  },
  *ancestors(root2, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p2 of Path.ancestors(path, options)) {
      var n2 = Node$1.ancestor(root2, p2);
      var entry = [n2, p2];
      yield entry;
    }
  },
  child(root2, index) {
    if (Text.isText(root2)) {
      throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(root2)));
    }
    var c2 = root2.children[index];
    if (c2 == null) {
      throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(JSON.stringify(root2)));
    }
    return c2;
  },
  *children(root2, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      reverse: reverse2 = false
    } = options;
    var ancestor = Node$1.ancestor(root2, path);
    var {
      children: children2
    } = ancestor;
    var index = reverse2 ? children2.length - 1 : 0;
    while (reverse2 ? index >= 0 : index < children2.length) {
      var child = Node$1.child(ancestor, index);
      var childPath = path.concat(index);
      yield [child, childPath];
      index = reverse2 ? index - 1 : index + 1;
    }
  },
  common(root2, path, another) {
    var p2 = Path.common(path, another);
    var n2 = Node$1.get(root2, p2);
    return [n2, p2];
  },
  descendant(root2, path) {
    var node = Node$1.get(root2, path);
    if (Editor$1.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(node));
    }
    return node;
  },
  *descendants(root2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node$1.nodes(root2, options)) {
      if (path.length !== 0) {
        yield [node, path];
      }
    }
  },
  *elements(root2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node$1.nodes(root2, options)) {
      if (Element$1.isElement(node)) {
        yield [node, path];
      }
    }
  },
  extractProps(node) {
    if (Element$1.isAncestor(node)) {
      var properties = _objectWithoutProperties(node, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node, _excluded2$2);
      return properties;
    }
  },
  first(root2, path) {
    var p2 = path.slice();
    var n2 = Node$1.get(root2, p2);
    while (n2) {
      if (Text.isText(n2) || n2.children.length === 0) {
        break;
      } else {
        n2 = n2.children[0];
        p2.push(0);
      }
    }
    return [n2, p2];
  },
  fragment(root2, range2) {
    if (Text.isText(root2)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(root2)));
    }
    var newRoot = fn$7({
      children: root2.children
    }, (r2) => {
      var [start2, end2] = Range.edges(range2);
      var nodeEntries = Node$1.nodes(r2, {
        reverse: true,
        pass: (_ref) => {
          var [, path2] = _ref;
          return !Range.includes(range2, path2);
        }
      });
      for (var [, path] of nodeEntries) {
        if (!Range.includes(range2, path)) {
          var parent2 = Node$1.parent(r2, path);
          var index = path[path.length - 1];
          parent2.children.splice(index, 1);
        }
        if (Path.equals(path, end2.path)) {
          var leaf = Node$1.leaf(r2, path);
          leaf.text = leaf.text.slice(0, end2.offset);
        }
        if (Path.equals(path, start2.path)) {
          var _leaf = Node$1.leaf(r2, path);
          _leaf.text = _leaf.text.slice(start2.offset);
        }
      }
      if (Editor$1.isEditor(r2)) {
        r2.selection = null;
      }
    });
    return newRoot.children;
  },
  get(root2, path) {
    var node = root2;
    for (var i2 = 0; i2 < path.length; i2++) {
      var p2 = path[i2];
      if (Text.isText(node) || !node.children[p2]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(JSON.stringify(root2)));
      }
      node = node.children[p2];
    }
    return node;
  },
  has(root2, path) {
    var node = root2;
    for (var i2 = 0; i2 < path.length; i2++) {
      var p2 = path[i2];
      if (Text.isText(node) || !node.children[p2]) {
        return false;
      }
      node = node.children[p2];
    }
    return true;
  },
  isNode(value) {
    return Text.isText(value) || Element$1.isElement(value) || Editor$1.isEditor(value);
  },
  isNodeList(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value.every((val2) => Node$1.isNode(val2));
    IS_NODE_LIST_CACHE.set(value, isNodeList);
    return isNodeList;
  },
  last(root2, path) {
    var p2 = path.slice();
    var n2 = Node$1.get(root2, p2);
    while (n2) {
      if (Text.isText(n2) || n2.children.length === 0) {
        break;
      } else {
        var i2 = n2.children.length - 1;
        n2 = n2.children[i2];
        p2.push(i2);
      }
    }
    return [n2, p2];
  },
  leaf(root2, path) {
    var node = Node$1.get(root2, path);
    if (!Text.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(node));
    }
    return node;
  },
  *levels(root2, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p2 of Path.levels(path, options)) {
      var n2 = Node$1.get(root2, p2);
      yield [n2, p2];
    }
  },
  matches(node, props) {
    return Element$1.isElement(node) && Element$1.isElementProps(props) && Element$1.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);
  },
  *nodes(root2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      pass,
      reverse: reverse2 = false
    } = options;
    var {
      from = [],
      to: to2
    } = options;
    var visited = /* @__PURE__ */ new Set();
    var p2 = [];
    var n2 = root2;
    while (true) {
      if (to2 && (reverse2 ? Path.isBefore(p2, to2) : Path.isAfter(p2, to2))) {
        break;
      }
      if (!visited.has(n2)) {
        yield [n2, p2];
      }
      if (!visited.has(n2) && !Text.isText(n2) && n2.children.length !== 0 && (pass == null || pass([n2, p2]) === false)) {
        visited.add(n2);
        var nextIndex = reverse2 ? n2.children.length - 1 : 0;
        if (Path.isAncestor(p2, from)) {
          nextIndex = from[p2.length];
        }
        p2 = p2.concat(nextIndex);
        n2 = Node$1.get(root2, p2);
        continue;
      }
      if (p2.length === 0) {
        break;
      }
      if (!reverse2) {
        var newPath = Path.next(p2);
        if (Node$1.has(root2, newPath)) {
          p2 = newPath;
          n2 = Node$1.get(root2, p2);
          continue;
        }
      }
      if (reverse2 && p2[p2.length - 1] !== 0) {
        var _newPath = Path.previous(p2);
        p2 = _newPath;
        n2 = Node$1.get(root2, p2);
        continue;
      }
      p2 = Path.parent(p2);
      n2 = Node$1.get(root2, p2);
      visited.add(n2);
    }
  },
  parent(root2, path) {
    var parentPath = Path.parent(path);
    var p2 = Node$1.get(root2, parentPath);
    if (Text.isText(p2)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }
    return p2;
  },
  string(node) {
    if (Text.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node$1.string).join("");
    }
  },
  *texts(root2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node$1.nodes(root2, options)) {
      if (Text.isText(node)) {
        yield [node, path];
      }
    }
  }
};
function ownKeys$7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Operation = {
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_node");
  },
  isOperation(value) {
    if (!isPlainObject(value)) {
      return false;
    }
    switch (value.type) {
      case "insert_node":
        return Path.isPath(value.path) && Node$1.isNode(value.node);
      case "insert_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "merge_node":
        return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject(value.properties);
      case "move_node":
        return Path.isPath(value.path) && Path.isPath(value.newPath);
      case "remove_node":
        return Path.isPath(value.path) && Node$1.isNode(value.node);
      case "remove_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "set_node":
        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "set_selection":
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "split_node":
        return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject(value.properties);
      default:
        return false;
    }
  },
  isOperationList(value) {
    return Array.isArray(value) && value.every((val2) => Operation.isOperation(val2));
  },
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_selection");
  },
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_text");
  },
  inverse(op2) {
    switch (op2.type) {
      case "insert_node": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "split_node",
          path: Path.previous(op2.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path
        } = op2;
        if (Path.equals(newPath, path)) {
          return op2;
        }
        if (Path.isSibling(path, newPath)) {
          return _objectSpread$7(_objectSpread$7({}, op2), {}, {
            path: newPath,
            newPath: path
          });
        }
        var inversePath = Path.transform(path, op2);
        var inverseNewPath = Path.transform(Path.next(path), op2);
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op2;
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op2;
        if (_properties == null) {
          return _objectSpread$7(_objectSpread$7({}, op2), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$7(_objectSpread$7({}, op2), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$7(_objectSpread$7({}, op2), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$7(_objectSpread$7({}, op2), {}, {
          type: "merge_node",
          path: Path.next(op2.path)
        });
      }
    }
  }
};
var Path = {
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse: reverse2 = false
    } = options;
    var paths = Path.levels(path, options);
    if (reverse2) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  common(path, another) {
    var common = [];
    for (var i2 = 0; i2 < path.length && i2 < another.length; i2++) {
      var av = path[i2];
      var bv = another[i2];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  compare(path, another) {
    var min3 = Math.min(path.length, another.length);
    for (var i2 = 0; i2 < min3; i2++) {
      if (path[i2] < another[i2])
        return -1;
      if (path[i2] > another[i2])
        return 1;
    }
    return 0;
  },
  endsAfter(path, another) {
    var i2 = path.length - 1;
    var as2 = path.slice(0, i2);
    var bs2 = another.slice(0, i2);
    var av = path[i2];
    var bv = another[i2];
    return Path.equals(as2, bs2) && av > bv;
  },
  endsAt(path, another) {
    var i2 = path.length;
    var as2 = path.slice(0, i2);
    var bs2 = another.slice(0, i2);
    return Path.equals(as2, bs2);
  },
  endsBefore(path, another) {
    var i2 = path.length - 1;
    var as2 = path.slice(0, i2);
    var bs2 = another.slice(0, i2);
    var av = path[i2];
    var bv = another[i2];
    return Path.equals(as2, bs2) && av < bv;
  },
  equals(path, another) {
    return path.length === another.length && path.every((n2, i2) => n2 === another[i2]);
  },
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
  },
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }
    var as2 = path.slice(0, -1);
    var bs2 = another.slice(0, -1);
    var al2 = path[path.length - 1];
    var bl2 = another[another.length - 1];
    return al2 !== bl2 && Path.equals(as2, bs2);
  },
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse: reverse2 = false
    } = options;
    var list = [];
    for (var i2 = 0; i2 <= path.length; i2++) {
      list.push(path.slice(0, i2));
    }
    if (reverse2) {
      list.reverse();
    }
    return list;
  },
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }
    var last2 = path[path.length - 1];
    return path.slice(0, -1).concat(last2 + 1);
  },
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }
    return path.slice(0, -1);
  },
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }
    var last2 = path[path.length - 1];
    if (last2 <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }
    return path.slice(0, -1).concat(last2 - 1);
  },
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path.slice(ancestor.length);
  },
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn$7(path, (p2) => {
      var {
        affinity = "forward"
      } = options;
      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {
        return;
      }
      if (p2 === null) {
        return null;
      }
      switch (operation.type) {
        case "insert_node": {
          var {
            path: op2
          } = operation;
          if (Path.equals(op2, p2) || Path.endsBefore(op2, p2) || Path.isAncestor(op2, p2)) {
            p2[op2.length - 1] += 1;
          }
          break;
        }
        case "remove_node": {
          var {
            path: _op
          } = operation;
          if (Path.equals(_op, p2) || Path.isAncestor(_op, p2)) {
            return null;
          } else if (Path.endsBefore(_op, p2)) {
            p2[_op.length - 1] -= 1;
          }
          break;
        }
        case "merge_node": {
          var {
            path: _op2,
            position
          } = operation;
          if (Path.equals(_op2, p2) || Path.endsBefore(_op2, p2)) {
            p2[_op2.length - 1] -= 1;
          } else if (Path.isAncestor(_op2, p2)) {
            p2[_op2.length - 1] -= 1;
            p2[_op2.length] += position;
          }
          break;
        }
        case "split_node": {
          var {
            path: _op3,
            position: _position
          } = operation;
          if (Path.equals(_op3, p2)) {
            if (affinity === "forward") {
              p2[p2.length - 1] += 1;
            } else if (affinity === "backward")
              ;
            else {
              return null;
            }
          } else if (Path.endsBefore(_op3, p2)) {
            p2[_op3.length - 1] += 1;
          } else if (Path.isAncestor(_op3, p2) && path[_op3.length] >= _position) {
            p2[_op3.length - 1] += 1;
            p2[_op3.length] -= _position;
          }
          break;
        }
        case "move_node": {
          var {
            path: _op4,
            newPath: onp
          } = operation;
          if (Path.equals(_op4, onp)) {
            return;
          }
          if (Path.isAncestor(_op4, p2) || Path.equals(_op4, p2)) {
            var copy2 = onp.slice();
            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
              copy2[_op4.length - 1] -= 1;
            }
            return copy2.concat(p2.slice(_op4.length));
          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p2) || Path.equals(onp, p2))) {
            if (Path.endsBefore(_op4, p2)) {
              p2[_op4.length - 1] -= 1;
            } else {
              p2[_op4.length - 1] += 1;
            }
          } else if (Path.endsBefore(onp, p2) || Path.equals(onp, p2) || Path.isAncestor(onp, p2)) {
            if (Path.endsBefore(_op4, p2)) {
              p2[_op4.length - 1] -= 1;
            }
            p2[onp.length - 1] += 1;
          } else if (Path.endsBefore(_op4, p2)) {
            if (Path.equals(onp, p2)) {
              p2[onp.length - 1] += 1;
            }
            p2[_op4.length - 1] -= 1;
          }
          break;
        }
      }
    });
  }
};
var PathRef = {
  transform(ref2, op2) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var path = Path.transform(current, op2, {
      affinity
    });
    ref2.current = path;
    if (path == null) {
      ref2.unref();
    }
  }
};
function ownKeys$6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Point = {
  compare(point, another) {
    var result = Path.compare(point.path, another.path);
    if (result === 0) {
      if (point.offset < another.offset)
        return -1;
      if (point.offset > another.offset)
        return 1;
      return 0;
    }
    return result;
  },
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },
  equals(point, another) {
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },
  isPoint(value) {
    return isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
  },
  transform(point, op2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn$7(point, (p2) => {
      if (p2 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options;
      var {
        path,
        offset: offset2
      } = p2;
      switch (op2.type) {
        case "insert_node":
        case "move_node": {
          p2.path = Path.transform(path, op2, options);
          break;
        }
        case "insert_text": {
          if (Path.equals(op2.path, path) && op2.offset <= offset2) {
            p2.offset += op2.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op2.path, path)) {
            p2.offset += op2.position;
          }
          p2.path = Path.transform(path, op2, options);
          break;
        }
        case "remove_text": {
          if (Path.equals(op2.path, path) && op2.offset <= offset2) {
            p2.offset -= Math.min(offset2 - op2.offset, op2.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op2.path, path) || Path.isAncestor(op2.path, path)) {
            return null;
          }
          p2.path = Path.transform(path, op2, options);
          break;
        }
        case "split_node": {
          if (Path.equals(op2.path, path)) {
            if (op2.position === offset2 && affinity == null) {
              return null;
            } else if (op2.position < offset2 || op2.position === offset2 && affinity === "forward") {
              p2.offset -= op2.position;
              p2.path = Path.transform(path, op2, _objectSpread$6(_objectSpread$6({}, options), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p2.path = Path.transform(path, op2, options);
          }
          break;
        }
      }
    });
  }
};
var PointRef = {
  transform(ref2, op2) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var point = Point.transform(current, op2, {
      affinity
    });
    ref2.current = point;
    if (point == null) {
      ref2.unref();
    }
  }
};
var _excluded$2 = ["anchor", "focus"];
function ownKeys$5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Range = {
  edges(range2) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse: reverse2 = false
    } = options;
    var {
      anchor,
      focus: focus2
    } = range2;
    return Range.isBackward(range2) === reverse2 ? [anchor, focus2] : [focus2, anchor];
  },
  end(range2) {
    var [, end2] = Range.edges(range2);
    return end2;
  },
  equals(range2, another) {
    return Point.equals(range2.anchor, another.anchor) && Point.equals(range2.focus, another.focus);
  },
  includes(range2, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range2, target.anchor) || Range.includes(range2, target.focus)) {
        return true;
      }
      var [rs2, re2] = Range.edges(range2);
      var [ts2, te2] = Range.edges(target);
      return Point.isBefore(rs2, ts2) && Point.isAfter(re2, te2);
    }
    var [start2, end2] = Range.edges(range2);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start2) >= 0;
      isBeforeEnd = Point.compare(target, end2) <= 0;
    } else {
      isAfterStart = Path.compare(target, start2.path) >= 0;
      isBeforeEnd = Path.compare(target, end2.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  intersection(range2, another) {
    var rest = _objectWithoutProperties(range2, _excluded$2);
    var [s1, e1] = Range.edges(range2);
    var [s2, e22] = Range.edges(another);
    var start2 = Point.isBefore(s1, s2) ? s2 : s1;
    var end2 = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end2, start2)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start2,
        focus: end2
      }, rest);
    }
  },
  isBackward(range2) {
    var {
      anchor,
      focus: focus2
    } = range2;
    return Point.isAfter(anchor, focus2);
  },
  isCollapsed(range2) {
    var {
      anchor,
      focus: focus2
    } = range2;
    return Point.equals(anchor, focus2);
  },
  isExpanded(range2) {
    return !Range.isCollapsed(range2);
  },
  isForward(range2) {
    return !Range.isBackward(range2);
  },
  isRange(value) {
    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },
  *points(range2) {
    yield [range2.anchor, "anchor"];
    yield [range2.focus, "focus"];
  },
  start(range2) {
    var [start2] = Range.edges(range2);
    return start2;
  },
  transform(range2, op2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn$7(range2, (r2) => {
      if (r2 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed = Range.isCollapsed(r2);
        if (Range.isForward(r2)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r2)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r2.anchor, op2, {
        affinity: affinityAnchor
      });
      var focus2 = Point.transform(r2.focus, op2, {
        affinity: affinityFocus
      });
      if (!anchor || !focus2) {
        return null;
      }
      r2.anchor = anchor;
      r2.focus = focus2;
    });
  }
};
var RangeRef = {
  transform(ref2, op2) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var path = Range.transform(current, op2, {
      affinity
    });
    ref2.current = path;
    if (path == null) {
      ref2.unref();
    }
  }
};
var isDeepEqual = (node, another) => {
  for (var key in node) {
    var a2 = node[key];
    var b2 = another[key];
    if (isPlainObject(a2) && isPlainObject(b2)) {
      if (!isDeepEqual(a2, b2))
        return false;
    } else if (Array.isArray(a2) && Array.isArray(b2)) {
      if (a2.length !== b2.length)
        return false;
      for (var i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b2[i2])
          return false;
      }
    } else if (a2 !== b2) {
      return false;
    }
  }
  for (var _key in another) {
    if (node[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
var _excluded$1 = ["text"], _excluded2$1 = ["anchor", "focus"];
function ownKeys$4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Text = {
  equals(text2, another) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$1);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text2) : text2, loose ? omitText(another) : another);
  },
  isText(value) {
    return isPlainObject(value) && typeof value.text === "string";
  },
  isTextList(value) {
    return Array.isArray(value) && value.every((val2) => Text.isText(val2));
  },
  isTextProps(props) {
    return props.text !== void 0;
  },
  matches(text2, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text2.hasOwnProperty(key) || text2[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  decorations(node, decorations) {
    var leaves = [_objectSpread$4({}, node)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$1);
      var [start2, end2] = Range.edges(dec);
      var next = [];
      var o2 = 0;
      for (var leaf of leaves) {
        var {
          length: length2
        } = leaf.text;
        var offset2 = o2;
        o2 += length2;
        if (start2.offset <= offset2 && end2.offset >= o2) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        }
        if (start2.offset !== end2.offset && (start2.offset === o2 || end2.offset === offset2) || start2.offset > o2 || end2.offset < offset2 || end2.offset === offset2 && offset2 !== 0) {
          next.push(leaf);
          continue;
        }
        var middle = leaf;
        var before2 = void 0;
        var after2 = void 0;
        if (end2.offset < o2) {
          var off2 = end2.offset - offset2;
          after2 = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off2)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off2)
          });
        }
        if (start2.offset > offset2) {
          var _off = start2.offset - offset2;
          before2 = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before2) {
          next.push(before2);
        }
        next.push(middle);
        if (after2) {
          next.push(after2);
        }
      }
      leaves = next;
    }
    return leaves;
  }
};
function ownKeys$3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var applyToDraft = (editor, selection, op2) => {
  switch (op2.type) {
    case "insert_node": {
      var {
        path,
        node
      } = op2;
      var parent2 = Node$1.parent(editor, path);
      var index = path[path.length - 1];
      if (index > parent2.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path, "] because the destination is past the end of the node."));
      }
      parent2.children.splice(index, 0, node);
      if (selection) {
        for (var [point, key] of Range.points(selection)) {
          selection[key] = Point.transform(point, op2);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset: offset2,
        text: text2
      } = op2;
      if (text2.length === 0)
        break;
      var _node = Node$1.leaf(editor, _path);
      var before2 = _node.text.slice(0, offset2);
      var after2 = _node.text.slice(offset2);
      _node.text = before2 + text2 + after2;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op2);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op2;
      var _node2 = Node$1.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev = Node$1.get(editor, prevPath);
      var _parent = Node$1.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text.isText(_node2) && Text.isText(prev)) {
        prev.text += _node2.text;
      } else if (!Text.isText(_node2) && !Text.isText(prev)) {
        prev.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(_node2, " ").concat(prev));
      }
      _parent.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op2);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op2;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node$1.get(editor, _path3);
      var _parent2 = Node$1.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent2.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op2);
      var newParent = Node$1.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op2);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op2;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node$1.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op2);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev = void 0;
            var next = void 0;
            for (var [n2, p2] of Node$1.texts(editor)) {
              if (Path.compare(p2, _path4) === -1) {
                _prev = [n2, p2];
              } else {
                next = [n2, p2];
                break;
              }
            }
            var preferNext = false;
            if (_prev && next) {
              if (Path.equals(next[1], _path4)) {
                preferNext = !Path.hasPrevious(next[1]);
              } else {
                preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
              }
            }
            if (_prev && !preferNext) {
              _point4.path = _prev[1];
              _point4.offset = _prev[0].text.length;
            } else if (next) {
              _point4.path = next[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op2;
      if (_text.length === 0)
        break;
      var _node4 = Node$1.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op2);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op2;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node$1.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value = newProperties[_key6];
        if (value == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op2;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(JSON.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$3({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value2 = _newProperties[_key8];
          if (_value2 == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value2;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position,
        properties: _properties
      } = op2;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node$1.get(editor, _path7);
      var _parent4 = Node$1.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position);
        var _after2 = _node6.text.slice(position);
        _node6.text = _before2;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position);
        var _after3 = _node6.children.slice(position);
        _node6.children = _before3;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op2);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  transform(editor, op2) {
    editor.children = ln$7(editor.children);
    var selection = editor.selection && ln$7(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op2);
    } finally {
      editor.children = dn$7(editor.children);
      if (selection) {
        editor.selection = t(selection) ? dn$7(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var _excluded = ["text"], _excluded2 = ["children"];
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NodeTransforms = {
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at: at2,
        match,
        select: select2
      } = options;
      if (Node$1.isNode(nodes)) {
        nodes = [nodes];
      }
      if (nodes.length === 0) {
        return;
      }
      var [node] = nodes;
      if (!at2) {
        if (editor.selection) {
          at2 = editor.selection;
        } else if (editor.children.length > 0) {
          at2 = Editor$1.end(editor, []);
        } else {
          at2 = [0];
        }
        select2 = true;
      }
      if (select2 == null) {
        select2 = false;
      }
      if (Range.isRange(at2)) {
        if (!hanging) {
          at2 = Editor$1.unhangRange(editor, at2);
        }
        if (Range.isCollapsed(at2)) {
          at2 = at2.anchor;
        } else {
          var [, end2] = Range.edges(at2);
          var pointRef = Editor$1.pointRef(editor, end2);
          Transforms.delete(editor, {
            at: at2
          });
          at2 = pointRef.unref();
        }
      }
      if (Point.isPoint(at2)) {
        if (match == null) {
          if (Text.isText(node)) {
            match = (n2) => Text.isText(n2);
          } else if (editor.isInline(node)) {
            match = (n2) => Text.isText(n2) || Editor$1.isInline(editor, n2);
          } else {
            match = (n2) => Editor$1.isBlock(editor, n2);
          }
        }
        var [entry] = Editor$1.nodes(editor, {
          at: at2.path,
          match,
          mode,
          voids
        });
        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor$1.pathRef(editor, _matchPath);
          var isAtEnd = Editor$1.isEnd(editor, at2, _matchPath);
          Transforms.splitNodes(editor, {
            at: at2,
            match,
            mode,
            voids
          });
          var path = pathRef.unref();
          at2 = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }
      var parentPath = Path.parent(at2);
      var index = at2[at2.length - 1];
      if (!voids && Editor$1.void(editor, {
        at: parentPath
      })) {
        return;
      }
      for (var _node of nodes) {
        var _path = parentPath.concat(index);
        index++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node
        });
        at2 = Path.next(at2);
      }
      at2 = Path.previous(at2);
      if (select2) {
        var point = Editor$1.end(editor, at2);
        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        at: at2 = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match
      } = options;
      if (match == null) {
        match = Path.isPath(at2) ? matchPath(editor, at2) : (n2) => Editor$1.isBlock(editor, n2);
      }
      if (!at2) {
        return;
      }
      var matches = Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p2] = _ref;
        return Editor$1.pathRef(editor, p2);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }
        var parentNodeEntry = Editor$1.node(editor, Path.parent(path));
        var [parent2, parentPath] = parentNodeEntry;
        var index = path[path.length - 1];
        var {
          length: length2
        } = parent2.children;
        if (length2 === 1) {
          var toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index === length2 - 1) {
          var _toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);
          var _toPath2 = Path.next(parentPath);
          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        match,
        at: at2 = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        if (Path.isPath(at2)) {
          var [parent2] = Editor$1.parent(editor, at2);
          match = (n2) => parent2.children.includes(n2);
        } else {
          match = (n2) => Editor$1.isBlock(editor, n2);
        }
      }
      if (!hanging && Range.isRange(at2)) {
        at2 = Editor$1.unhangRange(editor, at2);
      }
      if (Range.isRange(at2)) {
        if (Range.isCollapsed(at2)) {
          at2 = at2.anchor;
        } else {
          var [, end2] = Range.edges(at2);
          var pointRef = Editor$1.pointRef(editor, end2);
          Transforms.delete(editor, {
            at: at2
          });
          at2 = pointRef.unref();
          if (options.at == null) {
            Transforms.select(editor, at2);
          }
        }
      }
      var [current] = Editor$1.nodes(editor, {
        at: at2,
        match,
        voids,
        mode
      });
      var prev = Editor$1.previous(editor, {
        at: at2,
        match,
        voids,
        mode
      });
      if (!current || !prev) {
        return;
      }
      var [node, path] = current;
      var [prevNode, prevPath] = prev;
      if (path.length === 0 || prevPath.length === 0) {
        return;
      }
      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor$1.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n2] = _ref2;
        return n2;
      }).slice(commonPath.length).slice(0, -1);
      var emptyAncestor = Editor$1.above(editor, {
        at: path,
        mode: "highest",
        match: (n2) => levels.includes(n2) && hasSingleChildNest(editor, n2)
      });
      var emptyRef = emptyAncestor && Editor$1.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position;
      if (Text.isText(node) && Text.isText(prevNode)) {
        var rest = _objectWithoutProperties(node, _excluded);
        position = prevNode.text.length;
        properties = rest;
      } else if (Element$1.isElement(node) && Element$1.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node, _excluded2);
        position = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(node), " ").concat(JSON.stringify(prevNode)));
      }
      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      }
      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      }
      if (Element$1.isElement(prevNode) && Editor$1.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: "merge_node",
          path: newPath,
          position,
          properties
        });
      }
      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },
  moveNodes(editor, options) {
    Editor$1.withoutNormalizing(editor, () => {
      var {
        to: to2,
        at: at2 = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        match = Path.isPath(at2) ? matchPath(editor, at2) : (n2) => Editor$1.isBlock(editor, n2);
      }
      var toRef2 = Editor$1.pathRef(editor, to2);
      var targets = Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p2] = _ref3;
        return Editor$1.pathRef(editor, p2);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef2.current;
        if (path.length !== 0) {
          editor.apply({
            type: "move_node",
            path,
            newPath
          });
        }
        if (toRef2.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
          toRef2.current = Path.next(toRef2.current);
        }
      }
      toRef2.unref();
    });
  },
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at: at2 = editor.selection,
        match
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        match = Path.isPath(at2) ? matchPath(editor, at2) : (n2) => Editor$1.isBlock(editor, n2);
      }
      if (!hanging && Range.isRange(at2)) {
        at2 = Editor$1.unhangRange(editor, at2);
      }
      var depths = Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p2] = _ref4;
        return Editor$1.pathRef(editor, p2);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path) {
          var [node] = Editor$1.node(editor, path);
          editor.apply({
            type: "remove_node",
            path,
            node
          });
        }
      }
    });
  },
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        match,
        at: at2 = editor.selection
      } = options;
      var {
        hanging = false,
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        match = Path.isPath(at2) ? matchPath(editor, at2) : (n2) => Editor$1.isBlock(editor, n2);
      }
      if (!hanging && Range.isRange(at2)) {
        at2 = Editor$1.unhangRange(editor, at2);
      }
      if (split2 && Range.isRange(at2)) {
        if (Range.isCollapsed(at2) && Editor$1.leaf(editor, at2.anchor)[0].text.length > 0) {
          return;
        }
        var rangeRef = Editor$1.rangeRef(editor, at2, {
          affinity: "inward"
        });
        var [start2, end2] = Range.edges(at2);
        var splitMode = mode === "lowest" ? "lowest" : "highest";
        var endAtEndOfNode = Editor$1.isEnd(editor, end2, end2.path);
        Transforms.splitNodes(editor, {
          at: end2,
          match,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor$1.isStart(editor, start2, start2.path);
        Transforms.splitNodes(editor, {
          at: start2,
          match,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at2 = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at2);
        }
      }
      for (var [node, path] of Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {};
        if (path.length === 0) {
          continue;
        }
        var hasChanges = false;
        for (var k2 in props) {
          if (k2 === "children" || k2 === "text") {
            continue;
          }
          if (props[k2] !== node[k2]) {
            hasChanges = true;
            if (node.hasOwnProperty(k2))
              properties[k2] = node[k2];
            if (props[k2] != null)
              newProperties[k2] = props[k2];
          }
        }
        if (hasChanges) {
          editor.apply({
            type: "set_node",
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match,
        at: at2 = editor.selection,
        height: height2 = 0,
        always = false
      } = options;
      if (match == null) {
        match = (n2) => Editor$1.isBlock(editor, n2);
      }
      if (Range.isRange(at2)) {
        at2 = deleteRange(editor, at2);
      }
      if (Path.isPath(at2)) {
        var path = at2;
        var point = Editor$1.point(editor, path);
        var [parent2] = Editor$1.parent(editor, path);
        match = (n2) => n2 === parent2;
        height2 = point.path.length - path.length + 1;
        at2 = point;
        always = true;
      }
      if (!at2) {
        return;
      }
      var beforeRef = Editor$1.pointRef(editor, at2, {
        affinity: "backward"
      });
      var [highest] = Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      if (!highest) {
        return;
      }
      var voidMatch = Editor$1.void(editor, {
        at: at2,
        mode: "highest"
      });
      var nudge = 0;
      if (!voids && voidMatch) {
        var [voidNode, voidPath] = voidMatch;
        if (Element$1.isElement(voidNode) && editor.isInline(voidNode)) {
          var after2 = Editor$1.after(editor, voidPath);
          if (!after2) {
            var text2 = {
              text: ""
            };
            var afterPath = Path.next(voidPath);
            Transforms.insertNodes(editor, text2, {
              at: afterPath,
              voids
            });
            after2 = Editor$1.point(editor, afterPath);
          }
          at2 = after2;
          always = true;
        }
        var siblingHeight = at2.path.length - voidPath.length;
        height2 = siblingHeight + 1;
        always = true;
      }
      var afterRef = Editor$1.pointRef(editor, at2);
      var depth = at2.path.length - height2;
      var [, highestPath] = highest;
      var lowestPath = at2.path.slice(0, depth);
      var position = height2 === 0 ? at2.offset : at2.path[depth] + nudge;
      for (var [node, _path2] of Editor$1.levels(editor, {
        at: lowestPath,
        reverse: true,
        voids
      })) {
        var split2 = false;
        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor$1.isVoid(editor, node)) {
          break;
        }
        var _point = beforeRef.current;
        var isEnd = Editor$1.isEnd(editor, _point, _path2);
        if (always || !beforeRef || !Editor$1.isEdge(editor, _point, _path2)) {
          split2 = true;
          var properties = Node$1.extractProps(node);
          editor.apply({
            type: "split_node",
            path: _path2,
            position,
            properties
          });
        }
        position = _path2[_path2.length - 1] + (split2 || isEnd ? 1 : 0);
      }
      if (options.at == null) {
        var _point2 = afterRef.current || Editor$1.end(editor, []);
        Transforms.select(editor, _point2);
      }
      beforeRef.unref();
      afterRef.unref();
    });
  },
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!Array.isArray(props)) {
      props = [props];
    }
    var obj = {};
    for (var key of props) {
      obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
  },
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        at: at2 = editor.selection,
        match
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        match = Path.isPath(at2) ? matchPath(editor, at2) : (n2) => Editor$1.isBlock(editor, n2);
      }
      if (Path.isPath(at2)) {
        at2 = Editor$1.range(editor, at2);
      }
      var rangeRef = Range.isRange(at2) ? Editor$1.rangeRef(editor, at2) : null;
      var matches = Editor$1.nodes(editor, {
        at: at2,
        match,
        mode,
        voids
      });
      var pathRefs = Array.from(
        matches,
        (_ref5) => {
          var [, p2] = _ref5;
          return Editor$1.pathRef(editor, p2);
        }
      ).reverse();
      var _loop = function _loop2(pathRef2) {
        var path = pathRef2.unref();
        var [node] = Editor$1.node(editor, path);
        var range2 = Editor$1.range(editor, path);
        if (split2 && rangeRef) {
          range2 = Range.intersection(rangeRef.current, range2);
        }
        Transforms.liftNodes(editor, {
          at: range2,
          match: (n2) => Element$1.isAncestor(node) && node.children.includes(n2),
          voids
        });
      };
      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }
      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        match,
        at: at2 = editor.selection
      } = options;
      if (!at2) {
        return;
      }
      if (match == null) {
        if (Path.isPath(at2)) {
          match = matchPath(editor, at2);
        } else if (editor.isInline(element)) {
          match = (n2) => Editor$1.isInline(editor, n2) || Text.isText(n2);
        } else {
          match = (n2) => Editor$1.isBlock(editor, n2);
        }
      }
      if (split2 && Range.isRange(at2)) {
        var [start2, end2] = Range.edges(at2);
        var rangeRef = Editor$1.rangeRef(editor, at2, {
          affinity: "inward"
        });
        Transforms.splitNodes(editor, {
          at: end2,
          match,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start2,
          match,
          voids
        });
        at2 = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at2);
        }
      }
      var roots2 = Array.from(Editor$1.nodes(editor, {
        at: at2,
        match: editor.isInline(element) ? (n2) => Editor$1.isBlock(editor, n2) : (n2) => Editor$1.isEditor(n2),
        mode: "lowest",
        voids
      }));
      for (var [, rootPath] of roots2) {
        var a2 = Range.isRange(at2) ? Range.intersection(at2, Editor$1.range(editor, rootPath)) : at2;
        if (!a2) {
          continue;
        }
        var matches = Array.from(Editor$1.nodes(editor, {
          at: a2,
          match,
          mode,
          voids
        }));
        if (matches.length > 0) {
          var _ret = function() {
            var [first2] = matches;
            var last2 = matches[matches.length - 1];
            var [, firstPath] = first2;
            var [, lastPath] = last2;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return "continue";
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range2 = Editor$1.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor$1.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range2,
              match: (n2) => Element$1.isAncestor(commonNode) && commonNode.children.includes(n2),
              to: wrapperPath.concat(0),
              voids
            });
          }();
          if (_ret === "continue")
            continue;
        }
      }
    });
  }
};
var hasSingleChildNest = (editor, node) => {
  if (Element$1.isElement(node)) {
    var element = node;
    if (Editor$1.isVoid(editor, node)) {
      return true;
    } else if (element.children.length === 1) {
      return hasSingleChildNest(editor, element.children[0]);
    } else {
      return false;
    }
  } else if (Editor$1.isEditor(node)) {
    return false;
  } else {
    return true;
  }
};
var deleteRange = (editor, range2) => {
  if (Range.isCollapsed(range2)) {
    return range2.anchor;
  } else {
    var [, end2] = Range.edges(range2);
    var pointRef = Editor$1.pointRef(editor, end2);
    Transforms.delete(editor, {
      at: range2
    });
    return pointRef.unref();
  }
};
var matchPath = (editor, path) => {
  var [node] = Editor$1.node(editor, path);
  return (n2) => n2 === node;
};
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var SelectionTransforms = {
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      edge = "anchor"
    } = options;
    var {
      selection
    } = editor;
    if (!selection) {
      return;
    } else if (edge === "anchor") {
      Transforms.select(editor, selection.anchor);
    } else if (edge === "focus") {
      Transforms.select(editor, selection.focus);
    } else if (edge === "start") {
      var [start2] = Range.edges(selection);
      Transforms.select(editor, start2);
    } else if (edge === "end") {
      var [, end2] = Range.edges(selection);
      Transforms.select(editor, end2);
    }
  },
  deselect(editor) {
    var {
      selection
    } = editor;
    if (selection) {
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: null
      });
    }
  },
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance: distance2 = 1,
      unit = "character",
      reverse: reverse2 = false
    } = options;
    var {
      edge = null
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus: focus2
    } = selection;
    var opts = {
      distance: distance2,
      unit
    };
    var props = {};
    if (edge == null || edge === "anchor") {
      var point = reverse2 ? Editor$1.before(editor, anchor, opts) : Editor$1.after(editor, anchor, opts);
      if (point) {
        props.anchor = point;
      }
    }
    if (edge == null || edge === "focus") {
      var _point = reverse2 ? Editor$1.before(editor, focus2, opts) : Editor$1.after(editor, focus2, opts);
      if (_point) {
        props.focus = _point;
      }
    }
    Transforms.setSelection(editor, props);
  },
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor$1.range(editor, target);
    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }
    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(target)));
    }
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: target
    });
  },
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = "both"
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus: focus2
    } = selection;
    var point = edge === "anchor" ? anchor : focus2;
    Transforms.setSelection(editor, {
      [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point), props)
    });
  },
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
      return;
    }
    for (var k2 in props) {
      if (k2 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k2 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k2 !== "anchor" && k2 !== "focus" && props[k2] !== selection[k2]) {
        oldProps[k2] = selection[k2];
        newProps[k2] = props[k2];
      }
    }
    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: "set_selection",
        properties: oldProps,
        newProperties: newProps
      });
    }
  }
};
var TextTransforms = {
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        reverse: reverse2 = false,
        unit = "character",
        distance: distance2 = 1,
        voids = false
      } = options;
      var {
        at: at2 = editor.selection,
        hanging = false
      } = options;
      if (!at2) {
        return;
      }
      if (Range.isRange(at2) && Range.isCollapsed(at2)) {
        at2 = at2.anchor;
      }
      if (Point.isPoint(at2)) {
        var furthestVoid = Editor$1.void(editor, {
          at: at2,
          mode: "highest"
        });
        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at2 = voidPath;
        } else {
          var opts = {
            unit,
            distance: distance2
          };
          var target = reverse2 ? Editor$1.before(editor, at2, opts) || Editor$1.start(editor, []) : Editor$1.after(editor, at2, opts) || Editor$1.end(editor, []);
          at2 = {
            anchor: at2,
            focus: target
          };
          hanging = true;
        }
      }
      if (Path.isPath(at2)) {
        Transforms.removeNodes(editor, {
          at: at2,
          voids
        });
        return;
      }
      if (Range.isCollapsed(at2)) {
        return;
      }
      if (!hanging) {
        var [, _end] = Range.edges(at2);
        var endOfDoc = Editor$1.end(editor, []);
        if (!Point.equals(_end, endOfDoc)) {
          at2 = Editor$1.unhangRange(editor, at2, {
            voids
          });
        }
      }
      var [start2, end2] = Range.edges(at2);
      var startBlock = Editor$1.above(editor, {
        match: (n2) => Editor$1.isBlock(editor, n2),
        at: start2,
        voids
      });
      var endBlock = Editor$1.above(editor, {
        match: (n2) => Editor$1.isBlock(editor, n2),
        at: end2,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start2.path, end2.path);
      var startVoid = voids ? null : Editor$1.void(editor, {
        at: start2,
        mode: "highest"
      });
      var endVoid = voids ? null : Editor$1.void(editor, {
        at: end2,
        mode: "highest"
      });
      if (startVoid) {
        var before2 = Editor$1.before(editor, start2);
        if (before2 && startBlock && Path.isAncestor(startBlock[1], before2.path)) {
          start2 = before2;
        }
      }
      if (endVoid) {
        var after2 = Editor$1.after(editor, end2);
        if (after2 && endBlock && Path.isAncestor(endBlock[1], after2.path)) {
          end2 = after2;
        }
      }
      var matches = [];
      var lastPath;
      for (var entry of Editor$1.nodes(editor, {
        at: at2,
        voids
      })) {
        var [node, path] = entry;
        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }
        if (!voids && Editor$1.isVoid(editor, node) || !Path.isCommon(path, start2.path) && !Path.isCommon(path, end2.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p2] = _ref;
        return Editor$1.pathRef(editor, p2);
      });
      var startRef = Editor$1.pointRef(editor, start2);
      var endRef = Editor$1.pointRef(editor, end2);
      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor$1.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset: offset2
        } = start2;
        var text2 = _node.text.slice(offset2);
        if (text2.length > 0)
          editor.apply({
            type: "remove_text",
            path: _path,
            offset: offset2,
            text: text2
          });
      }
      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();
        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }
      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor$1.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;
        var _offset = isSingleText ? start2.offset : 0;
        var _text = _node2.text.slice(_offset, end2.offset);
        if (_text.length > 0)
          editor.apply({
            type: "remove_text",
            path: _path3,
            offset: _offset,
            text: _text
          });
      }
      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }
      var point = reverse2 ? startRef.unref() || endRef.unref() : endRef.unref() || startRef.unref();
      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },
  insertFragment(editor, fragment2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at: at2 = editor.selection
      } = options;
      if (!fragment2.length) {
        return;
      }
      if (!at2) {
        return;
      } else if (Range.isRange(at2)) {
        if (!hanging) {
          at2 = Editor$1.unhangRange(editor, at2);
        }
        if (Range.isCollapsed(at2)) {
          at2 = at2.anchor;
        } else {
          var [, end2] = Range.edges(at2);
          if (!voids && Editor$1.void(editor, {
            at: end2
          })) {
            return;
          }
          var pointRef = Editor$1.pointRef(editor, end2);
          Transforms.delete(editor, {
            at: at2
          });
          at2 = pointRef.unref();
        }
      } else if (Path.isPath(at2)) {
        at2 = Editor$1.start(editor, at2);
      }
      if (!voids && Editor$1.void(editor, {
        at: at2
      })) {
        return;
      }
      var inlineElementMatch = Editor$1.above(editor, {
        at: at2,
        match: (n2) => Editor$1.isInline(editor, n2),
        mode: "highest",
        voids
      });
      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;
        if (Editor$1.isEnd(editor, at2, _inlinePath)) {
          var after2 = Editor$1.after(editor, _inlinePath);
          at2 = after2;
        } else if (Editor$1.isStart(editor, at2, _inlinePath)) {
          var before2 = Editor$1.before(editor, _inlinePath);
          at2 = before2;
        }
      }
      var blockMatch = Editor$1.above(editor, {
        match: (n2) => Editor$1.isBlock(editor, n2),
        at: at2,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor$1.isStart(editor, at2, blockPath);
      var isBlockEnd = Editor$1.isEnd(editor, at2, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node$1.first({
        children: fragment2
      }, []);
      var [, lastPath] = Node$1.last({
        children: fragment2
      }, []);
      var matches = [];
      var matcher = (_ref2) => {
        var [n2, p2] = _ref2;
        var isRoot = p2.length === 0;
        if (isRoot) {
          return false;
        }
        if (isBlockEmpty) {
          return true;
        }
        if (mergeStart && Path.isAncestor(p2, firstPath) && Element$1.isElement(n2) && !editor.isVoid(n2) && !editor.isInline(n2)) {
          return false;
        }
        if (mergeEnd && Path.isAncestor(p2, lastPath) && Element$1.isElement(n2) && !editor.isVoid(n2) && !editor.isInline(n2)) {
          return false;
        }
        return true;
      };
      for (var entry of Node$1.nodes({
        children: fragment2
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }
      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;
      for (var [node] of matches) {
        if (Element$1.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }
      var [inlineMatch] = Editor$1.nodes(editor, {
        at: at2,
        match: (n2) => Text.isText(n2) || Editor$1.isInline(editor, n2),
        mode: "highest",
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor$1.isStart(editor, at2, inlinePath);
      var isInlineEnd = Editor$1.isEnd(editor, at2, inlinePath);
      var middleRef = Editor$1.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);
      var endRef = Editor$1.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      var blockPathRef = Editor$1.pathRef(editor, blockPath);
      Transforms.splitNodes(editor, {
        at: at2,
        match: (n2) => hasBlocks ? Editor$1.isBlock(editor, n2) : Text.isText(n2) || Editor$1.isInline(editor, n2),
        mode: hasBlocks ? "lowest" : "highest",
        voids
      });
      var startRef = Editor$1.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: (n2) => Text.isText(n2) || Editor$1.isInline(editor, n2),
        mode: "highest",
        voids
      });
      if (isBlockEmpty && middles.length) {
        Transforms.delete(editor, {
          at: blockPathRef.unref(),
          voids
        });
      }
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: (n2) => Editor$1.isBlock(editor, n2),
        mode: "lowest",
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: (n2) => Text.isText(n2) || Editor$1.isInline(editor, n2),
        mode: "highest",
        voids
      });
      if (!options.at) {
        var path;
        if (ends.length > 0) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0) {
          path = Path.previous(middleRef.current);
        } else {
          path = Path.previous(startRef.current);
        }
        var _end2 = Editor$1.end(editor, path);
        Transforms.select(editor, _end2);
      }
      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },
  insertText(editor, text2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor$1.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at: at2 = editor.selection
      } = options;
      if (!at2) {
        return;
      }
      if (Path.isPath(at2)) {
        at2 = Editor$1.range(editor, at2);
      }
      if (Range.isRange(at2)) {
        if (Range.isCollapsed(at2)) {
          at2 = at2.anchor;
        } else {
          var end2 = Range.end(at2);
          if (!voids && Editor$1.void(editor, {
            at: end2
          })) {
            return;
          }
          var pointRef = Editor$1.pointRef(editor, end2);
          Transforms.delete(editor, {
            at: at2,
            voids
          });
          at2 = pointRef.unref();
          Transforms.setSelection(editor, {
            anchor: at2,
            focus: at2
          });
        }
      }
      if (!voids && Editor$1.void(editor, {
        at: at2
      })) {
        return;
      }
      var {
        path,
        offset: offset2
      } = at2;
      if (text2.length > 0)
        editor.apply({
          type: "insert_text",
          path,
          offset: offset2,
          text: text2
        });
    });
  }
};
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn2) {
  var module = { exports: {} };
  return fn2(module, module.exports), module.exports;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var argsTag$1 = "[object Arguments]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange$1 = "\\u20d0-\\u20f0", rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral$1 = "[" + rsAstralRange$1 + "]", rsCombo$1 = "[" + rsComboMarksRange$1 + rsComboSymbolsRange$1 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol$1 = "(?:" + [rsNonAstral$1 + rsCombo$1 + "?", rsCombo$1, rsRegional$1, rsSurrPair$1, rsAstral$1].join("|") + ")";
var reUnicode$1 = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol$1 + rsSeq$1, "g");
var reHasUnicode$1 = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboMarksRange$1 + rsComboSymbolsRange$1 + rsVarRange$1 + "]");
var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$3 = typeof self == "object" && self && self.Object === Object && self;
var root$3 = freeGlobal$3 || freeSelf$3 || Function("return this")();
function arrayMap(array2, iteratee) {
  var index = -1, length2 = array2 ? array2.length : 0, result = Array(length2);
  while (++index < length2) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
function asciiToArray$1(string) {
  return string.split("");
}
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function hasUnicode$1(string) {
  return reHasUnicode$1.test(string);
}
function isHostObject(value) {
  var result = false;
  if (value != null && typeof value.toString != "function") {
    try {
      result = !!(value + "");
    } catch (e3) {
    }
  }
  return result;
}
function iteratorToArray(iterator2) {
  var data5, result = [];
  while (!(data5 = iterator2.next()).done) {
    result.push(data5.value);
  }
  return result;
}
function mapToArray(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function setToArray(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray$1(string) : asciiToArray$1(string);
}
function unicodeToArray$1(string) {
  return string.match(reUnicode$1) || [];
}
var funcProto = Function.prototype, objectProto$4 = Object.prototype;
var coreJsData = root$3["__core-js_shared__"];
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$4.hasOwnProperty;
var objectToString$4 = objectProto$4.toString;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
var Symbol$2 = root$3.Symbol, iteratorSymbol = Symbol$2 ? Symbol$2.iterator : void 0, propertyIsEnumerable$1 = objectProto$4.propertyIsEnumerable;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var DataView = getNative(root$3, "DataView"), Map$1 = getNative(root$3, "Map"), Promise$1 = getNative(root$3, "Promise"), Set$1 = getNative(root$3, "Set"), WeakMap$1 = getNative(root$3, "WeakMap");
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
function arrayLikeKeys$1(value, inherited) {
  var result = isArray$1(value) || isArguments$1(value) ? baseTimes$1(value.length, String) : [];
  var length2 = result.length, skipIndexes = !!length2;
  for (var key in value) {
    if ((inherited || hasOwnProperty$2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex$1(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function baseGetTag(value) {
  return objectToString$4.call(value);
}
function baseIsNative(value) {
  if (!isObject$4(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function baseKeys$1(object) {
  if (!isPrototype$1(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function copyArray(source, array2) {
  var index = -1, length2 = source.length;
  array2 || (array2 = Array(length2));
  while (++index < length2) {
    array2[index] = source[index];
  }
  return array2;
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = objectToString$4.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
function isIndex$1(value, length2) {
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (typeof value == "number" || reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto2;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
function isArguments$1(value) {
  return isArrayLikeObject$1(value) && hasOwnProperty$2.call(value, "callee") && (!propertyIsEnumerable$1.call(value, "callee") || objectToString$4.call(value) == argsTag$1);
}
var isArray$1 = Array.isArray;
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
function isArrayLikeObject$1(value) {
  return isObjectLike$4(value) && isArrayLike$1(value);
}
function isFunction$1(value) {
  var tag = isObject$4(value) ? objectToString$4.call(value) : "";
  return tag == funcTag$1 || tag == genTag$1;
}
function isLength$1(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isObject$4(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike$4(value) {
  return !!value && typeof value == "object";
}
function isString(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$4(value) && objectToString$4.call(value) == stringTag;
}
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike$1(value)) {
    return isString(value) ? stringToArray$1(value) : copyArray(value);
  }
  if (iteratorSymbol && value[iteratorSymbol]) {
    return iteratorToArray(value[iteratorSymbol]());
  }
  var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
  return func(value);
}
function keys$1(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);
}
function values(object) {
  return object ? baseValues(object, keys$1(object)) : [];
}
var lodash_toarray = toArray;
function isObject$3(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(function(key) {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$3(src[key]) && isObject$3(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}
var ssrDocument = {
  body: {},
  addEventListener: function() {
  },
  removeEventListener: function() {
  },
  activeElement: {
    blur: function() {
    },
    nodeName: ""
  },
  querySelector: function() {
    return null;
  },
  querySelectorAll: function() {
    return [];
  },
  getElementById: function() {
    return null;
  },
  createEvent: function() {
    return {
      initEvent: function() {
      }
    };
  },
  createElement: function() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function() {
      },
      getElementsByTagName: function() {
        return [];
      }
    };
  },
  createElementNS: function() {
    return {};
  },
  importNode: function() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  var doc = typeof document !== "undefined" ? document : {};
  extend(doc, ssrDocument);
  return doc;
}
var ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState: function() {
    },
    pushState: function() {
    },
    go: function() {
    },
    back: function() {
    }
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function() {
  },
  removeEventListener: function() {
  },
  getComputedStyle: function() {
    return {
      getPropertyValue: function() {
        return "";
      }
    };
  },
  Image: function() {
  },
  Date: function() {
  },
  screen: {},
  setTimeout: function() {
  },
  clearTimeout: function() {
  },
  matchMedia: function() {
    return {};
  },
  requestAnimationFrame: function(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame: function(id2) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id2);
  }
};
function getWindow() {
  var win = typeof window !== "undefined" ? window : {};
  extend(win, ssrWindow);
  return win;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance2 = new Constructor();
      if (Class2)
        _setPrototypeOf(instance2, Class2.prototype);
      return instance2;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function makeReactive(obj) {
  var proto2 = obj.__proto__;
  Object.defineProperty(obj, "__proto__", {
    get: function get3() {
      return proto2;
    },
    set: function set2(value) {
      proto2.__proto__ = value;
    }
  });
}
var Dom7 = /* @__PURE__ */ function(_Array) {
  _inheritsLoose(Dom72, _Array);
  function Dom72(items) {
    var _this;
    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }
  return Dom72;
}(/* @__PURE__ */ _wrapNativeSuper(Array));
function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }
  var res = [];
  arr.forEach(function(el2) {
    if (Array.isArray(el2)) {
      res.push.apply(res, arrayFlat(el2));
    } else {
      res.push(el2);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];
  for (var i2 = 0; i2 < arr.length; i2 += 1) {
    if (uniqueArray.indexOf(arr[i2]) === -1)
      uniqueArray.push(arr[i2]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function(match, group) {
    return group.toUpperCase();
  });
}
function qsa(selector, context) {
  if (typeof selector !== "string") {
    return [selector];
  }
  var a2 = [];
  var res = context.querySelectorAll(selector);
  for (var i2 = 0; i2 < res.length; i2 += 1) {
    a2.push(res[i2]);
  }
  return a2;
}
function $$6(selector, context) {
  var window2 = getWindow();
  var document2 = getDocument();
  var arr = [];
  if (!context && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === "string") {
    var html2 = selector.trim();
    if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
      var toCreate = "div";
      if (html2.indexOf("<li") === 0)
        toCreate = "ul";
      if (html2.indexOf("<tr") === 0)
        toCreate = "tbody";
      if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0)
        toCreate = "tr";
      if (html2.indexOf("<tbody") === 0)
        toCreate = "table";
      if (html2.indexOf("<option") === 0)
        toCreate = "select";
      var tempParent = document2.createElement(toCreate);
      tempParent.innerHTML = html2;
      for (var i2 = 0; i2 < tempParent.childNodes.length; i2 += 1) {
        arr.push(tempParent.childNodes[i2]);
      }
    } else {
      arr = qsa(selector.trim(), context || document2);
    }
  } else if (selector.nodeType || selector === window2 || selector === document2) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7)
      return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
$$6.fn = Dom7.prototype;
function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }
  var classNames = arrayFlat(classes.map(function(c2) {
    return c2.split(" ");
  }));
  this.forEach(function(el2) {
    var _el$classList;
    (_el$classList = el2.classList).add.apply(_el$classList, classNames);
  });
  return this;
}
function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }
  var classNames = arrayFlat(classes.map(function(c2) {
    return c2.split(" ");
  }));
  this.forEach(function(el2) {
    var _el$classList2;
    (_el$classList2 = el2.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}
function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }
  var classNames = arrayFlat(classes.map(function(c2) {
    return c2.split(" ");
  }));
  return arrayFilter(this, function(el2) {
    return classNames.filter(function(className) {
      return el2.classList.contains(className);
    }).length > 0;
  }).length > 0;
}
function attr(attrs2, value) {
  if (arguments.length === 1 && typeof attrs2 === "string") {
    if (this[0])
      return this[0].getAttribute(attrs2);
    return void 0;
  }
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    if (arguments.length === 2) {
      this[i2].setAttribute(attrs2, value);
    } else {
      for (var attrName in attrs2) {
        this[i2][attrName] = attrs2[attrName];
        this[i2].setAttribute(attrName, attrs2[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr2) {
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].removeAttribute(attr2);
  }
  return this;
}
function dataset() {
  var el2 = this[0];
  if (!el2)
    return void 0;
  var dataset2 = {};
  if (el2.dataset) {
    for (var dataKey in el2.dataset) {
      dataset2[dataKey] = el2.dataset[dataKey];
    }
  } else {
    for (var i2 = 0; i2 < el2.attributes.length; i2 += 1) {
      var _attr = el2.attributes[i2];
      if (_attr.name.indexOf("data-") >= 0) {
        dataset2[toCamelCase(_attr.name.split("data-")[1])] = _attr.value;
      }
    }
  }
  for (var key in dataset2) {
    if (dataset2[key] === "false")
      dataset2[key] = false;
    else if (dataset2[key] === "true")
      dataset2[key] = true;
    else if (parseFloat(dataset2[key]) === dataset2[key] * 1)
      dataset2[key] *= 1;
  }
  return dataset2;
}
function val(value) {
  if (typeof value === "undefined") {
    var el2 = this[0];
    if (!el2)
      return void 0;
    if (el2.multiple && el2.nodeName.toLowerCase() === "select") {
      var values2 = [];
      for (var i2 = 0; i2 < el2.selectedOptions.length; i2 += 1) {
        values2.push(el2.selectedOptions[i2].value);
      }
      return values2;
    }
    return el2.value;
  }
  for (var _i2 = 0; _i2 < this.length; _i2 += 1) {
    var _el = this[_i2];
    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === "select") {
      for (var j2 = 0; j2 < _el.options.length; j2 += 1) {
        _el.options[j2].selected = value.indexOf(_el.options[j2].value) >= 0;
      }
    } else {
      _el.value = value;
    }
  }
  return this;
}
function on$7() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }
  var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
  if (typeof args[1] === "function") {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  function handleLiveEvent(e3) {
    var target = e3.target;
    if (!target)
      return;
    var eventData = e3.target.dom7EventData || [];
    if (eventData.indexOf(e3) < 0) {
      eventData.unshift(e3);
    }
    if ($$6(target).is(targetSelector))
      listener.apply(target, eventData);
    else {
      var _parents = $$6(target).parents();
      for (var k2 = 0; k2 < _parents.length; k2 += 1) {
        if ($$6(_parents[k2]).is(targetSelector))
          listener.apply(_parents[k2], eventData);
      }
    }
  }
  function handleEvent2(e3) {
    var eventData = e3 && e3.target ? e3.target.dom7EventData || [] : [];
    if (eventData.indexOf(e3) < 0) {
      eventData.unshift(e3);
    }
    listener.apply(this, eventData);
  }
  var events = eventType.split(" ");
  var j2;
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var el2 = this[i2];
    if (!targetSelector) {
      for (j2 = 0; j2 < events.length; j2 += 1) {
        var event = events[j2];
        if (!el2.dom7Listeners)
          el2.dom7Listeners = {};
        if (!el2.dom7Listeners[event])
          el2.dom7Listeners[event] = [];
        el2.dom7Listeners[event].push({
          listener,
          proxyListener: handleEvent2
        });
        el2.addEventListener(event, handleEvent2, capture);
      }
    } else {
      for (j2 = 0; j2 < events.length; j2 += 1) {
        var _event = events[j2];
        if (!el2.dom7LiveListeners)
          el2.dom7LiveListeners = {};
        if (!el2.dom7LiveListeners[_event])
          el2.dom7LiveListeners[_event] = [];
        el2.dom7LiveListeners[_event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el2.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
  if (typeof args[1] === "function") {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  var events = eventType.split(" ");
  for (var i2 = 0; i2 < events.length; i2 += 1) {
    var event = events[i2];
    for (var j2 = 0; j2 < this.length; j2 += 1) {
      var el2 = this[j2];
      var handlers = void 0;
      if (!targetSelector && el2.dom7Listeners) {
        handlers = el2.dom7Listeners[event];
      } else if (targetSelector && el2.dom7LiveListeners) {
        handlers = el2.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (var k2 = handlers.length - 1; k2 >= 0; k2 -= 1) {
          var handler3 = handlers[k2];
          if (listener && handler3.listener === listener) {
            el2.removeEventListener(event, handler3.proxyListener, capture);
            handlers.splice(k2, 1);
          } else if (listener && handler3.listener && handler3.listener.dom7proxy && handler3.listener.dom7proxy === listener) {
            el2.removeEventListener(event, handler3.proxyListener, capture);
            handlers.splice(k2, 1);
          } else if (!listener) {
            el2.removeEventListener(event, handler3.proxyListener, capture);
            handlers.splice(k2, 1);
          }
        }
      }
    }
  }
  return this;
}
function width() {
  var window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerWidth;
  }
  if (this.length > 0) {
    return parseFloat(this.css("width"));
  }
  return null;
}
function height() {
  var window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerHeight;
  }
  if (this.length > 0) {
    return parseFloat(this.css("height"));
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    var window2 = getWindow();
    var document2 = getDocument();
    var el2 = this[0];
    var box2 = el2.getBoundingClientRect();
    var body = document2.body;
    var clientTop = el2.clientTop || body.clientTop || 0;
    var clientLeft = el2.clientLeft || body.clientLeft || 0;
    var scrollTop = el2 === window2 ? window2.scrollY : el2.scrollTop;
    var scrollLeft = el2 === window2 ? window2.scrollX : el2.scrollLeft;
    return {
      top: box2.top + scrollTop - clientTop,
      left: box2.left + scrollLeft - clientLeft
    };
  }
  return null;
}
function hide() {
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].style.display = "none";
  }
  return this;
}
function show() {
  var window2 = getWindow();
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var el2 = this[i2];
    if (el2.style.display === "none") {
      el2.style.display = "";
    }
    if (window2.getComputedStyle(el2, null).getPropertyValue("display") === "none") {
      el2.style.display = "block";
    }
  }
  return this;
}
function css(props, value) {
  var window2 = getWindow();
  var i2;
  if (arguments.length === 1) {
    if (typeof props === "string") {
      if (this[0])
        return window2.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i2 = 0; i2 < this.length; i2 += 1) {
        for (var _prop in props) {
          this[i2].style[_prop] = props[_prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === "string") {
    for (i2 = 0; i2 < this.length; i2 += 1) {
      this[i2].style[props] = value;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback)
    return this;
  this.forEach(function(el2, index) {
    callback.apply(el2, [el2, index]);
  });
  return this;
}
function filter(callback) {
  var result = arrayFilter(this, callback);
  return $$6(result);
}
function html(html2) {
  if (typeof html2 === "undefined") {
    return this[0] ? this[0].innerHTML : null;
  }
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].innerHTML = html2;
  }
  return this;
}
function text(text2) {
  if (typeof text2 === "undefined") {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    this[i2].textContent = text2;
  }
  return this;
}
function is$2(selector) {
  var window2 = getWindow();
  var document2 = getDocument();
  var el2 = this[0];
  var compareWith;
  var i2;
  if (!el2 || typeof selector === "undefined")
    return false;
  if (typeof selector === "string") {
    if (el2.matches)
      return el2.matches(selector);
    if (el2.webkitMatchesSelector)
      return el2.webkitMatchesSelector(selector);
    if (el2.msMatchesSelector)
      return el2.msMatchesSelector(selector);
    compareWith = $$6(selector);
    for (i2 = 0; i2 < compareWith.length; i2 += 1) {
      if (compareWith[i2] === el2)
        return true;
    }
    return false;
  }
  if (selector === document2) {
    return el2 === document2;
  }
  if (selector === window2) {
    return el2 === window2;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i2 = 0; i2 < compareWith.length; i2 += 1) {
      if (compareWith[i2] === el2)
        return true;
    }
    return false;
  }
  return false;
}
function append() {
  var newChild;
  var document2 = getDocument();
  for (var k2 = 0; k2 < arguments.length; k2 += 1) {
    newChild = k2 < 0 || arguments.length <= k2 ? void 0 : arguments[k2];
    for (var i2 = 0; i2 < this.length; i2 += 1) {
      if (typeof newChild === "string") {
        var tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i2].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j2 = 0; j2 < newChild.length; j2 += 1) {
          this[i2].appendChild(newChild[j2]);
        }
      } else {
        this[i2].appendChild(newChild);
      }
    }
  }
  return this;
}
function prepend(newChild) {
  var document2 = getDocument();
  var i2;
  var j2;
  for (i2 = 0; i2 < this.length; i2 += 1) {
    if (typeof newChild === "string") {
      var tempDiv = document2.createElement("div");
      tempDiv.innerHTML = newChild;
      for (j2 = tempDiv.childNodes.length - 1; j2 >= 0; j2 -= 1) {
        this[i2].insertBefore(tempDiv.childNodes[j2], this[i2].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j2 = 0; j2 < newChild.length; j2 += 1) {
        this[i2].insertBefore(newChild[j2], this[i2].childNodes[0]);
      }
    } else {
      this[i2].insertBefore(newChild, this[i2].childNodes[0]);
    }
  }
  return this;
}
function parent(selector) {
  var parents2 = [];
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    if (this[i2].parentNode !== null) {
      if (selector) {
        if ($$6(this[i2].parentNode).is(selector))
          parents2.push(this[i2].parentNode);
      } else {
        parents2.push(this[i2].parentNode);
      }
    }
  }
  return $$6(parents2);
}
function parents(selector) {
  var parents2 = [];
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var _parent = this[i2].parentNode;
    while (_parent) {
      if (selector) {
        if ($$6(_parent).is(selector))
          parents2.push(_parent);
      } else {
        parents2.push(_parent);
      }
      _parent = _parent.parentNode;
    }
  }
  return $$6(parents2);
}
function find(selector) {
  var foundElements = [];
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var found = this[i2].querySelectorAll(selector);
    for (var j2 = 0; j2 < found.length; j2 += 1) {
      foundElements.push(found[j2]);
    }
  }
  return $$6(foundElements);
}
function children(selector) {
  var children2 = [];
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var childNodes = this[i2].children;
    for (var j2 = 0; j2 < childNodes.length; j2 += 1) {
      if (!selector || $$6(childNodes[j2]).is(selector)) {
        children2.push(childNodes[j2]);
      }
    }
  }
  return $$6(children2);
}
function remove() {
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    if (this[i2].parentNode)
      this[i2].parentNode.removeChild(this[i2]);
  }
  return this;
}
function empty() {
  for (var i2 = 0; i2 < this.length; i2 += 1) {
    var el2 = this[i2];
    if (el2.nodeType === 1) {
      for (var j2 = 0; j2 < el2.childNodes.length; j2 += 1) {
        if (el2.childNodes[j2].parentNode) {
          el2.childNodes[j2].parentNode.removeChild(el2.childNodes[j2]);
        }
      }
      el2.textContent = "";
    }
  }
  return this;
}
var noTrigger = "resize scroll".split(" ");
function shortcut(name2) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "undefined") {
      for (var i2 = 0; i2 < this.length; i2 += 1) {
        if (noTrigger.indexOf(name2) < 0) {
          if (name2 in this[i2])
            this[i2][name2]();
          else {
            $$6(this[i2]).trigger(name2);
          }
        }
      }
      return this;
    }
    return this.on.apply(this, [name2].concat(args));
  }
  return eventHandler;
}
var click = shortcut("click");
var focus$1 = shortcut("focus");
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
var reIsUint = /^(?:0|[1-9]\d*)$/;
function arrayEach(array2, iteratee) {
  var index = -1, length2 = array2 ? array2.length : 0;
  while (++index < length2) {
    if (iteratee(array2[index], index, array2) === false) {
      break;
    }
  }
  return array2;
}
function baseTimes(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$1 = objectProto$3.hasOwnProperty;
var objectToString$3 = objectProto$3.toString;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var nativeKeys = overArg(Object.keys, Object);
function arrayLikeKeys(value, inherited) {
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
  var length2 = result.length, skipIndexes = !!length2;
  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var baseEach = createBaseEach(baseForOwn);
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$1.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length2) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[fromRight ? length2 : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
function isIndex(value, length2) {
  length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
  return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto2;
}
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, typeof iteratee == "function" ? iteratee : identity);
}
function isArguments(value) {
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString$3.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike$3(value) && isArrayLike(value);
}
function isFunction(value) {
  var tag = isObject$2(value) ? objectToString$3.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject$2(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike$3(value) {
  return !!value && typeof value == "object";
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
  return value;
}
var lodash_foreach = forEach;
{
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
    throw new Error(
      "React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID."
    );
  }
  if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
    throw new Error(
      "Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support"
    );
  }
  if (typeof crypto === "undefined") {
    throw new Error(
      "Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure."
    );
  }
}
let nanoid$3 = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    let byte = bytes[size] & 63;
    if (byte < 36) {
      id2 += byte.toString(36);
    } else if (byte < 62) {
      id2 += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id2 += "_";
    } else {
      id2 += "-";
    }
  }
  return id2;
};
var FUNC_ERROR_TEXT$1 = "Expected a function";
var NAN$1 = 0 / 0;
var symbolTag$2 = "[object Symbol]";
var reTrim$1 = /^\s+|\s+$/g;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
var freeGlobal$2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$2 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal$2 || freeSelf$2 || Function("return this")();
var objectProto$2 = Object.prototype;
var objectToString$2 = objectProto$2.toString;
var nativeMax$1 = Math.max, nativeMin$1 = Math.min;
var now$1 = function() {
  return root$2.Date.now();
};
function debounce$2(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$1(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$1();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time2 = now$1(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$1(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$2(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
function isObject$1(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike$2(value) {
  return !!value && typeof value == "object";
}
function isSymbol$2(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && objectToString$2.call(value) == symbolTag$2;
}
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN$1;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim$1, "");
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var lodash_throttle = throttle;
function createElement(tagName2, options) {
  return document.createElement(tagName2, options);
}
function createElementNS(namespaceURI, qualifiedName, options) {
  return document.createElementNS(namespaceURI, qualifiedName, options);
}
function createTextNode(text2) {
  return document.createTextNode(text2);
}
function createComment(text2) {
  return document.createComment(text2);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function tagName(elm) {
  return elm.tagName;
}
function setTextContent(node, text2) {
  node.textContent = text2;
}
function getTextContent(node) {
  return node.textContent;
}
function isElement(node) {
  return node.nodeType === 1;
}
function isText(node) {
  return node.nodeType === 3;
}
function isComment(node) {
  return node.nodeType === 8;
}
const htmlDomApi = {
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  getTextContent,
  isElement,
  isText,
  isComment
};
function vnode(sel, data5, children2, text2, elm) {
  const key = data5 === void 0 ? void 0 : data5.key;
  return { sel, data: data5, children: children2, text: text2, elm, key };
}
const array = Array.isArray;
function primitive(s2) {
  return typeof s2 === "string" || typeof s2 === "number" || s2 instanceof String || s2 instanceof Number;
}
function isUndef(s2) {
  return s2 === void 0;
}
function isDef(s2) {
  return s2 !== void 0;
}
const emptyNode = vnode("", {}, [], void 0, void 0);
function sameVnode(vnode1, vnode2) {
  var _a2, _b2;
  const isSameKey = vnode1.key === vnode2.key;
  const isSameIs = ((_a2 = vnode1.data) === null || _a2 === void 0 ? void 0 : _a2.is) === ((_b2 = vnode2.data) === null || _b2 === void 0 ? void 0 : _b2.is);
  const isSameSel = vnode1.sel === vnode2.sel;
  return isSameSel && isSameKey && isSameIs;
}
function isVnode(vnode2) {
  return vnode2.sel !== void 0;
}
function createKeyToOldIdx(children2, beginIdx, endIdx) {
  var _a2;
  const map2 = {};
  for (let i2 = beginIdx; i2 <= endIdx; ++i2) {
    const key = (_a2 = children2[i2]) === null || _a2 === void 0 ? void 0 : _a2.key;
    if (key !== void 0) {
      map2[key] = i2;
    }
  }
  return map2;
}
const hooks = [
  "create",
  "update",
  "remove",
  "destroy",
  "pre",
  "post"
];
function init(modules, domApi) {
  const cbs = {
    create: [],
    update: [],
    remove: [],
    destroy: [],
    pre: [],
    post: []
  };
  const api = domApi !== void 0 ? domApi : htmlDomApi;
  for (const hook of hooks) {
    for (const module of modules) {
      const currentHook = module[hook];
      if (currentHook !== void 0) {
        cbs[hook].push(currentHook);
      }
    }
  }
  function emptyNodeAt(elm) {
    const id2 = elm.id ? "#" + elm.id : "";
    const classes = elm.getAttribute("class");
    const c2 = classes ? "." + classes.split(" ").join(".") : "";
    return vnode(api.tagName(elm).toLowerCase() + id2 + c2, {}, [], void 0, elm);
  }
  function createRmCb(childElm, listeners) {
    return function rmCb() {
      if (--listeners === 0) {
        const parent2 = api.parentNode(childElm);
        api.removeChild(parent2, childElm);
      }
    };
  }
  function createElm(vnode2, insertedVnodeQueue) {
    var _a2, _b2;
    let i2;
    let data5 = vnode2.data;
    if (data5 !== void 0) {
      const init5 = (_a2 = data5.hook) === null || _a2 === void 0 ? void 0 : _a2.init;
      if (isDef(init5)) {
        init5(vnode2);
        data5 = vnode2.data;
      }
    }
    const children2 = vnode2.children;
    const sel = vnode2.sel;
    if (sel === "!") {
      if (isUndef(vnode2.text)) {
        vnode2.text = "";
      }
      vnode2.elm = api.createComment(vnode2.text);
    } else if (sel !== void 0) {
      const hashIdx = sel.indexOf("#");
      const dotIdx = sel.indexOf(".", hashIdx);
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      const dot2 = dotIdx > 0 ? dotIdx : sel.length;
      const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot2)) : sel;
      const elm = vnode2.elm = isDef(data5) && isDef(i2 = data5.ns) ? api.createElementNS(i2, tag, data5) : api.createElement(tag, data5);
      if (hash < dot2)
        elm.setAttribute("id", sel.slice(hash + 1, dot2));
      if (dotIdx > 0)
        elm.setAttribute("class", sel.slice(dot2 + 1).replace(/\./g, " "));
      for (i2 = 0; i2 < cbs.create.length; ++i2)
        cbs.create[i2](emptyNode, vnode2);
      if (array(children2)) {
        for (i2 = 0; i2 < children2.length; ++i2) {
          const ch2 = children2[i2];
          if (ch2 != null) {
            api.appendChild(elm, createElm(ch2, insertedVnodeQueue));
          }
        }
      } else if (primitive(vnode2.text)) {
        api.appendChild(elm, api.createTextNode(vnode2.text));
      }
      const hook = vnode2.data.hook;
      if (isDef(hook)) {
        (_b2 = hook.create) === null || _b2 === void 0 ? void 0 : _b2.call(hook, emptyNode, vnode2);
        if (hook.insert) {
          insertedVnodeQueue.push(vnode2);
        }
      }
    } else {
      vnode2.elm = api.createTextNode(vnode2.text);
    }
    return vnode2.elm;
  }
  function addVnodes(parentElm, before2, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch2 = vnodes[startIdx];
      if (ch2 != null) {
        api.insertBefore(parentElm, createElm(ch2, insertedVnodeQueue), before2);
      }
    }
  }
  function invokeDestroyHook(vnode2) {
    var _a2, _b2;
    const data5 = vnode2.data;
    if (data5 !== void 0) {
      (_b2 = (_a2 = data5 === null || data5 === void 0 ? void 0 : data5.hook) === null || _a2 === void 0 ? void 0 : _a2.destroy) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, vnode2);
      for (let i2 = 0; i2 < cbs.destroy.length; ++i2)
        cbs.destroy[i2](vnode2);
      if (vnode2.children !== void 0) {
        for (let j2 = 0; j2 < vnode2.children.length; ++j2) {
          const child = vnode2.children[j2];
          if (child != null && typeof child !== "string") {
            invokeDestroyHook(child);
          }
        }
      }
    }
  }
  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    var _a2, _b2;
    for (; startIdx <= endIdx; ++startIdx) {
      let listeners;
      let rm2;
      const ch2 = vnodes[startIdx];
      if (ch2 != null) {
        if (isDef(ch2.sel)) {
          invokeDestroyHook(ch2);
          listeners = cbs.remove.length + 1;
          rm2 = createRmCb(ch2.elm, listeners);
          for (let i2 = 0; i2 < cbs.remove.length; ++i2)
            cbs.remove[i2](ch2, rm2);
          const removeHook = (_b2 = (_a2 = ch2 === null || ch2 === void 0 ? void 0 : ch2.data) === null || _a2 === void 0 ? void 0 : _a2.hook) === null || _b2 === void 0 ? void 0 : _b2.remove;
          if (isDef(removeHook)) {
            removeHook(ch2, rm2);
          } else {
            rm2();
          }
        } else {
          api.removeChild(parentElm, ch2.elm);
        }
      }
    }
  }
  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let oldKeyToIdx;
    let idxInOld;
    let elmToMove;
    let before2;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === void 0) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) {
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
        } else {
          elmToMove = oldCh[idxInOld];
          if (elmToMove.sel !== newStartVnode.sel) {
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
          } else {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = void 0;
            api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before2 = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, before2, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }
  function patchVnode(oldVnode, vnode2, insertedVnodeQueue) {
    var _a2, _b2, _c2, _d2, _e2;
    const hook = (_a2 = vnode2.data) === null || _a2 === void 0 ? void 0 : _a2.hook;
    (_b2 = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b2 === void 0 ? void 0 : _b2.call(hook, oldVnode, vnode2);
    const elm = vnode2.elm = oldVnode.elm;
    const oldCh = oldVnode.children;
    const ch2 = vnode2.children;
    if (oldVnode === vnode2)
      return;
    if (vnode2.data !== void 0) {
      for (let i2 = 0; i2 < cbs.update.length; ++i2)
        cbs.update[i2](oldVnode, vnode2);
      (_d2 = (_c2 = vnode2.data.hook) === null || _c2 === void 0 ? void 0 : _c2.update) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, oldVnode, vnode2);
    }
    if (isUndef(vnode2.text)) {
      if (isDef(oldCh) && isDef(ch2)) {
        if (oldCh !== ch2)
          updateChildren(elm, oldCh, ch2, insertedVnodeQueue);
      } else if (isDef(ch2)) {
        if (isDef(oldVnode.text))
          api.setTextContent(elm, "");
        addVnodes(elm, null, ch2, 0, ch2.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        api.setTextContent(elm, "");
      }
    } else if (oldVnode.text !== vnode2.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
      api.setTextContent(elm, vnode2.text);
    }
    (_e2 = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _e2 === void 0 ? void 0 : _e2.call(hook, oldVnode, vnode2);
  }
  return function patch(oldVnode, vnode2) {
    let i2, elm, parent2;
    const insertedVnodeQueue = [];
    for (i2 = 0; i2 < cbs.pre.length; ++i2)
      cbs.pre[i2]();
    if (!isVnode(oldVnode)) {
      oldVnode = emptyNodeAt(oldVnode);
    }
    if (sameVnode(oldVnode, vnode2)) {
      patchVnode(oldVnode, vnode2, insertedVnodeQueue);
    } else {
      elm = oldVnode.elm;
      parent2 = api.parentNode(elm);
      createElm(vnode2, insertedVnodeQueue);
      if (parent2 !== null) {
        api.insertBefore(parent2, vnode2.elm, api.nextSibling(elm));
        removeVnodes(parent2, [oldVnode], 0, 0);
      }
    }
    for (i2 = 0; i2 < insertedVnodeQueue.length; ++i2) {
      insertedVnodeQueue[i2].data.hook.insert(insertedVnodeQueue[i2]);
    }
    for (i2 = 0; i2 < cbs.post.length; ++i2)
      cbs.post[i2]();
    return vnode2;
  };
}
function addNS(data5, children2, sel) {
  data5.ns = "http://www.w3.org/2000/svg";
  if (sel !== "foreignObject" && children2 !== void 0) {
    for (let i2 = 0; i2 < children2.length; ++i2) {
      const childData = children2[i2].data;
      if (childData !== void 0) {
        addNS(childData, children2[i2].children, children2[i2].sel);
      }
    }
  }
}
function h$3(sel, b2, c2) {
  let data5 = {};
  let children2;
  let text2;
  let i2;
  if (c2 !== void 0) {
    if (b2 !== null) {
      data5 = b2;
    }
    if (array(c2)) {
      children2 = c2;
    } else if (primitive(c2)) {
      text2 = c2.toString();
    } else if (c2 && c2.sel) {
      children2 = [c2];
    }
  } else if (b2 !== void 0 && b2 !== null) {
    if (array(b2)) {
      children2 = b2;
    } else if (primitive(b2)) {
      text2 = b2.toString();
    } else if (b2 && b2.sel) {
      children2 = [b2];
    } else {
      data5 = b2;
    }
  }
  if (children2 !== void 0) {
    for (i2 = 0; i2 < children2.length; ++i2) {
      if (primitive(children2[i2]))
        children2[i2] = vnode(void 0, void 0, void 0, children2[i2], void 0);
    }
  }
  if (sel[0] === "s" && sel[1] === "v" && sel[2] === "g" && (sel.length === 3 || sel[3] === "." || sel[3] === "#")) {
    addNS(data5, children2, sel);
  }
  return vnode(sel, data5, children2, text2, void 0);
}
function updateClass(oldVnode, vnode2) {
  let cur;
  let name2;
  const elm = vnode2.elm;
  let oldClass = oldVnode.data.class;
  let klass = vnode2.data.class;
  if (!oldClass && !klass)
    return;
  if (oldClass === klass)
    return;
  oldClass = oldClass || {};
  klass = klass || {};
  for (name2 in oldClass) {
    if (oldClass[name2] && !Object.prototype.hasOwnProperty.call(klass, name2)) {
      elm.classList.remove(name2);
    }
  }
  for (name2 in klass) {
    cur = klass[name2];
    if (cur !== oldClass[name2]) {
      elm.classList[cur ? "add" : "remove"](name2);
    }
  }
}
const classModule = { create: updateClass, update: updateClass };
const CAPS_REGEX = /[A-Z]/g;
function updateDataset(oldVnode, vnode2) {
  const elm = vnode2.elm;
  let oldDataset = oldVnode.data.dataset;
  let dataset2 = vnode2.data.dataset;
  let key;
  if (!oldDataset && !dataset2)
    return;
  if (oldDataset === dataset2)
    return;
  oldDataset = oldDataset || {};
  dataset2 = dataset2 || {};
  const d3 = elm.dataset;
  for (key in oldDataset) {
    if (!dataset2[key]) {
      if (d3) {
        if (key in d3) {
          delete d3[key];
        }
      } else {
        elm.removeAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase());
      }
    }
  }
  for (key in dataset2) {
    if (oldDataset[key] !== dataset2[key]) {
      if (d3) {
        d3[key] = dataset2[key];
      } else {
        elm.setAttribute("data-" + key.replace(CAPS_REGEX, "-$&").toLowerCase(), dataset2[key]);
      }
    }
  }
}
const datasetModule = {
  create: updateDataset,
  update: updateDataset
};
function invokeHandler(handler3, vnode2, event) {
  if (typeof handler3 === "function") {
    handler3.call(vnode2, event, vnode2);
  } else if (typeof handler3 === "object") {
    for (let i2 = 0; i2 < handler3.length; i2++) {
      invokeHandler(handler3[i2], vnode2, event);
    }
  }
}
function handleEvent(event, vnode2) {
  const name2 = event.type;
  const on2 = vnode2.data.on;
  if (on2 && on2[name2]) {
    invokeHandler(on2[name2], vnode2, event);
  }
}
function createListener() {
  return function handler3(event) {
    handleEvent(event, handler3.vnode);
  };
}
function updateEventListeners(oldVnode, vnode2) {
  const oldOn = oldVnode.data.on;
  const oldListener = oldVnode.listener;
  const oldElm = oldVnode.elm;
  const on2 = vnode2 && vnode2.data.on;
  const elm = vnode2 && vnode2.elm;
  let name2;
  if (oldOn === on2) {
    return;
  }
  if (oldOn && oldListener) {
    if (!on2) {
      for (name2 in oldOn) {
        oldElm.removeEventListener(name2, oldListener, false);
      }
    } else {
      for (name2 in oldOn) {
        if (!on2[name2]) {
          oldElm.removeEventListener(name2, oldListener, false);
        }
      }
    }
  }
  if (on2) {
    const listener = vnode2.listener = oldVnode.listener || createListener();
    listener.vnode = vnode2;
    if (!oldOn) {
      for (name2 in on2) {
        elm.addEventListener(name2, listener, false);
      }
    } else {
      for (name2 in on2) {
        if (!oldOn[name2]) {
          elm.addEventListener(name2, listener, false);
        }
      }
    }
  }
}
const eventListenersModule = {
  create: updateEventListeners,
  update: updateEventListeners,
  destroy: updateEventListeners
};
function updateProps(oldVnode, vnode2) {
  let key;
  let cur;
  let old;
  const elm = vnode2.elm;
  let oldProps = oldVnode.data.props;
  let props = vnode2.data.props;
  if (!oldProps && !props)
    return;
  if (oldProps === props)
    return;
  oldProps = oldProps || {};
  props = props || {};
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== "value" || elm[key] !== cur)) {
      elm[key] = cur;
    }
  }
}
const propsModule = { create: updateProps, update: updateProps };
const raf = typeof window !== "undefined" && window.requestAnimationFrame.bind(window) || setTimeout;
const nextFrame = function(fn2) {
  raf(function() {
    raf(fn2);
  });
};
let reflowForced = false;
function setNextFrame(obj, prop, val2) {
  nextFrame(function() {
    obj[prop] = val2;
  });
}
function updateStyle(oldVnode, vnode2) {
  let cur;
  let name2;
  const elm = vnode2.elm;
  let oldStyle = oldVnode.data.style;
  let style = vnode2.data.style;
  if (!oldStyle && !style)
    return;
  if (oldStyle === style)
    return;
  oldStyle = oldStyle || {};
  style = style || {};
  const oldHasDel = "delayed" in oldStyle;
  for (name2 in oldStyle) {
    if (!style[name2]) {
      if (name2[0] === "-" && name2[1] === "-") {
        elm.style.removeProperty(name2);
      } else {
        elm.style[name2] = "";
      }
    }
  }
  for (name2 in style) {
    cur = style[name2];
    if (name2 === "delayed" && style.delayed) {
      for (const name22 in style.delayed) {
        cur = style.delayed[name22];
        if (!oldHasDel || cur !== oldStyle.delayed[name22]) {
          setNextFrame(elm.style, name22, cur);
        }
      }
    } else if (name2 !== "remove" && cur !== oldStyle[name2]) {
      if (name2[0] === "-" && name2[1] === "-") {
        elm.style.setProperty(name2, cur);
      } else {
        elm.style[name2] = cur;
      }
    }
  }
}
function applyDestroyStyle(vnode2) {
  let style;
  let name2;
  const elm = vnode2.elm;
  const s2 = vnode2.data.style;
  if (!s2 || !(style = s2.destroy))
    return;
  for (name2 in style) {
    elm.style[name2] = style[name2];
  }
}
function applyRemoveStyle(vnode2, rm2) {
  const s2 = vnode2.data.style;
  if (!s2 || !s2.remove) {
    rm2();
    return;
  }
  if (!reflowForced) {
    vnode2.elm.offsetLeft;
    reflowForced = true;
  }
  let name2;
  const elm = vnode2.elm;
  let i2 = 0;
  const style = s2.remove;
  let amount = 0;
  const applied = [];
  for (name2 in style) {
    applied.push(name2);
    elm.style[name2] = style[name2];
  }
  const compStyle = getComputedStyle(elm);
  const props = compStyle["transition-property"].split(", ");
  for (; i2 < props.length; ++i2) {
    if (applied.indexOf(props[i2]) !== -1)
      amount++;
  }
  elm.addEventListener("transitionend", function(ev) {
    if (ev.target === elm)
      --amount;
    if (amount === 0)
      rm2();
  });
}
function forceReflow() {
  reflowForced = false;
}
const styleModule = {
  pre: forceReflow,
  create: updateStyle,
  update: updateStyle,
  destroy: applyDestroyStyle,
  remove: applyRemoveStyle
};
function flattenAndFilter(children2, flattened) {
  for (const child of children2) {
    if (child !== void 0 && child !== null && child !== false && child !== "") {
      if (Array.isArray(child)) {
        flattenAndFilter(child, flattened);
      } else if (typeof child === "string" || typeof child === "number" || typeof child === "boolean") {
        flattened.push(vnode(void 0, void 0, void 0, String(child), void 0));
      } else {
        flattened.push(child);
      }
    }
  }
  return flattened;
}
function jsx(tag, data5, ...children2) {
  const flatChildren = flattenAndFilter(children2, []);
  if (typeof tag === "function") {
    return tag(data5, flatChildren);
  } else {
    if (flatChildren.length === 1 && !flatChildren[0].sel && flatChildren[0].text) {
      return h$3(tag, data5, flatChildren[0].text);
    } else {
      return h$3(tag, data5, flatChildren);
    }
  }
}
(function(jsx2) {
})(jsx || (jsx = {}));
var INFINITY = 1 / 0;
var symbolTag$1 = "[object Symbol]";
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0", rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")", rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reApos = RegExp(rsApos, "g");
var reComboMark = RegExp(rsCombo, "g");
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
  rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
  rsUpper + "+" + rsOptUpperContr,
  rsDigits,
  rsEmoji
].join("|"), "g");
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  "\xC6": "Ae",
  "\xE6": "ae",
  "\xDE": "Th",
  "\xFE": "th",
  "\xDF": "ss",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  "\u0132": "IJ",
  "\u0133": "ij",
  "\u0152": "Oe",
  "\u0153": "oe",
  "\u0149": "'n",
  "\u017F": "ss"
};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal$1 || freeSelf$1 || Function("return this")();
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index = -1, length2 = array2 ? array2.length : 0;
  if (initAccum && length2) {
    accumulator = array2[++index];
  }
  while (++index < length2) {
    accumulator = iteratee(accumulator, array2[index], index, array2);
  }
  return accumulator;
}
function asciiToArray(string) {
  return string.split("");
}
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var deburrLetter = basePropertyOf(deburredLetters);
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var objectProto$1 = Object.prototype;
var objectToString$1 = objectProto$1.toString;
var Symbol$1 = root$1.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseSlice(array2, start2, end2) {
  var index = -1, length2 = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length2 ? 0 : length2 + start2;
  }
  end2 = end2 > length2 ? length2 : end2;
  if (end2 < 0) {
    end2 += length2;
  }
  length2 = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length2);
  while (++index < length2) {
    result[index] = array2[index + start2];
  }
  return result;
}
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function castSlice(array2, start2, end2) {
  var length2 = array2.length;
  end2 = end2 === void 0 ? length2 : end2;
  return !start2 && end2 >= length2 ? array2 : baseSlice(array2, start2, end2);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize(word) : word);
});
function capitalize(string) {
  return upperFirst(toString(string).toLowerCase());
}
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var upperFirst = createCaseFirst("toUpperCase");
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
var lodash_camelcase = camelCase;
var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
var MODIFIERS = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
};
var ALIASES = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IS_MAC ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
};
var CODES = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var f$2 = 1; f$2 < 20; f$2++) {
  CODES["f" + f$2] = 111 + f$2;
}
function isHotkey(hotkey, options, event) {
  if (options && !("byKey" in options)) {
    event = options;
    options = null;
  }
  if (!Array.isArray(hotkey)) {
    hotkey = [hotkey];
  }
  var array2 = hotkey.map(function(string) {
    return parseHotkey(string, options);
  });
  var check2 = function check3(e3) {
    return array2.some(function(object) {
      return compareHotkey(object, e3);
    });
  };
  var ret = event == null ? check2 : check2(event);
  return ret;
}
function isKeyHotkey(hotkey, event) {
  return isHotkey(hotkey, { byKey: true }, event);
}
function parseHotkey(hotkey, options) {
  var byKey = options && options.byKey;
  var ret = {};
  hotkey = hotkey.replace("++", "+add");
  var values2 = hotkey.split("+");
  var length2 = values2.length;
  for (var k2 in MODIFIERS) {
    ret[MODIFIERS[k2]] = false;
  }
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = values2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var value = _step.value;
      var optional = value.endsWith("?") && value.length > 1;
      if (optional) {
        value = value.slice(0, -1);
      }
      var name2 = toKeyName(value);
      var modifier = MODIFIERS[name2];
      if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name2]) {
        throw new TypeError('Unknown modifier: "' + value + '"');
      }
      if (length2 === 1 || !modifier) {
        if (byKey) {
          ret.key = name2;
        } else {
          ret.which = toKeyCode(value);
        }
      }
      if (modifier) {
        ret[modifier] = optional ? null : true;
      }
    }
  } catch (err2) {
    _didIteratorError = true;
    _iteratorError = err2;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return ret;
}
function compareHotkey(object, event) {
  for (var key in object) {
    var expected = object[key];
    var actual = void 0;
    if (expected == null) {
      continue;
    }
    if (key === "key" && event.key != null) {
      actual = event.key.toLowerCase();
    } else if (key === "which") {
      actual = expected === 91 && event.which === 93 ? 91 : event.which;
    } else {
      actual = event[key];
    }
    if (actual == null && expected === false) {
      continue;
    }
    if (actual !== expected) {
      return false;
    }
  }
  return true;
}
function toKeyCode(name2) {
  name2 = toKeyName(name2);
  var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
  return code;
}
function toKeyName(name2) {
  name2 = name2.toLowerCase();
  name2 = ALIASES[name2] || name2;
  return name2;
}
var isHotkey_1 = isHotkey;
var isKeyHotkey_1 = isKeyHotkey;
var FUNC_ERROR_TEXT = "Expected a function";
var NAN = 0 / 0;
var symbolTag = "[object Symbol]";
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var nativeMax = Math.max, nativeMin = Math.min;
var now = function() {
  return root.Date.now();
};
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
    return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time2 = now(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, "");
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var lodash_debounce = debounce$1;
var lodash_clonedeep = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag = "[object Number]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", regexpTag = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag2 = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag2] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag2] = cloneableTags[numberTag] = cloneableTags[objectTag2] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map2, pair) {
    map2.set(pair[0], pair[1]);
    return map2;
  }
  function addSetEntry(set2, value) {
    set2.add(value);
    return set2;
  }
  function arrayEach2(array2, iteratee) {
    var index = -1, length2 = array2 ? array2.length : 0;
    while (++index < length2) {
      if (iteratee(array2[index], index, array2) === false) {
        break;
      }
    }
    return array2;
  }
  function arrayPush(array2, values2) {
    var index = -1, length2 = values2.length, offset2 = array2.length;
    while (++index < length2) {
      array2[offset2 + index] = values2[index];
    }
    return array2;
  }
  function arrayReduce2(array2, iteratee, accumulator, initAccum) {
    var index = -1, length2 = array2 ? array2.length : 0;
    if (initAccum && length2) {
      accumulator = array2[++index];
    }
    while (++index < length2) {
      accumulator = iteratee(accumulator, array2[index], index, array2);
    }
    return accumulator;
  }
  function baseTimes2(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject2(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e3) {
      }
    }
    return result;
  }
  function mapToArray2(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg2(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray2(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, getPrototype = overArg2(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys2 = overArg2(Object.keys, Object);
  var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries2) {
    var index = -1, length2 = entries2 ? entries2.length : 0;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
  }
  function hashDelete2(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet2(key) {
    var data5 = this.__data__;
    if (nativeCreate2) {
      var result = data5[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data5, key) ? data5[key] : void 0;
  }
  function hashHas2(key) {
    var data5 = this.__data__;
    return nativeCreate2 ? data5[key] !== void 0 : hasOwnProperty2.call(data5, key);
  }
  function hashSet2(key, value) {
    var data5 = this.__data__;
    data5[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries2) {
    var index = -1, length2 = entries2 ? entries2.length : 0;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
  }
  function listCacheDelete2(key) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data5.length - 1;
    if (index == lastIndex) {
      data5.pop();
    } else {
      splice2.call(data5, index, 1);
    }
    return true;
  }
  function listCacheGet2(key) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    return index < 0 ? void 0 : data5[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    if (index < 0) {
      data5.push([key, value]);
    } else {
      data5[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries2) {
    var index = -1, length2 = entries2 ? entries2.length : 0;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    return getMapData2(this, key)["delete"](key);
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    getMapData2(this, key).set(key, value);
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function Stack(entries2) {
    this.__data__ = new ListCache2(entries2);
  }
  function stackClear() {
    this.__data__ = new ListCache2();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache2 = this.__data__;
    if (cache2 instanceof ListCache2) {
      var pairs = cache2.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache2 = this.__data__ = new MapCache2(pairs);
    }
    cache2.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys2(value, inherited) {
    var result = isArray2(value) || isArguments2(value) ? baseTimes2(value.length, String) : [];
    var length2 = result.length, skipIndexes = !!length2;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === void 0 && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf2(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys2(source), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray2(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray2(value, result);
      }
    } else {
      var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
        if (isHostObject2(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys2(value);
    }
    arrayEach2(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto2) {
    return isObject2(proto2) ? objectCreate(proto2) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag2(value) {
    return objectToString2.call(value);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseKeys2(object) {
    if (!isPrototype2(object)) {
      return nativeKeys2(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map2, isDeep, cloneFunc) {
    var array2 = isDeep ? cloneFunc(mapToArray2(map2), true) : mapToArray2(map2);
    return arrayReduce2(array2, addMapEntry, new map2.constructor());
  }
  function cloneRegExp(regexp2) {
    var result = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
    result.lastIndex = regexp2.lastIndex;
    return result;
  }
  function cloneSet(set2, isDeep, cloneFunc) {
    var array2 = isDeep ? cloneFunc(setToArray2(set2), true) : setToArray2(set2);
    return arrayReduce2(array2, addSetEntry, new set2.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray2(source, array2) {
    var index = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index < length2) {
      array2[index] = source[index];
    }
    return array2;
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length2 = props.length;
    while (++index < length2) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      assignValue(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  function getMapData2(map2, key) {
    var data5 = map2.__data__;
    return isKeyable2(key) ? data5[typeof key == "string" ? "string" : "hash"] : data5.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols ? overArg2(nativeGetSymbols, Object) : stubArray;
  var getTag2 = baseGetTag2;
  if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
    getTag2 = function(value) {
      var result = objectToString2.call(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString2:
            return dataViewTag2;
          case mapCtorString2:
            return mapTag2;
          case promiseCtorString2:
            return promiseTag2;
          case setCtorString2:
            return setTag2;
          case weakMapCtorString2:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  function initCloneArray(array2) {
    var length2 = array2.length, result = array2.constructor(length2);
    if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
      result.index = array2.index;
      result.input = array2.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag2:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag2:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag2:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag2:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag2:
        return cloneSymbol(object);
    }
  }
  function isIndex2(value, length2) {
    length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
    return !!length2 && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments2(value) {
    return isArrayLikeObject2(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable2.call(value, "callee") || objectToString2.call(value) == argsTag2);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject2(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString2.call(value) : "";
    return tag == funcTag2 || tag == genTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return !!value && typeof value == "object";
  }
  function keys2(object) {
    return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
});
var hasProperty = function has2(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};
var _apply;
function _classPrivateFieldLooseBase$8(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$a = 0;
function _classPrivateFieldLooseKey$8(name2) {
  return "__private_" + id$a++ + "_" + name2;
}
function insertReplacement(source, rx, replacement) {
  const newParts = [];
  source.forEach((chunk2) => {
    if (typeof chunk2 !== "string") {
      return newParts.push(chunk2);
    }
    return rx[Symbol.split](chunk2).forEach((raw, i2, list) => {
      if (raw !== "") {
        newParts.push(raw);
      }
      if (i2 < list.length - 1) {
        newParts.push(replacement);
      }
    });
  });
  return newParts;
}
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */
function interpolate(phrase, options) {
  const dollarRegex = /\$/g;
  const dollarBillsYall = "$$$$";
  let interpolated = [phrase];
  if (options == null)
    return interpolated;
  for (const arg of Object.keys(options)) {
    if (arg !== "_") {
      let replacement = options[arg];
      if (typeof replacement === "string") {
        replacement = dollarRegex[Symbol.replace](replacement, dollarBillsYall);
      }
      interpolated = insertReplacement(interpolated, new RegExp(`%\\{${arg}\\}`, "g"), replacement);
    }
  }
  return interpolated;
}
var Translator_1 = (_apply = /* @__PURE__ */ _classPrivateFieldLooseKey$8("apply"), class Translator {
  constructor(locales) {
    Object.defineProperty(this, _apply, {
      value: _apply2
    });
    this.locale = {
      strings: {},
      pluralize(n2) {
        if (n2 === 1) {
          return 0;
        }
        return 1;
      }
    };
    if (Array.isArray(locales)) {
      locales.forEach(_classPrivateFieldLooseBase$8(this, _apply)[_apply], this);
    } else {
      _classPrivateFieldLooseBase$8(this, _apply)[_apply](locales);
    }
  }
  translate(key, options) {
    return this.translateArray(key, options).join("");
  }
  translateArray(key, options) {
    if (!hasProperty(this.locale.strings, key)) {
      throw new Error(`missing string: ${key}`);
    }
    const string = this.locale.strings[key];
    const hasPluralForms = typeof string === "object";
    if (hasPluralForms) {
      if (options && typeof options.smart_count !== "undefined") {
        const plural = this.locale.pluralize(options.smart_count);
        return interpolate(string[plural], options);
      }
      throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}");
    }
    return interpolate(string, options);
  }
});
function _apply2(locale2) {
  if (!(locale2 != null && locale2.strings)) {
    return;
  }
  const prevLocale = this.locale;
  this.locale = {
    ...prevLocale,
    strings: {
      ...prevLocale.strings,
      ...locale2.strings
    }
  };
  this.locale.pluralize = locale2.pluralize || prevLocale.pluralize;
}
var namespaceEmitter = function createNamespaceEmitter() {
  var emitter2 = {};
  var _fns = emitter2._fns = {};
  emitter2.emit = function emit(event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event);
    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6]);
    }
  };
  emitter2.on = function on2(event, fn2) {
    if (!_fns[event]) {
      _fns[event] = [];
    }
    _fns[event].push(fn2);
  };
  emitter2.once = function once2(event, fn2) {
    function one() {
      fn2.apply(this, arguments);
      emitter2.off(event, one);
    }
    this.on(event, one);
  };
  emitter2.off = function off2(event, fn2) {
    var keep = [];
    if (event && fn2) {
      var fns = this._fns[event];
      var i2 = 0;
      var l2 = fns ? fns.length : 0;
      for (i2; i2 < l2; i2++) {
        if (fns[i2] !== fn2) {
          keep.push(fns[i2]);
        }
      }
    }
    keep.length ? this._fns[event] = keep : delete this._fns[event];
  };
  function getListeners(e3) {
    var out2 = _fns[e3] ? _fns[e3] : [];
    var idx = e3.indexOf(":");
    var args = idx === -1 ? [e3] : [e3.substring(0, idx), e3.substring(idx + 1)];
    var keys2 = Object.keys(_fns);
    var i2 = 0;
    var l2 = keys2.length;
    for (i2; i2 < l2; i2++) {
      var key = keys2[i2];
      if (key === "*") {
        out2 = out2.concat(_fns[key]);
      }
      if (args.length === 2 && args[0] === key) {
        out2 = out2.concat(_fns[key]);
        break;
      }
    }
    return out2;
  }
  function emitAll(e3, fns, args) {
    var i2 = 0;
    var l2 = fns.length;
    for (i2; i2 < l2; i2++) {
      if (!fns[i2])
        break;
      fns[i2].event = e3;
      fns[i2].apply(fns[i2], args);
    }
  }
  return emitter2;
};
let urlAlphabet$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var urlAlphabet_1 = { urlAlphabet: urlAlphabet$1 };
let { urlAlphabet } = urlAlphabet_1;
{
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
    throw new Error(
      "React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID."
    );
  }
  if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
    throw new Error(
      "Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support"
    );
  }
  if (typeof crypto === "undefined") {
    throw new Error(
      "Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure."
    );
  }
}
let random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, size, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * size / alphabet.length);
  return () => {
    let id2 = "";
    while (true) {
      let bytes = getRandom(step);
      let j2 = step;
      while (j2--) {
        id2 += alphabet[bytes[j2] & mask] || "";
        if (id2.length === size)
          return id2;
      }
    }
  };
};
let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);
let nanoid$2 = (size = 21) => {
  let id2 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    let byte = bytes[size] & 63;
    if (byte < 36) {
      id2 += byte.toString(36);
    } else if (byte < 62) {
      id2 += (byte - 26).toString(36).toUpperCase();
    } else if (byte < 63) {
      id2 += "_";
    } else {
      id2 += "-";
    }
  }
  return id2;
};
var index_browser = { nanoid: nanoid$2, customAlphabet, customRandom, urlAlphabet, random };
var prettierBytes = function prettierBytes2(num) {
  if (typeof num !== "number" || isNaN(num)) {
    throw new TypeError("Expected a number, got " + typeof num);
  }
  var neg = num < 0;
  var units = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  if (neg) {
    num = -num;
  }
  if (num < 1) {
    return (neg ? "-" : "") + num + " B";
  }
  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
  num = Number(num / Math.pow(1024, exponent));
  var unit = units[exponent];
  if (num >= 10 || num % 1 === 0) {
    return (neg ? "-" : "") + num.toFixed(0) + " " + unit;
  } else {
    return (neg ? "-" : "") + num.toFixed(1) + " " + unit;
  }
};
function WildcardMatcher(text2, separator) {
  this.text = text2 = text2 || "";
  this.hasWild = ~text2.indexOf("*");
  this.separator = separator;
  this.parts = text2.split(separator);
}
WildcardMatcher.prototype.match = function(input4) {
  var matches = true;
  var parts = this.parts;
  var ii2;
  var partsCount = parts.length;
  var testParts;
  if (typeof input4 == "string" || input4 instanceof String) {
    if (!this.hasWild && this.text != input4) {
      matches = false;
    } else {
      testParts = (input4 || "").split(this.separator);
      for (ii2 = 0; matches && ii2 < partsCount; ii2++) {
        if (parts[ii2] === "*") {
          continue;
        } else if (ii2 < testParts.length) {
          matches = parts[ii2] === testParts[ii2];
        } else {
          matches = false;
        }
      }
      matches = matches && testParts;
    }
  } else if (typeof input4.splice == "function") {
    matches = [];
    for (ii2 = input4.length; ii2--; ) {
      if (this.match(input4[ii2])) {
        matches[matches.length] = input4[ii2];
      }
    }
  } else if (typeof input4 == "object") {
    matches = {};
    for (var key in input4) {
      if (this.match(key)) {
        matches[key] = input4[key];
      }
    }
  }
  return matches;
};
var wildcard = function(text2, test, separator) {
  var matcher = new WildcardMatcher(text2, separator || /[\/\.]/);
  if (typeof test != "undefined") {
    return matcher.match(test);
  }
  return matcher;
};
var reMimePartSplit = /[\/\+\.]/;
var mimeMatch = function(target, pattern) {
  function test(pattern2) {
    var result = wildcard(pattern2, target, reMimePartSplit);
    return result && result.length >= 2;
  }
  return pattern ? test(pattern.split(";")[0]) : test;
};
function _classPrivateFieldLooseBase$7(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$9 = 0;
function _classPrivateFieldLooseKey$7(name2) {
  return "__private_" + id$9++ + "_" + name2;
}
var _publish = /* @__PURE__ */ _classPrivateFieldLooseKey$7("publish");
class DefaultStore {
  constructor() {
    Object.defineProperty(this, _publish, {
      value: _publish2
    });
    this.state = {};
    this.callbacks = [];
  }
  getState() {
    return this.state;
  }
  setState(patch) {
    const prevState = {
      ...this.state
    };
    const nextState = {
      ...this.state,
      ...patch
    };
    this.state = nextState;
    _classPrivateFieldLooseBase$7(this, _publish)[_publish](prevState, nextState, patch);
  }
  subscribe(listener) {
    this.callbacks.push(listener);
    return () => {
      this.callbacks.splice(this.callbacks.indexOf(listener), 1);
    };
  }
}
function _publish2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  this.callbacks.forEach((listener) => {
    listener(...args);
  });
}
DefaultStore.VERSION = "2.0.3";
var lib$3 = function defaultStore() {
  return new DefaultStore();
};
var getFileNameAndExtension = function getFileNameAndExtension2(fullFileName) {
  const lastDot = fullFileName.lastIndexOf(".");
  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: void 0
    };
  }
  return {
    name: fullFileName.slice(0, lastDot),
    extension: fullFileName.slice(lastDot + 1)
  };
};
var mimeTypes = {
  md: "text/markdown",
  markdown: "text/markdown",
  mp4: "video/mp4",
  mp3: "audio/mp3",
  svg: "image/svg+xml",
  jpg: "image/jpeg",
  png: "image/png",
  gif: "image/gif",
  heic: "image/heic",
  heif: "image/heif",
  yaml: "text/yaml",
  yml: "text/yaml",
  csv: "text/csv",
  tsv: "text/tab-separated-values",
  tab: "text/tab-separated-values",
  avi: "video/x-msvideo",
  mks: "video/x-matroska",
  mkv: "video/x-matroska",
  mov: "video/quicktime",
  doc: "application/msword",
  docm: "application/vnd.ms-word.document.macroenabled.12",
  docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  dot: "application/msword",
  dotm: "application/vnd.ms-word.template.macroenabled.12",
  dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  xla: "application/vnd.ms-excel",
  xlam: "application/vnd.ms-excel.addin.macroenabled.12",
  xlc: "application/vnd.ms-excel",
  xlf: "application/x-xliff+xml",
  xlm: "application/vnd.ms-excel",
  xls: "application/vnd.ms-excel",
  xlsb: "application/vnd.ms-excel.sheet.binary.macroenabled.12",
  xlsm: "application/vnd.ms-excel.sheet.macroenabled.12",
  xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  xlt: "application/vnd.ms-excel",
  xltm: "application/vnd.ms-excel.template.macroenabled.12",
  xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  xlw: "application/vnd.ms-excel",
  txt: "text/plain",
  text: "text/plain",
  conf: "text/plain",
  log: "text/plain",
  pdf: "application/pdf",
  zip: "application/zip",
  "7z": "application/x-7z-compressed",
  rar: "application/x-rar-compressed",
  tar: "application/x-tar",
  gz: "application/gzip",
  dmg: "application/x-apple-diskimage"
};
var getFileType = function getFileType2(file) {
  var _getFileNameAndExtens;
  if (file.type)
    return file.type;
  const fileExtension = file.name ? (_getFileNameAndExtens = getFileNameAndExtension(file.name).extension) == null ? void 0 : _getFileNameAndExtens.toLowerCase() : null;
  if (fileExtension && fileExtension in mimeTypes) {
    return mimeTypes[fileExtension];
  }
  return "application/octet-stream";
};
function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}
function encodeFilename(name2) {
  let suffix = "";
  return name2.replace(/[^A-Z0-9]/ig, (character) => {
    suffix += `-${encodeCharacter(character)}`;
    return "/";
  }) + suffix;
}
var generateFileID = function generateFileID2(file) {
  let id2 = "uppy";
  if (typeof file.name === "string") {
    id2 += `-${encodeFilename(file.name.toLowerCase())}`;
  }
  if (file.type !== void 0) {
    id2 += `-${file.type}`;
  }
  if (file.meta && typeof file.meta.relativePath === "string") {
    id2 += `-${encodeFilename(file.meta.relativePath.toLowerCase())}`;
  }
  if (file.data.size !== void 0) {
    id2 += `-${file.data.size}`;
  }
  if (file.data.lastModified !== void 0) {
    id2 += `-${file.data.lastModified}`;
  }
  return id2;
};
var supportsUploadProgress = function supportsUploadProgress2(userAgent) {
  if (userAgent == null) {
    userAgent = typeof navigator !== "undefined" ? navigator.userAgent : null;
  }
  if (!userAgent)
    return true;
  const m2 = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m2)
    return true;
  const edgeVersion = m2[1];
  let [major, minor] = edgeVersion.split(".");
  major = parseInt(major, 10);
  minor = parseInt(minor, 10);
  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  }
  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  }
  return false;
};
var getFileName = function getFileName2(fileType, fileDescriptor) {
  if (fileDescriptor.name) {
    return fileDescriptor.name;
  }
  if (fileType.split("/")[0] === "image") {
    return `${fileType.split("/")[0]}.${fileType.split("/")[1]}`;
  }
  return "noname";
};
function pad(number2) {
  return number2 < 10 ? `0${number2}` : number2.toString();
}
var getTimeStamp = function getTimeStamp2() {
  const date = new Date();
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${hours}:${minutes}:${seconds}`;
};
const justErrorsLogger$1 = {
  debug: () => {
  },
  warn: () => {
  },
  error: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
  }
};
const debugLogger$2 = {
  debug: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return console.debug(`[Uppy] [${getTimeStamp()}]`, ...args);
  },
  warn: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return console.warn(`[Uppy] [${getTimeStamp()}]`, ...args);
  },
  error: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return console.error(`[Uppy] [${getTimeStamp()}]`, ...args);
  }
};
var loggers = {
  justErrorsLogger: justErrorsLogger$1,
  debugLogger: debugLogger$2
};
var locale$1 = {
  strings: {
    addBulkFilesFailed: {
      0: "Failed to add %{smart_count} file due to an internal error",
      1: "Failed to add %{smart_count} files due to internal errors"
    },
    youCanOnlyUploadX: {
      0: "You can only upload %{smart_count} file",
      1: "You can only upload %{smart_count} files"
    },
    youHaveToAtLeastSelectX: {
      0: "You have to select at least %{smart_count} file",
      1: "You have to select at least %{smart_count} files"
    },
    exceedsSize: "%{file} exceeds maximum allowed size of %{size}",
    missingRequiredMetaField: "Missing required meta fields",
    missingRequiredMetaFieldOnFile: "Missing required meta fields in %{fileName}",
    inferiorSize: "This file is smaller than the allowed size of %{size}",
    youCanOnlyUploadFileTypes: "You can only upload: %{types}",
    noMoreFilesAllowed: "Cannot add more files",
    noDuplicates: "Cannot add the duplicate file '%{fileName}', it already exists",
    companionError: "Connection with Companion failed",
    authAborted: "Authentication aborted",
    companionUnauthorizeHint: "To unauthorize to your %{provider} account, please go to %{url}",
    failedToUpload: "Failed to upload %{file}",
    noInternetConnection: "No Internet connection",
    connectedToInternet: "Connected to the Internet",
    noFilesFound: "You have no files or folders here",
    selectX: {
      0: "Select %{smart_count}",
      1: "Select %{smart_count}"
    },
    allFilesFromFolderNamed: "All files from folder %{name}",
    openFolderNamed: "Open folder %{name}",
    cancel: "Cancel",
    logOut: "Log out",
    filter: "Filter",
    resetFilter: "Reset filter",
    loading: "Loading...",
    authenticateWithTitle: "Please authenticate with %{pluginName} to select files",
    authenticateWith: "Connect to %{pluginName}",
    signInWithGoogle: "Sign in with Google",
    searchImages: "Search for images",
    enterTextToSearch: "Enter text to search for images",
    backToSearch: "Back to Search",
    emptyFolderAdded: "No files were added from empty folder",
    folderAlreadyAdded: 'The folder "%{folder}" was already added',
    folderAdded: {
      0: "Added %{smart_count} file from %{folder}",
      1: "Added %{smart_count} files from %{folder}"
    }
  }
};
var require$$0 = index_browser;
let _Symbol$for$1, _Symbol$for2$1;
function _classPrivateFieldLooseBase$6(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$8 = 0;
function _classPrivateFieldLooseKey$6(name2) {
  return "__private_" + id$8++ + "_" + name2;
}
const {
  nanoid: nanoid$1
} = require$$0;
const {
  justErrorsLogger,
  debugLogger: debugLogger$1
} = loggers;
class RestrictionError extends Error {
  constructor() {
    super(...arguments);
    this.isRestriction = true;
  }
}
if (typeof AggregateError === "undefined") {
  globalThis.AggregateError = class AggregateError extends Error {
    constructor(errors, message2) {
      super(message2);
      this.errors = errors;
    }
  };
}
class AggregateRestrictionError extends AggregateError {
  constructor() {
    super(...arguments);
    this.isRestriction = true;
  }
}
var _plugins = /* @__PURE__ */ _classPrivateFieldLooseKey$6("plugins");
var _storeUnsubscribe = /* @__PURE__ */ _classPrivateFieldLooseKey$6("storeUnsubscribe");
var _emitter$2 = /* @__PURE__ */ _classPrivateFieldLooseKey$6("emitter");
var _preProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$6("preProcessors");
var _uploaders = /* @__PURE__ */ _classPrivateFieldLooseKey$6("uploaders");
var _postProcessors = /* @__PURE__ */ _classPrivateFieldLooseKey$6("postProcessors");
var _checkRestrictions = /* @__PURE__ */ _classPrivateFieldLooseKey$6("checkRestrictions");
var _checkMinNumberOfFiles = /* @__PURE__ */ _classPrivateFieldLooseKey$6("checkMinNumberOfFiles");
var _checkRequiredMetaFieldsOnFile = /* @__PURE__ */ _classPrivateFieldLooseKey$6("checkRequiredMetaFieldsOnFile");
var _checkRequiredMetaFields = /* @__PURE__ */ _classPrivateFieldLooseKey$6("checkRequiredMetaFields");
var _showOrLogErrorAndThrow = /* @__PURE__ */ _classPrivateFieldLooseKey$6("showOrLogErrorAndThrow");
var _assertNewUploadAllowed = /* @__PURE__ */ _classPrivateFieldLooseKey$6("assertNewUploadAllowed");
var _checkAndCreateFileStateObject = /* @__PURE__ */ _classPrivateFieldLooseKey$6("checkAndCreateFileStateObject");
var _startIfAutoProceed = /* @__PURE__ */ _classPrivateFieldLooseKey$6("startIfAutoProceed");
var _addListeners = /* @__PURE__ */ _classPrivateFieldLooseKey$6("addListeners");
var _updateOnlineStatus = /* @__PURE__ */ _classPrivateFieldLooseKey$6("updateOnlineStatus");
var _createUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$6("createUpload");
var _getUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$6("getUpload");
var _removeUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$6("removeUpload");
var _runUpload = /* @__PURE__ */ _classPrivateFieldLooseKey$6("runUpload");
_Symbol$for$1 = Symbol.for("uppy test: getPlugins");
_Symbol$for2$1 = Symbol.for("uppy test: createUpload");
class Uppy {
  constructor(_opts) {
    Object.defineProperty(this, _runUpload, {
      value: _runUpload2
    });
    Object.defineProperty(this, _removeUpload, {
      value: _removeUpload2
    });
    Object.defineProperty(this, _getUpload, {
      value: _getUpload2
    });
    Object.defineProperty(this, _createUpload, {
      value: _createUpload2
    });
    Object.defineProperty(this, _addListeners, {
      value: _addListeners2
    });
    Object.defineProperty(this, _startIfAutoProceed, {
      value: _startIfAutoProceed2
    });
    Object.defineProperty(this, _checkAndCreateFileStateObject, {
      value: _checkAndCreateFileStateObject2
    });
    Object.defineProperty(this, _assertNewUploadAllowed, {
      value: _assertNewUploadAllowed2
    });
    Object.defineProperty(this, _showOrLogErrorAndThrow, {
      value: _showOrLogErrorAndThrow2
    });
    Object.defineProperty(this, _checkRequiredMetaFields, {
      value: _checkRequiredMetaFields2
    });
    Object.defineProperty(this, _checkRequiredMetaFieldsOnFile, {
      value: _checkRequiredMetaFieldsOnFile2
    });
    Object.defineProperty(this, _checkMinNumberOfFiles, {
      value: _checkMinNumberOfFiles2
    });
    Object.defineProperty(this, _checkRestrictions, {
      value: _checkRestrictions2
    });
    Object.defineProperty(this, _plugins, {
      writable: true,
      value: /* @__PURE__ */ Object.create(null)
    });
    Object.defineProperty(this, _storeUnsubscribe, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _emitter$2, {
      writable: true,
      value: namespaceEmitter()
    });
    Object.defineProperty(this, _preProcessors, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _uploaders, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _postProcessors, {
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, _updateOnlineStatus, {
      writable: true,
      value: this.updateOnlineStatus.bind(this)
    });
    this.defaultLocale = locale$1;
    const defaultOptions = {
      id: "uppy",
      autoProceed: false,
      allowMultipleUploads: true,
      allowMultipleUploadBatches: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        minFileSize: null,
        maxTotalFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null,
        requiredMetaFields: []
      },
      meta: {},
      onBeforeFileAdded: (currentFile) => currentFile,
      onBeforeUpload: (files) => files,
      store: lib$3(),
      logger: justErrorsLogger,
      infoTimeout: 5e3
    };
    this.opts = {
      ...defaultOptions,
      ..._opts,
      restrictions: {
        ...defaultOptions.restrictions,
        ..._opts && _opts.restrictions
      }
    };
    if (_opts && _opts.logger && _opts.debug) {
      this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.", "warning");
    } else if (_opts && _opts.debug) {
      this.opts.logger = debugLogger$1;
    }
    this.log(`Using Core v${this.constructor.VERSION}`);
    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError("`restrictions.allowedFileTypes` must be an array");
    }
    this.i18nInit();
    this.calculateProgress = lodash_throttle(this.calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: {
        ...this.opts.meta
      },
      info: [],
      recoveredState: null
    });
    _classPrivateFieldLooseBase$6(this, _storeUnsubscribe)[_storeUnsubscribe] = this.store.subscribe((prevState, nextState, patch) => {
      this.emit("state-update", prevState, nextState, patch);
      this.updateAll(nextState);
    });
    if (this.opts.debug && typeof window !== "undefined") {
      window[this.opts.id] = this;
    }
    _classPrivateFieldLooseBase$6(this, _addListeners)[_addListeners]();
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    _classPrivateFieldLooseBase$6(this, _emitter$2)[_emitter$2].emit(event, ...args);
  }
  on(event, callback) {
    _classPrivateFieldLooseBase$6(this, _emitter$2)[_emitter$2].on(event, callback);
    return this;
  }
  once(event, callback) {
    _classPrivateFieldLooseBase$6(this, _emitter$2)[_emitter$2].once(event, callback);
    return this;
  }
  off(event, callback) {
    _classPrivateFieldLooseBase$6(this, _emitter$2)[_emitter$2].off(event, callback);
    return this;
  }
  updateAll(state) {
    this.iteratePlugins((plugin) => {
      plugin.update(state);
    });
  }
  setState(patch) {
    this.store.setState(patch);
  }
  getState() {
    return this.store.getState();
  }
  get state() {
    return this.getState();
  }
  setFileState(fileID, state) {
    if (!this.getState().files[fileID]) {
      throw new Error(`Can\u2019t set state for ${fileID} (the file could have been removed)`);
    }
    this.setState({
      files: {
        ...this.getState().files,
        [fileID]: {
          ...this.getState().files[fileID],
          ...state
        }
      }
    });
  }
  i18nInit() {
    const translator = new Translator_1([this.defaultLocale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.locale = translator.locale;
  }
  setOptions(newOpts) {
    this.opts = {
      ...this.opts,
      ...newOpts,
      restrictions: {
        ...this.opts.restrictions,
        ...newOpts && newOpts.restrictions
      }
    };
    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }
    this.i18nInit();
    if (newOpts.locale) {
      this.iteratePlugins((plugin) => {
        plugin.setOptions();
      });
    }
    this.setState();
  }
  resetProgress() {
    const defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };
    const files = {
      ...this.getState().files
    };
    const updatedFiles = {};
    Object.keys(files).forEach((fileID) => {
      const updatedFile = {
        ...files[fileID]
      };
      updatedFile.progress = {
        ...updatedFile.progress,
        ...defaultProgress
      };
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit("reset-progress");
  }
  addPreProcessor(fn2) {
    _classPrivateFieldLooseBase$6(this, _preProcessors)[_preProcessors].add(fn2);
  }
  removePreProcessor(fn2) {
    return _classPrivateFieldLooseBase$6(this, _preProcessors)[_preProcessors].delete(fn2);
  }
  addPostProcessor(fn2) {
    _classPrivateFieldLooseBase$6(this, _postProcessors)[_postProcessors].add(fn2);
  }
  removePostProcessor(fn2) {
    return _classPrivateFieldLooseBase$6(this, _postProcessors)[_postProcessors].delete(fn2);
  }
  addUploader(fn2) {
    _classPrivateFieldLooseBase$6(this, _uploaders)[_uploaders].add(fn2);
  }
  removeUploader(fn2) {
    return _classPrivateFieldLooseBase$6(this, _uploaders)[_uploaders].delete(fn2);
  }
  setMeta(data5) {
    const updatedMeta = {
      ...this.getState().meta,
      ...data5
    };
    const updatedFiles = {
      ...this.getState().files
    };
    Object.keys(updatedFiles).forEach((fileID) => {
      updatedFiles[fileID] = {
        ...updatedFiles[fileID],
        meta: {
          ...updatedFiles[fileID].meta,
          ...data5
        }
      };
    });
    this.log("Adding metadata:");
    this.log(data5);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  }
  setFileMeta(fileID, data5) {
    const updatedFiles = {
      ...this.getState().files
    };
    if (!updatedFiles[fileID]) {
      this.log("Was trying to set metadata for a file that has been removed: ", fileID);
      return;
    }
    const newMeta = {
      ...updatedFiles[fileID].meta,
      ...data5
    };
    updatedFiles[fileID] = {
      ...updatedFiles[fileID],
      meta: newMeta
    };
    this.setState({
      files: updatedFiles
    });
  }
  getFile(fileID) {
    return this.getState().files[fileID];
  }
  getFiles() {
    const {
      files
    } = this.getState();
    return Object.values(files);
  }
  getObjectOfFilesPerState() {
    const {
      files: filesObject,
      totalProgress,
      error
    } = this.getState();
    const files = Object.values(filesObject);
    const inProgressFiles = files.filter((_ref) => {
      let {
        progress
      } = _ref;
      return !progress.uploadComplete && progress.uploadStarted;
    });
    const newFiles = files.filter((file) => !file.progress.uploadStarted);
    const startedFiles = files.filter((file) => file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess);
    const uploadStartedFiles = files.filter((file) => file.progress.uploadStarted);
    const pausedFiles = files.filter((file) => file.isPaused);
    const completeFiles = files.filter((file) => file.progress.uploadComplete);
    const erroredFiles = files.filter((file) => file.error);
    const inProgressNotPausedFiles = inProgressFiles.filter((file) => !file.isPaused);
    const processingFiles = files.filter((file) => file.progress.preprocess || file.progress.postprocess);
    return {
      newFiles,
      startedFiles,
      uploadStartedFiles,
      pausedFiles,
      completeFiles,
      erroredFiles,
      inProgressFiles,
      inProgressNotPausedFiles,
      processingFiles,
      isUploadStarted: uploadStartedFiles.length > 0,
      isAllComplete: totalProgress === 100 && completeFiles.length === files.length && processingFiles.length === 0,
      isAllErrored: !!error && erroredFiles.length === files.length,
      isAllPaused: inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length,
      isUploadInProgress: inProgressFiles.length > 0,
      isSomeGhost: files.some((file) => file.isGhost)
    };
  }
  validateRestrictions(file, files) {
    try {
      _classPrivateFieldLooseBase$6(this, _checkRestrictions)[_checkRestrictions](file, files);
      return {
        result: true
      };
    } catch (err2) {
      return {
        result: false,
        reason: err2.message
      };
    }
  }
  checkIfFileAlreadyExists(fileID) {
    const {
      files
    } = this.getState();
    if (files[fileID] && !files[fileID].isGhost) {
      return true;
    }
    return false;
  }
  addFile(file) {
    _classPrivateFieldLooseBase$6(this, _assertNewUploadAllowed)[_assertNewUploadAllowed](file);
    const {
      files
    } = this.getState();
    let newFile = _classPrivateFieldLooseBase$6(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, file);
    if (files[newFile.id] && files[newFile.id].isGhost) {
      newFile = {
        ...files[newFile.id],
        data: file.data,
        isGhost: false
      };
      this.log(`Replaced the blob in the restored ghost file: ${newFile.name}, ${newFile.id}`);
    }
    this.setState({
      files: {
        ...files,
        [newFile.id]: newFile
      }
    });
    this.emit("file-added", newFile);
    this.emit("files-added", [newFile]);
    this.log(`Added file: ${newFile.name}, ${newFile.id}, mime type: ${newFile.type}`);
    _classPrivateFieldLooseBase$6(this, _startIfAutoProceed)[_startIfAutoProceed]();
    return newFile.id;
  }
  addFiles(fileDescriptors) {
    _classPrivateFieldLooseBase$6(this, _assertNewUploadAllowed)[_assertNewUploadAllowed]();
    const files = {
      ...this.getState().files
    };
    const newFiles = [];
    const errors = [];
    for (let i2 = 0; i2 < fileDescriptors.length; i2++) {
      try {
        let newFile = _classPrivateFieldLooseBase$6(this, _checkAndCreateFileStateObject)[_checkAndCreateFileStateObject](files, fileDescriptors[i2]);
        if (files[newFile.id] && files[newFile.id].isGhost) {
          newFile = {
            ...files[newFile.id],
            data: fileDescriptors[i2].data,
            isGhost: false
          };
          this.log(`Replaced blob in a ghost file: ${newFile.name}, ${newFile.id}`);
        }
        files[newFile.id] = newFile;
        newFiles.push(newFile);
      } catch (err2) {
        if (!err2.isRestriction) {
          errors.push(err2);
        }
      }
    }
    this.setState({
      files
    });
    newFiles.forEach((newFile) => {
      this.emit("file-added", newFile);
    });
    this.emit("files-added", newFiles);
    if (newFiles.length > 5) {
      this.log(`Added batch of ${newFiles.length} files`);
    } else {
      Object.keys(newFiles).forEach((fileID) => {
        this.log(`Added file: ${newFiles[fileID].name}
 id: ${newFiles[fileID].id}
 type: ${newFiles[fileID].type}`);
      });
    }
    if (newFiles.length > 0) {
      _classPrivateFieldLooseBase$6(this, _startIfAutoProceed)[_startIfAutoProceed]();
    }
    if (errors.length > 0) {
      let message2 = "Multiple errors occurred while adding files:\n";
      errors.forEach((subError) => {
        message2 += `
 * ${subError.message}`;
      });
      this.info({
        message: this.i18n("addBulkFilesFailed", {
          smart_count: errors.length
        }),
        details: message2
      }, "error", this.opts.infoTimeout);
      if (typeof AggregateError === "function") {
        throw new AggregateError(errors, message2);
      } else {
        const err2 = new Error(message2);
        err2.errors = errors;
        throw err2;
      }
    }
  }
  removeFiles(fileIDs, reason) {
    const {
      files,
      currentUploads
    } = this.getState();
    const updatedFiles = {
      ...files
    };
    const updatedUploads = {
      ...currentUploads
    };
    const removedFiles = /* @__PURE__ */ Object.create(null);
    fileIDs.forEach((fileID) => {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    });
    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === void 0;
    }
    Object.keys(updatedUploads).forEach((uploadID) => {
      const newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved);
      if (newFileIDs.length === 0) {
        delete updatedUploads[uploadID];
        return;
      }
      updatedUploads[uploadID] = {
        ...currentUploads[uploadID],
        fileIDs: newFileIDs
      };
    });
    const stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    };
    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
      stateUpdate.error = null;
      stateUpdate.recoveredState = null;
    }
    this.setState(stateUpdate);
    this.calculateTotalProgress();
    const removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach((fileID) => {
      this.emit("file-removed", removedFiles[fileID], reason);
    });
    if (removedFileIDs.length > 5) {
      this.log(`Removed ${removedFileIDs.length} files`);
    } else {
      this.log(`Removed files: ${removedFileIDs.join(", ")}`);
    }
  }
  removeFile(fileID, reason) {
    if (reason === void 0) {
      reason = null;
    }
    this.removeFiles([fileID], reason);
  }
  pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return void 0;
    }
    const wasPaused = this.getFile(fileID).isPaused || false;
    const isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused
    });
    this.emit("upload-pause", fileID, isPaused);
    return isPaused;
  }
  pauseAll() {
    const updatedFiles = {
      ...this.getState().files
    };
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach((file) => {
      const updatedFile = {
        ...updatedFiles[file],
        isPaused: true
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit("pause-all");
  }
  resumeAll() {
    const updatedFiles = {
      ...this.getState().files
    };
    const inProgressUpdatedFiles = Object.keys(updatedFiles).filter((file) => {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach((file) => {
      const updatedFile = {
        ...updatedFiles[file],
        isPaused: false,
        error: null
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit("resume-all");
  }
  retryAll() {
    const updatedFiles = {
      ...this.getState().files
    };
    const filesToRetry = Object.keys(updatedFiles).filter((file) => {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach((file) => {
      const updatedFile = {
        ...updatedFiles[file],
        isPaused: false,
        error: null
      };
      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit("retry-all", filesToRetry);
    if (filesToRetry.length === 0) {
      return Promise.resolve({
        successful: [],
        failed: []
      });
    }
    const uploadID = _classPrivateFieldLooseBase$6(this, _createUpload)[_createUpload](filesToRetry, {
      forceAllowNewUpload: true
    });
    return _classPrivateFieldLooseBase$6(this, _runUpload)[_runUpload](uploadID);
  }
  cancelAll() {
    this.emit("cancel-all");
    const {
      files
    } = this.getState();
    const fileIDs = Object.keys(files);
    if (fileIDs.length) {
      this.removeFiles(fileIDs, "cancel-all");
    }
    this.setState({
      totalProgress: 0,
      error: null,
      recoveredState: null
    });
  }
  retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit("upload-retry", fileID);
    const uploadID = _classPrivateFieldLooseBase$6(this, _createUpload)[_createUpload]([fileID], {
      forceAllowNewUpload: true
    });
    return _classPrivateFieldLooseBase$6(this, _runUpload)[_runUpload](uploadID);
  }
  reset() {
    this.cancelAll();
  }
  logout() {
    this.iteratePlugins((plugin) => {
      if (plugin.provider && plugin.provider.logout) {
        plugin.provider.logout();
      }
    });
  }
  calculateProgress(file, data5) {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const canHavePercentage = Number.isFinite(data5.bytesTotal) && data5.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: {
        ...this.getFile(file.id).progress,
        bytesUploaded: data5.bytesUploaded,
        bytesTotal: data5.bytesTotal,
        percentage: canHavePercentage ? Math.round(data5.bytesUploaded / data5.bytesTotal * 100) : 0
      }
    });
    this.calculateTotalProgress();
  }
  calculateTotalProgress() {
    const files = this.getFiles();
    const inProgress = files.filter((file) => {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    if (inProgress.length === 0) {
      this.emit("progress", 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }
    const sizedFiles = inProgress.filter((file) => file.progress.bytesTotal != null);
    const unsizedFiles = inProgress.filter((file) => file.progress.bytesTotal == null);
    if (sizedFiles.length === 0) {
      const progressMax = inProgress.length * 100;
      const currentProgress = unsizedFiles.reduce((acc, file) => {
        return acc + file.progress.percentage;
      }, 0);
      const totalProgress2 = Math.round(currentProgress / progressMax * 100);
      this.setState({
        totalProgress: totalProgress2
      });
      return;
    }
    let totalSize = sizedFiles.reduce((acc, file) => {
      return acc + file.progress.bytesTotal;
    }, 0);
    const averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    let uploadedSize = 0;
    sizedFiles.forEach((file) => {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach((file) => {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    let totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100);
    if (totalProgress > 100) {
      totalProgress = 100;
    }
    this.setState({
      totalProgress
    });
    this.emit("progress", totalProgress);
  }
  updateOnlineStatus() {
    const online = typeof window.navigator.onLine !== "undefined" ? window.navigator.onLine : true;
    if (!online) {
      this.emit("is-offline");
      this.info(this.i18n("noInternetConnection"), "error", 0);
      this.wasOffline = true;
    } else {
      this.emit("is-online");
      if (this.wasOffline) {
        this.emit("back-online");
        this.info(this.i18n("connectedToInternet"), "success", 3e3);
        this.wasOffline = false;
      }
    }
  }
  getID() {
    return this.opts.id;
  }
  use(Plugin, opts) {
    if (typeof Plugin !== "function") {
      const msg = `Expected a plugin class, but got ${Plugin === null ? "null" : typeof Plugin}. Please verify that the plugin was imported and spelled correctly.`;
      throw new TypeError(msg);
    }
    const plugin = new Plugin(this, opts);
    const pluginId = plugin.id;
    if (!pluginId) {
      throw new Error("Your plugin must have an id");
    }
    if (!plugin.type) {
      throw new Error("Your plugin must have a type");
    }
    const existsPluginAlready = this.getPlugin(pluginId);
    if (existsPluginAlready) {
      const msg = `Already found a plugin named '${existsPluginAlready.id}'. Tried to use: '${pluginId}'.
Uppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;
      throw new Error(msg);
    }
    if (Plugin.VERSION) {
      this.log(`Using ${pluginId} v${Plugin.VERSION}`);
    }
    if (plugin.type in _classPrivateFieldLooseBase$6(this, _plugins)[_plugins]) {
      _classPrivateFieldLooseBase$6(this, _plugins)[_plugins][plugin.type].push(plugin);
    } else {
      _classPrivateFieldLooseBase$6(this, _plugins)[_plugins][plugin.type] = [plugin];
    }
    plugin.install();
    return this;
  }
  getPlugin(id2) {
    for (const plugins of Object.values(_classPrivateFieldLooseBase$6(this, _plugins)[_plugins])) {
      const foundPlugin = plugins.find((plugin) => plugin.id === id2);
      if (foundPlugin != null)
        return foundPlugin;
    }
    return void 0;
  }
  [_Symbol$for$1](type2) {
    return _classPrivateFieldLooseBase$6(this, _plugins)[_plugins][type2];
  }
  iteratePlugins(method) {
    Object.values(_classPrivateFieldLooseBase$6(this, _plugins)[_plugins]).flat(1).forEach(method);
  }
  removePlugin(instance2) {
    this.log(`Removing plugin ${instance2.id}`);
    this.emit("plugin-remove", instance2);
    if (instance2.uninstall) {
      instance2.uninstall();
    }
    const list = _classPrivateFieldLooseBase$6(this, _plugins)[_plugins][instance2.type];
    const index = list.findIndex((item) => item.id === instance2.id);
    if (index !== -1) {
      list.splice(index, 1);
    }
    const state = this.getState();
    const updatedState = {
      plugins: {
        ...state.plugins,
        [instance2.id]: void 0
      }
    };
    this.setState(updatedState);
  }
  close() {
    this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`);
    this.reset();
    _classPrivateFieldLooseBase$6(this, _storeUnsubscribe)[_storeUnsubscribe]();
    this.iteratePlugins((plugin) => {
      this.removePlugin(plugin);
    });
    if (typeof window !== "undefined" && window.removeEventListener) {
      window.removeEventListener("online", _classPrivateFieldLooseBase$6(this, _updateOnlineStatus)[_updateOnlineStatus]);
      window.removeEventListener("offline", _classPrivateFieldLooseBase$6(this, _updateOnlineStatus)[_updateOnlineStatus]);
    }
  }
  hideInfo() {
    const {
      info: info2
    } = this.getState();
    this.setState({
      info: info2.slice(1)
    });
    this.emit("info-hidden");
  }
  info(message2, type2, duration) {
    if (type2 === void 0) {
      type2 = "info";
    }
    if (duration === void 0) {
      duration = 3e3;
    }
    const isComplexMessage = typeof message2 === "object";
    this.setState({
      info: [...this.getState().info, {
        type: type2,
        message: isComplexMessage ? message2.message : message2,
        details: isComplexMessage ? message2.details : null
      }]
    });
    setTimeout(() => this.hideInfo(), duration);
    this.emit("info-visible");
  }
  log(message2, type2) {
    const {
      logger
    } = this.opts;
    switch (type2) {
      case "error":
        logger.error(message2);
        break;
      case "warning":
        logger.warn(message2);
        break;
      default:
        logger.debug(message2);
        break;
    }
  }
  restore(uploadID) {
    this.log(`Core: attempting to restore upload "${uploadID}"`);
    if (!this.getState().currentUploads[uploadID]) {
      _classPrivateFieldLooseBase$6(this, _removeUpload)[_removeUpload](uploadID);
      return Promise.reject(new Error("Nonexistent upload"));
    }
    return _classPrivateFieldLooseBase$6(this, _runUpload)[_runUpload](uploadID);
  }
  [_Symbol$for2$1]() {
    return _classPrivateFieldLooseBase$6(this, _createUpload)[_createUpload](...arguments);
  }
  addResultData(uploadID, data5) {
    if (!_classPrivateFieldLooseBase$6(this, _getUpload)[_getUpload](uploadID)) {
      this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
      return;
    }
    const {
      currentUploads
    } = this.getState();
    const currentUpload = {
      ...currentUploads[uploadID],
      result: {
        ...currentUploads[uploadID].result,
        ...data5
      }
    };
    this.setState({
      currentUploads: {
        ...currentUploads,
        [uploadID]: currentUpload
      }
    });
  }
  upload() {
    var _classPrivateFieldLoo;
    if (!((_classPrivateFieldLoo = _classPrivateFieldLooseBase$6(this, _plugins)[_plugins].uploader) != null && _classPrivateFieldLoo.length)) {
      this.log("No uploader type plugins are used", "warning");
    }
    let {
      files
    } = this.getState();
    const onBeforeUploadResult = this.opts.onBeforeUpload(files);
    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false"));
    }
    if (onBeforeUploadResult && typeof onBeforeUploadResult === "object") {
      files = onBeforeUploadResult;
      this.setState({
        files
      });
    }
    return Promise.resolve().then(() => {
      _classPrivateFieldLooseBase$6(this, _checkMinNumberOfFiles)[_checkMinNumberOfFiles](files);
      _classPrivateFieldLooseBase$6(this, _checkRequiredMetaFields)[_checkRequiredMetaFields](files);
    }).catch((err2) => {
      _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err2);
    }).then(() => {
      const {
        currentUploads
      } = this.getState();
      const currentlyUploadingFiles = Object.values(currentUploads).flatMap((curr) => curr.fileIDs);
      const waitingFileIDs = [];
      Object.keys(files).forEach((fileID) => {
        const file = this.getFile(fileID);
        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });
      const uploadID = _classPrivateFieldLooseBase$6(this, _createUpload)[_createUpload](waitingFileIDs);
      return _classPrivateFieldLooseBase$6(this, _runUpload)[_runUpload](uploadID);
    }).catch((err2) => {
      _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err2, {
        showInformer: false
      });
    });
  }
}
function _checkRestrictions2(file, files) {
  if (files === void 0) {
    files = this.getFiles();
  }
  const {
    maxFileSize,
    minFileSize,
    maxTotalFileSize,
    maxNumberOfFiles,
    allowedFileTypes
  } = this.opts.restrictions;
  if (maxNumberOfFiles) {
    if (files.length + 1 > maxNumberOfFiles) {
      throw new RestrictionError(`${this.i18n("youCanOnlyUploadX", {
        smart_count: maxNumberOfFiles
      })}`);
    }
  }
  if (allowedFileTypes) {
    const isCorrectFileType = allowedFileTypes.some((type2) => {
      if (type2.indexOf("/") > -1) {
        if (!file.type)
          return false;
        return mimeMatch(file.type.replace(/;.*?$/, ""), type2);
      }
      if (type2[0] === "." && file.extension) {
        return file.extension.toLowerCase() === type2.substr(1).toLowerCase();
      }
      return false;
    });
    if (!isCorrectFileType) {
      const allowedFileTypesString = allowedFileTypes.join(", ");
      throw new RestrictionError(this.i18n("youCanOnlyUploadFileTypes", {
        types: allowedFileTypesString
      }));
    }
  }
  if (maxTotalFileSize && file.size != null) {
    let totalFilesSize = 0;
    totalFilesSize += file.size;
    files.forEach((f2) => {
      totalFilesSize += f2.size;
    });
    if (totalFilesSize > maxTotalFileSize) {
      throw new RestrictionError(this.i18n("exceedsSize", {
        size: prettierBytes(maxTotalFileSize),
        file: file.name
      }));
    }
  }
  if (maxFileSize && file.size != null) {
    if (file.size > maxFileSize) {
      throw new RestrictionError(this.i18n("exceedsSize", {
        size: prettierBytes(maxFileSize),
        file: file.name
      }));
    }
  }
  if (minFileSize && file.size != null) {
    if (file.size < minFileSize) {
      throw new RestrictionError(this.i18n("inferiorSize", {
        size: prettierBytes(minFileSize)
      }));
    }
  }
}
function _checkMinNumberOfFiles2(files) {
  const {
    minNumberOfFiles
  } = this.opts.restrictions;
  if (Object.keys(files).length < minNumberOfFiles) {
    throw new RestrictionError(`${this.i18n("youHaveToAtLeastSelectX", {
      smart_count: minNumberOfFiles
    })}`);
  }
}
function _checkRequiredMetaFieldsOnFile2(file) {
  const {
    requiredMetaFields
  } = this.opts.restrictions;
  const {
    hasOwnProperty: hasOwnProperty2
  } = Object.prototype;
  const errors = [];
  const missingFields = [];
  for (let i2 = 0; i2 < requiredMetaFields.length; i2++) {
    if (!hasOwnProperty2.call(file.meta, requiredMetaFields[i2]) || file.meta[requiredMetaFields[i2]] === "") {
      const err2 = new RestrictionError(`${this.i18n("missingRequiredMetaFieldOnFile", {
        fileName: file.name
      })}`);
      errors.push(err2);
      missingFields.push(requiredMetaFields[i2]);
      _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err2, {
        file,
        showInformer: false,
        throwErr: false
      });
    }
  }
  this.setFileState(file.id, {
    missingRequiredMetaFields: missingFields
  });
  return errors;
}
function _checkRequiredMetaFields2(files) {
  const errors = Object.keys(files).flatMap((fileID) => {
    const file = this.getFile(fileID);
    return _classPrivateFieldLooseBase$6(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
  });
  if (errors.length) {
    throw new AggregateRestrictionError(errors, `${this.i18n("missingRequiredMetaField")}`);
  }
}
function _showOrLogErrorAndThrow2(err2, _temp2) {
  let {
    showInformer = true,
    file = null,
    throwErr = true
  } = _temp2 === void 0 ? {} : _temp2;
  const message2 = typeof err2 === "object" ? err2.message : err2;
  const details = typeof err2 === "object" && err2.details ? err2.details : "";
  let logMessageWithDetails = message2;
  if (details) {
    logMessageWithDetails += ` ${details}`;
  }
  if (err2.isRestriction) {
    this.log(logMessageWithDetails);
    this.emit("restriction-failed", file, err2);
  } else {
    this.log(logMessageWithDetails, "error");
  }
  if (showInformer) {
    this.info({
      message: message2,
      details
    }, "error", this.opts.infoTimeout);
  }
  if (throwErr) {
    throw typeof err2 === "object" ? err2 : new Error(err2);
  }
}
function _assertNewUploadAllowed2(file) {
  const {
    allowNewUpload
  } = this.getState();
  if (allowNewUpload === false) {
    _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError(this.i18n("noMoreFilesAllowed")), {
      file
    });
  }
}
function _checkAndCreateFileStateObject2(files, fileDescriptor) {
  const fileType = getFileType(fileDescriptor);
  const fileName = getFileName(fileType, fileDescriptor);
  const fileExtension = getFileNameAndExtension(fileName).extension;
  const isRemote = Boolean(fileDescriptor.isRemote);
  const fileID = generateFileID({
    ...fileDescriptor,
    type: fileType
  });
  if (this.checkIfFileAlreadyExists(fileID)) {
    const error = new RestrictionError(this.i18n("noDuplicates", {
      fileName
    }));
    _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
      file: fileDescriptor
    });
  }
  const meta = fileDescriptor.meta || {};
  meta.name = fileName;
  meta.type = fileType;
  const size = Number.isFinite(fileDescriptor.data.size) ? fileDescriptor.data.size : null;
  let newFile = {
    source: fileDescriptor.source || "",
    id: fileID,
    name: fileName,
    extension: fileExtension || "",
    meta: {
      ...this.getState().meta,
      ...meta
    },
    type: fileType,
    data: fileDescriptor.data,
    progress: {
      percentage: 0,
      bytesUploaded: 0,
      bytesTotal: size,
      uploadComplete: false,
      uploadStarted: null
    },
    size,
    isRemote,
    remote: fileDescriptor.remote || "",
    preview: fileDescriptor.preview
  };
  const onBeforeFileAddedResult = this.opts.onBeforeFileAdded(newFile, files);
  if (onBeforeFileAddedResult === false) {
    _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](new RestrictionError("Cannot add the file because onBeforeFileAdded returned false."), {
      showInformer: false,
      fileDescriptor
    });
  } else if (typeof onBeforeFileAddedResult === "object" && onBeforeFileAddedResult !== null) {
    newFile = onBeforeFileAddedResult;
  }
  try {
    const filesArray = Object.keys(files).map((i2) => files[i2]);
    _classPrivateFieldLooseBase$6(this, _checkRestrictions)[_checkRestrictions](newFile, filesArray);
  } catch (err2) {
    _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](err2, {
      file: newFile
    });
  }
  return newFile;
}
function _startIfAutoProceed2() {
  if (this.opts.autoProceed && !this.scheduledAutoProceed) {
    this.scheduledAutoProceed = setTimeout(() => {
      this.scheduledAutoProceed = null;
      this.upload().catch((err2) => {
        if (!err2.isRestriction) {
          this.log(err2.stack || err2.message || err2);
        }
      });
    }, 4);
  }
}
function _addListeners2() {
  const errorHandler = (error, file, response) => {
    let errorMsg = error.message || "Unknown error";
    if (error.details) {
      errorMsg += ` ${error.details}`;
    }
    this.setState({
      error: errorMsg
    });
    if (file != null && file.id in this.getState().files) {
      this.setFileState(file.id, {
        error: errorMsg,
        response
      });
    }
  };
  this.on("error", errorHandler);
  this.on("upload-error", (file, error, response) => {
    errorHandler(error, file, response);
    if (typeof error === "object" && error.message) {
      const newError = new Error(error.message);
      newError.details = error.message;
      if (error.details) {
        newError.details += ` ${error.details}`;
      }
      newError.message = this.i18n("failedToUpload", {
        file: file.name
      });
      _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](newError, {
        throwErr: false
      });
    } else {
      _classPrivateFieldLooseBase$6(this, _showOrLogErrorAndThrow)[_showOrLogErrorAndThrow](error, {
        throwErr: false
      });
    }
  });
  this.on("upload", () => {
    this.setState({
      error: null
    });
  });
  this.on("upload-started", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: {
        uploadStarted: Date.now(),
        uploadComplete: false,
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: file.size
      }
    });
  });
  this.on("upload-progress", this.calculateProgress);
  this.on("upload-success", (file, uploadResp) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const currentProgress = this.getFile(file.id).progress;
    this.setFileState(file.id, {
      progress: {
        ...currentProgress,
        postprocess: _classPrivateFieldLooseBase$6(this, _postProcessors)[_postProcessors].size > 0 ? {
          mode: "indeterminate"
        } : null,
        uploadComplete: true,
        percentage: 100,
        bytesUploaded: currentProgress.bytesTotal
      },
      response: uploadResp,
      uploadURL: uploadResp.uploadURL,
      isPaused: false
    });
    if (file.size == null) {
      this.setFileState(file.id, {
        size: uploadResp.bytesUploaded || currentProgress.bytesTotal
      });
    }
    this.calculateTotalProgress();
  });
  this.on("preprocess-progress", (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: {
        ...this.getFile(file.id).progress,
        preprocess: progress
      }
    });
  });
  this.on("preprocess-complete", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const files = {
      ...this.getState().files
    };
    files[file.id] = {
      ...files[file.id],
      progress: {
        ...files[file.id].progress
      }
    };
    delete files[file.id].progress.preprocess;
    this.setState({
      files
    });
  });
  this.on("postprocess-progress", (file, progress) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    this.setFileState(file.id, {
      progress: {
        ...this.getState().files[file.id].progress,
        postprocess: progress
      }
    });
  });
  this.on("postprocess-complete", (file) => {
    if (!this.getFile(file.id)) {
      this.log(`Not setting progress for a file that has been removed: ${file.id}`);
      return;
    }
    const files = {
      ...this.getState().files
    };
    files[file.id] = {
      ...files[file.id],
      progress: {
        ...files[file.id].progress
      }
    };
    delete files[file.id].progress.postprocess;
    this.setState({
      files
    });
  });
  this.on("restored", () => {
    this.calculateTotalProgress();
  });
  this.on("dashboard:file-edit-complete", (file) => {
    if (file) {
      _classPrivateFieldLooseBase$6(this, _checkRequiredMetaFieldsOnFile)[_checkRequiredMetaFieldsOnFile](file);
    }
  });
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("online", _classPrivateFieldLooseBase$6(this, _updateOnlineStatus)[_updateOnlineStatus]);
    window.addEventListener("offline", _classPrivateFieldLooseBase$6(this, _updateOnlineStatus)[_updateOnlineStatus]);
    setTimeout(_classPrivateFieldLooseBase$6(this, _updateOnlineStatus)[_updateOnlineStatus], 3e3);
  }
}
function _createUpload2(fileIDs, opts) {
  if (opts === void 0) {
    opts = {};
  }
  const {
    forceAllowNewUpload = false
  } = opts;
  const {
    allowNewUpload,
    currentUploads
  } = this.getState();
  if (!allowNewUpload && !forceAllowNewUpload) {
    throw new Error("Cannot create a new upload: already uploading.");
  }
  const uploadID = nanoid$1();
  this.emit("upload", {
    id: uploadID,
    fileIDs
  });
  this.setState({
    allowNewUpload: this.opts.allowMultipleUploadBatches !== false && this.opts.allowMultipleUploads !== false,
    currentUploads: {
      ...currentUploads,
      [uploadID]: {
        fileIDs,
        step: 0,
        result: {}
      }
    }
  });
  return uploadID;
}
function _getUpload2(uploadID) {
  const {
    currentUploads
  } = this.getState();
  return currentUploads[uploadID];
}
function _removeUpload2(uploadID) {
  const currentUploads = {
    ...this.getState().currentUploads
  };
  delete currentUploads[uploadID];
  this.setState({
    currentUploads
  });
}
async function _runUpload2(uploadID) {
  let {
    currentUploads
  } = this.getState();
  let currentUpload = currentUploads[uploadID];
  const restoreStep = currentUpload.step || 0;
  const steps = [..._classPrivateFieldLooseBase$6(this, _preProcessors)[_preProcessors], ..._classPrivateFieldLooseBase$6(this, _uploaders)[_uploaders], ..._classPrivateFieldLooseBase$6(this, _postProcessors)[_postProcessors]];
  try {
    for (let step = restoreStep; step < steps.length; step++) {
      if (!currentUpload) {
        break;
      }
      const fn2 = steps[step];
      const updatedUpload = {
        ...currentUpload,
        step
      };
      this.setState({
        currentUploads: {
          ...currentUploads,
          [uploadID]: updatedUpload
        }
      });
      await fn2(updatedUpload.fileIDs, uploadID);
      currentUploads = this.getState().currentUploads;
      currentUpload = currentUploads[uploadID];
    }
  } catch (err2) {
    this.emit("error", err2);
    _classPrivateFieldLooseBase$6(this, _removeUpload)[_removeUpload](uploadID);
    throw err2;
  }
  if (currentUpload) {
    currentUpload.fileIDs.forEach((fileID) => {
      const file = this.getFile(fileID);
      if (file && file.progress.postprocess) {
        this.emit("postprocess-complete", file);
      }
    });
    const files = currentUpload.fileIDs.map((fileID) => this.getFile(fileID));
    const successful = files.filter((file) => !file.error);
    const failed = files.filter((file) => file.error);
    await this.addResultData(uploadID, {
      successful,
      failed,
      uploadID
    });
    currentUploads = this.getState().currentUploads;
    currentUpload = currentUploads[uploadID];
  }
  let result;
  if (currentUpload) {
    result = currentUpload.result;
    this.emit("complete", result);
    _classPrivateFieldLooseBase$6(this, _removeUpload)[_removeUpload](uploadID);
  }
  if (result == null) {
    this.log(`Not setting result for an upload that has been removed: ${uploadID}`);
  }
  return result;
}
Uppy.VERSION = "2.1.3";
var Uppy_1$1 = Uppy;
var preact = createCommonjsModule(function(module, exports) {
  var n2, l2, u2, t2, i2, r2, o2, f2, e3 = {}, c2 = [], s2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function a2(n3, l3) {
    for (var u3 in l3)
      n3[u3] = l3[u3];
    return n3;
  }
  function v2(n3) {
    var l3 = n3.parentNode;
    l3 && l3.removeChild(n3);
  }
  function h2(l3, u3, t3) {
    var i3, r3, o3, f3 = {};
    for (o3 in u3)
      "key" == o3 ? i3 = u3[o3] : "ref" == o3 ? r3 = u3[o3] : f3[o3] = u3[o3];
    if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), "function" == typeof l3 && null != l3.defaultProps)
      for (o3 in l3.defaultProps)
        void 0 === f3[o3] && (f3[o3] = l3.defaultProps[o3]);
    return p2(l3, f3, i3, r3, null);
  }
  function p2(n3, t3, i3, r3, o3) {
    var f3 = { type: n3, props: t3, key: i3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o3 ? ++u2 : o3 };
    return null == o3 && null != l2.vnode && l2.vnode(f3), f3;
  }
  function y2(n3) {
    return n3.children;
  }
  function d3(n3, l3) {
    this.props = n3, this.context = l3;
  }
  function _2(n3, l3) {
    if (null == l3)
      return n3.__ ? _2(n3.__, n3.__.__k.indexOf(n3) + 1) : null;
    for (var u3; l3 < n3.__k.length; l3++)
      if (null != (u3 = n3.__k[l3]) && null != u3.__e)
        return u3.__e;
    return "function" == typeof n3.type ? _2(n3) : null;
  }
  function k2(n3) {
    var l3, u3;
    if (null != (n3 = n3.__) && null != n3.__c) {
      for (n3.__e = n3.__c.base = null, l3 = 0; l3 < n3.__k.length; l3++)
        if (null != (u3 = n3.__k[l3]) && null != u3.__e) {
          n3.__e = n3.__c.base = u3.__e;
          break;
        }
      return k2(n3);
    }
  }
  function x2(n3) {
    (!n3.__d && (n3.__d = true) && i2.push(n3) && !b2.__r++ || o2 !== l2.debounceRendering) && ((o2 = l2.debounceRendering) || r2)(b2);
  }
  function b2() {
    for (var n3; b2.__r = i2.length; )
      n3 = i2.sort(function(n4, l3) {
        return n4.__v.__b - l3.__v.__b;
      }), i2 = [], n3.some(function(n4) {
        var l3, u3, t3, i3, r3, o3;
        n4.__d && (r3 = (i3 = (l3 = n4).__v).__e, (o3 = l3.__P) && (u3 = [], (t3 = a2({}, i3)).__v = i3.__v + 1, I2(o3, i3, t3, l3.__n, void 0 !== o3.ownerSVGElement, null != i3.__h ? [r3] : null, u3, null == r3 ? _2(i3) : r3, i3.__h), T2(u3, i3), i3.__e != r3 && k2(i3)));
      });
  }
  function m2(n3, l3, u3, t3, i3, r3, o3, f3, s3, a3) {
    var v3, h3, d4, k3, x3, b3, m3, A3 = t3 && t3.__k || c2, P3 = A3.length;
    for (u3.__k = [], v3 = 0; v3 < l3.length; v3++)
      if (null != (k3 = u3.__k[v3] = null == (k3 = l3[v3]) || "boolean" == typeof k3 ? null : "string" == typeof k3 || "number" == typeof k3 || "bigint" == typeof k3 ? p2(null, k3, null, null, k3) : Array.isArray(k3) ? p2(y2, { children: k3 }, null, null, null) : k3.__b > 0 ? p2(k3.type, k3.props, k3.key, null, k3.__v) : k3)) {
        if (k3.__ = u3, k3.__b = u3.__b + 1, null === (d4 = A3[v3]) || d4 && k3.key == d4.key && k3.type === d4.type)
          A3[v3] = void 0;
        else
          for (h3 = 0; h3 < P3; h3++) {
            if ((d4 = A3[h3]) && k3.key == d4.key && k3.type === d4.type) {
              A3[h3] = void 0;
              break;
            }
            d4 = null;
          }
        I2(n3, k3, d4 = d4 || e3, i3, r3, o3, f3, s3, a3), x3 = k3.__e, (h3 = k3.ref) && d4.ref != h3 && (m3 || (m3 = []), d4.ref && m3.push(d4.ref, null, k3), m3.push(h3, k3.__c || x3, k3)), null != x3 ? (null == b3 && (b3 = x3), "function" == typeof k3.type && k3.__k === d4.__k ? k3.__d = s3 = g2(k3, s3, n3) : s3 = w2(n3, k3, d4, A3, x3, s3), "function" == typeof u3.type && (u3.__d = s3)) : s3 && d4.__e == s3 && s3.parentNode != n3 && (s3 = _2(d4));
      }
    for (u3.__e = b3, v3 = P3; v3--; )
      null != A3[v3] && ("function" == typeof u3.type && null != A3[v3].__e && A3[v3].__e == u3.__d && (u3.__d = _2(t3, v3 + 1)), L2(A3[v3], A3[v3]));
    if (m3)
      for (v3 = 0; v3 < m3.length; v3++)
        z2(m3[v3], m3[++v3], m3[++v3]);
  }
  function g2(n3, l3, u3) {
    for (var t3, i3 = n3.__k, r3 = 0; i3 && r3 < i3.length; r3++)
      (t3 = i3[r3]) && (t3.__ = n3, l3 = "function" == typeof t3.type ? g2(t3, l3, u3) : w2(u3, t3, t3, i3, t3.__e, l3));
    return l3;
  }
  function w2(n3, l3, u3, t3, i3, r3) {
    var o3, f3, e4;
    if (void 0 !== l3.__d)
      o3 = l3.__d, l3.__d = void 0;
    else if (null == u3 || i3 != r3 || null == i3.parentNode)
      n:
        if (null == r3 || r3.parentNode !== n3)
          n3.appendChild(i3), o3 = null;
        else {
          for (f3 = r3, e4 = 0; (f3 = f3.nextSibling) && e4 < t3.length; e4 += 2)
            if (f3 == i3)
              break n;
          n3.insertBefore(i3, r3), o3 = r3;
        }
    return void 0 !== o3 ? o3 : i3.nextSibling;
  }
  function A2(n3, l3, u3, t3, i3) {
    var r3;
    for (r3 in u3)
      "children" === r3 || "key" === r3 || r3 in l3 || C2(n3, r3, null, u3[r3], t3);
    for (r3 in l3)
      i3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || C2(n3, r3, l3[r3], u3[r3], t3);
  }
  function P2(n3, l3, u3) {
    "-" === l3[0] ? n3.setProperty(l3, u3) : n3[l3] = null == u3 ? "" : "number" != typeof u3 || s2.test(l3) ? u3 : u3 + "px";
  }
  function C2(n3, l3, u3, t3, i3) {
    var r3;
    n:
      if ("style" === l3)
        if ("string" == typeof u3)
          n3.style.cssText = u3;
        else {
          if ("string" == typeof t3 && (n3.style.cssText = t3 = ""), t3)
            for (l3 in t3)
              u3 && l3 in u3 || P2(n3.style, l3, "");
          if (u3)
            for (l3 in u3)
              t3 && u3[l3] === t3[l3] || P2(n3.style, l3, u3[l3]);
        }
      else if ("o" === l3[0] && "n" === l3[1])
        r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n3 ? l3.toLowerCase().slice(2) : l3.slice(2), n3.l || (n3.l = {}), n3.l[l3 + r3] = u3, u3 ? t3 || n3.addEventListener(l3, r3 ? H2 : $2, r3) : n3.removeEventListener(l3, r3 ? H2 : $2, r3);
      else if ("dangerouslySetInnerHTML" !== l3) {
        if (i3)
          l3 = l3.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
        else if ("href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n3)
          try {
            n3[l3] = null == u3 ? "" : u3;
            break n;
          } catch (n4) {
          }
        "function" == typeof u3 || (null != u3 && (false !== u3 || "a" === l3[0] && "r" === l3[1]) ? n3.setAttribute(l3, u3) : n3.removeAttribute(l3));
      }
  }
  function $2(n3) {
    this.l[n3.type + false](l2.event ? l2.event(n3) : n3);
  }
  function H2(n3) {
    this.l[n3.type + true](l2.event ? l2.event(n3) : n3);
  }
  function I2(n3, u3, t3, i3, r3, o3, f3, e4, c3) {
    var s3, v3, h3, p3, _3, k3, x3, b3, g3, w3, A3, P3 = u3.type;
    if (void 0 !== u3.constructor)
      return null;
    null != t3.__h && (c3 = t3.__h, e4 = u3.__e = t3.__e, u3.__h = null, o3 = [e4]), (s3 = l2.__b) && s3(u3);
    try {
      n:
        if ("function" == typeof P3) {
          if (b3 = u3.props, g3 = (s3 = P3.contextType) && i3[s3.__c], w3 = s3 ? g3 ? g3.props.value : s3.__ : i3, t3.__c ? x3 = (v3 = u3.__c = t3.__c).__ = v3.__E : ("prototype" in P3 && P3.prototype.render ? u3.__c = v3 = new P3(b3, w3) : (u3.__c = v3 = new d3(b3, w3), v3.constructor = P3, v3.render = M2), g3 && g3.sub(v3), v3.props = b3, v3.state || (v3.state = {}), v3.context = w3, v3.__n = i3, h3 = v3.__d = true, v3.__h = []), null == v3.__s && (v3.__s = v3.state), null != P3.getDerivedStateFromProps && (v3.__s == v3.state && (v3.__s = a2({}, v3.__s)), a2(v3.__s, P3.getDerivedStateFromProps(b3, v3.__s))), p3 = v3.props, _3 = v3.state, h3)
            null == P3.getDerivedStateFromProps && null != v3.componentWillMount && v3.componentWillMount(), null != v3.componentDidMount && v3.__h.push(v3.componentDidMount);
          else {
            if (null == P3.getDerivedStateFromProps && b3 !== p3 && null != v3.componentWillReceiveProps && v3.componentWillReceiveProps(b3, w3), !v3.__e && null != v3.shouldComponentUpdate && false === v3.shouldComponentUpdate(b3, v3.__s, w3) || u3.__v === t3.__v) {
              v3.props = b3, v3.state = v3.__s, u3.__v !== t3.__v && (v3.__d = false), v3.__v = u3, u3.__e = t3.__e, u3.__k = t3.__k, u3.__k.forEach(function(n4) {
                n4 && (n4.__ = u3);
              }), v3.__h.length && f3.push(v3);
              break n;
            }
            null != v3.componentWillUpdate && v3.componentWillUpdate(b3, v3.__s, w3), null != v3.componentDidUpdate && v3.__h.push(function() {
              v3.componentDidUpdate(p3, _3, k3);
            });
          }
          v3.context = w3, v3.props = b3, v3.state = v3.__s, (s3 = l2.__r) && s3(u3), v3.__d = false, v3.__v = u3, v3.__P = n3, s3 = v3.render(v3.props, v3.state, v3.context), v3.state = v3.__s, null != v3.getChildContext && (i3 = a2(a2({}, i3), v3.getChildContext())), h3 || null == v3.getSnapshotBeforeUpdate || (k3 = v3.getSnapshotBeforeUpdate(p3, _3)), A3 = null != s3 && s3.type === y2 && null == s3.key ? s3.props.children : s3, m2(n3, Array.isArray(A3) ? A3 : [A3], u3, t3, i3, r3, o3, f3, e4, c3), v3.base = u3.__e, u3.__h = null, v3.__h.length && f3.push(v3), x3 && (v3.__E = v3.__ = null), v3.__e = false;
        } else
          null == o3 && u3.__v === t3.__v ? (u3.__k = t3.__k, u3.__e = t3.__e) : u3.__e = j2(t3.__e, u3, t3, i3, r3, o3, f3, c3);
      (s3 = l2.diffed) && s3(u3);
    } catch (n4) {
      u3.__v = null, (c3 || null != o3) && (u3.__e = e4, u3.__h = !!c3, o3[o3.indexOf(e4)] = null), l2.__e(n4, u3, t3);
    }
  }
  function T2(n3, u3) {
    l2.__c && l2.__c(u3, n3), n3.some(function(u4) {
      try {
        n3 = u4.__h, u4.__h = [], n3.some(function(n4) {
          n4.call(u4);
        });
      } catch (n4) {
        l2.__e(n4, u4.__v);
      }
    });
  }
  function j2(l3, u3, t3, i3, r3, o3, f3, c3) {
    var s3, a3, h3, p3 = t3.props, y3 = u3.props, d4 = u3.type, k3 = 0;
    if ("svg" === d4 && (r3 = true), null != o3) {
      for (; k3 < o3.length; k3++)
        if ((s3 = o3[k3]) && "setAttribute" in s3 == !!d4 && (d4 ? s3.localName === d4 : 3 === s3.nodeType)) {
          l3 = s3, o3[k3] = null;
          break;
        }
    }
    if (null == l3) {
      if (null === d4)
        return document.createTextNode(y3);
      l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d4) : document.createElement(d4, y3.is && y3), o3 = null, c3 = false;
    }
    if (null === d4)
      p3 === y3 || c3 && l3.data === y3 || (l3.data = y3);
    else {
      if (o3 = o3 && n2.call(l3.childNodes), a3 = (p3 = t3.props || e3).dangerouslySetInnerHTML, h3 = y3.dangerouslySetInnerHTML, !c3) {
        if (null != o3)
          for (p3 = {}, k3 = 0; k3 < l3.attributes.length; k3++)
            p3[l3.attributes[k3].name] = l3.attributes[k3].value;
        (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
      }
      if (A2(l3, y3, p3, r3, c3), h3)
        u3.__k = [];
      else if (k3 = u3.props.children, m2(l3, Array.isArray(k3) ? k3 : [k3], u3, t3, i3, r3 && "foreignObject" !== d4, o3, f3, o3 ? o3[0] : t3.__k && _2(t3, 0), c3), null != o3)
        for (k3 = o3.length; k3--; )
          null != o3[k3] && v2(o3[k3]);
      c3 || ("value" in y3 && void 0 !== (k3 = y3.value) && (k3 !== p3.value || k3 !== l3.value || "progress" === d4 && !k3) && C2(l3, "value", k3, p3.value, false), "checked" in y3 && void 0 !== (k3 = y3.checked) && k3 !== l3.checked && C2(l3, "checked", k3, p3.checked, false));
    }
    return l3;
  }
  function z2(n3, u3, t3) {
    try {
      "function" == typeof n3 ? n3(u3) : n3.current = u3;
    } catch (n4) {
      l2.__e(n4, t3);
    }
  }
  function L2(n3, u3, t3) {
    var i3, r3;
    if (l2.unmount && l2.unmount(n3), (i3 = n3.ref) && (i3.current && i3.current !== n3.__e || z2(i3, null, u3)), null != (i3 = n3.__c)) {
      if (i3.componentWillUnmount)
        try {
          i3.componentWillUnmount();
        } catch (n4) {
          l2.__e(n4, u3);
        }
      i3.base = i3.__P = null;
    }
    if (i3 = n3.__k)
      for (r3 = 0; r3 < i3.length; r3++)
        i3[r3] && L2(i3[r3], u3, "function" != typeof n3.type);
    t3 || null == n3.__e || v2(n3.__e), n3.__e = n3.__d = void 0;
  }
  function M2(n3, l3, u3) {
    return this.constructor(n3, u3);
  }
  function N2(u3, t3, i3) {
    var r3, o3, f3;
    l2.__ && l2.__(u3, t3), o3 = (r3 = "function" == typeof i3) ? null : i3 && i3.__k || t3.__k, f3 = [], I2(t3, u3 = (!r3 && i3 || t3).__k = h2(y2, null, [u3]), o3 || e3, e3, void 0 !== t3.ownerSVGElement, !r3 && i3 ? [i3] : o3 ? null : t3.firstChild ? n2.call(t3.childNodes) : null, f3, !r3 && i3 ? i3 : o3 ? o3.__e : t3.firstChild, r3), T2(f3, u3);
  }
  n2 = c2.slice, l2 = { __e: function(n3, l3) {
    for (var u3, t3, i3; l3 = l3.__; )
      if ((u3 = l3.__c) && !u3.__)
        try {
          if ((t3 = u3.constructor) && null != t3.getDerivedStateFromError && (u3.setState(t3.getDerivedStateFromError(n3)), i3 = u3.__d), null != u3.componentDidCatch && (u3.componentDidCatch(n3), i3 = u3.__d), i3)
            return u3.__E = u3;
        } catch (l4) {
          n3 = l4;
        }
    throw n3;
  } }, u2 = 0, t2 = function(n3) {
    return null != n3 && void 0 === n3.constructor;
  }, d3.prototype.setState = function(n3, l3) {
    var u3;
    u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a2({}, this.state), "function" == typeof n3 && (n3 = n3(a2({}, u3), this.props)), n3 && a2(u3, n3), null != n3 && this.__v && (l3 && this.__h.push(l3), x2(this));
  }, d3.prototype.forceUpdate = function(n3) {
    this.__v && (this.__e = true, n3 && this.__h.push(n3), x2(this));
  }, d3.prototype.render = y2, i2 = [], r2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, b2.__r = 0, f2 = 0, exports.Component = d3, exports.Fragment = y2, exports.cloneElement = function(l3, u3, t3) {
    var i3, r3, o3, f3 = a2({}, l3.props);
    for (o3 in u3)
      "key" == o3 ? i3 = u3[o3] : "ref" == o3 ? r3 = u3[o3] : f3[o3] = u3[o3];
    return arguments.length > 2 && (f3.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), p2(l3.type, f3, i3 || l3.key, r3 || l3.ref, null);
  }, exports.createContext = function(n3, l3) {
    var u3 = { __c: l3 = "__cC" + f2++, __: n3, Consumer: function(n4, l4) {
      return n4.children(l4);
    }, Provider: function(n4) {
      var u4, t3;
      return this.getChildContext || (u4 = [], (t3 = {})[l3] = this, this.getChildContext = function() {
        return t3;
      }, this.shouldComponentUpdate = function(n5) {
        this.props.value !== n5.value && u4.some(x2);
      }, this.sub = function(n5) {
        u4.push(n5);
        var l4 = n5.componentWillUnmount;
        n5.componentWillUnmount = function() {
          u4.splice(u4.indexOf(n5), 1), l4 && l4.call(n5);
        };
      }), n4.children;
    } };
    return u3.Provider.__ = u3.Consumer.contextType = u3;
  }, exports.createElement = h2, exports.createRef = function() {
    return { current: null };
  }, exports.h = h2, exports.hydrate = function n3(l3, u3) {
    N2(l3, u3, n3);
  }, exports.isValidElement = t2, exports.options = l2, exports.render = N2, exports.toChildArray = function n3(l3, u3) {
    return u3 = u3 || [], null == l3 || "boolean" == typeof l3 || (Array.isArray(l3) ? l3.some(function(l4) {
      n3(l4, u3);
    }) : u3.push(l3)), u3;
  };
});
var isDOMElement = function isDOMElement2(obj) {
  return (obj == null ? void 0 : obj.nodeType) === Node.ELEMENT_NODE;
};
var findDOMElement = function findDOMElement2(element, context) {
  if (context === void 0) {
    context = document;
  }
  if (typeof element === "string") {
    return context.querySelector(element);
  }
  if (isDOMElement(element)) {
    return element;
  }
  return null;
};
var BasePlugin_1$1 = class BasePlugin {
  constructor(uppy, opts) {
    if (opts === void 0) {
      opts = {};
    }
    this.uppy = uppy;
    this.opts = opts;
  }
  getPluginState() {
    const {
      plugins
    } = this.uppy.getState();
    return plugins[this.id] || {};
  }
  setPluginState(update5) {
    const {
      plugins
    } = this.uppy.getState();
    this.uppy.setState({
      plugins: {
        ...plugins,
        [this.id]: {
          ...plugins[this.id],
          ...update5
        }
      }
    });
  }
  setOptions(newOpts) {
    this.opts = {
      ...this.opts,
      ...newOpts
    };
    this.setPluginState();
    this.i18nInit();
  }
  i18nInit() {
    const translator = new Translator_1([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = translator.translate.bind(translator);
    this.i18nArray = translator.translateArray.bind(translator);
    this.setPluginState();
  }
  addTarget() {
    throw new Error("Extend the addTarget method to add your plugin to another plugin's target");
  }
  install() {
  }
  uninstall() {
  }
  render() {
    throw new Error("Extend the render method to add your plugin to a DOM element");
  }
  update() {
  }
  afterUpdate() {
  }
};
function _classPrivateFieldLooseBase$5(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$7 = 0;
function _classPrivateFieldLooseKey$5(name2) {
  return "__private_" + id$7++ + "_" + name2;
}
const {
  render
} = preact;
function debounce(fn2) {
  let calling = null;
  let latestArgs = null;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    latestArgs = args;
    if (!calling) {
      calling = Promise.resolve().then(() => {
        calling = null;
        return fn2(...latestArgs);
      });
    }
    return calling;
  };
}
var _updateUI = /* @__PURE__ */ _classPrivateFieldLooseKey$5("updateUI");
class UIPlugin extends BasePlugin_1$1 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, _updateUI, {
      writable: true,
      value: void 0
    });
  }
  mount(target, plugin) {
    const callerPluginName = plugin.id;
    const targetElement = findDOMElement(target);
    if (targetElement) {
      this.isTargetDOMEl = true;
      const uppyRootElement = document.createDocumentFragment();
      _classPrivateFieldLooseBase$5(this, _updateUI)[_updateUI] = debounce((state) => {
        if (!this.uppy.getPlugin(this.id))
          return;
        render(this.render(state), uppyRootElement);
        this.afterUpdate();
      });
      this.uppy.log(`Installing ${callerPluginName} to a DOM element '${target}'`);
      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = "";
      }
      render(this.render(this.uppy.getState()), uppyRootElement);
      this.el = uppyRootElement.firstElementChild;
      targetElement.appendChild(uppyRootElement);
      this.onMount();
      return this.el;
    }
    let targetPlugin;
    if (typeof target === "object" && target instanceof UIPlugin) {
      targetPlugin = target;
    } else if (typeof target === "function") {
      const Target = target;
      this.uppy.iteratePlugins((p2) => {
        if (p2 instanceof Target) {
          targetPlugin = p2;
          return false;
        }
      });
    }
    if (targetPlugin) {
      this.uppy.log(`Installing ${callerPluginName} to ${targetPlugin.id}`);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }
    this.uppy.log(`Not installing ${callerPluginName}`);
    let message2 = `Invalid target option given to ${callerPluginName}.`;
    if (typeof target === "function") {
      message2 += " The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.";
    } else {
      message2 += "If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.";
    }
    throw new Error(message2);
  }
  update(state) {
    if (this.el != null) {
      var _classPrivateFieldLoo, _classPrivateFieldLoo2;
      (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase$5(this, _updateUI))[_updateUI]) == null ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, state);
    }
  }
  unmount() {
    if (this.isTargetDOMEl) {
      var _this$el;
      (_this$el = this.el) == null ? void 0 : _this$el.remove();
    }
    this.onUnmount();
  }
  onMount() {
  }
  onUnmount() {
  }
}
var UIPlugin_1$1 = UIPlugin;
const {
  debugLogger
} = loggers;
var lib$2 = Uppy_1$1;
var Uppy_1 = Uppy_1$1;
var UIPlugin_1 = UIPlugin_1$1;
var BasePlugin_1 = BasePlugin_1$1;
var debugLogger_1 = debugLogger;
lib$2.Uppy = Uppy_1;
lib$2.UIPlugin = UIPlugin_1;
lib$2.BasePlugin = BasePlugin_1;
lib$2.debugLogger = debugLogger_1;
class NetworkError extends Error {
  constructor(error, xhr) {
    if (xhr === void 0) {
      xhr = null;
    }
    super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);
    this.cause = error;
    this.isNetworkError = true;
    this.request = xhr;
  }
}
var NetworkError_1 = NetworkError;
var fetchWithNetworkError = function fetchWithNetworkError2() {
  return fetch(...arguments).catch((err2) => {
    if (err2.name === "AbortError") {
      throw err2;
    } else {
      throw new NetworkError_1(err2);
    }
  });
};
class AuthError extends Error {
  constructor() {
    super("Authorization required");
    this.name = "AuthError";
    this.isAuthError = true;
  }
}
var AuthError_1 = AuthError;
var _class$1, _getPostResponseFunc, _getUrl, _errorHandler, _temp$1;
function _classPrivateFieldLooseBase$4(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$6 = 0;
function _classPrivateFieldLooseKey$4(name2) {
  return "__private_" + id$6++ + "_" + name2;
}
function stripSlash(url) {
  return url.replace(/\/$/, "");
}
async function handleJSONResponse(res) {
  if (res.status === 401) {
    throw new AuthError_1();
  }
  const jsonPromise = res.json();
  if (res.status < 200 || res.status > 300) {
    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;
    try {
      const errData = await jsonPromise;
      errMsg = errData.message ? `${errMsg} message: ${errData.message}` : errMsg;
      errMsg = errData.requestId ? `${errMsg} request-Id: ${errData.requestId}` : errMsg;
    } finally {
      throw new Error(errMsg);
    }
  }
  return jsonPromise;
}
var RequestClient_1 = (_temp$1 = (_getPostResponseFunc = /* @__PURE__ */ _classPrivateFieldLooseKey$4("getPostResponseFunc"), _getUrl = /* @__PURE__ */ _classPrivateFieldLooseKey$4("getUrl"), _errorHandler = /* @__PURE__ */ _classPrivateFieldLooseKey$4("errorHandler"), _class$1 = class RequestClient2 {
  constructor(uppy, opts) {
    Object.defineProperty(this, _errorHandler, {
      value: _errorHandler2
    });
    Object.defineProperty(this, _getUrl, {
      value: _getUrl2
    });
    Object.defineProperty(this, _getPostResponseFunc, {
      writable: true,
      value: (skip) => (response) => skip ? response : this.onReceiveResponse(response)
    });
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ["accept", "content-type", "uppy-auth-token"];
    this.preflightDone = false;
  }
  get hostname() {
    const {
      companion
    } = this.uppy.getState();
    const host = this.opts.companionUrl;
    return stripSlash(companion && companion[host] ? companion[host] : host);
  }
  headers() {
    const userHeaders = this.opts.companionHeaders || {};
    return Promise.resolve({
      ...RequestClient2.defaultHeaders,
      ...userHeaders
    });
  }
  onReceiveResponse(response) {
    const state = this.uppy.getState();
    const companion = state.companion || {};
    const host = this.opts.companionUrl;
    const {
      headers
    } = response;
    if (headers.has("i-am") && headers.get("i-am") !== companion[host]) {
      this.uppy.setState({
        companion: {
          ...companion,
          [host]: headers.get("i-am")
        }
      });
    }
    return response;
  }
  preflight(path) {
    if (this.preflightDone) {
      return Promise.resolve(this.allowedHeaders.slice());
    }
    return fetch(_classPrivateFieldLooseBase$4(this, _getUrl)[_getUrl](path), {
      method: "OPTIONS"
    }).then((response) => {
      if (response.headers.has("access-control-allow-headers")) {
        this.allowedHeaders = response.headers.get("access-control-allow-headers").split(",").map((headerName) => headerName.trim().toLowerCase());
      }
      this.preflightDone = true;
      return this.allowedHeaders.slice();
    }).catch((err2) => {
      this.uppy.log(`[CompanionClient] unable to make preflight request ${err2}`, "warning");
      this.preflightDone = true;
      return this.allowedHeaders.slice();
    });
  }
  preflightAndHeaders(path) {
    return Promise.all([this.preflight(path), this.headers()]).then((_ref) => {
      let [allowedHeaders, headers] = _ref;
      Object.keys(headers).forEach((header) => {
        if (!allowedHeaders.includes(header.toLowerCase())) {
          this.uppy.log(`[CompanionClient] excluding disallowed header ${header}`);
          delete headers[header];
        }
      });
      return headers;
    });
  }
  get(path, skipPostResponse) {
    const method = "get";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(_classPrivateFieldLooseBase$4(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin"
    })).then(_classPrivateFieldLooseBase$4(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$4(this, _errorHandler)[_errorHandler](method, path));
  }
  post(path, data5, skipPostResponse) {
    const method = "post";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(_classPrivateFieldLooseBase$4(this, _getUrl)[_getUrl](path), {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin",
      body: JSON.stringify(data5)
    })).then(_classPrivateFieldLooseBase$4(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$4(this, _errorHandler)[_errorHandler](method, path));
  }
  delete(path, data5, skipPostResponse) {
    const method = "delete";
    return this.preflightAndHeaders(path).then((headers) => fetchWithNetworkError(`${this.hostname}/${path}`, {
      method,
      headers,
      credentials: this.opts.companionCookiesRule || "same-origin",
      body: data5 ? JSON.stringify(data5) : null
    })).then(_classPrivateFieldLooseBase$4(this, _getPostResponseFunc)[_getPostResponseFunc](skipPostResponse)).then(handleJSONResponse).catch(_classPrivateFieldLooseBase$4(this, _errorHandler)[_errorHandler](method, path));
  }
}), _class$1.VERSION = "2.0.4", _class$1.defaultHeaders = {
  Accept: "application/json",
  "Content-Type": "application/json",
  "Uppy-Versions": `@uppy/companion-client=${_class$1.VERSION}`
}, _temp$1);
function _getUrl2(url) {
  if (/^(https?:|)\/\//.test(url)) {
    return url;
  }
  return `${this.hostname}/${url}`;
}
function _errorHandler2(method, path) {
  return (err2) => {
    var _err;
    if (!((_err = err2) != null && _err.isAuthError)) {
      const error = new Error(`Could not ${method} ${_classPrivateFieldLooseBase$4(this, _getUrl)[_getUrl](path)}`);
      error.cause = err2;
      err2 = error;
    }
    return Promise.reject(err2);
  };
}
var setItem = (key, value) => {
  return new Promise((resolve) => {
    localStorage.setItem(key, value);
    resolve();
  });
};
var getItem = (key) => {
  return Promise.resolve(localStorage.getItem(key));
};
var removeItem = (key) => {
  return new Promise((resolve) => {
    localStorage.removeItem(key);
    resolve();
  });
};
var tokenStorage = {
  setItem,
  getItem,
  removeItem
};
const getName$1 = (id2) => {
  return id2.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
};
var Provider_1 = class Provider2 extends RequestClient_1 {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName$1(this.id);
    this.pluginId = this.opts.pluginId;
    this.tokenKey = `companion-${this.pluginId}-auth-token`;
    this.companionKeysParams = this.opts.companionKeysParams;
    this.preAuthToken = null;
  }
  headers() {
    return Promise.all([super.headers(), this.getAuthToken()]).then((_ref) => {
      let [headers, token] = _ref;
      const authHeaders = {};
      if (token) {
        authHeaders["uppy-auth-token"] = token;
      }
      if (this.companionKeysParams) {
        authHeaders["uppy-credentials-params"] = btoa(JSON.stringify({
          params: this.companionKeysParams
        }));
      }
      return {
        ...headers,
        ...authHeaders
      };
    });
  }
  onReceiveResponse(response) {
    response = super.onReceiveResponse(response);
    const plugin = this.uppy.getPlugin(this.pluginId);
    const oldAuthenticated = plugin.getPluginState().authenticated;
    const authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated
    });
    return response;
  }
  setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  }
  getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  }
  authUrl(queries) {
    if (queries === void 0) {
      queries = {};
    }
    if (this.preAuthToken) {
      queries.uppyPreAuthToken = this.preAuthToken;
    }
    return `${this.hostname}/${this.id}/connect?${new URLSearchParams(queries)}`;
  }
  fileUrl(id2) {
    return `${this.hostname}/${this.id}/get/${id2}`;
  }
  fetchPreAuthToken() {
    if (!this.companionKeysParams) {
      return Promise.resolve();
    }
    return this.post(`${this.id}/preauth/`, {
      params: this.companionKeysParams
    }).then((res) => {
      this.preAuthToken = res.token;
    }).catch((err2) => {
      this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${err2}`, "warning");
    });
  }
  list(directory) {
    return this.get(`${this.id}/list/${directory || ""}`);
  }
  logout() {
    return this.get(`${this.id}/logout`).then((response) => Promise.all([response, this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)])).then((_ref2) => {
      let [response] = _ref2;
      return response;
    });
  }
  static initPlugin(plugin, opts, defaultOpts) {
    plugin.type = "acquirer";
    plugin.files = [];
    if (defaultOpts) {
      plugin.opts = {
        ...defaultOpts,
        ...opts
      };
    }
    if (opts.serverUrl || opts.serverPattern) {
      throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");
    }
    if (opts.companionAllowedHosts) {
      const pattern = opts.companionAllowedHosts;
      if (typeof pattern !== "string" && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(`${plugin.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);
      }
      plugin.opts.companionAllowedHosts = pattern;
    } else if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
      plugin.opts.companionAllowedHosts = `https://${opts.companionUrl.replace(/^\/\//, "")}`;
    } else {
      plugin.opts.companionAllowedHosts = new URL(opts.companionUrl).origin;
    }
    plugin.storage = plugin.opts.storage || tokenStorage;
  }
};
const getName = (id2) => {
  return id2.split("-").map((s2) => s2.charAt(0).toUpperCase() + s2.slice(1)).join(" ");
};
var SearchProvider_1 = class SearchProvider extends RequestClient_1 {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.provider = opts.provider;
    this.id = this.provider;
    this.name = this.opts.name || getName(this.id);
    this.pluginId = this.opts.pluginId;
  }
  fileUrl(id2) {
    return `${this.hostname}/search/${this.id}/get/${id2}`;
  }
  search(text2, queries) {
    queries = queries ? `&${queries}` : "";
    return this.get(`search/${this.id}/list?q=${encodeURIComponent(text2)}${queries}`);
  }
};
var _queued, _emitter$1, _isOpen, _socket, _handleMessage;
let _Symbol$for, _Symbol$for2;
function _classPrivateFieldLooseBase$3(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$5 = 0;
function _classPrivateFieldLooseKey$3(name2) {
  return "__private_" + id$5++ + "_" + name2;
}
var Socket$1 = (_queued = /* @__PURE__ */ _classPrivateFieldLooseKey$3("queued"), _emitter$1 = /* @__PURE__ */ _classPrivateFieldLooseKey$3("emitter"), _isOpen = /* @__PURE__ */ _classPrivateFieldLooseKey$3("isOpen"), _socket = /* @__PURE__ */ _classPrivateFieldLooseKey$3("socket"), _handleMessage = /* @__PURE__ */ _classPrivateFieldLooseKey$3("handleMessage"), _Symbol$for = Symbol.for("uppy test: getSocket"), _Symbol$for2 = Symbol.for("uppy test: getQueued"), class UppySocket {
  constructor(opts) {
    Object.defineProperty(this, _queued, {
      writable: true,
      value: []
    });
    Object.defineProperty(this, _emitter$1, {
      writable: true,
      value: namespaceEmitter()
    });
    Object.defineProperty(this, _isOpen, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _socket, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _handleMessage, {
      writable: true,
      value: (e3) => {
        try {
          const message2 = JSON.parse(e3.data);
          this.emit(message2.action, message2.payload);
        } catch (err2) {
          console.log(err2);
        }
      }
    });
    this.opts = opts;
    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }
  get isOpen() {
    return _classPrivateFieldLooseBase$3(this, _isOpen)[_isOpen];
  }
  [_Symbol$for]() {
    return _classPrivateFieldLooseBase$3(this, _socket)[_socket];
  }
  [_Symbol$for2]() {
    return _classPrivateFieldLooseBase$3(this, _queued)[_queued];
  }
  open() {
    _classPrivateFieldLooseBase$3(this, _socket)[_socket] = new WebSocket(this.opts.target);
    _classPrivateFieldLooseBase$3(this, _socket)[_socket].onopen = () => {
      _classPrivateFieldLooseBase$3(this, _isOpen)[_isOpen] = true;
      while (_classPrivateFieldLooseBase$3(this, _queued)[_queued].length > 0 && _classPrivateFieldLooseBase$3(this, _isOpen)[_isOpen]) {
        const first2 = _classPrivateFieldLooseBase$3(this, _queued)[_queued].shift();
        this.send(first2.action, first2.payload);
      }
    };
    _classPrivateFieldLooseBase$3(this, _socket)[_socket].onclose = () => {
      _classPrivateFieldLooseBase$3(this, _isOpen)[_isOpen] = false;
    };
    _classPrivateFieldLooseBase$3(this, _socket)[_socket].onmessage = _classPrivateFieldLooseBase$3(this, _handleMessage)[_handleMessage];
  }
  close() {
    var _classPrivateFieldLoo;
    (_classPrivateFieldLoo = _classPrivateFieldLooseBase$3(this, _socket)[_socket]) == null ? void 0 : _classPrivateFieldLoo.close();
  }
  send(action, payload) {
    if (!_classPrivateFieldLooseBase$3(this, _isOpen)[_isOpen]) {
      _classPrivateFieldLooseBase$3(this, _queued)[_queued].push({
        action,
        payload
      });
      return;
    }
    _classPrivateFieldLooseBase$3(this, _socket)[_socket].send(JSON.stringify({
      action,
      payload
    }));
  }
  on(action, handler3) {
    _classPrivateFieldLooseBase$3(this, _emitter$1)[_emitter$1].on(action, handler3);
  }
  emit(action, payload) {
    _classPrivateFieldLooseBase$3(this, _emitter$1)[_emitter$1].emit(action, payload);
  }
  once(action, handler3) {
    _classPrivateFieldLooseBase$3(this, _emitter$1)[_emitter$1].once(action, handler3);
  }
});
var lib$1 = {
  RequestClient: RequestClient_1,
  Provider: Provider_1,
  SearchProvider: SearchProvider_1,
  Socket: Socket$1
};
function emitSocketProgress(uploader, progressData, file) {
  const {
    progress,
    bytesUploaded,
    bytesTotal
  } = progressData;
  if (progress) {
    uploader.uppy.log(`Upload progress: ${progress}`);
    uploader.uppy.emit("upload-progress", file, {
      uploader,
      bytesUploaded,
      bytesTotal
    });
  }
}
var emitSocketProgress_1 = lodash_throttle(emitSocketProgress, 300, {
  leading: true,
  trailing: true
});
var getSocketHost = function getSocketHost2(url) {
  const regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  const host = regex.exec(url)[1];
  const socketProtocol = /^http:\/\//i.test(url) ? "ws" : "wss";
  return `${socketProtocol}://${host}`;
};
var settle = function settle2(promises) {
  const resolutions = [];
  const rejections = [];
  function resolved(value) {
    resolutions.push(value);
  }
  function rejected(error) {
    rejections.push(error);
  }
  const wait = Promise.all(promises.map((promise) => promise.then(resolved, rejected)));
  return wait.then(() => {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};
var _emitter, _events;
function _classPrivateFieldLooseBase$2(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$4 = 0;
function _classPrivateFieldLooseKey$2(name2) {
  return "__private_" + id$4++ + "_" + name2;
}
var EventTracker_1 = (_emitter = /* @__PURE__ */ _classPrivateFieldLooseKey$2("emitter"), _events = /* @__PURE__ */ _classPrivateFieldLooseKey$2("events"), class EventTracker {
  constructor(emitter2) {
    Object.defineProperty(this, _emitter, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _events, {
      writable: true,
      value: []
    });
    _classPrivateFieldLooseBase$2(this, _emitter)[_emitter] = emitter2;
  }
  on(event, fn2) {
    _classPrivateFieldLooseBase$2(this, _events)[_events].push([event, fn2]);
    return _classPrivateFieldLooseBase$2(this, _emitter)[_emitter].on(event, fn2);
  }
  remove() {
    for (const [event, fn2] of _classPrivateFieldLooseBase$2(this, _events)[_events].splice(0)) {
      _classPrivateFieldLooseBase$2(this, _emitter)[_emitter].off(event, fn2);
    }
  }
});
function _classPrivateFieldLooseBase$1(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$3 = 0;
function _classPrivateFieldLooseKey$1(name2) {
  return "__private_" + id$3++ + "_" + name2;
}
var _aliveTimer = /* @__PURE__ */ _classPrivateFieldLooseKey$1("aliveTimer");
var _isDone = /* @__PURE__ */ _classPrivateFieldLooseKey$1("isDone");
var _onTimedOut = /* @__PURE__ */ _classPrivateFieldLooseKey$1("onTimedOut");
var _timeout = /* @__PURE__ */ _classPrivateFieldLooseKey$1("timeout");
class ProgressTimeout {
  constructor(timeout, timeoutHandler) {
    Object.defineProperty(this, _aliveTimer, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _isDone, {
      writable: true,
      value: false
    });
    Object.defineProperty(this, _onTimedOut, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _timeout, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase$1(this, _timeout)[_timeout] = timeout;
    _classPrivateFieldLooseBase$1(this, _onTimedOut)[_onTimedOut] = timeoutHandler;
  }
  progress() {
    if (_classPrivateFieldLooseBase$1(this, _isDone)[_isDone])
      return;
    if (_classPrivateFieldLooseBase$1(this, _timeout)[_timeout] > 0) {
      clearTimeout(_classPrivateFieldLooseBase$1(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase$1(this, _aliveTimer)[_aliveTimer] = setTimeout(_classPrivateFieldLooseBase$1(this, _onTimedOut)[_onTimedOut], _classPrivateFieldLooseBase$1(this, _timeout)[_timeout]);
    }
  }
  done() {
    if (!_classPrivateFieldLooseBase$1(this, _isDone)[_isDone]) {
      clearTimeout(_classPrivateFieldLooseBase$1(this, _aliveTimer)[_aliveTimer]);
      _classPrivateFieldLooseBase$1(this, _aliveTimer)[_aliveTimer] = null;
      _classPrivateFieldLooseBase$1(this, _isDone)[_isDone] = true;
    }
  }
}
var ProgressTimeout_1 = ProgressTimeout;
function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id$2 = 0;
function _classPrivateFieldLooseKey(name2) {
  return "__private_" + id$2++ + "_" + name2;
}
function createCancelError() {
  return new Error("Cancelled");
}
var _activeRequests = /* @__PURE__ */ _classPrivateFieldLooseKey("activeRequests");
var _queuedHandlers = /* @__PURE__ */ _classPrivateFieldLooseKey("queuedHandlers");
var _call = /* @__PURE__ */ _classPrivateFieldLooseKey("call");
var _queueNext = /* @__PURE__ */ _classPrivateFieldLooseKey("queueNext");
var _next = /* @__PURE__ */ _classPrivateFieldLooseKey("next");
var _queue = /* @__PURE__ */ _classPrivateFieldLooseKey("queue");
var _dequeue = /* @__PURE__ */ _classPrivateFieldLooseKey("dequeue");
class RateLimitedQueue$1 {
  constructor(limit2) {
    Object.defineProperty(this, _dequeue, {
      value: _dequeue2
    });
    Object.defineProperty(this, _queue, {
      value: _queue2
    });
    Object.defineProperty(this, _next, {
      value: _next2
    });
    Object.defineProperty(this, _queueNext, {
      value: _queueNext2
    });
    Object.defineProperty(this, _call, {
      value: _call2
    });
    Object.defineProperty(this, _activeRequests, {
      writable: true,
      value: 0
    });
    Object.defineProperty(this, _queuedHandlers, {
      writable: true,
      value: []
    });
    if (typeof limit2 !== "number" || limit2 === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit2;
    }
  }
  run(fn2, queueOptions) {
    if (_classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] < this.limit) {
      return _classPrivateFieldLooseBase(this, _call)[_call](fn2);
    }
    return _classPrivateFieldLooseBase(this, _queue)[_queue](fn2, queueOptions);
  }
  wrapPromiseFunction(fn2, queueOptions) {
    var _this = this;
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      let queuedRequest;
      const outerPromise = new Promise((resolve, reject) => {
        queuedRequest = _this.run(() => {
          let cancelError;
          let innerPromise;
          try {
            innerPromise = Promise.resolve(fn2(...args));
          } catch (err2) {
            innerPromise = Promise.reject(err2);
          }
          innerPromise.then((result) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, (err2) => {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err2);
            }
          });
          return () => {
            cancelError = createCancelError();
          };
        }, queueOptions);
      });
      outerPromise.abort = () => {
        queuedRequest.abort();
      };
      return outerPromise;
    };
  }
}
function _call2(fn2) {
  _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] += 1;
  let done = false;
  let cancelActive;
  try {
    cancelActive = fn2();
  } catch (err2) {
    _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
    throw err2;
  }
  return {
    abort: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
      cancelActive();
      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
    },
    done: () => {
      if (done)
        return;
      done = true;
      _classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] -= 1;
      _classPrivateFieldLooseBase(this, _queueNext)[_queueNext]();
    }
  };
}
function _queueNext2() {
  queueMicrotask(() => _classPrivateFieldLooseBase(this, _next)[_next]());
}
function _next2() {
  if (_classPrivateFieldLooseBase(this, _activeRequests)[_activeRequests] >= this.limit) {
    return;
  }
  if (_classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].length === 0) {
    return;
  }
  const next = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].shift();
  const handler3 = _classPrivateFieldLooseBase(this, _call)[_call](next.fn);
  next.abort = handler3.abort;
  next.done = handler3.done;
}
function _queue2(fn2, options) {
  if (options === void 0) {
    options = {};
  }
  const handler3 = {
    fn: fn2,
    priority: options.priority || 0,
    abort: () => {
      _classPrivateFieldLooseBase(this, _dequeue)[_dequeue](handler3);
    },
    done: () => {
      throw new Error("Cannot mark a queued request as done: this indicates a bug");
    }
  };
  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].findIndex((other) => {
    return handler3.priority > other.priority;
  });
  if (index === -1) {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].push(handler3);
  } else {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 0, handler3);
  }
  return handler3;
}
function _dequeue2(handler3) {
  const index = _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].indexOf(handler3);
  if (index !== -1) {
    _classPrivateFieldLooseBase(this, _queuedHandlers)[_queuedHandlers].splice(index, 1);
  }
}
var RateLimitedQueue_1 = {
  RateLimitedQueue: RateLimitedQueue$1,
  internalRateLimitedQueue: Symbol("__queue")
};
function isNetworkError(xhr) {
  if (!xhr) {
    return false;
  }
  return xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0;
}
var isNetworkError_1 = isNetworkError;
var locale = {
  strings: {
    timedOut: "Upload stalled for %{seconds} seconds, aborting."
  }
};
var _class, _temp;
const {
  nanoid
} = require$$0;
const {
  Provider,
  RequestClient,
  Socket
} = lib$1;
const {
  RateLimitedQueue,
  internalRateLimitedQueue
} = RateLimitedQueue_1;
function buildResponseError(xhr, err2) {
  let error = err2;
  if (!error)
    error = new Error("Upload error");
  if (typeof error === "string")
    error = new Error(error);
  if (!(error instanceof Error)) {
    error = Object.assign(new Error("Upload error"), {
      data: error
    });
  }
  if (isNetworkError_1(xhr)) {
    error = new NetworkError_1(error, xhr);
    return error;
  }
  error.request = xhr;
  return error;
}
function setTypeInBlob(file) {
  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
  return dataWithUpdatedType;
}
var lib = (_temp = _class = class XHRUpload extends BasePlugin_1$1 {
  constructor(uppy, opts) {
    super(uppy, opts);
    this.type = "uploader";
    this.id = this.opts.id || "XHRUpload";
    this.title = "XHRUpload";
    this.defaultLocale = locale;
    const defaultOptions = {
      formData: true,
      fieldName: opts.bundle ? "files[]" : "file",
      method: "post",
      metaFields: null,
      responseUrlFieldName: "url",
      bundle: false,
      headers: {},
      timeout: 30 * 1e3,
      limit: 5,
      withCredentials: false,
      responseType: "",
      getResponseData(responseText) {
        let parsedResponse = {};
        try {
          parsedResponse = JSON.parse(responseText);
        } catch (err2) {
          uppy.log(err2);
        }
        return parsedResponse;
      },
      getResponseError(_2, response) {
        let error = new Error("Upload error");
        if (isNetworkError_1(response)) {
          error = new NetworkError_1(error, response);
        }
        return error;
      },
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    this.opts = {
      ...defaultOptions,
      ...opts
    };
    this.i18nInit();
    this.handleUpload = this.handleUpload.bind(this);
    if (internalRateLimitedQueue in this.opts) {
      this.requests = this.opts[internalRateLimitedQueue];
    } else {
      this.requests = new RateLimitedQueue(this.opts.limit);
    }
    if (this.opts.bundle && !this.opts.formData) {
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    }
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
  }
  getOptions(file) {
    const overrides = this.uppy.getState().xhrUpload;
    const {
      headers
    } = this.opts;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {}
    };
    if (typeof headers === "function") {
      opts.headers = headers(file);
    } else {
      Object.assign(opts.headers, this.opts.headers);
    }
    if (overrides) {
      Object.assign(opts.headers, overrides.headers);
    }
    if (file.xhrUpload) {
      Object.assign(opts.headers, file.xhrUpload.headers);
    }
    return opts;
  }
  addMetadata(formData3, meta, opts) {
    const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields : Object.keys(meta);
    metaFields.forEach((item) => {
      formData3.append(item, meta[item]);
    });
  }
  createFormDataUpload(file, opts) {
    const formPost = new FormData();
    this.addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  createBundledUpload(files, opts) {
    const formPost = new FormData();
    const {
      meta
    } = this.uppy.getState();
    this.addMetadata(formPost, meta, opts);
    files.forEach((file) => {
      const options = this.getOptions(file);
      const dataWithUpdatedType = setTypeInBlob(file);
      if (file.name) {
        formPost.append(options.fieldName, dataWithUpdatedType, file.name);
      } else {
        formPost.append(options.fieldName, dataWithUpdatedType);
      }
    });
    return formPost;
  }
  upload(file, current, total) {
    const opts = this.getOptions(file);
    this.uppy.log(`uploading ${current} of ${total}`);
    return new Promise((resolve, reject) => {
      this.uppy.emit("upload-started", file);
      const data5 = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
      const xhr = new XMLHttpRequest();
      this.uploaderEvents[file.id] = new EventTracker_1(this.uppy);
      const timer = new ProgressTimeout_1(opts.timeout, () => {
        xhr.abort();
        queuedRequest.done();
        const error = new Error(this.i18n("timedOut", {
          seconds: Math.ceil(opts.timeout / 1e3)
        }));
        this.uppy.emit("upload-error", file, error);
        reject(error);
      });
      const id2 = nanoid();
      xhr.upload.addEventListener("loadstart", () => {
        this.uppy.log(`[XHRUpload] ${id2} started`);
      });
      xhr.upload.addEventListener("progress", (ev) => {
        this.uppy.log(`[XHRUpload] ${id2} progress: ${ev.loaded} / ${ev.total}`);
        timer.progress();
        if (ev.lengthComputable) {
          this.uppy.emit("upload-progress", file, {
            uploader: this,
            bytesUploaded: ev.loaded,
            bytesTotal: ev.total
          });
        }
      });
      xhr.addEventListener("load", (ev) => {
        this.uppy.log(`[XHRUpload] ${id2} finished`);
        timer.done();
        queuedRequest.done();
        if (this.uploaderEvents[file.id]) {
          this.uploaderEvents[file.id].remove();
          this.uploaderEvents[file.id] = null;
        }
        if (opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
          const body2 = opts.getResponseData(xhr.responseText, xhr);
          const uploadURL = body2[opts.responseUrlFieldName];
          const uploadResp = {
            status: ev.target.status,
            body: body2,
            uploadURL
          };
          this.uppy.emit("upload-success", file, uploadResp);
          if (uploadURL) {
            this.uppy.log(`Download ${file.name} from ${uploadURL}`);
          }
          return resolve(file);
        }
        const body = opts.getResponseData(xhr.responseText, xhr);
        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
        const response = {
          status: ev.target.status,
          body
        };
        this.uppy.emit("upload-error", file, error, response);
        return reject(error);
      });
      xhr.addEventListener("error", () => {
        this.uppy.log(`[XHRUpload] ${id2} errored`);
        timer.done();
        queuedRequest.done();
        if (this.uploaderEvents[file.id]) {
          this.uploaderEvents[file.id].remove();
          this.uploaderEvents[file.id] = null;
        }
        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));
        this.uppy.emit("upload-error", file, error);
        return reject(error);
      });
      xhr.open(opts.method.toUpperCase(), opts.endpoint, true);
      xhr.withCredentials = opts.withCredentials;
      if (opts.responseType !== "") {
        xhr.responseType = opts.responseType;
      }
      const queuedRequest = this.requests.run(() => {
        this.uppy.emit("upload-started", file);
        const currentOpts = this.getOptions(file);
        Object.keys(currentOpts.headers).forEach((header) => {
          xhr.setRequestHeader(header, currentOpts.headers[header]);
        });
        xhr.send(data5);
        return () => {
          timer.done();
          xhr.abort();
        };
      });
      this.onFileRemove(file.id, () => {
        queuedRequest.abort();
        reject(new Error("File removed"));
      });
      this.onCancelAll(file.id, () => {
        queuedRequest.abort();
        reject(new Error("Upload cancelled"));
      });
    });
  }
  uploadRemote(file) {
    const opts = this.getOptions(file);
    return new Promise((resolve, reject) => {
      this.uppy.emit("upload-started", file);
      const fields = {};
      const metaFields = Array.isArray(opts.metaFields) ? opts.metaFields : Object.keys(file.meta);
      metaFields.forEach((name2) => {
        fields[name2] = file.meta[name2];
      });
      const Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      const client = new Client(this.uppy, file.remote.providerOptions);
      client.post(file.remote.url, {
        ...file.remote.body,
        endpoint: opts.endpoint,
        size: file.data.size,
        fieldname: opts.fieldName,
        metadata: fields,
        httpMethod: opts.method,
        useFormData: opts.formData,
        headers: opts.headers
      }).then((res) => {
        const {
          token
        } = res;
        const host = getSocketHost(file.remote.companionUrl);
        const socket = new Socket({
          target: `${host}/api/${token}`,
          autoOpen: false
        });
        this.uploaderEvents[file.id] = new EventTracker_1(this.uppy);
        this.onFileRemove(file.id, () => {
          socket.send("cancel", {});
          queuedRequest.abort();
          resolve(`upload ${file.id} was removed`);
        });
        this.onCancelAll(file.id, () => {
          socket.send("cancel", {});
          queuedRequest.abort();
          resolve(`upload ${file.id} was canceled`);
        });
        this.onRetry(file.id, () => {
          socket.send("pause", {});
          socket.send("resume", {});
        });
        this.onRetryAll(file.id, () => {
          socket.send("pause", {});
          socket.send("resume", {});
        });
        socket.on("progress", (progressData) => emitSocketProgress_1(this, progressData, file));
        socket.on("success", (data5) => {
          const body = opts.getResponseData(data5.response.responseText, data5.response);
          const uploadURL = body[opts.responseUrlFieldName];
          const uploadResp = {
            status: data5.response.status,
            body,
            uploadURL
          };
          this.uppy.emit("upload-success", file, uploadResp);
          queuedRequest.done();
          if (this.uploaderEvents[file.id]) {
            this.uploaderEvents[file.id].remove();
            this.uploaderEvents[file.id] = null;
          }
          return resolve();
        });
        socket.on("error", (errData) => {
          const resp = errData.response;
          const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {
            cause: errData.error
          });
          this.uppy.emit("upload-error", file, error);
          queuedRequest.done();
          if (this.uploaderEvents[file.id]) {
            this.uploaderEvents[file.id].remove();
            this.uploaderEvents[file.id] = null;
          }
          reject(error);
        });
        const queuedRequest = this.requests.run(() => {
          socket.open();
          if (file.isPaused) {
            socket.send("pause", {});
          }
          return () => socket.close();
        });
      }).catch((err2) => {
        this.uppy.emit("upload-error", file, err2);
        reject(err2);
      });
    });
  }
  uploadBundle(files) {
    return new Promise((resolve, reject) => {
      const {
        endpoint
      } = this.opts;
      const {
        method
      } = this.opts;
      const optsFromState = this.uppy.getState().xhrUpload;
      const formData3 = this.createBundledUpload(files, {
        ...this.opts,
        ...optsFromState || {}
      });
      const xhr = new XMLHttpRequest();
      const timer = new ProgressTimeout_1(this.opts.timeout, () => {
        xhr.abort();
        const error = new Error(this.i18n("timedOut", {
          seconds: Math.ceil(this.opts.timeout / 1e3)
        }));
        emitError(error);
        reject(error);
      });
      const emitError = (error) => {
        files.forEach((file) => {
          this.uppy.emit("upload-error", file, error);
        });
      };
      xhr.upload.addEventListener("loadstart", () => {
        this.uppy.log("[XHRUpload] started uploading bundle");
        timer.progress();
      });
      xhr.upload.addEventListener("progress", (ev) => {
        timer.progress();
        if (!ev.lengthComputable)
          return;
        files.forEach((file) => {
          this.uppy.emit("upload-progress", file, {
            uploader: this,
            bytesUploaded: ev.loaded / ev.total * file.size,
            bytesTotal: file.size
          });
        });
      });
      xhr.addEventListener("load", (ev) => {
        timer.done();
        if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {
          const body = this.opts.getResponseData(xhr.responseText, xhr);
          const uploadResp = {
            status: ev.target.status,
            body
          };
          files.forEach((file) => {
            this.uppy.emit("upload-success", file, uploadResp);
          });
          return resolve();
        }
        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
        error.request = xhr;
        emitError(error);
        return reject(error);
      });
      xhr.addEventListener("error", () => {
        timer.done();
        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error("Upload error");
        emitError(error);
        return reject(error);
      });
      this.uppy.on("cancel-all", () => {
        timer.done();
        xhr.abort();
      });
      xhr.open(method.toUpperCase(), endpoint, true);
      xhr.withCredentials = this.opts.withCredentials;
      if (this.opts.responseType !== "") {
        xhr.responseType = this.opts.responseType;
      }
      Object.keys(this.opts.headers).forEach((header) => {
        xhr.setRequestHeader(header, this.opts.headers[header]);
      });
      xhr.send(formData3);
      files.forEach((file) => {
        this.uppy.emit("upload-started", file);
      });
    });
  }
  uploadFiles(files) {
    const promises = files.map((file, i2) => {
      const current = parseInt(i2, 10) + 1;
      const total = files.length;
      if (file.error) {
        return Promise.reject(new Error(file.error));
      }
      if (file.isRemote) {
        return this.uploadRemote(file, current, total);
      }
      return this.upload(file, current, total);
    });
    return settle(promises);
  }
  onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on("file-removed", (file) => {
      if (fileID === file.id)
        cb(file.id);
    });
  }
  onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on("upload-retry", (targetFileID) => {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  onRetryAll(fileID, cb) {
    this.uploaderEvents[fileID].on("retry-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  onCancelAll(fileID, cb) {
    this.uploaderEvents[fileID].on("cancel-all", () => {
      if (!this.uppy.getFile(fileID))
        return;
      cb();
    });
  }
  handleUpload(fileIDs) {
    if (fileIDs.length === 0) {
      this.uppy.log("[XHRUpload] No files to upload!");
      return Promise.resolve();
    }
    if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {
      this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
    }
    this.uppy.log("[XHRUpload] Uploading...");
    const files = fileIDs.map((fileID) => this.uppy.getFile(fileID));
    if (this.opts.bundle) {
      const isSomeFileRemote = files.some((file) => file.isRemote);
      if (isSomeFileRemote) {
        throw new Error("Can\u2019t upload remote files when the `bundle: true` option is set");
      }
      if (typeof this.opts.headers === "function") {
        throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
      }
      return this.uploadBundle(files);
    }
    return this.uploadFiles(files).then(() => null);
  }
  install() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: false
        }
      });
    }
    this.uppy.addUploader(this.handleUpload);
  }
  uninstall() {
    if (this.opts.bundle) {
      const {
        capabilities
      } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: true
        }
      });
    }
    this.uppy.removeUploader(this.handleUpload);
  }
}, _class.VERSION = "2.0.6", _temp);
var te$6 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ne$6(e3) {
  var t2 = { exports: {} };
  return e3(t2, t2.exports), t2.exports;
}
var re$6, oe$6, ie$6 = function(e3) {
  return e3 && e3.Math == Math && e3;
}, ae$6 = ie$6("object" == typeof globalThis && globalThis) || ie$6("object" == typeof window && window) || ie$6("object" == typeof self && self) || ie$6("object" == typeof te$6 && te$6) || function() {
  return this;
}() || Function("return this")(), se$6 = Object.defineProperty, le$6 = function(e3, t2) {
  try {
    se$6(ae$6, e3, { value: t2, configurable: true, writable: true });
  } catch (n2) {
    ae$6[e3] = t2;
  }
  return t2;
}, ue$6 = ae$6["__core-js_shared__"] || le$6("__core-js_shared__", {}), ce$6 = ne$6(function(e3) {
  (e3.exports = function(e4, t2) {
    return ue$6[e4] || (ue$6[e4] = void 0 !== t2 ? t2 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), fe$6 = Function.prototype, de$6 = fe$6.bind, he$6 = fe$6.call, pe$6 = de$6 && de$6.bind(he$6), ge$6 = de$6 ? function(e3) {
  return e3 && pe$6(he$6, e3);
} : function(e3) {
  return e3 && function() {
    return he$6.apply(e3, arguments);
  };
}, ve$6 = ae$6.TypeError, ye$6 = function(e3) {
  if (null == e3)
    throw ve$6("Can't call method on " + e3);
  return e3;
}, me$6 = ae$6.Object, be$6 = function(e3) {
  return me$6(ye$6(e3));
}, we$6 = ge$6({}.hasOwnProperty), xe$6 = Object.hasOwn || function(e3, t2) {
  return we$6(be$6(e3), t2);
}, Se$6 = 0, ke$6 = Math.random(), Ee$6 = ge$6(1 .toString), Oe$6 = function(e3) {
  return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + Ee$6(++Se$6 + ke$6, 36);
}, Ce$6 = function(e3) {
  return "function" == typeof e3;
}, Ne$6 = function(e3) {
  return Ce$6(e3) ? e3 : void 0;
}, Te$6 = function(e3, t2) {
  return arguments.length < 2 ? Ne$6(ae$6[e3]) : ae$6[e3] && ae$6[e3][t2];
}, Le$6 = Te$6("navigator", "userAgent") || "", Me$6 = ae$6.process, Pe$6 = ae$6.Deno, De$6 = Me$6 && Me$6.versions || Pe$6 && Pe$6.version, Re$6 = De$6 && De$6.v8;
Re$6 && (oe$6 = (re$6 = Re$6.split("."))[0] > 0 && re$6[0] < 4 ? 1 : +(re$6[0] + re$6[1])), !oe$6 && Le$6 && (!(re$6 = Le$6.match(/Edge\/(\d+)/)) || re$6[1] >= 74) && (re$6 = Le$6.match(/Chrome\/(\d+)/)) && (oe$6 = +re$6[1]);
var je$6 = oe$6, Ae$6 = function(e3) {
  try {
    return !!e3();
  } catch (e4) {
    return true;
  }
}, Fe$6 = !!Object.getOwnPropertySymbols && !Ae$6(function() {
  var e3 = Symbol();
  return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && je$6 && je$6 < 41;
}), Ie$6 = Fe$6 && !Symbol.sham && "symbol" == typeof Symbol.iterator, _e$6 = ce$6("wks"), Be$6 = ae$6.Symbol, $e$6 = Be$6 && Be$6.for, We$6 = Ie$6 ? Be$6 : Be$6 && Be$6.withoutSetter || Oe$6, Ve$6 = function(e3) {
  if (!xe$6(_e$6, e3) || !Fe$6 && "string" != typeof _e$6[e3]) {
    var t2 = "Symbol." + e3;
    Fe$6 && xe$6(Be$6, e3) ? _e$6[e3] = Be$6[e3] : _e$6[e3] = Ie$6 && $e$6 ? $e$6(t2) : We$6(t2);
  }
  return _e$6[e3];
}, ze$6 = {};
ze$6[Ve$6("toStringTag")] = "z";
var He$6 = "[object z]" === String(ze$6), Ue$6 = !Ae$6(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), Ke$6 = function(e3) {
  return "object" == typeof e3 ? null !== e3 : Ce$6(e3);
}, qe$6 = ae$6.document, Ge$6 = Ke$6(qe$6) && Ke$6(qe$6.createElement), Je$6 = function(e3) {
  return Ge$6 ? qe$6.createElement(e3) : {};
}, Ye$6 = !Ue$6 && !Ae$6(function() {
  return 7 != Object.defineProperty(Je$6("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Xe$6 = ae$6.String, Qe$6 = ae$6.TypeError, Ze$6 = function(e3) {
  if (Ke$6(e3))
    return e3;
  throw Qe$6(Xe$6(e3) + " is not an object");
}, et$6 = Function.prototype.call, tt$6 = et$6.bind ? et$6.bind(et$6) : function() {
  return et$6.apply(et$6, arguments);
}, nt$6 = ge$6({}.isPrototypeOf), rt$6 = ae$6.Object, ot$6 = Ie$6 ? function(e3) {
  return "symbol" == typeof e3;
} : function(e3) {
  var t2 = Te$6("Symbol");
  return Ce$6(t2) && nt$6(t2.prototype, rt$6(e3));
}, it$6 = ae$6.String, at$6 = function(e3) {
  try {
    return it$6(e3);
  } catch (e4) {
    return "Object";
  }
}, st$6 = ae$6.TypeError, lt$6 = function(e3) {
  if (Ce$6(e3))
    return e3;
  throw st$6(at$6(e3) + " is not a function");
}, ut$6 = function(e3, t2) {
  var n2 = e3[t2];
  return null == n2 ? void 0 : lt$6(n2);
}, ct$6 = ae$6.TypeError, ft$6 = ae$6.TypeError, dt$6 = Ve$6("toPrimitive"), ht$6 = function(e3, t2) {
  if (!Ke$6(e3) || ot$6(e3))
    return e3;
  var n2, r2 = ut$6(e3, dt$6);
  if (r2) {
    if (void 0 === t2 && (t2 = "default"), n2 = tt$6(r2, e3, t2), !Ke$6(n2) || ot$6(n2))
      return n2;
    throw ft$6("Can't convert object to primitive value");
  }
  return void 0 === t2 && (t2 = "number"), function(e4, t3) {
    var n3, r3;
    if ("string" === t3 && Ce$6(n3 = e4.toString) && !Ke$6(r3 = tt$6(n3, e4)))
      return r3;
    if (Ce$6(n3 = e4.valueOf) && !Ke$6(r3 = tt$6(n3, e4)))
      return r3;
    if ("string" !== t3 && Ce$6(n3 = e4.toString) && !Ke$6(r3 = tt$6(n3, e4)))
      return r3;
    throw ct$6("Can't convert object to primitive value");
  }(e3, t2);
}, pt$6 = function(e3) {
  var t2 = ht$6(e3, "string");
  return ot$6(t2) ? t2 : t2 + "";
}, gt$6 = ae$6.TypeError, vt$6 = Object.defineProperty, yt$6 = { f: Ue$6 ? vt$6 : function(e3, t2, n2) {
  if (Ze$6(e3), t2 = pt$6(t2), Ze$6(n2), Ye$6)
    try {
      return vt$6(e3, t2, n2);
    } catch (e4) {
    }
  if ("get" in n2 || "set" in n2)
    throw gt$6("Accessors not supported");
  return "value" in n2 && (e3[t2] = n2.value), e3;
} }, mt$6 = function(e3, t2) {
  return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
}, bt$6 = Ue$6 ? function(e3, t2, n2) {
  return yt$6.f(e3, t2, mt$6(1, n2));
} : function(e3, t2, n2) {
  return e3[t2] = n2, e3;
}, wt$6 = ge$6(Function.toString);
Ce$6(ue$6.inspectSource) || (ue$6.inspectSource = function(e3) {
  return wt$6(e3);
});
var xt$6, St$6, kt$6, Et$6 = ue$6.inspectSource, Ot$6 = ae$6.WeakMap, Ct$6 = Ce$6(Ot$6) && /native code/.test(Et$6(Ot$6)), Nt$6 = ce$6("keys"), Tt$6 = function(e3) {
  return Nt$6[e3] || (Nt$6[e3] = Oe$6(e3));
}, Lt$6 = {}, Mt$6 = ae$6.TypeError, Pt$6 = ae$6.WeakMap;
if (Ct$6 || ue$6.state) {
  var Dt$6 = ue$6.state || (ue$6.state = new Pt$6()), Rt$6 = ge$6(Dt$6.get), jt$6 = ge$6(Dt$6.has), At$6 = ge$6(Dt$6.set);
  xt$6 = function(e3, t2) {
    if (jt$6(Dt$6, e3))
      throw new Mt$6("Object already initialized");
    return t2.facade = e3, At$6(Dt$6, e3, t2), t2;
  }, St$6 = function(e3) {
    return Rt$6(Dt$6, e3) || {};
  }, kt$6 = function(e3) {
    return jt$6(Dt$6, e3);
  };
} else {
  var Ft$6 = Tt$6("state");
  Lt$6[Ft$6] = true, xt$6 = function(e3, t2) {
    if (xe$6(e3, Ft$6))
      throw new Mt$6("Object already initialized");
    return t2.facade = e3, bt$6(e3, Ft$6, t2), t2;
  }, St$6 = function(e3) {
    return xe$6(e3, Ft$6) ? e3[Ft$6] : {};
  }, kt$6 = function(e3) {
    return xe$6(e3, Ft$6);
  };
}
var It$6 = { set: xt$6, get: St$6, has: kt$6, enforce: function(e3) {
  return kt$6(e3) ? St$6(e3) : xt$6(e3, {});
}, getterFor: function(e3) {
  return function(t2) {
    var n2;
    if (!Ke$6(t2) || (n2 = St$6(t2)).type !== e3)
      throw Mt$6("Incompatible receiver, " + e3 + " required");
    return n2;
  };
} }, _t$6 = Function.prototype, Bt$6 = Ue$6 && Object.getOwnPropertyDescriptor, $t$6 = xe$6(_t$6, "name"), Wt$6 = { EXISTS: $t$6, PROPER: $t$6 && "something" === function() {
}.name, CONFIGURABLE: $t$6 && (!Ue$6 || Ue$6 && Bt$6(_t$6, "name").configurable) }, Vt$6 = ne$6(function(e3) {
  var t2 = Wt$6.CONFIGURABLE, n2 = It$6.get, r2 = It$6.enforce, o2 = String(String).split("String");
  (e3.exports = function(e4, n3, i2, a2) {
    var s2, l2 = !!a2 && !!a2.unsafe, u2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet, f2 = a2 && void 0 !== a2.name ? a2.name : n3;
    Ce$6(i2) && ("Symbol(" === String(f2).slice(0, 7) && (f2 = "[" + String(f2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!xe$6(i2, "name") || t2 && i2.name !== f2) && bt$6(i2, "name", f2), (s2 = r2(i2)).source || (s2.source = o2.join("string" == typeof f2 ? f2 : ""))), e4 !== ae$6 ? (l2 ? !c2 && e4[n3] && (u2 = true) : delete e4[n3], u2 ? e4[n3] = i2 : bt$6(e4, n3, i2)) : u2 ? e4[n3] = i2 : le$6(n3, i2);
  })(Function.prototype, "toString", function() {
    return Ce$6(this) && n2(this).source || Et$6(this);
  });
}), zt$6 = ge$6({}.toString), Ht$6 = ge$6("".slice), Ut$6 = function(e3) {
  return Ht$6(zt$6(e3), 8, -1);
}, Kt$6 = Ve$6("toStringTag"), qt$6 = ae$6.Object, Gt$6 = "Arguments" == Ut$6(function() {
  return arguments;
}()), Jt$6 = He$6 ? Ut$6 : function(e3) {
  var t2, n2, r2;
  return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (n2 = function(e4, t3) {
    try {
      return e4[t3];
    } catch (e5) {
    }
  }(t2 = qt$6(e3), Kt$6)) ? n2 : Gt$6 ? Ut$6(t2) : "Object" == (r2 = Ut$6(t2)) && Ce$6(t2.callee) ? "Arguments" : r2;
}, Yt$6 = He$6 ? {}.toString : function() {
  return "[object " + Jt$6(this) + "]";
};
He$6 || Vt$6(Object.prototype, "toString", Yt$6, { unsafe: true });
var Xt$6 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Qt$6 = Je$6("span").classList, Zt$6 = Qt$6 && Qt$6.constructor && Qt$6.constructor.prototype, en$6 = Zt$6 === Object.prototype ? void 0 : Zt$6, tn$6 = ge$6(ge$6.bind), nn$6 = function(e3, t2) {
  return lt$6(e3), void 0 === t2 ? e3 : tn$6 ? tn$6(e3, t2) : function() {
    return e3.apply(t2, arguments);
  };
}, rn$6 = ae$6.Object, on$6 = ge$6("".split), an$6 = Ae$6(function() {
  return !rn$6("z").propertyIsEnumerable(0);
}) ? function(e3) {
  return "String" == Ut$6(e3) ? on$6(e3, "") : rn$6(e3);
} : rn$6, sn$6 = Math.ceil, ln$6 = Math.floor, un$6 = function(e3) {
  var t2 = +e3;
  return t2 != t2 || 0 === t2 ? 0 : (t2 > 0 ? ln$6 : sn$6)(t2);
}, cn$6 = Math.min, fn$6 = function(e3) {
  return e3 > 0 ? cn$6(un$6(e3), 9007199254740991) : 0;
}, dn$6 = function(e3) {
  return fn$6(e3.length);
}, hn$6 = Array.isArray || function(e3) {
  return "Array" == Ut$6(e3);
}, pn$6 = function() {
}, gn$6 = [], vn$6 = Te$6("Reflect", "construct"), yn$6 = /^\s*(?:class|function)\b/, mn$6 = ge$6(yn$6.exec), bn$6 = !yn$6.exec(pn$6), wn$6 = function(e3) {
  if (!Ce$6(e3))
    return false;
  try {
    return vn$6(pn$6, gn$6, e3), true;
  } catch (e4) {
    return false;
  }
}, xn$6 = !vn$6 || Ae$6(function() {
  var e3;
  return wn$6(wn$6.call) || !wn$6(Object) || !wn$6(function() {
    e3 = true;
  }) || e3;
}) ? function(e3) {
  if (!Ce$6(e3))
    return false;
  switch (Jt$6(e3)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return bn$6 || !!mn$6(yn$6, Et$6(e3));
} : wn$6, Sn$6 = Ve$6("species"), kn$6 = ae$6.Array, En$6 = function(e3, t2) {
  return new (function(e4) {
    var t3;
    return hn$6(e4) && (t3 = e4.constructor, (xn$6(t3) && (t3 === kn$6 || hn$6(t3.prototype)) || Ke$6(t3) && null === (t3 = t3[Sn$6])) && (t3 = void 0)), void 0 === t3 ? kn$6 : t3;
  }(e3))(0 === t2 ? 0 : t2);
}, On$6 = ge$6([].push), Cn$6 = function(e3) {
  var t2 = 1 == e3, n2 = 2 == e3, r2 = 3 == e3, o2 = 4 == e3, i2 = 6 == e3, a2 = 7 == e3, s2 = 5 == e3 || i2;
  return function(l2, u2, c2, f2) {
    for (var d3, h2, p2 = be$6(l2), g2 = an$6(p2), v2 = nn$6(u2, c2), y2 = dn$6(g2), m2 = 0, b2 = f2 || En$6, w2 = t2 ? b2(l2, y2) : n2 || a2 ? b2(l2, 0) : void 0; y2 > m2; m2++)
      if ((s2 || m2 in g2) && (h2 = v2(d3 = g2[m2], m2, p2), e3))
        if (t2)
          w2[m2] = h2;
        else if (h2)
          switch (e3) {
            case 3:
              return true;
            case 5:
              return d3;
            case 6:
              return m2;
            case 2:
              On$6(w2, d3);
          }
        else
          switch (e3) {
            case 4:
              return false;
            case 7:
              On$6(w2, d3);
          }
    return i2 ? -1 : r2 || o2 ? o2 : w2;
  };
}, Nn$6 = { forEach: Cn$6(0), map: Cn$6(1), filter: Cn$6(2), some: Cn$6(3), every: Cn$6(4), find: Cn$6(5), findIndex: Cn$6(6), filterReject: Cn$6(7) }, Tn$6 = function(e3, t2) {
  var n2 = [][e3];
  return !!n2 && Ae$6(function() {
    n2.call(null, t2 || function() {
      throw 1;
    }, 1);
  });
}, Ln$6 = Nn$6.forEach, Mn$6 = Tn$6("forEach") ? [].forEach : function(e3) {
  return Ln$6(this, e3, arguments.length > 1 ? arguments[1] : void 0);
}, Pn$6 = function(e3) {
  if (e3 && e3.forEach !== Mn$6)
    try {
      bt$6(e3, "forEach", Mn$6);
    } catch (t2) {
      e3.forEach = Mn$6;
    }
};
for (var Dn$6 in Xt$6)
  Xt$6[Dn$6] && Pn$6(ae$6[Dn$6] && ae$6[Dn$6].prototype);
Pn$6(en$6);
var Rn$6 = {}.propertyIsEnumerable, jn$6 = Object.getOwnPropertyDescriptor, An$6 = jn$6 && !Rn$6.call({ 1: 2 }, 1) ? function(e3) {
  var t2 = jn$6(this, e3);
  return !!t2 && t2.enumerable;
} : Rn$6, Fn$6 = { f: An$6 }, In$6 = function(e3) {
  return an$6(ye$6(e3));
}, _n$6 = Object.getOwnPropertyDescriptor, Bn$6 = { f: Ue$6 ? _n$6 : function(e3, t2) {
  if (e3 = In$6(e3), t2 = pt$6(t2), Ye$6)
    try {
      return _n$6(e3, t2);
    } catch (e4) {
    }
  if (xe$6(e3, t2))
    return mt$6(!tt$6(Fn$6.f, e3, t2), e3[t2]);
} }, $n$6 = Math.max, Wn$6 = Math.min, Vn$6 = function(e3, t2) {
  var n2 = un$6(e3);
  return n2 < 0 ? $n$6(n2 + t2, 0) : Wn$6(n2, t2);
}, zn$6 = function(e3) {
  return function(t2, n2, r2) {
    var o2, i2 = In$6(t2), a2 = dn$6(i2), s2 = Vn$6(r2, a2);
    if (e3 && n2 != n2) {
      for (; a2 > s2; )
        if ((o2 = i2[s2++]) != o2)
          return true;
    } else
      for (; a2 > s2; s2++)
        if ((e3 || s2 in i2) && i2[s2] === n2)
          return e3 || s2 || 0;
    return !e3 && -1;
  };
}, Hn$6 = { includes: zn$6(true), indexOf: zn$6(false) }, Un$6 = Hn$6.indexOf, Kn$6 = ge$6([].push), qn$6 = function(e3, t2) {
  var n2, r2 = In$6(e3), o2 = 0, i2 = [];
  for (n2 in r2)
    !xe$6(Lt$6, n2) && xe$6(r2, n2) && Kn$6(i2, n2);
  for (; t2.length > o2; )
    xe$6(r2, n2 = t2[o2++]) && (~Un$6(i2, n2) || Kn$6(i2, n2));
  return i2;
}, Gn$6 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Jn$6 = Gn$6.concat("length", "prototype"), Yn$6 = { f: Object.getOwnPropertyNames || function(e3) {
  return qn$6(e3, Jn$6);
} }, Xn$6 = { f: Object.getOwnPropertySymbols }, Qn$6 = ge$6([].concat), Zn$6 = Te$6("Reflect", "ownKeys") || function(e3) {
  var t2 = Yn$6.f(Ze$6(e3)), n2 = Xn$6.f;
  return n2 ? Qn$6(t2, n2(e3)) : t2;
}, er$5 = function(e3, t2) {
  for (var n2 = Zn$6(t2), r2 = yt$6.f, o2 = Bn$6.f, i2 = 0; i2 < n2.length; i2++) {
    var a2 = n2[i2];
    xe$6(e3, a2) || r2(e3, a2, o2(t2, a2));
  }
}, tr$5 = /#|\.prototype\./, nr$5 = function(e3, t2) {
  var n2 = or$5[rr$5(e3)];
  return n2 == ar$5 || n2 != ir$5 && (Ce$6(t2) ? Ae$6(t2) : !!t2);
}, rr$5 = nr$5.normalize = function(e3) {
  return String(e3).replace(tr$5, ".").toLowerCase();
}, or$5 = nr$5.data = {}, ir$5 = nr$5.NATIVE = "N", ar$5 = nr$5.POLYFILL = "P", sr$5 = nr$5, lr$5 = Bn$6.f, ur$5 = function(e3, t2) {
  var n2, r2, o2, i2, a2, s2 = e3.target, l2 = e3.global, u2 = e3.stat;
  if (n2 = l2 ? ae$6 : u2 ? ae$6[s2] || le$6(s2, {}) : (ae$6[s2] || {}).prototype)
    for (r2 in t2) {
      if (i2 = t2[r2], o2 = e3.noTargetGet ? (a2 = lr$5(n2, r2)) && a2.value : n2[r2], !sr$5(l2 ? r2 : s2 + (u2 ? "." : "#") + r2, e3.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        er$5(i2, o2);
      }
      (e3.sham || o2 && o2.sham) && bt$6(i2, "sham", true), Vt$6(n2, r2, i2, e3);
    }
}, cr$5 = Object.keys || function(e3) {
  return qn$6(e3, Gn$6);
}, fr$5 = Ae$6(function() {
  cr$5(1);
});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function dr$5(e3) {
  return "[object Object]" === Object.prototype.toString.call(e3);
}
ur$5({ target: "Object", stat: true, forced: fr$5 }, { keys: function(e3) {
  return cr$5(be$6(e3));
} });
var hr$5 = { isHistory(e3) {
  return false !== dr$5(n2 = e3) && (void 0 === (r2 = n2.constructor) || false !== dr$5(o2 = r2.prototype) && false !== o2.hasOwnProperty("isPrototypeOf")) && Array.isArray(e3.redos) && Array.isArray(e3.undos) && (0 === e3.redos.length || Operation.isOperationList(e3.redos[0])) && (0 === e3.undos.length || Operation.isOperationList(e3.undos[0]));
  var n2, r2, o2;
} }, pr$5 = /* @__PURE__ */ new WeakMap(), gr$5 = /* @__PURE__ */ new WeakMap(), vr$5 = { isHistoryEditor: (t2) => hr$5.isHistory(t2.history) && Editor$1.isEditor(t2), isMerging: (e3) => gr$5.get(e3), isSaving: (e3) => pr$5.get(e3), redo(e3) {
  e3.redo();
}, undo(e3) {
  e3.undo();
}, withoutMerging(e3, t2) {
  var n2 = vr$5.isMerging(e3);
  gr$5.set(e3, false), t2(), gr$5.set(e3, n2);
}, withoutSaving(e3, t2) {
  var n2 = vr$5.isSaving(e3);
  pr$5.set(e3, false), t2(), pr$5.set(e3, n2);
} }, yr$5 = (e3, t2) => "set_selection" === e3.type || (!(!t2 || "insert_text" !== e3.type || "insert_text" !== t2.type || e3.offset !== t2.offset + t2.text.length || !Path.equals(e3.path, t2.path)) || !(!t2 || "remove_text" !== e3.type || "remove_text" !== t2.type || e3.offset + e3.text.length !== t2.offset || !Path.equals(e3.path, t2.path))), mr$5 = (e3, t2) => "set_selection" !== e3.type || null != e3.properties && null != e3.newProperties, br$5 = (e3, t2) => !(!t2 || "set_selection" !== e3.type || "set_selection" !== t2.type), wr$5 = (e3) => "set_selection" !== e3.type, xr$5 = ae$6.String, Sr$5 = function(e3) {
  if ("Symbol" === Jt$6(e3))
    throw TypeError("Cannot convert a Symbol value to a string");
  return xr$5(e3);
}, kr$5 = function() {
  var e3 = Ze$6(this), t2 = "";
  return e3.global && (t2 += "g"), e3.ignoreCase && (t2 += "i"), e3.multiline && (t2 += "m"), e3.dotAll && (t2 += "s"), e3.unicode && (t2 += "u"), e3.sticky && (t2 += "y"), t2;
}, Er$5 = Wt$6.PROPER, Or$5 = RegExp.prototype, Cr$5 = Or$5.toString, Nr$5 = ge$6(kr$5), Tr$5 = Ae$6(function() {
  return "/a/b" != Cr$5.call({ source: "a", flags: "b" });
}), Lr$5 = Er$5 && "toString" != Cr$5.name;
(Tr$5 || Lr$5) && Vt$6(RegExp.prototype, "toString", function() {
  var e3 = Ze$6(this), t2 = Sr$5(e3.source), n2 = e3.flags;
  return "/" + t2 + "/" + Sr$5(void 0 === n2 && nt$6(Or$5, e3) && !("flags" in Or$5) ? Nr$5(e3) : n2);
}, { unsafe: true });
var Mr$5, Pr$5 = Ue$6 ? Object.defineProperties : function(e3, t2) {
  Ze$6(e3);
  for (var n2, r2 = In$6(t2), o2 = cr$5(t2), i2 = o2.length, a2 = 0; i2 > a2; )
    yt$6.f(e3, n2 = o2[a2++], r2[n2]);
  return e3;
}, Dr$5 = Te$6("document", "documentElement"), Rr$5 = Tt$6("IE_PROTO"), jr$5 = function() {
}, Ar$5 = function(e3) {
  return "<script>" + e3 + "<\/script>";
}, Fr$5 = function(e3) {
  e3.write(Ar$5("")), e3.close();
  var t2 = e3.parentWindow.Object;
  return e3 = null, t2;
}, Ir$5 = function() {
  try {
    Mr$5 = new ActiveXObject("htmlfile");
  } catch (e4) {
  }
  var e3, t2;
  Ir$5 = "undefined" != typeof document ? document.domain && Mr$5 ? Fr$5(Mr$5) : ((t2 = Je$6("iframe")).style.display = "none", Dr$5.appendChild(t2), t2.src = String("javascript:"), (e3 = t2.contentWindow.document).open(), e3.write(Ar$5("document.F=Object")), e3.close(), e3.F) : Fr$5(Mr$5);
  for (var n2 = Gn$6.length; n2--; )
    delete Ir$5.prototype[Gn$6[n2]];
  return Ir$5();
};
Lt$6[Rr$5] = true;
var _r$5 = Object.create || function(e3, t2) {
  var n2;
  return null !== e3 ? (jr$5.prototype = Ze$6(e3), n2 = new jr$5(), jr$5.prototype = null, n2[Rr$5] = e3) : n2 = Ir$5(), void 0 === t2 ? n2 : Pr$5(n2, t2);
}, Br$5 = Ve$6("unscopables"), $r$5 = Array.prototype;
null == $r$5[Br$5] && yt$6.f($r$5, Br$5, { configurable: true, value: _r$5(null) });
var Wr$5 = function(e3) {
  $r$5[Br$5][e3] = true;
}, Vr$5 = Hn$6.includes;
ur$5({ target: "Array", proto: true }, { includes: function(e3) {
  return Vr$5(this, e3, arguments.length > 1 ? arguments[1] : void 0);
} }), Wr$5("includes");
var zr$5 = Ve$6("match"), Hr$5 = function(e3) {
  var t2;
  return Ke$6(e3) && (void 0 !== (t2 = e3[zr$5]) ? !!t2 : "RegExp" == Ut$6(e3));
}, Ur$5 = ae$6.TypeError, Kr$5 = function(e3) {
  if (Hr$5(e3))
    throw Ur$5("The method doesn't accept regular expressions");
  return e3;
}, qr$5 = Ve$6("match"), Gr$5 = function(e3) {
  var t2 = /./;
  try {
    "/./"[e3](t2);
  } catch (n2) {
    try {
      return t2[qr$5] = false, "/./"[e3](t2);
    } catch (e4) {
    }
  }
  return false;
}, Jr$5 = ge$6("".indexOf);
ur$5({ target: "String", proto: true, forced: !Gr$5("includes") }, { includes: function(e3) {
  return !!~Jr$5(Sr$5(ye$6(this)), Sr$5(Kr$5(e3)), arguments.length > 1 ? arguments[1] : void 0);
} });
var Yr$5, Xr$5 = /"/g, Qr$5 = ge$6("".replace);
ur$5({ target: "String", proto: true, forced: (Yr$5 = "anchor", Ae$6(function() {
  var e3 = ""[Yr$5]('"');
  return e3 !== e3.toLowerCase() || e3.split('"').length > 3;
})) }, { anchor: function(e3) {
  return t2 = "a", n2 = "name", r2 = e3, o2 = Sr$5(ye$6(this)), i2 = "<" + t2, "" !== n2 && (i2 += " " + n2 + '="' + Qr$5(Sr$5(r2), Xr$5, "&quot;") + '"'), i2 + ">" + o2 + "</" + t2 + ">";
  var t2, n2, r2, o2, i2;
} });
var Zr$5 = function(e3, t2, n2) {
  var r2, o2;
  Ze$6(e3);
  try {
    if (!(r2 = ut$6(e3, "return"))) {
      if ("throw" === t2)
        throw n2;
      return n2;
    }
    r2 = tt$6(r2, e3);
  } catch (e4) {
    o2 = true, r2 = e4;
  }
  if ("throw" === t2)
    throw n2;
  if (o2)
    throw r2;
  return Ze$6(r2), n2;
}, eo$5 = function(e3, t2, n2, r2) {
  try {
    return r2 ? t2(Ze$6(n2)[0], n2[1]) : t2(n2);
  } catch (t3) {
    Zr$5(e3, "throw", t3);
  }
}, to$5 = {}, no$5 = Ve$6("iterator"), ro$5 = Array.prototype, oo$4 = function(e3) {
  return void 0 !== e3 && (to$5.Array === e3 || ro$5[no$5] === e3);
}, io$4 = function(e3, t2, n2) {
  var r2 = pt$6(t2);
  r2 in e3 ? yt$6.f(e3, r2, mt$6(0, n2)) : e3[r2] = n2;
}, ao$4 = Ve$6("iterator"), so$4 = function(e3) {
  if (null != e3)
    return ut$6(e3, ao$4) || ut$6(e3, "@@iterator") || to$5[Jt$6(e3)];
}, lo$4 = ae$6.TypeError, uo$4 = function(e3, t2) {
  var n2 = arguments.length < 2 ? so$4(e3) : t2;
  if (lt$6(n2))
    return Ze$6(tt$6(n2, e3));
  throw lo$4(at$6(e3) + " is not iterable");
}, co$4 = ae$6.Array, fo$4 = Ve$6("iterator"), ho$4 = false;
try {
  var po$4 = 0, go$4 = { next: function() {
    return { done: !!po$4++ };
  }, return: function() {
    ho$4 = true;
  } };
  go$4[fo$4] = function() {
    return this;
  }, Array.from(go$4, function() {
    throw 2;
  });
} catch (e3) {
}
var vo$4 = function(e3, t2) {
  if (!t2 && !ho$4)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[fo$4] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, e3(r2);
  } catch (e4) {
  }
  return n2;
}, yo$4 = !vo$4(function(e3) {
  Array.from(e3);
});
ur$5({ target: "Array", stat: true, forced: yo$4 }, { from: function(e3) {
  var t2 = be$6(e3), n2 = xn$6(this), r2 = arguments.length, o2 = r2 > 1 ? arguments[1] : void 0, i2 = void 0 !== o2;
  i2 && (o2 = nn$6(o2, r2 > 2 ? arguments[2] : void 0));
  var a2, s2, l2, u2, c2, f2, d3 = so$4(t2), h2 = 0;
  if (!d3 || this == co$4 && oo$4(d3))
    for (a2 = dn$6(t2), s2 = n2 ? new this(a2) : co$4(a2); a2 > h2; h2++)
      f2 = i2 ? o2(t2[h2], h2) : t2[h2], io$4(s2, h2, f2);
  else
    for (c2 = (u2 = uo$4(t2, d3)).next, s2 = n2 ? new this() : []; !(l2 = tt$6(c2, u2)).done; h2++)
      f2 = i2 ? eo$5(u2, o2, [l2.value, h2], true) : l2.value, io$4(s2, h2, f2);
  return s2.length = h2, s2;
} });
var mo$4, bo$4, wo$4, xo$4 = ge$6("".charAt), So$4 = ge$6("".charCodeAt), ko$4 = ge$6("".slice), Eo$4 = function(e3) {
  return function(t2, n2) {
    var r2, o2, i2 = Sr$5(ye$6(t2)), a2 = un$6(n2), s2 = i2.length;
    return a2 < 0 || a2 >= s2 ? e3 ? "" : void 0 : (r2 = So$4(i2, a2)) < 55296 || r2 > 56319 || a2 + 1 === s2 || (o2 = So$4(i2, a2 + 1)) < 56320 || o2 > 57343 ? e3 ? xo$4(i2, a2) : r2 : e3 ? ko$4(i2, a2, a2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Oo$4 = { codeAt: Eo$4(false), charAt: Eo$4(true) }, Co$4 = !Ae$6(function() {
  function e3() {
  }
  return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
}), No$4 = Tt$6("IE_PROTO"), To$4 = ae$6.Object, Lo$4 = To$4.prototype, Mo$4 = Co$4 ? To$4.getPrototypeOf : function(e3) {
  var t2 = be$6(e3);
  if (xe$6(t2, No$4))
    return t2[No$4];
  var n2 = t2.constructor;
  return Ce$6(n2) && t2 instanceof n2 ? n2.prototype : t2 instanceof To$4 ? Lo$4 : null;
}, Po$4 = Ve$6("iterator"), Do$4 = false;
[].keys && ("next" in (wo$4 = [].keys()) ? (bo$4 = Mo$4(Mo$4(wo$4))) !== Object.prototype && (mo$4 = bo$4) : Do$4 = true);
var Ro$4 = null == mo$4 || Ae$6(function() {
  var e3 = {};
  return mo$4[Po$4].call(e3) !== e3;
});
Ro$4 && (mo$4 = {}), Ce$6(mo$4[Po$4]) || Vt$6(mo$4, Po$4, function() {
  return this;
});
var jo$4 = { IteratorPrototype: mo$4, BUGGY_SAFARI_ITERATORS: Do$4 }, Ao$4 = yt$6.f, Fo$4 = Ve$6("toStringTag"), Io$4 = function(e3, t2, n2) {
  e3 && !xe$6(e3 = n2 ? e3 : e3.prototype, Fo$4) && Ao$4(e3, Fo$4, { configurable: true, value: t2 });
}, _o$4 = jo$4.IteratorPrototype, Bo$4 = function() {
  return this;
}, $o$4 = ae$6.String, Wo$4 = ae$6.TypeError, Vo$4 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var e3, t2 = false, n2 = {};
  try {
    (e3 = ge$6(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n2, []), t2 = n2 instanceof Array;
  } catch (e4) {
  }
  return function(n3, r2) {
    return Ze$6(n3), function(e4) {
      if ("object" == typeof e4 || Ce$6(e4))
        return e4;
      throw Wo$4("Can't set " + $o$4(e4) + " as a prototype");
    }(r2), t2 ? e3(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), zo$4 = Wt$6.PROPER, Ho$4 = Wt$6.CONFIGURABLE, Uo$4 = jo$4.IteratorPrototype, Ko$4 = jo$4.BUGGY_SAFARI_ITERATORS, qo$4 = Ve$6("iterator"), Go$4 = function() {
  return this;
}, Jo$4 = function(e3, t2, n2, r2, o2, i2, a2) {
  !function(e4, t3, n3, r3) {
    var o3 = t3 + " Iterator";
    e4.prototype = _r$5(_o$4, { next: mt$6(+!r3, n3) }), Io$4(e4, o3, false), to$5[o3] = Bo$4;
  }(n2, t2, r2);
  var s2, l2, u2, c2 = function(e4) {
    if (e4 === o2 && g2)
      return g2;
    if (!Ko$4 && e4 in h2)
      return h2[e4];
    switch (e4) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, e4);
        };
    }
    return function() {
      return new n2(this);
    };
  }, f2 = t2 + " Iterator", d3 = false, h2 = e3.prototype, p2 = h2[qo$4] || h2["@@iterator"] || o2 && h2[o2], g2 = !Ko$4 && p2 || c2(o2), v2 = "Array" == t2 && h2.entries || p2;
  if (v2 && (s2 = Mo$4(v2.call(new e3()))) !== Object.prototype && s2.next && (Mo$4(s2) !== Uo$4 && (Vo$4 ? Vo$4(s2, Uo$4) : Ce$6(s2[qo$4]) || Vt$6(s2, qo$4, Go$4)), Io$4(s2, f2, true)), zo$4 && "values" == o2 && p2 && "values" !== p2.name && (Ho$4 ? bt$6(h2, "name", "values") : (d3 = true, g2 = function() {
    return tt$6(p2, this);
  })), o2)
    if (l2 = { values: c2("values"), keys: i2 ? g2 : c2("keys"), entries: c2("entries") }, a2)
      for (u2 in l2)
        (Ko$4 || d3 || !(u2 in h2)) && Vt$6(h2, u2, l2[u2]);
    else
      ur$5({ target: t2, proto: true, forced: Ko$4 || d3 }, l2);
  return h2[qo$4] !== g2 && Vt$6(h2, qo$4, g2, { name: o2 }), to$5[t2] = g2, l2;
}, Yo$4 = Oo$4.charAt, Xo$4 = It$6.set, Qo$4 = It$6.getterFor("String Iterator");
Jo$4(String, "String", function(e3) {
  Xo$4(this, { type: "String Iterator", string: Sr$5(e3), index: 0 });
}, function() {
  var e3, t2 = Qo$4(this), n2 = t2.string, r2 = t2.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (e3 = Yo$4(n2, r2), t2.index += e3.length, { value: e3, done: false });
});
var Zo$4, ei$4 = Bn$6.f, ti$4 = ge$6("".endsWith), ni$4 = ge$6("".slice), ri$4 = Math.min, oi$4 = Gr$5("endsWith"), ii$4 = !(oi$4 || (Zo$4 = ei$4(String.prototype, "endsWith"), !Zo$4 || Zo$4.writable));
ur$5({ target: "String", proto: true, forced: !ii$4 && !oi$4 }, { endsWith: function(e3) {
  var t2 = Sr$5(ye$6(this));
  Kr$5(e3);
  var n2 = arguments.length > 1 ? arguments[1] : void 0, r2 = t2.length, o2 = void 0 === n2 ? r2 : ri$4(fn$6(n2), r2), i2 = Sr$5(e3);
  return ti$4 ? ti$4(t2, i2, o2) : ni$4(t2, o2 - i2.length, o2) === i2;
} });
var ai$4 = ge$6([].join), si$4 = an$6 != Object, li$4 = Tn$6("join", ",");
ur$5({ target: "Array", proto: true, forced: si$4 || !li$4 }, { join: function(e3) {
  return ai$4(In$6(this), void 0 === e3 ? "," : e3);
} });
var ui$4 = Ve$6("species"), ci$4 = function(e3) {
  return je$6 >= 51 || !Ae$6(function() {
    var t2 = [];
    return (t2.constructor = {})[ui$4] = function() {
      return { foo: 1 };
    }, 1 !== t2[e3](Boolean).foo;
  });
}, fi$4 = Nn$6.map, di$4 = ci$4("map");
ur$5({ target: "Array", proto: true, forced: !di$4 }, { map: function(e3) {
  return fi$4(this, e3, arguments.length > 1 ? arguments[1] : void 0);
} });
var hi$4 = ae$6.RegExp, pi$4 = Ae$6(function() {
  var e3 = hi$4("a", "y");
  return e3.lastIndex = 2, null != e3.exec("abcd");
}), gi$4 = pi$4 || Ae$6(function() {
  return !hi$4("a", "y").sticky;
}), vi$4 = { BROKEN_CARET: pi$4 || Ae$6(function() {
  var e3 = hi$4("^r", "gy");
  return e3.lastIndex = 2, null != e3.exec("str");
}), MISSED_STICKY: gi$4, UNSUPPORTED_Y: pi$4 }, yi$4 = ae$6.RegExp, mi$3 = Ae$6(function() {
  var e3 = yi$4(".", "s");
  return !(e3.dotAll && e3.exec("\n") && "s" === e3.flags);
}), bi$3 = ae$6.RegExp, wi$3 = Ae$6(function() {
  var e3 = bi$3("(?<a>b)", "g");
  return "b" !== e3.exec("b").groups.a || "bc" !== "b".replace(e3, "$<a>c");
}), xi$3 = It$6.get, Si$3 = ce$6("native-string-replace", String.prototype.replace), ki$3 = RegExp.prototype.exec, Ei$3 = ki$3, Oi$3 = ge$6("".charAt), Ci$3 = ge$6("".indexOf), Ni$3 = ge$6("".replace), Ti$3 = ge$6("".slice), Li$3 = function() {
  var e3 = /a/, t2 = /b*/g;
  return tt$6(ki$3, e3, "a"), tt$6(ki$3, t2, "a"), 0 !== e3.lastIndex || 0 !== t2.lastIndex;
}(), Mi$3 = vi$4.BROKEN_CARET, Pi$3 = void 0 !== /()??/.exec("")[1];
(Li$3 || Pi$3 || Mi$3 || mi$3 || wi$3) && (Ei$3 = function(e3) {
  var t2, n2, r2, o2, i2, a2, s2, l2 = this, u2 = xi$3(l2), c2 = Sr$5(e3), f2 = u2.raw;
  if (f2)
    return f2.lastIndex = l2.lastIndex, t2 = tt$6(Ei$3, f2, c2), l2.lastIndex = f2.lastIndex, t2;
  var d3 = u2.groups, h2 = Mi$3 && l2.sticky, p2 = tt$6(kr$5, l2), g2 = l2.source, v2 = 0, y2 = c2;
  if (h2 && (p2 = Ni$3(p2, "y", ""), -1 === Ci$3(p2, "g") && (p2 += "g"), y2 = Ti$3(c2, l2.lastIndex), l2.lastIndex > 0 && (!l2.multiline || l2.multiline && "\n" !== Oi$3(c2, l2.lastIndex - 1)) && (g2 = "(?: " + g2 + ")", y2 = " " + y2, v2++), n2 = new RegExp("^(?:" + g2 + ")", p2)), Pi$3 && (n2 = new RegExp("^" + g2 + "$(?!\\s)", p2)), Li$3 && (r2 = l2.lastIndex), o2 = tt$6(ki$3, h2 ? n2 : l2, y2), h2 ? o2 ? (o2.input = Ti$3(o2.input, v2), o2[0] = Ti$3(o2[0], v2), o2.index = l2.lastIndex, l2.lastIndex += o2[0].length) : l2.lastIndex = 0 : Li$3 && o2 && (l2.lastIndex = l2.global ? o2.index + o2[0].length : r2), Pi$3 && o2 && o2.length > 1 && tt$6(Si$3, o2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && d3)
    for (o2.groups = a2 = _r$5(null), i2 = 0; i2 < d3.length; i2++)
      a2[(s2 = d3[i2])[0]] = o2[s2[1]];
  return o2;
});
var Di$3 = Ei$3;
ur$5({ target: "RegExp", proto: true, forced: /./.exec !== Di$3 }, { exec: Di$3 });
var Ri$3 = Function.prototype, ji$3 = Ri$3.apply, Ai$3 = Ri$3.bind, Fi$3 = Ri$3.call, Ii$3 = "object" == typeof Reflect && Reflect.apply || (Ai$3 ? Fi$3.bind(ji$3) : function() {
  return Fi$3.apply(ji$3, arguments);
}), _i$3 = Ve$6("species"), Bi$3 = RegExp.prototype, $i$3 = function(e3, t2, n2, r2) {
  var o2 = Ve$6(e3), i2 = !Ae$6(function() {
    var t3 = {};
    return t3[o2] = function() {
      return 7;
    }, 7 != ""[e3](t3);
  }), a2 = i2 && !Ae$6(function() {
    var t3 = false, n3 = /a/;
    return "split" === e3 && ((n3 = {}).constructor = {}, n3.constructor[_i$3] = function() {
      return n3;
    }, n3.flags = "", n3[o2] = /./[o2]), n3.exec = function() {
      return t3 = true, null;
    }, n3[o2](""), !t3;
  });
  if (!i2 || !a2 || n2) {
    var s2 = ge$6(/./[o2]), l2 = t2(o2, ""[e3], function(e4, t3, n3, r3, o3) {
      var a3 = ge$6(e4), l3 = t3.exec;
      return l3 === Di$3 || l3 === Bi$3.exec ? i2 && !o3 ? { done: true, value: s2(t3, n3, r3) } : { done: true, value: a3(n3, t3, r3) } : { done: false };
    });
    Vt$6(String.prototype, e3, l2[0]), Vt$6(Bi$3, o2, l2[1]);
  }
  r2 && bt$6(Bi$3[o2], "sham", true);
}, Wi$3 = Oo$4.charAt, Vi$3 = function(e3, t2, n2) {
  return t2 + (n2 ? Wi$3(e3, t2).length : 1);
}, zi$3 = Math.floor, Hi$3 = ge$6("".charAt), Ui$3 = ge$6("".replace), Ki$3 = ge$6("".slice), qi$3 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Gi$3 = /\$([$&'`]|\d{1,2})/g, Ji$3 = function(e3, t2, n2, r2, o2, i2) {
  var a2 = n2 + e3.length, s2 = r2.length, l2 = Gi$3;
  return void 0 !== o2 && (o2 = be$6(o2), l2 = qi$3), Ui$3(i2, l2, function(i3, l3) {
    var u2;
    switch (Hi$3(l3, 0)) {
      case "$":
        return "$";
      case "&":
        return e3;
      case "`":
        return Ki$3(t2, 0, n2);
      case "'":
        return Ki$3(t2, a2);
      case "<":
        u2 = o2[Ki$3(l3, 1, -1)];
        break;
      default:
        var c2 = +l3;
        if (0 === c2)
          return i3;
        if (c2 > s2) {
          var f2 = zi$3(c2 / 10);
          return 0 === f2 ? i3 : f2 <= s2 ? void 0 === r2[f2 - 1] ? Hi$3(l3, 1) : r2[f2 - 1] + Hi$3(l3, 1) : i3;
        }
        u2 = r2[c2 - 1];
    }
    return void 0 === u2 ? "" : u2;
  });
}, Yi$3 = ae$6.TypeError, Xi$3 = function(e3, t2) {
  var n2 = e3.exec;
  if (Ce$6(n2)) {
    var r2 = tt$6(n2, e3, t2);
    return null !== r2 && Ze$6(r2), r2;
  }
  if ("RegExp" === Ut$6(e3))
    return tt$6(Di$3, e3, t2);
  throw Yi$3("RegExp#exec called on incompatible receiver");
}, Qi$3 = Ve$6("replace"), Zi$3 = Math.max, ea$4 = Math.min, ta$4 = ge$6([].concat), na$4 = ge$6([].push), ra$4 = ge$6("".indexOf), oa$4 = ge$6("".slice), ia$4 = "$0" === "a".replace(/./, "$0"), aa$4 = !!/./[Qi$3] && "" === /./[Qi$3]("a", "$0");
$i$3("replace", function(e3, t2, n2) {
  var r2 = aa$4 ? "$" : "$0";
  return [function(e4, n3) {
    var r3 = ye$6(this), o2 = null == e4 ? void 0 : ut$6(e4, Qi$3);
    return o2 ? tt$6(o2, e4, r3, n3) : tt$6(t2, Sr$5(r3), e4, n3);
  }, function(e4, o2) {
    var i2 = Ze$6(this), a2 = Sr$5(e4);
    if ("string" == typeof o2 && -1 === ra$4(o2, r2) && -1 === ra$4(o2, "$<")) {
      var s2 = n2(t2, i2, a2, o2);
      if (s2.done)
        return s2.value;
    }
    var l2 = Ce$6(o2);
    l2 || (o2 = Sr$5(o2));
    var u2 = i2.global;
    if (u2) {
      var c2 = i2.unicode;
      i2.lastIndex = 0;
    }
    for (var f2 = []; ; ) {
      var d3 = Xi$3(i2, a2);
      if (null === d3)
        break;
      if (na$4(f2, d3), !u2)
        break;
      "" === Sr$5(d3[0]) && (i2.lastIndex = Vi$3(a2, fn$6(i2.lastIndex), c2));
    }
    for (var h2, p2 = "", g2 = 0, v2 = 0; v2 < f2.length; v2++) {
      for (var y2 = Sr$5((d3 = f2[v2])[0]), m2 = Zi$3(ea$4(un$6(d3.index), a2.length), 0), b2 = [], w2 = 1; w2 < d3.length; w2++)
        na$4(b2, void 0 === (h2 = d3[w2]) ? h2 : String(h2));
      var x2 = d3.groups;
      if (l2) {
        var S2 = ta$4([y2], b2, m2, a2);
        void 0 !== x2 && na$4(S2, x2);
        var k2 = Sr$5(Ii$3(o2, void 0, S2));
      } else
        k2 = Ji$3(y2, a2, m2, b2, x2, o2);
      m2 >= g2 && (p2 += oa$4(a2, g2, m2) + k2, g2 = m2 + y2.length);
    }
    return p2 + oa$4(a2, g2);
  }];
}, !!Ae$6(function() {
  var e3 = /./;
  return e3.exec = function() {
    var e4 = [];
    return e4.groups = { a: "7" }, e4;
  }, "7" !== "".replace(e3, "$<a>");
}) || !ia$4 || aa$4);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var sa$4 = function(e3, t2) {
  return sa$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t3) {
    e4.__proto__ = t3;
  } || function(e4, t3) {
    for (var n2 in t3)
      Object.prototype.hasOwnProperty.call(t3, n2) && (e4[n2] = t3[n2]);
  }, sa$4(e3, t2);
};
function la$4(e3, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
  function n2() {
    this.constructor = e3;
  }
  sa$4(e3, t2), e3.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
}
var ua$4 = function() {
  return ua$4 = Object.assign || function(e3) {
    for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, o2) && (e3[o2] = t2[o2]);
    return e3;
  }, ua$4.apply(this, arguments);
};
function ca$4(e3) {
  var t2 = "function" == typeof Symbol && Symbol.iterator, n2 = t2 && e3[t2], r2 = 0;
  if (n2)
    return n2.call(e3);
  if (e3 && "number" == typeof e3.length)
    return { next: function() {
      return e3 && r2 >= e3.length && (e3 = void 0), { value: e3 && e3[r2++], done: !e3 };
    } };
  throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function fa$4(e3, t2) {
  var n2 = "function" == typeof Symbol && e3[Symbol.iterator];
  if (!n2)
    return e3;
  var r2, o2, i2 = n2.call(e3), a2 = [];
  try {
    for (; (void 0 === t2 || t2-- > 0) && !(r2 = i2.next()).done; )
      a2.push(r2.value);
  } catch (e4) {
    o2 = { error: e4 };
  } finally {
    try {
      r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return a2;
}
function da$4(e3, t2) {
  for (var n2 = 0, r2 = t2.length, o2 = e3.length; n2 < r2; n2++, o2++)
    e3[o2] = t2[n2];
  return e3;
}
var ha$3 = 0, pa$4 = function() {
  this.id = "" + ha$3++;
}, ga$3 = It$6.set, va$4 = It$6.getterFor("Array Iterator"), ya$3 = Jo$4(Array, "Array", function(e3, t2) {
  ga$3(this, { type: "Array Iterator", target: In$6(e3), index: 0, kind: t2 });
}, function() {
  var e3 = va$4(this), t2 = e3.target, n2 = e3.kind, r2 = e3.index++;
  return !t2 || r2 >= t2.length ? (e3.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: t2[r2], done: false } : { value: [r2, t2[r2]], done: false };
}, "values");
to$5.Arguments = to$5.Array, Wr$5("keys"), Wr$5("values"), Wr$5("entries");
var ma$3 = function(e3, t2, n2) {
  for (var r2 in t2)
    Vt$6(e3, r2, t2[r2], n2);
  return e3;
}, ba$3 = ae$6.Array, wa$3 = Math.max, xa$3 = function(e3, t2, n2) {
  for (var r2 = dn$6(e3), o2 = Vn$6(t2, r2), i2 = Vn$6(void 0 === n2 ? r2 : n2, r2), a2 = ba$3(wa$3(i2 - o2, 0)), s2 = 0; o2 < i2; o2++, s2++)
    io$4(a2, s2, e3[o2]);
  return a2.length = s2, a2;
}, Sa$3 = Yn$6.f, ka$3 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Ea$3 = { f: function(e3) {
  return ka$3 && "Window" == Ut$6(e3) ? function(e4) {
    try {
      return Sa$3(e4);
    } catch (e5) {
      return xa$3(ka$3);
    }
  }(e3) : Sa$3(In$6(e3));
} }, Oa$3 = Ae$6(function() {
  if ("function" == typeof ArrayBuffer) {
    var e3 = new ArrayBuffer(8);
    Object.isExtensible(e3) && Object.defineProperty(e3, "a", { value: 8 });
  }
}), Ca$3 = Object.isExtensible, Na$3 = Ae$6(function() {
  Ca$3(1);
}) || Oa$3 ? function(e3) {
  return !!Ke$6(e3) && ((!Oa$3 || "ArrayBuffer" != Ut$6(e3)) && (!Ca$3 || Ca$3(e3)));
} : Ca$3, Ta$3 = !Ae$6(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), La$3 = ne$6(function(e3) {
  var t2 = yt$6.f, n2 = false, r2 = Oe$6("meta"), o2 = 0, i2 = function(e4) {
    t2(e4, r2, { value: { objectID: "O" + o2++, weakData: {} } });
  }, a2 = e3.exports = { enable: function() {
    a2.enable = function() {
    }, n2 = true;
    var e4 = Yn$6.f, t3 = ge$6([].splice), o3 = {};
    o3[r2] = 1, e4(o3).length && (Yn$6.f = function(n3) {
      for (var o4 = e4(n3), i3 = 0, a3 = o4.length; i3 < a3; i3++)
        if (o4[i3] === r2) {
          t3(o4, i3, 1);
          break;
        }
      return o4;
    }, ur$5({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: Ea$3.f }));
  }, fastKey: function(e4, t3) {
    if (!Ke$6(e4))
      return "symbol" == typeof e4 ? e4 : ("string" == typeof e4 ? "S" : "P") + e4;
    if (!xe$6(e4, r2)) {
      if (!Na$3(e4))
        return "F";
      if (!t3)
        return "E";
      i2(e4);
    }
    return e4[r2].objectID;
  }, getWeakData: function(e4, t3) {
    if (!xe$6(e4, r2)) {
      if (!Na$3(e4))
        return true;
      if (!t3)
        return false;
      i2(e4);
    }
    return e4[r2].weakData;
  }, onFreeze: function(e4) {
    return Ta$3 && n2 && Na$3(e4) && !xe$6(e4, r2) && i2(e4), e4;
  } };
  Lt$6[r2] = true;
}), Ma$3 = ae$6.TypeError, Pa$3 = function(e3, t2) {
  this.stopped = e3, this.result = t2;
}, Da$3 = Pa$3.prototype, Ra$3 = function(e3, t2, n2) {
  var r2, o2, i2, a2, s2, l2, u2, c2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d3 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), p2 = nn$6(t2, c2), g2 = function(e4) {
    return r2 && Zr$5(r2, "normal", e4), new Pa$3(true, e4);
  }, v2 = function(e4) {
    return f2 ? (Ze$6(e4), h2 ? p2(e4[0], e4[1], g2) : p2(e4[0], e4[1])) : h2 ? p2(e4, g2) : p2(e4);
  };
  if (d3)
    r2 = e3;
  else {
    if (!(o2 = so$4(e3)))
      throw Ma$3(at$6(e3) + " is not iterable");
    if (oo$4(o2)) {
      for (i2 = 0, a2 = dn$6(e3); a2 > i2; i2++)
        if ((s2 = v2(e3[i2])) && nt$6(Da$3, s2))
          return s2;
      return new Pa$3(false);
    }
    r2 = uo$4(e3, o2);
  }
  for (l2 = r2.next; !(u2 = tt$6(l2, r2)).done; ) {
    try {
      s2 = v2(u2.value);
    } catch (e4) {
      Zr$5(r2, "throw", e4);
    }
    if ("object" == typeof s2 && s2 && nt$6(Da$3, s2))
      return s2;
  }
  return new Pa$3(false);
}, ja$2 = ae$6.TypeError, Aa$3 = function(e3, t2) {
  if (nt$6(t2, e3))
    return e3;
  throw ja$2("Incorrect invocation");
}, Fa$3 = function(e3, t2, n2) {
  var r2, o2;
  return Vo$4 && Ce$6(r2 = t2.constructor) && r2 !== n2 && Ke$6(o2 = r2.prototype) && o2 !== n2.prototype && Vo$4(e3, o2), e3;
}, Ia$3 = function(e3, t2, n2) {
  var r2 = -1 !== e3.indexOf("Map"), o2 = -1 !== e3.indexOf("Weak"), i2 = r2 ? "set" : "add", a2 = ae$6[e3], s2 = a2 && a2.prototype, l2 = a2, u2 = {}, c2 = function(e4) {
    var t3 = ge$6(s2[e4]);
    Vt$6(s2, e4, "add" == e4 ? function(e5) {
      return t3(this, 0 === e5 ? 0 : e5), this;
    } : "delete" == e4 ? function(e5) {
      return !(o2 && !Ke$6(e5)) && t3(this, 0 === e5 ? 0 : e5);
    } : "get" == e4 ? function(e5) {
      return o2 && !Ke$6(e5) ? void 0 : t3(this, 0 === e5 ? 0 : e5);
    } : "has" == e4 ? function(e5) {
      return !(o2 && !Ke$6(e5)) && t3(this, 0 === e5 ? 0 : e5);
    } : function(e5, n3) {
      return t3(this, 0 === e5 ? 0 : e5, n3), this;
    });
  };
  if (sr$5(e3, !Ce$6(a2) || !(o2 || s2.forEach && !Ae$6(function() {
    new a2().entries().next();
  }))))
    l2 = n2.getConstructor(t2, e3, r2, i2), La$3.enable();
  else if (sr$5(e3, true)) {
    var f2 = new l2(), d3 = f2[i2](o2 ? {} : -0, 1) != f2, h2 = Ae$6(function() {
      f2.has(1);
    }), p2 = vo$4(function(e4) {
      new a2(e4);
    }), g2 = !o2 && Ae$6(function() {
      for (var e4 = new a2(), t3 = 5; t3--; )
        e4[i2](t3, t3);
      return !e4.has(-0);
    });
    p2 || ((l2 = t2(function(e4, t3) {
      Aa$3(e4, s2);
      var n3 = Fa$3(new a2(), e4, l2);
      return null != t3 && Ra$3(t3, n3[i2], { that: n3, AS_ENTRIES: r2 }), n3;
    })).prototype = s2, s2.constructor = l2), (h2 || g2) && (c2("delete"), c2("has"), r2 && c2("get")), (g2 || d3) && c2(i2), o2 && s2.clear && delete s2.clear;
  }
  return u2[e3] = l2, ur$5({ global: true, forced: l2 != a2 }, u2), Io$4(l2, e3), o2 || n2.setStrong(l2, e3, r2), l2;
}, _a$3 = La$3.getWeakData, Ba$3 = It$6.set, $a$3 = It$6.getterFor, Wa$2 = Nn$6.find, Va$2 = Nn$6.findIndex, za$2 = ge$6([].splice), Ha$2 = 0, Ua$3 = function(e3) {
  return e3.frozen || (e3.frozen = new Ka$2());
}, Ka$2 = function() {
  this.entries = [];
}, qa$2 = function(e3, t2) {
  return Wa$2(e3.entries, function(e4) {
    return e4[0] === t2;
  });
};
Ka$2.prototype = { get: function(e3) {
  var t2 = qa$2(this, e3);
  if (t2)
    return t2[1];
}, has: function(e3) {
  return !!qa$2(this, e3);
}, set: function(e3, t2) {
  var n2 = qa$2(this, e3);
  n2 ? n2[1] = t2 : this.entries.push([e3, t2]);
}, delete: function(e3) {
  var t2 = Va$2(this.entries, function(t3) {
    return t3[0] === e3;
  });
  return ~t2 && za$2(this.entries, t2, 1), !!~t2;
} };
var Ga$2, Ja$2 = { getConstructor: function(e3, t2, n2, r2) {
  var o2 = e3(function(e4, o3) {
    Aa$3(e4, i2), Ba$3(e4, { type: t2, id: Ha$2++, frozen: void 0 }), null != o3 && Ra$3(o3, e4[r2], { that: e4, AS_ENTRIES: n2 });
  }), i2 = o2.prototype, a2 = $a$3(t2), s2 = function(e4, t3, n3) {
    var r3 = a2(e4), o3 = _a$3(Ze$6(t3), true);
    return true === o3 ? Ua$3(r3).set(t3, n3) : o3[r3.id] = n3, e4;
  };
  return ma$3(i2, { delete: function(e4) {
    var t3 = a2(this);
    if (!Ke$6(e4))
      return false;
    var n3 = _a$3(e4);
    return true === n3 ? Ua$3(t3).delete(e4) : n3 && xe$6(n3, t3.id) && delete n3[t3.id];
  }, has: function(e4) {
    var t3 = a2(this);
    if (!Ke$6(e4))
      return false;
    var n3 = _a$3(e4);
    return true === n3 ? Ua$3(t3).has(e4) : n3 && xe$6(n3, t3.id);
  } }), ma$3(i2, n2 ? { get: function(e4) {
    var t3 = a2(this);
    if (Ke$6(e4)) {
      var n3 = _a$3(e4);
      return true === n3 ? Ua$3(t3).get(e4) : n3 ? n3[t3.id] : void 0;
    }
  }, set: function(e4, t3) {
    return s2(this, e4, t3);
  } } : { add: function(e4) {
    return s2(this, e4, true);
  } }), o2;
} }, Ya$2 = It$6.enforce, Xa$2 = !ae$6.ActiveXObject && "ActiveXObject" in ae$6, Qa$2 = function(e3) {
  return function() {
    return e3(this, arguments.length ? arguments[0] : void 0);
  };
}, Za$1 = Ia$3("WeakMap", Qa$2, Ja$2);
if (Ct$6 && Xa$2) {
  Ga$2 = Ja$2.getConstructor(Qa$2, "WeakMap", true), La$3.enable();
  var es$1 = Za$1.prototype, ts$1 = ge$6(es$1.delete), ns$1 = ge$6(es$1.has), rs$1 = ge$6(es$1.get), os$1 = ge$6(es$1.set);
  ma$3(es$1, { delete: function(e3) {
    if (Ke$6(e3) && !Na$3(e3)) {
      var t2 = Ya$2(this);
      return t2.frozen || (t2.frozen = new Ga$2()), ts$1(this, e3) || t2.frozen.delete(e3);
    }
    return ts$1(this, e3);
  }, has: function(e3) {
    if (Ke$6(e3) && !Na$3(e3)) {
      var t2 = Ya$2(this);
      return t2.frozen || (t2.frozen = new Ga$2()), ns$1(this, e3) || t2.frozen.has(e3);
    }
    return ns$1(this, e3);
  }, get: function(e3) {
    if (Ke$6(e3) && !Na$3(e3)) {
      var t2 = Ya$2(this);
      return t2.frozen || (t2.frozen = new Ga$2()), ns$1(this, e3) ? rs$1(this, e3) : t2.frozen.get(e3);
    }
    return rs$1(this, e3);
  }, set: function(e3, t2) {
    if (Ke$6(e3) && !Na$3(e3)) {
      var n2 = Ya$2(this);
      n2.frozen || (n2.frozen = new Ga$2()), ns$1(this, e3) ? os$1(this, e3, t2) : n2.frozen.set(e3, t2);
    } else
      os$1(this, e3, t2);
    return this;
  } });
}
var is$1 = Ve$6("iterator"), as$1 = Ve$6("toStringTag"), ss$1 = ya$3.values, ls$1 = function(e3, t2) {
  if (e3) {
    if (e3[is$1] !== ss$1)
      try {
        bt$6(e3, is$1, ss$1);
      } catch (t3) {
        e3[is$1] = ss$1;
      }
    if (e3[as$1] || bt$6(e3, as$1, t2), Xt$6[t2]) {
      for (var n2 in ya$3)
        if (e3[n2] !== ya$3[n2])
          try {
            bt$6(e3, n2, ya$3[n2]);
          } catch (t3) {
            e3[n2] = ya$3[n2];
          }
    }
  }
};
for (var us$1 in Xt$6)
  ls$1(ae$6[us$1] && ae$6[us$1].prototype, us$1);
ls$1(en$6, "DOMTokenList");
var cs$1 = /* @__PURE__ */ new WeakMap(), fs$1 = /* @__PURE__ */ new WeakMap(), ds$1 = /* @__PURE__ */ new WeakMap(), hs$1 = /* @__PURE__ */ new WeakMap(), ps$1 = /* @__PURE__ */ new WeakMap(), gs$1 = /* @__PURE__ */ new WeakMap(), vs$1 = /* @__PURE__ */ new WeakMap(), ys$1 = /* @__PURE__ */ new WeakMap(), ms$1 = /* @__PURE__ */ new WeakMap(), bs$1 = /* @__PURE__ */ new WeakMap(), ws$1 = /* @__PURE__ */ new WeakMap(), xs$1 = /* @__PURE__ */ new WeakMap(), Ss$1 = /* @__PURE__ */ new WeakMap(), ks$1 = /* @__PURE__ */ new WeakMap(), Es$1 = /* @__PURE__ */ new WeakMap(), Os$1 = /* @__PURE__ */ new WeakMap(), Cs$1 = /* @__PURE__ */ new WeakMap(), Ns$1 = /* @__PURE__ */ new WeakMap(), Ts$1 = /* @__PURE__ */ new WeakMap(), Ls$1 = /* @__PURE__ */ new WeakMap(), Ms$1 = /* @__PURE__ */ new WeakMap(), Ps$1 = /* @__PURE__ */ new WeakMap(), Ds$1 = /* @__PURE__ */ new WeakMap(), Rs$1 = /* @__PURE__ */ new WeakMap(), js$1 = /* @__PURE__ */ new WeakMap(), As$1 = Nn$6.find, Fs$1 = true;
"find" in [] && Array(1).find(function() {
  Fs$1 = false;
}), ur$5({ target: "Array", proto: true, forced: Fs$1 }, { find: function(e3) {
  return As$1(this, e3, arguments.length > 1 ? arguments[1] : void 0);
} }), Wr$5("find"), ur$5({ global: true }, { globalThis: ae$6 });
const Is$1 = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"];
css && ($$6.fn.css = css), append && ($$6.fn.append = append), addClass && ($$6.fn.addClass = addClass), removeClass && ($$6.fn.removeClass = removeClass), hasClass && ($$6.fn.hasClass = hasClass), on$7 && ($$6.fn.on = on$7), focus$1 && ($$6.fn.focus = focus$1), attr && ($$6.fn.attr = attr), removeAttr && ($$6.fn.removeAttr = removeAttr), hide && ($$6.fn.hide = hide), show && ($$6.fn.show = show), offset && ($$6.fn.offset = offset), width && ($$6.fn.width = width), height && ($$6.fn.height = height), parent && ($$6.fn.parent = parent), parents && ($$6.fn.parents = parents), is$2 && ($$6.fn.is = is$2), dataset && ($$6.fn.dataset = dataset), val && ($$6.fn.val = val), text && ($$6.fn.text = text), html && ($$6.fn.html = html), children && ($$6.fn.children = children), remove && ($$6.fn.remove = remove), find && ($$6.fn.find = find), each && ($$6.fn.each = each), empty && ($$6.fn.empty = empty);
var _s$1, Bs$1 = function(e3) {
  return e3 && e3.ownerDocument && e3.ownerDocument.defaultView || null;
}, $s$1 = function(e3) {
  return Ws$1(e3) && 1 === e3.nodeType;
}, Ws$1 = function(e3) {
  var t2 = Bs$1(e3);
  return !!t2 && e3 instanceof t2.Node;
}, Vs$1 = function(e3) {
  var t2 = e3 && e3.anchorNode && Bs$1(e3.anchorNode);
  return !!t2 && e3 instanceof t2.Selection;
}, zs$1 = function(e3) {
  return Ws$1(e3) && 3 === e3.nodeType;
}, Hs$1 = function(e3) {
  var t2, n2, r2;
  return null !== (t2 = window.document.getElementById(e3)) && void 0 !== t2 ? t2 : (null === (r2 = null === (n2 = window.document.activeElement) || void 0 === n2 ? void 0 : n2.shadowRoot) || void 0 === r2 ? void 0 : r2.getElementById(e3)) || null;
}, Us$1 = function(e3, t2, n2) {
  for (var r2, o2 = e3.childNodes, i2 = o2[t2], a2 = t2, s2 = false, l2 = false; (Ws$1(r2 = i2) && 8 === r2.nodeType || $s$1(i2) && 0 === i2.childNodes.length || $s$1(i2) && "false" === i2.getAttribute("contenteditable")) && (!s2 || !l2); )
    a2 >= o2.length ? (s2 = true, a2 = t2 - 1, n2 = "backward") : a2 < 0 ? (l2 = true, a2 = t2 + 1, n2 = "forward") : (i2 = o2[a2], t2 = a2, a2 += "forward" === n2 ? 1 : -1);
  return [i2, t2];
}, Ks$1 = function(e3, t2, n2) {
  return fa$4(Us$1(e3, t2, n2), 1)[0];
}, qs$1 = function e2(t2) {
  var n2, r2, o2 = "";
  if (zs$1(t2) && t2.nodeValue)
    return t2.nodeValue;
  if ($s$1(t2)) {
    try {
      for (var i2 = ca$4(Array.from(t2.childNodes)), a2 = i2.next(); !a2.done; a2 = i2.next()) {
        o2 += e2(a2.value);
      }
    } catch (e3) {
      n2 = { error: e3 };
    } finally {
      try {
        a2 && !a2.done && (r2 = i2.return) && r2.call(i2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    var s2 = getComputedStyle(t2).getPropertyValue("display");
    "block" !== s2 && "list" !== s2 && "table-row" !== s2 && "BR" !== t2.tagName || (o2 += "\n");
  }
  return o2;
};
function Gs$1(e3, t2) {
  if (!(e3 instanceof HTMLElement && "true" === e3.dataset.slateVoid))
    for (var n2 = e3.childNodes, r2 = n2.length; r2--; ) {
      var o2 = n2[r2], i2 = o2.nodeType;
      3 == i2 ? t2(o2, e3) : 1 != i2 && 9 != i2 && 11 != i2 || Gs$1(o2, t2);
    }
}
function Js$1(e3) {
  if (0 === e3.length)
    return "";
  var t2 = e3[0];
  return t2.nodeType !== _s$1.ELEMENT_NODE ? "" : t2.tagName.toLowerCase();
}
!function(e3) {
  e3[e3.ELEMENT_NODE = 1] = "ELEMENT_NODE", e3[e3.TEXT_NODE = 3] = "TEXT_NODE", e3[e3.CDATA_SECTION_NODE = 4] = "CDATA_SECTION_NODE", e3[e3.PROCESSING_INSTRUCTION_NODE = 7] = "PROCESSING_INSTRUCTION_NODE", e3[e3.COMMENT_NODE = 8] = "COMMENT_NODE", e3[e3.DOCUMENT_NODE = 9] = "DOCUMENT_NODE", e3[e3.DOCUMENT_TYPE_NODE = 10] = "DOCUMENT_TYPE_NODE", e3[e3.DOCUMENT_FRAGMENT_NODE = 11] = "DOCUMENT_FRAGMENT_NODE";
}(_s$1 || (_s$1 = {})), void 0 !== globalThis.navigator && void 0 !== globalThis.window && /iPad|iPhone|iPod/.test(navigator.userAgent) && globalThis.window.MSStream;
var Ys$1 = "undefined" != typeof navigator && /Mac OS X/.test(navigator.userAgent), Xs$1 = "undefined" != typeof navigator && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
"undefined" != typeof navigator && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var Qs$1 = "undefined" != typeof navigator && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent), Zs$1 = "undefined" != typeof navigator && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), el$1 = "undefined" != typeof navigator && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), tl$1 = "undefined" != typeof navigator && /Chrome/i.test(navigator.userAgent);
"undefined" != typeof navigator && /.*QQBrowser/.test(navigator.userAgent);
var nl$1 = !el$1 && !Zs$1 && "undefined" != typeof globalThis && globalThis.InputEvent && "function" == typeof globalThis.InputEvent.prototype.getTargetRanges, rl$1 = { getWindow: function(e3) {
  var t2 = Ms$1.get(e3);
  if (!t2)
    throw new Error("Unable to find a host window element for this editor");
  return t2;
}, findKey: function(e3, t2) {
  var n2 = Ls$1.get(t2);
  return n2 || (n2 = new pa$4(), Ls$1.set(t2, n2)), n2;
}, setNewKey: function(e3) {
  var t2 = new pa$4();
  Ls$1.set(e3, t2);
}, findPath: function(t2, n2) {
  for (var r2 = [], o2 = n2; ; ) {
    var i2 = Es$1.get(o2);
    if (null == i2) {
      if (Editor$1.isEditor(o2))
        return r2;
      break;
    }
    var a2 = ks$1.get(o2);
    if (null == a2)
      break;
    r2.unshift(a2), o2 = i2;
  }
  throw new Error("Unable to find the path for Slate node: " + JSON.stringify(n2));
}, findDocumentOrShadowRoot: function(e3) {
  if (e3.isDestroyed)
    return window.document;
  var t2 = rl$1.toDOMNode(e3, e3), n2 = t2.getRootNode();
  return (n2 instanceof Document || n2 instanceof ShadowRoot) && null != n2.getSelection ? n2 : t2.ownerDocument;
}, getParentNode: function(e3, t2) {
  return Es$1.get(t2) || null;
}, getParentsNodes: function(e3, t2) {
  for (var n2 = [], r2 = t2; r2 !== e3 && null != r2; ) {
    var o2 = rl$1.getParentNode(e3, r2);
    if (null == o2)
      break;
    n2.push(o2), r2 = o2;
  }
  return n2;
}, getTopNode: function(e3, t2) {
  var n2 = [rl$1.findPath(e3, t2)[0]];
  return Node$1.get(e3, n2);
}, toDOMNode: function(t2, n2) {
  var r2;
  if (Editor$1.isEditor(n2))
    r2 = Os$1.get(t2);
  else {
    var o2 = rl$1.findKey(t2, n2);
    r2 = Ns$1.get(o2);
  }
  if (!r2)
    throw new Error("Cannot resolve a DOM node from Slate node: " + JSON.stringify(n2));
  return r2;
}, hasDOMNode: function(e3, t2, n2) {
  void 0 === n2 && (n2 = {});
  var r2, o2 = n2.editable, i2 = void 0 !== o2 && o2, a2 = rl$1.toDOMNode(e3, e3);
  try {
    r2 = $s$1(t2) ? t2 : t2.parentElement;
  } catch (e4) {
    if (!e4.message.includes('Permission denied to access property "nodeType"'))
      throw e4;
  }
  return !!r2 && (r2.closest("[data-slate-editor]") === a2 && (!i2 || r2.isContentEditable || !!r2.getAttribute("data-slate-zero-width")));
}, toDOMRange: function(e3, t2) {
  var n2 = t2.anchor, r2 = t2.focus, i2 = Range.isBackward(t2), a2 = rl$1.toDOMPoint(e3, n2), s2 = Range.isCollapsed(t2) ? a2 : rl$1.toDOMPoint(e3, r2), l2 = rl$1.getWindow(e3).document.createRange(), u2 = fa$4(i2 ? s2 : a2, 2), c2 = u2[0], f2 = u2[1], d3 = fa$4(i2 ? a2 : s2, 2), h2 = d3[0], p2 = d3[1], g2 = !!($s$1(c2) ? c2 : c2.parentElement).getAttribute("data-slate-zero-width"), v2 = !!($s$1(h2) ? h2 : h2.parentElement).getAttribute("data-slate-zero-width");
  return l2.setStart(c2, g2 ? 1 : f2), l2.setEnd(h2, v2 ? 1 : p2), l2;
}, toDOMPoint: function(t2, n2) {
  var r2, o2, i2, a2 = fa$4(Editor$1.node(t2, n2.path), 1)[0], s2 = rl$1.toDOMNode(t2, a2);
  Editor$1.void(t2, { at: n2 }) && (n2 = { path: n2.path, offset: 0 });
  var l2 = Array.from(s2.querySelectorAll("[data-slate-string], [data-slate-zero-width]")), u2 = 0;
  try {
    for (var c2 = ca$4(l2), f2 = c2.next(); !f2.done; f2 = c2.next()) {
      var d3 = f2.value, h2 = d3.childNodes[0];
      if (null != h2 && null != h2.textContent) {
        var p2 = h2.textContent.length, g2 = d3.getAttribute("data-slate-length"), v2 = u2 + (null == g2 ? p2 : parseInt(g2, 10));
        if (n2.offset <= v2) {
          i2 = [h2, Math.min(p2, Math.max(0, n2.offset - u2))];
          break;
        }
        u2 = v2;
      }
    }
  } catch (e3) {
    r2 = { error: e3 };
  } finally {
    try {
      f2 && !f2.done && (o2 = c2.return) && o2.call(c2);
    } finally {
      if (r2)
        throw r2.error;
    }
  }
  if (!i2)
    throw new Error("Cannot resolve a DOM point from Slate point: " + JSON.stringify(n2));
  return i2;
}, toSlateNode: function(e3, t2) {
  var n2 = $s$1(t2) ? t2 : t2.parentElement;
  n2 && !n2.hasAttribute("data-slate-node") && (n2 = n2.closest("[data-slate-node]"));
  var r2 = n2 ? Cs$1.get(n2) : null;
  if (!r2)
    throw new Error("Cannot resolve a Slate node from DOM node: " + n2);
  return r2;
}, findEventRange: function(t2, n2) {
  "nativeEvent" in n2 && (n2 = n2.nativeEvent);
  var r2 = n2.clientX, o2 = n2.clientY, i2 = n2.target;
  if (null == r2 || null == o2)
    throw new Error("Cannot resolve a Slate range from a DOM event: " + n2);
  var a2, s2 = rl$1.toSlateNode(t2, n2.target), l2 = rl$1.findPath(t2, s2);
  if (Editor$1.isVoid(t2, s2)) {
    var u2 = i2.getBoundingClientRect(), c2 = t2.isInline(s2) ? r2 - u2.left < u2.left + u2.width - r2 : o2 - u2.top < u2.top + u2.height - o2, f2 = Editor$1.point(t2, l2, { edge: c2 ? "start" : "end" }), d3 = c2 ? Editor$1.before(t2, f2) : Editor$1.after(t2, f2);
    if (d3)
      return Editor$1.range(t2, d3);
  }
  var h2 = this.getWindow(t2).document;
  if (h2.caretRangeFromPoint)
    a2 = h2.caretRangeFromPoint(r2, o2);
  else {
    var p2 = h2.caretPositionFromPoint(r2, o2);
    p2 && ((a2 = h2.createRange()).setStart(p2.offsetNode, p2.offset), a2.setEnd(p2.offsetNode, p2.offset));
  }
  if (!a2)
    throw new Error("Cannot resolve a Slate range from a DOM event: " + n2);
  return rl$1.toSlateRange(t2, a2, { exactMatch: false, suppressThrow: false });
}, toSlateRange: function(t2, n2, r2) {
  var i2, a2, s2, l2, u2, c2 = r2.exactMatch, f2 = r2.suppressThrow;
  if ((Vs$1(n2) ? n2.anchorNode : n2.startContainer) && (Vs$1(n2) ? (i2 = n2.anchorNode, a2 = n2.anchorOffset, s2 = n2.focusNode, l2 = n2.focusOffset, u2 = tl$1 && window.document.activeElement && window.document.activeElement.shadowRoot ? n2.anchorNode === n2.focusNode && n2.anchorOffset === n2.focusOffset : n2.isCollapsed) : (i2 = n2.startContainer, a2 = n2.startOffset, s2 = n2.endContainer, l2 = n2.endOffset, u2 = n2.collapsed)), null == i2 || null == s2 || null == a2 || null == l2)
    throw new Error("Cannot resolve a Slate range from DOM range: " + n2);
  var d3 = rl$1.toSlatePoint(t2, [i2, a2], { exactMatch: c2, suppressThrow: f2 });
  if (!d3)
    return null;
  var h2 = u2 ? d3 : rl$1.toSlatePoint(t2, [s2, l2], { exactMatch: c2, suppressThrow: f2 });
  if (!h2)
    return null;
  var p2 = { anchor: d3, focus: h2 };
  return Range.isExpanded(p2) && Range.isForward(p2) && $s$1(s2) && Editor$1.void(t2, { at: p2.focus, mode: "highest" }) && (p2 = Editor$1.unhangRange(t2, p2, { voids: true })), p2;
}, toSlatePoint: function(e3, t2, n2) {
  var r2, o2 = n2.exactMatch, i2 = n2.suppressThrow, a2 = fa$4(o2 ? t2 : function(e4) {
    var t3, n3 = fa$4(e4, 2), r3 = n3[0], o3 = n3[1];
    if ($s$1(r3) && r3.childNodes.length) {
      var i3 = o3 === r3.childNodes.length, a3 = i3 ? o3 - 1 : o3;
      for (r3 = (t3 = fa$4(Us$1(r3, a3, i3 ? "backward" : "forward"), 2))[0], i3 = (a3 = t3[1]) < o3; $s$1(r3) && r3.childNodes.length; ) {
        var s3 = i3 ? r3.childNodes.length - 1 : 0;
        r3 = Ks$1(r3, s3, i3 ? "backward" : "forward");
      }
      o3 = i3 && null != r3.textContent ? r3.textContent.length : 0;
    }
    return [r3, o3];
  }(t2), 2), s2 = a2[0], l2 = a2[1], u2 = s2.parentNode, f2 = null, d3 = 0;
  if (u2) {
    var h2 = u2.closest('[data-slate-void="true"]'), p2 = u2.closest("[data-slate-leaf]"), g2 = null;
    if (p2) {
      f2 = p2.closest('[data-slate-node="text"]');
      var v2 = rl$1.getWindow(e3).document.createRange();
      v2.setStart(f2, 0), v2.setEnd(s2, l2);
      var y2 = v2.cloneContents();
      da$4(da$4([], fa$4(lodash_toarray(y2.querySelectorAll("[data-slate-zero-width]")))), fa$4(lodash_toarray(y2.querySelectorAll("[contenteditable=false]")))).forEach(function(e4) {
        e4.parentNode.removeChild(e4);
      }), d3 = y2.textContent.length, g2 = f2;
    } else
      h2 && ((p2 = h2.querySelector("[data-slate-leaf]")) ? (f2 = p2.closest('[data-slate-node="text"]'), d3 = (g2 = p2).textContent.length, g2.querySelectorAll("[data-slate-zero-width]").forEach(function(e4) {
        d3 -= e4.textContent.length;
      })) : d3 = 1);
    g2 && d3 === g2.textContent.length && (u2.hasAttribute("data-slate-zero-width") || Xs$1 && (null === (r2 = g2.textContent) || void 0 === r2 ? void 0 : r2.endsWith("\n"))) && d3--;
  }
  if (!f2) {
    if (i2)
      return null;
    throw new Error("Cannot resolve a Slate point from DOM point: " + t2);
  }
  var m2 = rl$1.toSlateNode(e3, f2);
  return { path: rl$1.findPath(e3, m2), offset: d3 };
}, hasRange: function(t2, n2) {
  var r2 = n2.anchor, o2 = n2.focus;
  return Editor$1.hasPath(t2, r2.path) && Editor$1.hasPath(t2, o2.path);
}, getNodeType: function(e3) {
  return Element$1.isElement(e3) ? e3.type : "";
}, checkNodeType: function(e3, t2) {
  return this.getNodeType(e3) === t2;
}, getNodesStr: function(e3) {
  return e3.map(function(e4) {
    return Node$1.string(e4);
  }).join("");
}, getSelectedElems: function(t2) {
  var n2, r2, o2 = [], a2 = Editor$1.nodes(t2, { universal: true });
  try {
    for (var s2 = ca$4(a2), l2 = s2.next(); !l2.done; l2 = s2.next()) {
      var u2 = fa$4(l2.value, 1)[0];
      Element$1.isElement(u2) && o2.push(u2);
    }
  } catch (e3) {
    n2 = { error: e3 };
  } finally {
    try {
      l2 && !l2.done && (r2 = s2.return) && r2.call(s2);
    } finally {
      if (n2)
        throw n2.error;
    }
  }
  return o2;
}, getSelectedNodeByType: function(t2, n2) {
  var r2 = this, o2 = fa$4(Editor$1.nodes(t2, { match: function(e3) {
    return r2.checkNodeType(e3, n2);
  }, universal: true }), 1), i2 = o2[0];
  return null == i2 ? null : i2[0];
}, getSelectedTextNode: function(t2) {
  var n2 = fa$4(Editor$1.nodes(t2, { match: function(e3) {
    return Text.isText(e3);
  }, universal: true }), 1), r2 = n2[0];
  return null == r2 ? null : r2[0];
}, isNodeSelected: function(t2, n2) {
  var r2 = fa$4(Editor$1.nodes(t2, { match: function(e3) {
    return e3 === n2;
  }, universal: true }), 1), o2 = r2[0];
  return null != o2 && fa$4(o2, 1)[0] === n2;
}, isSelectionAtLineEnd: function(t2, n2) {
  var r2 = t2.selection;
  return !!r2 && (Editor$1.isEnd(t2, r2.anchor, n2) || Editor$1.isEnd(t2, r2.focus, n2));
}, getTextarea: function(e3) {
  var t2 = cs$1.get(e3);
  if (null == t2)
    throw new Error("Cannot find textarea instance by editor");
  return t2;
}, getToolbar: function(e3) {
  return hs$1.get(e3) || null;
}, getHoverbar: function(e3) {
  return gs$1.get(e3) || null;
}, normalizeContent: function(e3) {
  e3.children.forEach(function(t2, n2) {
    e3.normalizeNode([t2, [n2]]);
  });
}, getLeftLengthOfMaxLength: function(e3) {
  var t2 = e3.getConfig(), n2 = t2.maxLength, r2 = t2.onMaxLength;
  if ("number" != typeof n2 || n2 <= 0)
    return 1 / 0;
  var o2 = n2 - e3.getText().replace(/\r|\n|(\r\n)/g, "").length;
  return o2 <= 0 && r2 && r2(e3), o2;
}, cleanExposedTexNodeInSelectionBlock: function(t2) {
  var n2, r2, o2, a2, s2 = rl$1.getTextarea(t2).$textArea, l2 = null == s2 ? void 0 : s2[0].childNodes;
  if (l2)
    try {
      for (var u2 = ca$4(Array.from(l2)), c2 = u2.next(); !c2.done; c2 = u2.next()) {
        var d3 = c2.value;
        if (3 !== d3.nodeType)
          break;
        d3.remove();
      }
    } catch (e3) {
      n2 = { error: e3 };
    } finally {
      try {
        c2 && !c2.done && (r2 = u2.return) && r2.call(u2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
  var h2 = Editor$1.nodes(t2, { match: function(e3) {
    return !(!Element$1.isElement(e3) || t2.isInline(e3));
  }, universal: true });
  try {
    for (var p2 = ca$4(h2), g2 = p2.next(); !g2.done; g2 = p2.next()) {
      var v2 = g2.value;
      if (null != v2) {
        var y2 = v2[0];
        Gs$1(rl$1.toDOMNode(t2, y2), function(e3, t3) {
          var n3 = $$6(t3);
          n3.attr("data-slate-string") || n3.attr("data-slate-zero-width") || t3.removeChild(e3);
        });
      }
    }
  } catch (e3) {
    o2 = { error: e3 };
  } finally {
    try {
      g2 && !g2.done && (a2 = p2.return) && a2.call(p2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
}, isLastNode: function(e3, t2) {
  var n2 = e3.children || [];
  return n2[n2.length - 1] === t2;
}, genEmptyParagraph: function() {
  return { type: "paragraph", children: [{ text: "" }] };
}, isSelectedVoidNode: function(t2) {
  var n2, r2, o2 = Editor$1.nodes(t2, { match: function(e3) {
    return t2.isVoid(e3);
  } }), i2 = 0;
  try {
    for (var a2 = ca$4(o2), s2 = a2.next(); !s2.done; s2 = a2.next()) {
      s2.value;
      i2++;
    }
  } catch (e3) {
    n2 = { error: e3 };
  } finally {
    try {
      s2 && !s2.done && (r2 = a2.return) && r2.call(a2);
    } finally {
      if (n2)
        throw n2.error;
    }
  }
  return i2 > 0;
}, isSelectedEmptyParagraph: function(e3) {
  var t2 = e3.selection;
  if (null == t2)
    return false;
  if (Range.isExpanded(t2))
    return false;
  var n2 = rl$1.getSelectedNodeByType(e3, "paragraph");
  if (null === n2)
    return false;
  var r2 = n2.children;
  return 1 === r2.length && ("" === r2[0].text || void 0);
}, isEmptyPath: function(t2, n2) {
  var r2 = Editor$1.node(t2, n2);
  if (null == r2)
    return false;
  var o2 = fa$4(r2, 1)[0].children;
  if (1 === o2.length && "" === o2[0].text)
    return true;
  return false;
} }, ol$1 = 1, il$1 = {};
var al$1 = {};
function sl$1(e3, t2) {
  var n2 = e3.key, r2 = e3.factory, o2 = e3.config, i2 = ua$4(ua$4({}, o2), t2 || {});
  if (null != al$1[n2])
    throw new Error("Duplicated key '" + n2 + "' in menu items");
  al$1[n2] = r2, function(e4, t3) {
    null != t3 && (il$1[e4] = t3);
  }(n2, i2);
}
var ll$1 = Ve$6("species"), ul$1 = function(e3) {
  var t2 = Te$6(e3), n2 = yt$6.f;
  Ue$6 && t2 && !t2[ll$1] && n2(t2, ll$1, { configurable: true, get: function() {
    return this;
  } });
}, cl$1 = yt$6.f, fl$1 = La$3.fastKey, dl$1 = It$6.set, hl$1 = It$6.getterFor, pl$1 = { getConstructor: function(e3, t2, n2, r2) {
  var o2 = e3(function(e4, o3) {
    Aa$3(e4, i2), dl$1(e4, { type: t2, index: _r$5(null), first: void 0, last: void 0, size: 0 }), Ue$6 || (e4.size = 0), null != o3 && Ra$3(o3, e4[r2], { that: e4, AS_ENTRIES: n2 });
  }), i2 = o2.prototype, a2 = hl$1(t2), s2 = function(e4, t3, n3) {
    var r3, o3, i3 = a2(e4), s3 = l2(e4, t3);
    return s3 ? s3.value = n3 : (i3.last = s3 = { index: o3 = fl$1(t3, true), key: t3, value: n3, previous: r3 = i3.last, next: void 0, removed: false }, i3.first || (i3.first = s3), r3 && (r3.next = s3), Ue$6 ? i3.size++ : e4.size++, "F" !== o3 && (i3.index[o3] = s3)), e4;
  }, l2 = function(e4, t3) {
    var n3, r3 = a2(e4), o3 = fl$1(t3);
    if ("F" !== o3)
      return r3.index[o3];
    for (n3 = r3.first; n3; n3 = n3.next)
      if (n3.key == t3)
        return n3;
  };
  return ma$3(i2, { clear: function() {
    for (var e4 = a2(this), t3 = e4.index, n3 = e4.first; n3; )
      n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete t3[n3.index], n3 = n3.next;
    e4.first = e4.last = void 0, Ue$6 ? e4.size = 0 : this.size = 0;
  }, delete: function(e4) {
    var t3 = this, n3 = a2(t3), r3 = l2(t3, e4);
    if (r3) {
      var o3 = r3.next, i3 = r3.previous;
      delete n3.index[r3.index], r3.removed = true, i3 && (i3.next = o3), o3 && (o3.previous = i3), n3.first == r3 && (n3.first = o3), n3.last == r3 && (n3.last = i3), Ue$6 ? n3.size-- : t3.size--;
    }
    return !!r3;
  }, forEach: function(e4) {
    for (var t3, n3 = a2(this), r3 = nn$6(e4, arguments.length > 1 ? arguments[1] : void 0); t3 = t3 ? t3.next : n3.first; )
      for (r3(t3.value, t3.key, this); t3 && t3.removed; )
        t3 = t3.previous;
  }, has: function(e4) {
    return !!l2(this, e4);
  } }), ma$3(i2, n2 ? { get: function(e4) {
    var t3 = l2(this, e4);
    return t3 && t3.value;
  }, set: function(e4, t3) {
    return s2(this, 0 === e4 ? 0 : e4, t3);
  } } : { add: function(e4) {
    return s2(this, e4 = 0 === e4 ? 0 : e4, e4);
  } }), Ue$6 && cl$1(i2, "size", { get: function() {
    return a2(this).size;
  } }), o2;
}, setStrong: function(e3, t2, n2) {
  var r2 = t2 + " Iterator", o2 = hl$1(t2), i2 = hl$1(r2);
  Jo$4(e3, t2, function(e4, t3) {
    dl$1(this, { type: r2, target: e4, state: o2(e4), kind: t3, last: void 0 });
  }, function() {
    for (var e4 = i2(this), t3 = e4.kind, n3 = e4.last; n3 && n3.removed; )
      n3 = n3.previous;
    return e4.target && (e4.last = n3 = n3 ? n3.next : e4.state.first) ? "keys" == t3 ? { value: n3.key, done: false } : "values" == t3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (e4.target = void 0, { value: void 0, done: true });
  }, n2 ? "entries" : "values", !n2, true), ul$1(t2);
} };
Ia$3("Set", function(e3) {
  return function() {
    return e3(this, arguments.length ? arguments[0] : void 0);
  };
}, pl$1);
var gl$1 = Nn$6.filter, vl$1 = ci$4("filter");
ur$5({ target: "Array", proto: true, forced: !vl$1 }, { filter: function(e3) {
  return gl$1(this, e3, arguments.length > 1 ? arguments[1] : void 0);
} });
var yl$1 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", ml$1 = ge$6("".replace), bl$1 = "[" + yl$1 + "]", wl$1 = RegExp("^" + bl$1 + bl$1 + "*"), xl$1 = RegExp(bl$1 + bl$1 + "*$"), Sl$1 = function(e3) {
  return function(t2) {
    var n2 = Sr$5(ye$6(t2));
    return 1 & e3 && (n2 = ml$1(n2, wl$1, "")), 2 & e3 && (n2 = ml$1(n2, xl$1, "")), n2;
  };
}, kl$1 = { start: Sl$1(1), end: Sl$1(2), trim: Sl$1(3) }, El$1 = Wt$6.PROPER, Ol$1 = kl$1.trim;
ur$5({ target: "String", proto: true, forced: function(e3) {
  return Ae$6(function() {
    return !!yl$1[e3]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[e3]() || El$1 && yl$1[e3].name !== e3;
  });
}("trim") }, { trim: function() {
  return Ol$1(this);
} });
var Cl$1 = [];
function Nl$1(e3) {
  Cl$1.push(e3);
}
var Tl$1 = {};
function Ll$1(e3) {
  var t2 = e3.type, n2 = e3.elemToHtml;
  Tl$1[t2 || ""] = n2;
}
function Ml$1(e3, t2, n2) {
  var r2 = n2.isInline(e3) ? "span" : "div";
  return "<" + r2 + ">" + t2 + "</" + r2 + ">";
}
function Pl$1(t2, n2) {
  var r2 = t2.type, o2 = void 0 === r2 ? "" : r2, i2 = t2.children, a2 = void 0 === i2 ? [] : i2, s2 = Editor$1.isVoid(n2, t2), l2 = "";
  s2 || (l2 = a2.map(function(e3) {
    return fc$1(e3, n2);
  }).join(""));
  var u2 = function(e3) {
    return Tl$1[e3] || Ml$1;
  }(o2), c2 = u2(t2, l2, n2);
  return s2 || Cl$1.forEach(function(e3) {
    return c2 = e3(t2, c2);
  }), c2;
}
var Dl$1, Rl$1, jl$1, Al$1, Fl$1 = ae$6.Promise, Il$1 = ae$6.TypeError, _l$1 = Ve$6("species"), Bl$1 = function(e3, t2) {
  var n2, r2 = Ze$6(e3).constructor;
  return void 0 === r2 || null == (n2 = Ze$6(r2)[_l$1]) ? t2 : function(e4) {
    if (xn$6(e4))
      return e4;
    throw Il$1(at$6(e4) + " is not a constructor");
  }(n2);
}, $l$1 = ge$6([].slice), Wl$1 = /(?:ipad|iphone|ipod).*applewebkit/i.test(Le$6), Vl$1 = "process" == Ut$6(ae$6.process), zl$1 = ae$6.setImmediate, Hl$1 = ae$6.clearImmediate, Ul$1 = ae$6.process, Kl$1 = ae$6.Dispatch, ql$1 = ae$6.Function, Gl$1 = ae$6.MessageChannel, Jl$1 = ae$6.String, Yl$1 = 0, Xl$1 = {};
try {
  Dl$1 = ae$6.location;
} catch (e3) {
}
var Ql$1 = function(e3) {
  if (xe$6(Xl$1, e3)) {
    var t2 = Xl$1[e3];
    delete Xl$1[e3], t2();
  }
}, Zl$1 = function(e3) {
  return function() {
    Ql$1(e3);
  };
}, eu$3 = function(e3) {
  Ql$1(e3.data);
}, tu$3 = function(e3) {
  ae$6.postMessage(Jl$1(e3), Dl$1.protocol + "//" + Dl$1.host);
};
zl$1 && Hl$1 || (zl$1 = function(e3) {
  var t2 = $l$1(arguments, 1);
  return Xl$1[++Yl$1] = function() {
    Ii$3(Ce$6(e3) ? e3 : ql$1(e3), void 0, t2);
  }, Rl$1(Yl$1), Yl$1;
}, Hl$1 = function(e3) {
  delete Xl$1[e3];
}, Vl$1 ? Rl$1 = function(e3) {
  Ul$1.nextTick(Zl$1(e3));
} : Kl$1 && Kl$1.now ? Rl$1 = function(e3) {
  Kl$1.now(Zl$1(e3));
} : Gl$1 && !Wl$1 ? (Al$1 = (jl$1 = new Gl$1()).port2, jl$1.port1.onmessage = eu$3, Rl$1 = nn$6(Al$1.postMessage, Al$1)) : ae$6.addEventListener && Ce$6(ae$6.postMessage) && !ae$6.importScripts && Dl$1 && "file:" !== Dl$1.protocol && !Ae$6(tu$3) ? (Rl$1 = tu$3, ae$6.addEventListener("message", eu$3, false)) : Rl$1 = "onreadystatechange" in Je$6("script") ? function(e3) {
  Dr$5.appendChild(Je$6("script")).onreadystatechange = function() {
    Dr$5.removeChild(this), Ql$1(e3);
  };
} : function(e3) {
  setTimeout(Zl$1(e3), 0);
});
var nu$3, ru$3, ou$3, iu$3, au$3, su$3, lu$3, uu$3, cu$3 = { set: zl$1, clear: Hl$1 }, fu$3 = /ipad|iphone|ipod/i.test(Le$6) && void 0 !== ae$6.Pebble, du$3 = /web0s(?!.*chrome)/i.test(Le$6), hu$3 = Bn$6.f, pu$3 = cu$3.set, gu$3 = ae$6.MutationObserver || ae$6.WebKitMutationObserver, vu$3 = ae$6.document, yu$3 = ae$6.process, mu$3 = ae$6.Promise, bu$3 = hu$3(ae$6, "queueMicrotask"), wu$3 = bu$3 && bu$3.value;
wu$3 || (nu$3 = function() {
  var e3, t2;
  for (Vl$1 && (e3 = yu$3.domain) && e3.exit(); ru$3; ) {
    t2 = ru$3.fn, ru$3 = ru$3.next;
    try {
      t2();
    } catch (e4) {
      throw ru$3 ? iu$3() : ou$3 = void 0, e4;
    }
  }
  ou$3 = void 0, e3 && e3.enter();
}, Wl$1 || Vl$1 || du$3 || !gu$3 || !vu$3 ? !fu$3 && mu$3 && mu$3.resolve ? ((lu$3 = mu$3.resolve(void 0)).constructor = mu$3, uu$3 = nn$6(lu$3.then, lu$3), iu$3 = function() {
  uu$3(nu$3);
}) : Vl$1 ? iu$3 = function() {
  yu$3.nextTick(nu$3);
} : (pu$3 = nn$6(pu$3, ae$6), iu$3 = function() {
  pu$3(nu$3);
}) : (au$3 = true, su$3 = vu$3.createTextNode(""), new gu$3(nu$3).observe(su$3, { characterData: true }), iu$3 = function() {
  su$3.data = au$3 = !au$3;
}));
var xu$3, Su$3, ku$3, Eu$3, Ou$3 = wu$3 || function(e3) {
  var t2 = { fn: e3, next: void 0 };
  ou$3 && (ou$3.next = t2), ru$3 || (ru$3 = t2, iu$3()), ou$3 = t2;
}, Cu$3 = function(e3) {
  var t2, n2;
  this.promise = new e3(function(e4, r2) {
    if (void 0 !== t2 || void 0 !== n2)
      throw TypeError("Bad Promise constructor");
    t2 = e4, n2 = r2;
  }), this.resolve = lt$6(t2), this.reject = lt$6(n2);
}, Nu$3 = { f: function(e3) {
  return new Cu$3(e3);
} }, Tu$3 = function(e3) {
  try {
    return { error: false, value: e3() };
  } catch (e4) {
    return { error: true, value: e4 };
  }
}, Lu$3 = "object" == typeof window, Mu$3 = cu$3.set, Pu$3 = Ve$6("species"), Du$3 = "Promise", Ru$3 = It$6.getterFor(Du$3), ju$3 = It$6.set, Au$3 = It$6.getterFor(Du$3), Fu$3 = Fl$1 && Fl$1.prototype, Iu$3 = Fl$1, _u$3 = Fu$3, Bu$3 = ae$6.TypeError, $u$3 = ae$6.document, Wu$3 = ae$6.process, Vu$3 = Nu$3.f, zu$3 = Vu$3, Hu$3 = !!($u$3 && $u$3.createEvent && ae$6.dispatchEvent), Uu$3 = Ce$6(ae$6.PromiseRejectionEvent), Ku$3 = false, qu$3 = sr$5(Du$3, function() {
  var e3 = Et$6(Iu$3), t2 = e3 !== String(Iu$3);
  if (!t2 && 66 === je$6)
    return true;
  if (je$6 >= 51 && /native code/.test(e3))
    return false;
  var n2 = new Iu$3(function(e4) {
    e4(1);
  }), r2 = function(e4) {
    e4(function() {
    }, function() {
    });
  };
  return (n2.constructor = {})[Pu$3] = r2, !(Ku$3 = n2.then(function() {
  }) instanceof r2) || !t2 && Lu$3 && !Uu$3;
}), Gu$3 = qu$3 || !vo$4(function(e3) {
  Iu$3.all(e3).catch(function() {
  });
}), Ju$3 = function(e3) {
  var t2;
  return !(!Ke$6(e3) || !Ce$6(t2 = e3.then)) && t2;
}, Yu$3 = function(e3, t2) {
  if (!e3.notified) {
    e3.notified = true;
    var n2 = e3.reactions;
    Ou$3(function() {
      for (var r2 = e3.value, o2 = 1 == e3.state, i2 = 0; n2.length > i2; ) {
        var a2, s2, l2, u2 = n2[i2++], c2 = o2 ? u2.ok : u2.fail, f2 = u2.resolve, d3 = u2.reject, h2 = u2.domain;
        try {
          c2 ? (o2 || (2 === e3.rejection && ec$1(e3), e3.rejection = 1), true === c2 ? a2 = r2 : (h2 && h2.enter(), a2 = c2(r2), h2 && (h2.exit(), l2 = true)), a2 === u2.promise ? d3(Bu$3("Promise-chain cycle")) : (s2 = Ju$3(a2)) ? tt$6(s2, a2, f2, d3) : f2(a2)) : d3(r2);
        } catch (e4) {
          h2 && !l2 && h2.exit(), d3(e4);
        }
      }
      e3.reactions = [], e3.notified = false, t2 && !e3.rejection && Qu$3(e3);
    });
  }
}, Xu$3 = function(e3, t2, n2) {
  var r2, o2;
  Hu$3 ? ((r2 = $u$3.createEvent("Event")).promise = t2, r2.reason = n2, r2.initEvent(e3, false, true), ae$6.dispatchEvent(r2)) : r2 = { promise: t2, reason: n2 }, !Uu$3 && (o2 = ae$6["on" + e3]) ? o2(r2) : "unhandledrejection" === e3 && function(e4, t3) {
    var n3 = ae$6.console;
    n3 && n3.error && (1 == arguments.length ? n3.error(e4) : n3.error(e4, t3));
  }("Unhandled promise rejection", n2);
}, Qu$3 = function(e3) {
  tt$6(Mu$3, ae$6, function() {
    var t2, n2 = e3.facade, r2 = e3.value;
    if (Zu$3(e3) && (t2 = Tu$3(function() {
      Vl$1 ? Wu$3.emit("unhandledRejection", r2, n2) : Xu$3("unhandledrejection", n2, r2);
    }), e3.rejection = Vl$1 || Zu$3(e3) ? 2 : 1, t2.error))
      throw t2.value;
  });
}, Zu$3 = function(e3) {
  return 1 !== e3.rejection && !e3.parent;
}, ec$1 = function(e3) {
  tt$6(Mu$3, ae$6, function() {
    var t2 = e3.facade;
    Vl$1 ? Wu$3.emit("rejectionHandled", t2) : Xu$3("rejectionhandled", t2, e3.value);
  });
}, tc$1 = function(e3, t2, n2) {
  return function(r2) {
    e3(t2, r2, n2);
  };
}, nc$1 = function(e3, t2, n2) {
  e3.done || (e3.done = true, n2 && (e3 = n2), e3.value = t2, e3.state = 2, Yu$3(e3, true));
}, rc$1 = function(e3, t2, n2) {
  if (!e3.done) {
    e3.done = true, n2 && (e3 = n2);
    try {
      if (e3.facade === t2)
        throw Bu$3("Promise can't be resolved itself");
      var r2 = Ju$3(t2);
      r2 ? Ou$3(function() {
        var n3 = { done: false };
        try {
          tt$6(r2, t2, tc$1(rc$1, n3, e3), tc$1(nc$1, n3, e3));
        } catch (t3) {
          nc$1(n3, t3, e3);
        }
      }) : (e3.value = t2, e3.state = 1, Yu$3(e3, false));
    } catch (t3) {
      nc$1({ done: false }, t3, e3);
    }
  }
};
if (qu$3 && (_u$3 = (Iu$3 = function(e3) {
  Aa$3(this, _u$3), lt$6(e3), tt$6(xu$3, this);
  var t2 = Ru$3(this);
  try {
    e3(tc$1(rc$1, t2), tc$1(nc$1, t2));
  } catch (e4) {
    nc$1(t2, e4);
  }
}).prototype, (xu$3 = function(e3) {
  ju$3(this, { type: Du$3, done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
}).prototype = ma$3(_u$3, { then: function(e3, t2) {
  var n2 = Au$3(this), r2 = n2.reactions, o2 = Vu$3(Bl$1(this, Iu$3));
  return o2.ok = !Ce$6(e3) || e3, o2.fail = Ce$6(t2) && t2, o2.domain = Vl$1 ? Wu$3.domain : void 0, n2.parent = true, r2[r2.length] = o2, 0 != n2.state && Yu$3(n2, false), o2.promise;
}, catch: function(e3) {
  return this.then(void 0, e3);
} }), Su$3 = function() {
  var e3 = new xu$3(), t2 = Ru$3(e3);
  this.promise = e3, this.resolve = tc$1(rc$1, t2), this.reject = tc$1(nc$1, t2);
}, Nu$3.f = Vu$3 = function(e3) {
  return e3 === Iu$3 || e3 === ku$3 ? new Su$3(e3) : zu$3(e3);
}, Ce$6(Fl$1) && Fu$3 !== Object.prototype)) {
  Eu$3 = Fu$3.then, Ku$3 || (Vt$6(Fu$3, "then", function(e3, t2) {
    var n2 = this;
    return new Iu$3(function(e4, t3) {
      tt$6(Eu$3, n2, e4, t3);
    }).then(e3, t2);
  }, { unsafe: true }), Vt$6(Fu$3, "catch", _u$3.catch, { unsafe: true }));
  try {
    delete Fu$3.constructor;
  } catch (e3) {
  }
  Vo$4 && Vo$4(Fu$3, _u$3);
}
ur$5({ global: true, wrap: true, forced: qu$3 }, { Promise: Iu$3 }), Io$4(Iu$3, Du$3, false), ul$1(Du$3), ku$3 = Te$6(Du$3), ur$5({ target: Du$3, stat: true, forced: qu$3 }, { reject: function(e3) {
  var t2 = Vu$3(this);
  return tt$6(t2.reject, void 0, e3), t2.promise;
} }), ur$5({ target: Du$3, stat: true, forced: qu$3 }, { resolve: function(e3) {
  return function(e4, t2) {
    if (Ze$6(e4), Ke$6(t2) && t2.constructor === e4)
      return t2;
    var n2 = Nu$3.f(e4);
    return (0, n2.resolve)(t2), n2.promise;
  }(this, e3);
} }), ur$5({ target: Du$3, stat: true, forced: Gu$3 }, { all: function(e3) {
  var t2 = this, n2 = Vu$3(t2), r2 = n2.resolve, o2 = n2.reject, i2 = Tu$3(function() {
    var n3 = lt$6(t2.resolve), i3 = [], a2 = 0, s2 = 1;
    Ra$3(e3, function(e4) {
      var l2 = a2++, u2 = false;
      s2++, tt$6(n3, t2, e4).then(function(e5) {
        u2 || (u2 = true, i3[l2] = e5, --s2 || r2(i3));
      }, o2);
    }), --s2 || r2(i3);
  });
  return i2.error && o2(i2.value), n2.promise;
}, race: function(e3) {
  var t2 = this, n2 = Vu$3(t2), r2 = n2.reject, o2 = Tu$3(function() {
    var o3 = lt$6(t2.resolve);
    Ra$3(e3, function(e4) {
      tt$6(o3, t2, e4).then(n2.resolve, r2);
    });
  });
  return o2.error && r2(o2.value), n2.promise;
} });
var oc$1 = vi$4.UNSUPPORTED_Y, ic$1 = Math.min, ac$1 = [].push, sc$1 = ge$6(/./.exec), lc$1 = ge$6(ac$1), uc$1 = ge$6("".slice);
function cc$1(e3) {
  Promise.resolve().then(e3);
}
function fc$1(e3, t2) {
  return Element$1.isElement(e3) ? Pl$1(e3, t2) : function(e4, t3) {
    var n2 = e4.text;
    if (null == n2)
      throw new Error("Current node is not slate Text " + JSON.stringify(e4));
    var r2 = n2;
    r2 = function(e5) {
      return e5.replace(/ {2}/g, " &nbsp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(//g, "&reg;").replace(//g, "&copy;").replace(//g, "&trade;");
    }(r2);
    var o2 = rl$1.getParentsNodes(t3, e4).some(function(e5) {
      return "pre" === rl$1.getNodeType(e5);
    });
    if (o2 || (r2 = r2.replace(/\r\n|\r|\n/g, "<br>")), o2 && (r2 = r2.replace(/&nbsp;/g, " ")), "" === r2) {
      var i2 = rl$1.getParentNode(null, e4);
      if (!i2 || 0 !== i2.children.length)
        return r2;
      r2 = "<br>";
    }
    return Cl$1.forEach(function(t4) {
      return r2 = t4(e4, r2);
    }), r2;
  }(e3, t2);
}
function dc$1(e3) {
  return "w-e-element-" + e3;
}
$i$3("split", function(e3, t2, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e4, n3) {
    var r3 = Sr$5(ye$6(this)), o2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === o2)
      return [];
    if (void 0 === e4)
      return [r3];
    if (!Hr$5(e4))
      return tt$6(t2, r3, e4, o2);
    for (var i2, a2, s2, l2 = [], u2 = (e4.ignoreCase ? "i" : "") + (e4.multiline ? "m" : "") + (e4.unicode ? "u" : "") + (e4.sticky ? "y" : ""), c2 = 0, f2 = new RegExp(e4.source, u2 + "g"); (i2 = tt$6(Di$3, f2, r3)) && !((a2 = f2.lastIndex) > c2 && (lc$1(l2, uc$1(r3, c2, i2.index)), i2.length > 1 && i2.index < r3.length && Ii$3(ac$1, l2, xa$3(i2, 1)), s2 = i2[0].length, c2 = a2, l2.length >= o2)); )
      f2.lastIndex === i2.index && f2.lastIndex++;
    return c2 === r3.length ? !s2 && sc$1(f2, "") || lc$1(l2, "") : lc$1(l2, uc$1(r3, c2)), l2.length > o2 ? xa$3(l2, 0, o2) : l2;
  } : "0".split(void 0, 0).length ? function(e4, n3) {
    return void 0 === e4 && 0 === n3 ? [] : tt$6(t2, this, e4, n3);
  } : t2, [function(t3, n3) {
    var o2 = ye$6(this), i2 = null == t3 ? void 0 : ut$6(t3, e3);
    return i2 ? tt$6(i2, t3, o2, n3) : tt$6(r2, Sr$5(o2), t3, n3);
  }, function(e4, o2) {
    var i2 = Ze$6(this), a2 = Sr$5(e4), s2 = n2(r2, i2, a2, o2, r2 !== t2);
    if (s2.done)
      return s2.value;
    var l2 = Bl$1(i2, RegExp), u2 = i2.unicode, c2 = (i2.ignoreCase ? "i" : "") + (i2.multiline ? "m" : "") + (i2.unicode ? "u" : "") + (oc$1 ? "g" : "y"), f2 = new l2(oc$1 ? "^(?:" + i2.source + ")" : i2, c2), d3 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === d3)
      return [];
    if (0 === a2.length)
      return null === Xi$3(f2, a2) ? [a2] : [];
    for (var h2 = 0, p2 = 0, g2 = []; p2 < a2.length; ) {
      f2.lastIndex = oc$1 ? 0 : p2;
      var v2, y2 = Xi$3(f2, oc$1 ? uc$1(a2, p2) : a2);
      if (null === y2 || (v2 = ic$1(fn$6(f2.lastIndex + (oc$1 ? p2 : 0)), a2.length)) === h2)
        p2 = Vi$3(a2, p2, u2);
      else {
        if (lc$1(g2, uc$1(a2, h2, p2)), g2.length === d3)
          return g2;
        for (var m2 = 1; m2 <= y2.length - 1; m2++)
          if (lc$1(g2, y2[m2]), g2.length === d3)
            return g2;
        p2 = h2 = v2;
      }
    }
    return lc$1(g2, uc$1(a2, h2)), g2;
  }];
}, !!Ae$6(function() {
  var e3 = /(?:)/, t2 = e3.exec;
  e3.exec = function() {
    return t2.apply(this, arguments);
  };
  var n2 = "ab".split(e3);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), oc$1);
var hc$1 = function(e3, t2) {
  var n2 = (t2.top + t2.bottom) / 2;
  return e3.top <= n2 && e3.bottom >= n2;
}, pc$1 = function(e3, t2, n2) {
  var r2 = rl$1.toDOMRange(e3, t2).getBoundingClientRect(), o2 = rl$1.toDOMRange(e3, n2).getBoundingClientRect();
  return hc$1(r2, o2) && hc$1(o2, r2);
}, gc$1 = ["span", "b", "strong", "i", "em", "s", "strike", "u", "font", "sub", "sup"], vc$1 = [];
function yc$1(e3) {
  vc$1.push(e3);
}
var mc$1 = [];
function bc$1(e3) {
  mc$1.push(e3);
}
var wc$1 = {};
function xc$1(e3) {
  var t2 = e3.selector, n2 = e3.parseElemHtml;
  wc$1[t2] = n2;
}
var Sc$1 = yt$6.f, kc$1 = Yn$6.f, Ec$1 = It$6.enforce, Oc$1 = Ve$6("match"), Cc$1 = ae$6.RegExp, Nc$1 = Cc$1.prototype, Tc$1 = ae$6.SyntaxError, Lc$1 = ge$6(kr$5), Mc$1 = ge$6(Nc$1.exec), Pc$1 = ge$6("".charAt), Dc$1 = ge$6("".replace), Rc$1 = ge$6("".indexOf), jc$1 = ge$6("".slice), Ac$1 = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, Fc$1 = /a/g, Ic$1 = /a/g, _c$1 = new Cc$1(Fc$1) !== Fc$1, Bc$1 = vi$4.MISSED_STICKY, $c$1 = vi$4.UNSUPPORTED_Y, Wc$1 = Ue$6 && (!_c$1 || Bc$1 || mi$3 || wi$3 || Ae$6(function() {
  return Ic$1[Oc$1] = false, Cc$1(Fc$1) != Fc$1 || Cc$1(Ic$1) == Ic$1 || "/a/i" != Cc$1(Fc$1, "i");
}));
if (sr$5("RegExp", Wc$1)) {
  for (var Vc$1 = function(e3, t2) {
    var n2, r2, o2, i2, a2, s2, l2 = nt$6(Nc$1, this), u2 = Hr$5(e3), c2 = void 0 === t2, f2 = [], d3 = e3;
    if (!l2 && u2 && c2 && e3.constructor === Vc$1)
      return e3;
    if ((u2 || nt$6(Nc$1, e3)) && (e3 = e3.source, c2 && (t2 = "flags" in d3 ? d3.flags : Lc$1(d3))), e3 = void 0 === e3 ? "" : Sr$5(e3), t2 = void 0 === t2 ? "" : Sr$5(t2), d3 = e3, mi$3 && "dotAll" in Fc$1 && (r2 = !!t2 && Rc$1(t2, "s") > -1) && (t2 = Dc$1(t2, /s/g, "")), n2 = t2, Bc$1 && "sticky" in Fc$1 && (o2 = !!t2 && Rc$1(t2, "y") > -1) && $c$1 && (t2 = Dc$1(t2, /y/g, "")), wi$3 && (i2 = function(e4) {
      for (var t3, n3 = e4.length, r3 = 0, o3 = "", i3 = [], a3 = {}, s3 = false, l3 = false, u3 = 0, c3 = ""; r3 <= n3; r3++) {
        if ("\\" === (t3 = Pc$1(e4, r3)))
          t3 += Pc$1(e4, ++r3);
        else if ("]" === t3)
          s3 = false;
        else if (!s3)
          switch (true) {
            case "[" === t3:
              s3 = true;
              break;
            case "(" === t3:
              Mc$1(Ac$1, jc$1(e4, r3 + 1)) && (r3 += 2, l3 = true), o3 += t3, u3++;
              continue;
            case (">" === t3 && l3):
              if ("" === c3 || xe$6(a3, c3))
                throw new Tc$1("Invalid capture group name");
              a3[c3] = true, i3[i3.length] = [c3, u3], l3 = false, c3 = "";
              continue;
          }
        l3 ? c3 += t3 : o3 += t3;
      }
      return [o3, i3];
    }(e3), e3 = i2[0], f2 = i2[1]), a2 = Fa$3(Cc$1(e3, t2), l2 ? this : Nc$1, Vc$1), (r2 || o2 || f2.length) && (s2 = Ec$1(a2), r2 && (s2.dotAll = true, s2.raw = Vc$1(function(e4) {
      for (var t3, n3 = e4.length, r3 = 0, o3 = "", i3 = false; r3 <= n3; r3++)
        "\\" !== (t3 = Pc$1(e4, r3)) ? i3 || "." !== t3 ? ("[" === t3 ? i3 = true : "]" === t3 && (i3 = false), o3 += t3) : o3 += "[\\s\\S]" : o3 += t3 + Pc$1(e4, ++r3);
      return o3;
    }(e3), n2)), o2 && (s2.sticky = true), f2.length && (s2.groups = f2)), e3 !== d3)
      try {
        bt$6(a2, "source", "" === d3 ? "(?:)" : d3);
      } catch (e4) {
      }
    return a2;
  }, zc$1 = function(e3) {
    e3 in Vc$1 || Sc$1(Vc$1, e3, { configurable: true, get: function() {
      return Cc$1[e3];
    }, set: function(t2) {
      Cc$1[e3] = t2;
    } });
  }, Hc$1 = kc$1(Cc$1), Uc$1 = 0; Hc$1.length > Uc$1; )
    zc$1(Hc$1[Uc$1++]);
  Nc$1.constructor = Vc$1, Vc$1.prototype = Nc$1, Vt$6(ae$6, "RegExp", Vc$1);
}
ul$1("RegExp");
var Kc$1 = new RegExp(String.fromCharCode(160), "g");
function qc$1(e3) {
  return e3.replace(Kc$1, " ");
}
function Gc$1(e3, t2) {
  var n2 = e3.length;
  if (n2) {
    var r2 = e3[n2 - 1];
    if (Text.isText(r2)) {
      var o2 = Object.keys(r2);
      if (1 === o2.length && "text" === o2[0])
        return r2.text = r2.text + t2, true;
    }
  }
  return false;
}
function Jc$1(e3, t2, n2) {
  return { type: "paragraph", children: [{ text: $$6(e3).text().replace(/\s+/gm, " ") }] };
}
function Yc$1(t2, n2) {
  var r2 = function(e3, t3) {
    var n3 = [];
    if (null != e3.attr("data-w-e-is-void"))
      return n3;
    var r3 = e3[0].childNodes;
    return 1 === r3.length && "BR" === r3[0].nodeName ? (n3.push({ text: "" }), n3) : (r3.forEach(function(e4) {
      if (e4.nodeType !== _s$1.ELEMENT_NODE)
        if (e4.nodeType !== _s$1.TEXT_NODE)
          ;
        else {
          var r4 = e4.textContent || "";
          if ("" === r4.trim() && r4.indexOf("\n") >= 0)
            return;
          r4 && (r4 = qc$1(r4), Gc$1(n3, r4) || n3.push({ text: r4 }));
        }
      else {
        if ("BR" === e4.nodeName)
          return void (Gc$1(n3, "\n") || n3.push({ text: "\n" }));
        var o3 = $$6(e4);
        n3.push(Qc$1(o3, t3));
      }
    }), n3);
  }(t2, n2), o2 = function(e3) {
    for (var t3 in wc$1)
      if (e3[0].matches(t3))
        return wc$1[t3];
    return Jc$1;
  }(t2), i2 = o2(t2[0], r2, n2);
  return Editor$1.isVoid(n2, i2) || (0 === r2.length && (i2.children = [{ text: t2.text().replace(/\s+/gm, " ") }]), mc$1.forEach(function(e3) {
    i2 = e3(t2[0], i2, n2);
  })), i2;
}
function Xc$1(e3, t2) {
  0 === e3.parents("pre").length && (e3[0].innerHTML = e3[0].innerHTML.replace(/\s+/gm, " ").replace(/<br>/g, "\n"));
  var n2 = e3[0].textContent || "";
  n2 = function(e4) {
    return e4.replace(/&nbsp;/g, " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&reg;/g, "\xAE").replace(/&copy;/g, "\xA9").replace(/&trade;/g, "\u2122");
  }(n2);
  var r2 = { text: n2 = qc$1(n2) };
  return mc$1.forEach(function(n3) {
    r2 = n3(e3[0], r2, t2);
  }), r2;
}
function Qc$1(e3, t2) {
  vc$1.forEach(function(t3) {
    var n3 = t3.selector, r2 = t3.preParseHtml;
    e3[0].matches(n3) && (e3 = $$6(r2(e3[0])));
  });
  var n2 = Js$1(e3);
  return "span" === n2 ? e3.attr("data-w-e-type") ? Yc$1(e3, t2) : Xc$1(e3, t2) : "code" === n2 ? "pre" === Js$1(e3.parent()) ? Yc$1(e3, t2) : Xc$1(e3, t2) : gc$1.includes(n2) ? Xc$1(e3, t2) : Yc$1(e3, t2);
}
function Zc$1(e3, t2, n2) {
  var r2 = $$6(n2);
  return !!r2.attr(t2) || (r2.attr(t2, "true"), e3.on("destroyed", function() {
    r2.removeAttr(t2);
  }), false);
}
function ef$1(e3, t2) {
  void 0 === t2 && (t2 = ""), "" === t2 && (t2 = "<p><br></p>"), 0 !== t2.indexOf("<") && (t2 = t2.split(/\n/).map(function(e4) {
    return "<p>" + e4 + "</p>";
  }).join(""));
  var n2 = $$6("<div>" + t2 + "</div>");
  return Array.from(n2.children()).map(function(t3) {
    return Qc$1($$6(t3), e3);
  });
}
var tf$1 = /* @__PURE__ */ new Set(["doctype", "!doctype", "meta", "script", "style", "link", "frame", "iframe", "title", "svg"]), nf$1 = function(t2) {
  var l2 = t2, u2 = l2.onChange, c2 = l2.insertText, d3 = l2.apply, h2 = l2.deleteBackward;
  return l2.insertText = function(e3) {
    l2.getConfig().readOnly || c2(e3);
  }, l2.apply = function(t3) {
    var r2, o2, i2, a2, s2, u3, c3, f2, h3 = [];
    switch (t3.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
        try {
          for (var p2 = ca$4(Editor$1.levels(l2, { at: t3.path })), g2 = p2.next(); !g2.done; g2 = p2.next()) {
            var v2 = fa$4(g2.value, 2), y2 = v2[0], m2 = v2[1], b2 = rl$1.findKey(l2, y2);
            h3.push([m2, b2]);
          }
        } catch (e3) {
          r2 = { error: e3 };
        } finally {
          try {
            g2 && !g2.done && (o2 = p2.return) && o2.call(p2);
          } finally {
            if (r2)
              throw r2.error;
          }
        }
        break;
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
        try {
          for (var w2 = ca$4(Editor$1.levels(l2, { at: Path.parent(t3.path) })), x2 = w2.next(); !x2.done; x2 = w2.next()) {
            var S2 = fa$4(x2.value, 2);
            y2 = S2[0], m2 = S2[1], b2 = rl$1.findKey(l2, y2);
            h3.push([m2, b2]);
          }
        } catch (e3) {
          i2 = { error: e3 };
        } finally {
          try {
            x2 && !x2.done && (a2 = w2.return) && a2.call(w2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
        break;
      case "move_node":
        try {
          for (var k2 = ca$4(Editor$1.levels(l2, { at: Path.common(Path.parent(t3.path), Path.parent(t3.newPath)) })), E2 = k2.next(); !E2.done; E2 = k2.next()) {
            var O2 = fa$4(E2.value, 2);
            y2 = O2[0], m2 = O2[1], b2 = rl$1.findKey(l2, y2);
            h3.push([m2, b2]);
          }
        } catch (e3) {
          s2 = { error: e3 };
        } finally {
          try {
            E2 && !E2.done && (u3 = k2.return) && u3.call(k2);
          } finally {
            if (s2)
              throw s2.error;
          }
        }
    }
    d3(t3);
    try {
      for (var C2 = ca$4(h3), N2 = C2.next(); !N2.done; N2 = C2.next()) {
        var T2 = fa$4(N2.value, 2);
        m2 = T2[0], b2 = T2[1], y2 = fa$4(Editor$1.node(l2, m2), 1)[0];
        Ls$1.set(y2, b2);
      }
    } catch (e3) {
      c3 = { error: e3 };
    } finally {
      try {
        N2 && !N2.done && (f2 = C2.return) && f2.call(C2);
      } finally {
        if (c3)
          throw c3.error;
      }
    }
  }, l2.deleteBackward = function(n2) {
    if ("line" !== n2)
      return h2(n2);
    if (t2.selection && Range.isCollapsed(t2.selection)) {
      var r2 = Editor$1.above(t2, { match: function(n3) {
        return Editor$1.isBlock(t2, n3);
      }, at: t2.selection });
      if (r2) {
        var i2 = fa$4(r2, 2)[1], a2 = Editor$1.range(t2, i2, t2.selection.anchor), u3 = function(t3, n3) {
          var r3 = Editor$1.range(t3, Range.end(n3)), i3 = Array.from(Editor$1.positions(t3, { at: n3 })), a3 = 0, s2 = i3.length, l3 = Math.floor(s2 / 2);
          if (pc$1(t3, Editor$1.range(t3, i3[a3]), r3))
            return Editor$1.range(t3, i3[a3], r3);
          if (i3.length < 2)
            return Editor$1.range(t3, i3[i3.length - 1], r3);
          for (; l3 !== i3.length && l3 !== a3; )
            pc$1(t3, Editor$1.range(t3, i3[l3]), r3) ? s2 = l3 : a3 = l3, l3 = Math.floor((a3 + s2) / 2);
          return Editor$1.range(t3, i3[s2], r3);
        }(l2, a2);
        Range.isCollapsed(u3) || Transforms.delete(t2, { at: u3 });
      }
    }
  }, l2.onChange = function() {
    var e3 = l2.selection;
    null != e3 && Ds$1.set(l2, e3), l2.emit("change"), u2();
  }, l2.handleTab = function() {
    l2.insertText("    ");
  }, l2.getHtml = function() {
    var e3 = l2.children;
    return (void 0 === e3 ? [] : e3).map(function(e4) {
      return fc$1(e4, l2);
    }).join("");
  }, l2.getText = function() {
    var e3 = l2.children;
    return (void 0 === e3 ? [] : e3).map(function(e4) {
      return Node$1.string(e4);
    }).join("\n");
  }, l2.getSelectionText = function() {
    var n2 = l2.selection;
    return null == n2 ? "" : Editor$1.string(t2, n2);
  }, l2.getElemsByType = function(t3, n2) {
    var r2, o2;
    void 0 === n2 && (n2 = false);
    var a2 = [], s2 = Editor$1.nodes(l2, { at: [], universal: true });
    try {
      for (var u3 = ca$4(s2), c3 = u3.next(); !c3.done; c3 = u3.next()) {
        var f2 = fa$4(c3.value, 1)[0];
        if (Element$1.isElement(f2)) {
          if (n2 ? f2.type.indexOf(t3) >= 0 : f2.type === t3) {
            var d4 = dc$1(rl$1.findKey(l2, f2).id);
            a2.push(ua$4(ua$4({}, f2), { id: d4 }));
          }
        }
      }
    } catch (e3) {
      r2 = { error: e3 };
    } finally {
      try {
        c3 && !c3.done && (o2 = u3.return) && o2.call(u3);
      } finally {
        if (r2)
          throw r2.error;
      }
    }
    return a2;
  }, l2.getElemsByTypePrefix = function(e3) {
    return l2.getElemsByType(e3, true);
  }, l2.isEmpty = function() {
    var e3 = l2.children, t3 = void 0 === e3 ? [] : e3;
    if (t3.length > 1)
      return false;
    var n2 = t3[0];
    if (null == n2)
      return true;
    if (Element$1.isElement(n2) && "paragraph" === n2.type) {
      var r2 = n2.children, o2 = void 0 === r2 ? [] : r2;
      if (o2.length > 1)
        return false;
      var s2 = o2[0];
      if (null == s2)
        return true;
      if (Text.isText(s2) && "" === s2.text)
        return true;
    }
    return false;
  }, l2.clear = function() {
    Transforms.removeNodes(l2, { at: { anchor: Editor$1.start(l2, []), focus: Editor$1.end(l2, []) }, mode: "highest" }), 0 === l2.children.length && Transforms.insertNodes(l2, [{ type: "paragraph", children: [{ text: "" }] }]);
  }, l2.getParentNode = function(e3) {
    return rl$1.getParentNode(l2, e3);
  }, l2.dangerouslyInsertHtml = function(e3, t3) {
    if (void 0 === e3 && (e3 = ""), void 0 === t3 && (t3 = false), e3) {
      var n2 = document.createElement("div");
      n2.innerHTML = e3;
      var r2 = Array.from(n2.childNodes);
      if (r2 = r2.filter(function(e4) {
        var t4 = e4.nodeType, n3 = e4.nodeName;
        return t4 === _s$1.TEXT_NODE || t4 === _s$1.ELEMENT_NODE && !tf$1.has(n3.toLowerCase());
      }), 0 !== r2.length) {
        var o2 = l2.selection;
        if (null != o2) {
          var i2 = null;
          if (rl$1.isSelectedEmptyParagraph(l2) && !t3)
            i2 = [o2.focus.path[0]];
          n2.setAttribute("hidden", "true"), document.body.appendChild(n2);
          var a2 = 0;
          r2.forEach(function(e4) {
            var t4 = e4.nodeType, n3 = e4.nodeName, r3 = e4.textContent, o3 = void 0 === r3 ? "" : r3;
            if (t4 !== _s$1.TEXT_NODE)
              if ("BR" !== n3) {
                var i3 = e4, u3 = false;
                if (gc$1.includes(n3.toLowerCase()))
                  u3 = true;
                else
                  for (var c3 in wc$1)
                    if (i3.matches(c3)) {
                      u3 = true;
                      break;
                    }
                if (u3) {
                  var d4 = Qc$1($$6(i3), l2);
                  return l2.isInline(d4) ? (l2.insertNode(d4), "link" === d4.type && l2.insertFragment([{ text: "" }])) : Transforms.insertNodes(l2, d4, { mode: "highest" }), a2++, void (rl$1.isSelectedVoidNode(l2) && l2.move(1));
                }
                var h3 = window.getComputedStyle(i3).display;
                rl$1.isSelectedEmptyParagraph(l2) || h3.indexOf("inline") < 0 && l2.insertBreak(), l2.dangerouslyInsertHtml(i3.innerHTML, true);
              } else
                l2.insertText("\n");
            else {
              if (!o3 || !o3.trim())
                return;
              l2.insertNode({ text: o3 });
            }
          }), a2 && i2 && rl$1.isEmptyPath(l2, i2) && Transforms.removeNodes(l2, { at: i2 }), n2.remove();
        }
      }
    }
  }, l2.setHtml = function(t3) {
    void 0 === t3 && (t3 = "");
    var n2 = l2.isDisabled(), r2 = l2.isFocused(), o2 = JSON.stringify(l2.selection);
    l2.enable(), l2.focus(), l2.select([]), l2.deleteFragment(), Transforms.setNodes(l2, { type: "paragraph" }, { mode: "highest" });
    var i2 = ef$1(l2, t3);
    if (Transforms.insertFragment(l2, i2), r2 || (l2.deselect(), l2.blur()), n2 && (l2.deselect(), l2.disable()), l2.isFocused())
      try {
        l2.select(JSON.parse(o2));
      } catch (t4) {
        l2.select(Editor$1.start(l2, []));
      }
  }, l2;
}, rf$1 = function(t2) {
  var n2 = t2, r2 = n2.insertText;
  return n2.insertFragment, n2.setFragmentData = function(t3) {
    var r3 = n2.selection;
    if (r3) {
      var i2 = fa$4(Range.edges(r3), 2), a2 = i2[0], s2 = i2[1], l2 = Editor$1.void(n2, { at: a2.path }), u2 = Editor$1.void(n2, { at: s2.path });
      if (!Range.isCollapsed(r3) || l2) {
        var c2 = rl$1.toDOMRange(n2, r3), f2 = c2.cloneContents(), d3 = f2.childNodes[0];
        if (f2.childNodes.forEach(function(e3) {
          e3.textContent && "" !== e3.textContent.trim() && (d3 = e3);
        }), u2) {
          var h2 = fa$4(u2, 1)[0], p2 = c2.cloneRange(), g2 = rl$1.toDOMNode(n2, h2);
          p2.setEndAfter(g2), f2 = p2.cloneContents();
        }
        if (l2 && (d3 = f2.querySelector("[data-slate-spacer]")), Array.from(f2.querySelectorAll("[data-slate-zero-width]")).forEach(function(e3) {
          var t4 = "n" === e3.getAttribute("data-slate-zero-width");
          e3.textContent = t4 ? "\n" : "";
        }), zs$1(d3)) {
          var v2 = d3.ownerDocument.createElement("span");
          v2.style.whiteSpace = "pre", v2.appendChild(d3), f2.appendChild(v2), d3 = v2;
        }
        var y2 = n2.getFragment(), m2 = JSON.stringify(y2), b2 = window.btoa(encodeURIComponent(m2));
        d3.setAttribute("data-slate-fragment", b2), t3.setData("application/x-slate-fragment", b2);
        var w2 = f2.ownerDocument.createElement("div");
        return w2.appendChild(f2), w2.setAttribute("hidden", "true"), f2.ownerDocument.body.appendChild(w2), t3.setData("text/html", w2.innerHTML), t3.setData("text/plain", qs$1(w2)), f2.ownerDocument.body.removeChild(w2), t3;
      }
    }
  }, n2.insertData = function(e3) {
    var t3, o2, i2 = e3.getData("application/x-slate-fragment");
    if (i2) {
      var a2 = decodeURIComponent(window.atob(i2)), l2 = JSON.parse(a2);
      n2.insertFragment(l2);
    } else {
      var u2 = e3.getData("text/plain"), c2 = e3.getData("text/html");
      if (c2)
        n2.dangerouslyInsertHtml(c2);
      else if (u2) {
        var f2 = u2.split(/\r\n|\r|\n/), d3 = false;
        try {
          for (var h2 = ca$4(f2), p2 = h2.next(); !p2.done; p2 = h2.next()) {
            var g2 = p2.value;
            d3 && Transforms.splitNodes(n2, { always: true }), r2(g2), d3 = true;
          }
        } catch (e4) {
          t3 = { error: e4 };
        } finally {
          try {
            p2 && !p2.done && (o2 = h2.return) && o2.call(h2);
          } finally {
            if (t3)
              throw t3.error;
          }
        }
      } else
        ;
    }
  }, n2;
}, of$1 = function(e3) {
  return null != e3;
}, af$1 = { object: true, function: true, undefined: true }, sf$1 = function(e3) {
  if (!function(e4) {
    return !!of$1(e4) && hasOwnProperty.call(af$1, typeof e4);
  }(e3))
    return false;
  try {
    return !!e3.constructor && e3.constructor.prototype === e3;
  } catch (e4) {
    return false;
  }
}, lf$1 = /^\s*class[\s{/}]/, uf$1 = Function.prototype.toString, cf$1 = function(e3) {
  return !!function(e4) {
    if ("function" != typeof e4)
      return false;
    if (!hasOwnProperty.call(e4, "length"))
      return false;
    try {
      if ("number" != typeof e4.length)
        return false;
      if ("function" != typeof e4.call)
        return false;
      if ("function" != typeof e4.apply)
        return false;
    } catch (e5) {
      return false;
    }
    return !sf$1(e4);
  }(e3) && !lf$1.test(uf$1.call(e3));
}, ff$1 = function(e3) {
  return null != e3;
}, df$1 = Object.keys, hf$1 = function() {
  try {
    return Object.keys("primitive"), true;
  } catch (e3) {
    return false;
  }
}() ? Object.keys : function(e3) {
  return df$1(ff$1(e3) ? Object(e3) : e3);
}, pf$1 = function(e3) {
  if (!ff$1(e3))
    throw new TypeError("Cannot use null or undefined");
  return e3;
}, gf$1 = Math.max, vf$1 = function() {
  var e3, t2 = Object.assign;
  return "function" == typeof t2 && (t2(e3 = { foo: "raz" }, { bar: "dwa" }, { trzy: "trzy" }), e3.foo + e3.bar + e3.trzy === "razdwatrzy");
}() ? Object.assign : function(e3, t2) {
  var n2, r2, o2, i2 = gf$1(arguments.length, 2);
  for (e3 = Object(pf$1(e3)), o2 = function(r3) {
    try {
      e3[r3] = t2[r3];
    } catch (e4) {
      n2 || (n2 = e4);
    }
  }, r2 = 1; r2 < i2; ++r2)
    hf$1(t2 = arguments[r2]).forEach(o2);
  if (void 0 !== n2)
    throw n2;
  return e3;
}, yf$1 = Array.prototype.forEach, mf$1 = Object.create, bf$1 = function(e3, t2) {
  var n2;
  for (n2 in e3)
    t2[n2] = e3[n2];
}, wf$1 = function(e3) {
  var t2 = mf$1(null);
  return yf$1.call(arguments, function(e4) {
    ff$1(e4) && bf$1(Object(e4), t2);
  }), t2;
}, xf$1 = "razdwatrzy", Sf$1 = String.prototype.indexOf, kf$1 = "function" == typeof xf$1.contains && true === xf$1.contains("dwa") && false === xf$1.contains("foo") ? String.prototype.contains : function(e3) {
  return Sf$1.call(this, e3, arguments[1]) > -1;
}, Ef$1 = ne$6(function(e3) {
  var t2 = e3.exports = function(e4, t3) {
    var n2, r2, o2, i2, a2;
    return arguments.length < 2 || "string" != typeof e4 ? (i2 = t3, t3 = e4, e4 = null) : i2 = arguments[2], of$1(e4) ? (n2 = kf$1.call(e4, "c"), r2 = kf$1.call(e4, "e"), o2 = kf$1.call(e4, "w")) : (n2 = o2 = true, r2 = false), a2 = { value: t3, configurable: n2, enumerable: r2, writable: o2 }, i2 ? vf$1(wf$1(i2), a2) : a2;
  };
  t2.gs = function(e4, t3, n2) {
    var r2, o2, i2, a2;
    return "string" != typeof e4 ? (i2 = n2, n2 = t3, t3 = e4, e4 = null) : i2 = arguments[3], of$1(t3) ? cf$1(t3) ? of$1(n2) ? cf$1(n2) || (i2 = n2, n2 = void 0) : n2 = void 0 : (i2 = t3, t3 = n2 = void 0) : t3 = void 0, of$1(e4) ? (r2 = kf$1.call(e4, "c"), o2 = kf$1.call(e4, "e")) : (r2 = true, o2 = false), a2 = { get: t3, set: n2, configurable: r2, enumerable: o2 }, i2 ? vf$1(wf$1(i2), a2) : a2;
  };
}), Of$1 = function(e3) {
  if ("function" != typeof e3)
    throw new TypeError(e3 + " is not a function");
  return e3;
}, Cf$1 = ne$6(function(e3, t2) {
  var n2, r2, o2, i2, a2, s2, l2, u2 = Function.prototype.apply, c2 = Function.prototype.call, f2 = Object.create, d3 = Object.defineProperty, h2 = Object.defineProperties, p2 = Object.prototype.hasOwnProperty, g2 = { configurable: true, enumerable: false, writable: true };
  n2 = function(e4, t3) {
    var n3;
    return Of$1(t3), p2.call(this, "__ee__") ? n3 = this.__ee__ : (n3 = g2.value = f2(null), d3(this, "__ee__", g2), g2.value = null), n3[e4] ? "object" == typeof n3[e4] ? n3[e4].push(t3) : n3[e4] = [n3[e4], t3] : n3[e4] = t3, this;
  }, r2 = function(e4, t3) {
    var r3, i3;
    return Of$1(t3), i3 = this, n2.call(this, e4, r3 = function() {
      o2.call(i3, e4, r3), u2.call(t3, this, arguments);
    }), r3.__eeOnceListener__ = t3, this;
  }, o2 = function(e4, t3) {
    var n3, r3, o3, i3;
    if (Of$1(t3), !p2.call(this, "__ee__"))
      return this;
    if (!(n3 = this.__ee__)[e4])
      return this;
    if ("object" == typeof (r3 = n3[e4]))
      for (i3 = 0; o3 = r3[i3]; ++i3)
        o3 !== t3 && o3.__eeOnceListener__ !== t3 || (2 === r3.length ? n3[e4] = r3[i3 ? 0 : 1] : r3.splice(i3, 1));
    else
      r3 !== t3 && r3.__eeOnceListener__ !== t3 || delete n3[e4];
    return this;
  }, i2 = function(e4) {
    var t3, n3, r3, o3, i3;
    if (p2.call(this, "__ee__") && (o3 = this.__ee__[e4]))
      if ("object" == typeof o3) {
        for (n3 = arguments.length, i3 = new Array(n3 - 1), t3 = 1; t3 < n3; ++t3)
          i3[t3 - 1] = arguments[t3];
        for (o3 = o3.slice(), t3 = 0; r3 = o3[t3]; ++t3)
          u2.call(r3, this, i3);
      } else
        switch (arguments.length) {
          case 1:
            c2.call(o3, this);
            break;
          case 2:
            c2.call(o3, this, arguments[1]);
            break;
          case 3:
            c2.call(o3, this, arguments[1], arguments[2]);
            break;
          default:
            for (n3 = arguments.length, i3 = new Array(n3 - 1), t3 = 1; t3 < n3; ++t3)
              i3[t3 - 1] = arguments[t3];
            u2.call(o3, this, i3);
        }
  }, a2 = { on: n2, once: r2, off: o2, emit: i2 }, s2 = { on: Ef$1(n2), once: Ef$1(r2), off: Ef$1(o2), emit: Ef$1(i2) }, l2 = h2({}, s2), e3.exports = t2 = function(e4) {
    return null == e4 ? f2(l2) : h2(Object(e4), s2);
  }, t2.methods = a2;
});
function Nf$1(e3) {
  var t2 = Rs$1.get(e3);
  return null == t2 && (t2 = Cf$1(), Rs$1.set(e3, t2)), t2;
}
var Tf$1 = /* @__PURE__ */ new WeakMap();
function Lf$1(e3, t2) {
  var n2 = Tf$1.get(e3);
  null == n2 && (n2 = /* @__PURE__ */ new Set(), Tf$1.set(e3, n2)), n2.add(t2);
}
function Mf$1(e3) {
  return Tf$1.get(e3) || /* @__PURE__ */ new Set();
}
function Pf$1(e3) {
  Tf$1.set(e3, /* @__PURE__ */ new Set());
}
function Df$1(e3) {
  var t2 = rl$1.getTextarea(e3).$textAreaContainer, n2 = t2.width(), r2 = t2.height(), o2 = t2.offset();
  return { top: o2.top, left: o2.left, width: n2, height: r2 };
}
function Rf$1(e3) {
  var t2 = { top: "0", left: "0" }, n2 = e3.selection;
  if (null == n2)
    return t2;
  var r2 = Df$1(e3);
  if (null == r2)
    return t2;
  var o2 = r2.top, i2 = r2.left, a2 = r2.width, s2 = r2.height, l2 = rl$1.toDOMRange(e3, n2).getClientRects()[0];
  if (null == l2)
    return t2;
  l2.width;
  var u2 = l2.height, c2 = {}, f2 = l2.top - o2, d3 = l2.left - i2;
  if (d3 > a2 / 2) {
    var h2 = a2 - d3;
    c2.right = h2 + 5 + "px";
  } else
    c2.left = d3 + 5 + "px";
  if (f2 > s2 / 2) {
    var p2 = s2 - f2;
    c2.bottom = p2 + 5 + "px";
  } else {
    var g2 = f2 + u2;
    g2 < 0 && (g2 = 0), c2.top = g2 + 5 + "px";
  }
  return c2;
}
function jf$1(e3, t2, n2) {
  void 0 === n2 && (n2 = "modal");
  var r2 = { top: "0", left: "0" };
  if (null == e3.selection)
    return r2;
  var o2 = Element$1.isElement(t2) && e3.isVoid(t2), a2 = Element$1.isElement(t2) && e3.isInline(t2), s2 = Ts$1.get(t2);
  if (null == s2)
    return r2;
  var l2 = s2.getBoundingClientRect(), u2 = l2.top, c2 = l2.left, f2 = l2.height, d3 = l2.width;
  if (o2) {
    var h2 = function(e4) {
      var t3 = [];
      t3.push(e4);
      for (var n3 = 0; t3.length > 0; ) {
        var r3 = t3.pop();
        if (null == r3)
          break;
        if (++n3 > 1e4)
          break;
        var o3 = r3.nodeName;
        if (1 === r3.nodeType) {
          var i2 = o3.toLowerCase();
          if (Is$1.includes(i2) || "iframe" === i2 || "video" === i2)
            return r3;
          var a3 = r3.children || [], s3 = a3.length;
          if (s3)
            for (var l3 = s3 - 1; l3 >= 0; l3--)
              t3.push(a3[l3]);
        }
      }
      return null;
    }(s2);
    if (null != h2) {
      var p2 = h2.getBoundingClientRect();
      u2 = p2.top, f2 = p2.height;
    }
  }
  var g2 = Df$1(e3);
  if (null == g2)
    return r2;
  var v2 = g2.top, y2 = g2.left, m2 = g2.width, b2 = g2.height, w2 = {}, x2 = u2 - v2, S2 = c2 - y2;
  if ("bar" === n2)
    return w2.left = S2 + "px", x2 > 40 ? w2.bottom = b2 - x2 + 5 + "px" : w2.top = x2 + f2 + 5 + "px", w2;
  if ("modal" === n2) {
    var k2;
    if (o2 ? a2 ? S2 > (m2 - d3) / 2 ? w2.right = m2 - S2 + 5 + "px" : w2.left = S2 + d3 + 5 + "px" : w2.left = "20px" : w2.left = S2 + "px", o2)
      (k2 = x2) < 0 && (k2 = 0), w2.top = k2 + "px";
    else if (x2 > (b2 - f2) / 2)
      w2.bottom = b2 - x2 + 5 + "px";
    else
      (k2 = x2 + f2) < 0 && (k2 = 0), w2.top = k2 + 5 + "px";
    return w2;
  }
  throw new Error("type '" + n2 + "' is invalid");
}
function Af$1(e3, t2) {
  cc$1(function() {
    var n2 = Df$1(e3);
    if (null != n2) {
      var r2, o2 = n2.top, i2 = n2.left, a2 = n2.width, s2 = n2.height, l2 = t2.offset(), u2 = l2.top, c2 = l2.left, f2 = t2.width(), d3 = t2.height(), h2 = u2 - o2, p2 = c2 - i2, g2 = t2.attr("style");
      if (g2.indexOf("top") >= 0) {
        if ((r2 = h2 + d3 - s2) > 0) {
          var v2 = t2.css("top"), y2 = parseInt(v2.toString()) - r2;
          y2 < 0 && (y2 = 0), t2.css("top", y2 + "px");
        }
      }
      if (g2.indexOf("bottom") >= 0 && u2 < 0) {
        var m2 = t2.css("bottom"), b2 = parseInt(m2.toString()) - Math.abs(u2);
        t2.css("bottom", b2 + "px");
      }
      if (g2.indexOf("left") >= 0) {
        if ((r2 = p2 + f2 - a2) > 0) {
          var w2 = t2.css("left"), x2 = parseInt(w2.toString()) - r2;
          x2 < 0 && (x2 = 0), t2.css("left", x2 + "px");
        }
      }
      if (g2.indexOf("right") >= 0 && c2 < 0) {
        var S2 = t2.css("right"), k2 = parseInt(S2.toString()) - Math.abs(c2);
        t2.css("right", k2 + "px");
      }
    }
  });
}
var Ff$1 = ci$4("slice"), If$1 = Ve$6("species"), _f$1 = ae$6.Array, Bf$1 = Math.max;
ur$5({ target: "Array", proto: true, forced: !Ff$1 }, { slice: function(e3, t2) {
  var n2, r2, o2, i2 = In$6(this), a2 = dn$6(i2), s2 = Vn$6(e3, a2), l2 = Vn$6(void 0 === t2 ? a2 : t2, a2);
  if (hn$6(i2) && (n2 = i2.constructor, (xn$6(n2) && (n2 === _f$1 || hn$6(n2.prototype)) || Ke$6(n2) && null === (n2 = n2[If$1])) && (n2 = void 0), n2 === _f$1 || void 0 === n2))
    return $l$1(i2, s2, l2);
  for (r2 = new (void 0 === n2 ? _f$1 : n2)(Bf$1(l2 - s2, 0)), o2 = 0; s2 < l2; s2++, o2++)
    s2 in i2 && io$4(r2, o2, i2[s2]);
  return r2.length = o2, r2;
} });
var $f$1 = Bn$6.f, Wf$1 = ge$6("".startsWith), Vf$1 = ge$6("".slice), zf$1 = Math.min, Hf$1 = Gr$5("startsWith"), Uf$1 = !Hf$1 && !!function() {
  var e3 = $f$1(String.prototype, "startsWith");
  return e3 && !e3.writable;
}();
ur$5({ target: "String", proto: true, forced: !Uf$1 && !Hf$1 }, { startsWith: function(e3) {
  var t2 = Sr$5(ye$6(this));
  Kr$5(e3);
  var n2 = fn$6(zf$1(arguments.length > 1 ? arguments[1] : void 0, t2.length)), r2 = Sr$5(e3);
  return Wf$1 ? Wf$1(t2, r2, n2) : Vf$1(t2, n2, n2 + r2.length) === r2;
} });
var Kf$1 = Object.assign, qf$1 = Object.defineProperty, Gf$1 = ge$6([].concat), Jf$1 = !Kf$1 || Ae$6(function() {
  if (Ue$6 && 1 !== Kf$1({ b: 1 }, Kf$1(qf$1({}, "a", { enumerable: true, get: function() {
    qf$1(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b)
    return true;
  var e3 = {}, t2 = {}, n2 = Symbol(), r2 = "abcdefghijklmnopqrst";
  return e3[n2] = 7, r2.split("").forEach(function(e4) {
    t2[e4] = e4;
  }), 7 != Kf$1({}, e3)[n2] || cr$5(Kf$1({}, t2)).join("") != r2;
}) ? function(e3, t2) {
  for (var n2 = be$6(e3), r2 = arguments.length, o2 = 1, i2 = Xn$6.f, a2 = Fn$6.f; r2 > o2; )
    for (var s2, l2 = an$6(arguments[o2++]), u2 = i2 ? Gf$1(cr$5(l2), i2(l2)) : cr$5(l2), c2 = u2.length, f2 = 0; c2 > f2; )
      s2 = u2[f2++], Ue$6 && !tt$6(a2, l2, s2) || (n2[s2] = l2[s2]);
  return n2;
} : Kf$1;
ur$5({ target: "Object", stat: true, forced: Object.assign !== Jf$1 }, { assign: Jf$1 });
var Yf$1 = ["props", "attrs", "style", "dataset", "on", "hook"];
function Xf$1(e3) {
  var t2 = e3.data, n2 = void 0 === t2 ? {} : t2, r2 = e3.children, o2 = void 0 === r2 ? [] : r2;
  Object.keys(n2).forEach(function(t3) {
    var r3, o3, i2 = n2[t3];
    if ("key" !== t3) {
      if (!Yf$1.includes(t3)) {
        if (t3.startsWith("data-")) {
          var a2 = t3.slice(5);
          return a2 = lodash_camelcase(a2), function(e4, t4) {
            null == e4.data && (e4.data = {});
            var n3 = e4.data;
            null == n3.dataset && (n3.dataset = {});
            Object.assign(n3.dataset, t4);
          }(e3, ((r3 = {})[a2] = i2, r3)), void delete n2[t3];
        }
        !function(e4, t4) {
          null == e4.data && (e4.data = {});
          var n3 = e4.data;
          null == n3.props && (n3.props = {});
          Object.assign(n3.props, t4);
        }(e3, (o3 = {}, o3[t3] = i2, o3)), delete n2[t3];
      }
    } else
      e3.key = i2;
  }), o2.length > 0 && o2.forEach(function(e4) {
    "string" != typeof e4 && Xf$1(e4);
  });
}
var Qf$1 = [];
function Zf$1(e3) {
  Qf$1.push(e3);
}
var ed$1 = {};
function td$1(e3) {
  var t2 = e3.type, n2 = e3.renderElem;
  ed$1[t2 || ""] = n2;
}
function nd$1(e3, t2, n2) {
  var r2 = n2.isInline(e3) ? "span" : "div";
  return jsx(r2, null, t2);
}
function rd$1(t2, n2) {
  var o2, i2 = rl$1.findKey(n2, t2), a2 = n2.isInline(t2), s2 = Editor$1.isVoid(n2, t2), l2 = dc$1(i2.id), u2 = { id: l2, key: i2.id, "data-slate-node": "element", "data-slate-inline": a2 }, c2 = t2.type, f2 = t2.children, d3 = void 0 === f2 ? [] : f2, h2 = function(e3) {
    return ed$1[e3] || nd$1;
  }(c2);
  o2 = s2 ? null : d3.map(function(e3, r2) {
    return sd$1(e3, r2, t2, n2);
  });
  var p2 = h2(t2, o2, n2);
  if (s2) {
    u2["data-slate-void"] = true;
    var g2 = a2 ? "span" : "div", v2 = fa$4(Node$1.texts(t2), 1), y2 = fa$4(v2[0], 1)[0], m2 = sd$1(y2, 0, t2, n2), b2 = jsx(g2, { "data-slate-spacer": true, style: { height: "0", color: "transparent", outline: "none", position: "absolute" } }, m2);
    p2 = jsx(g2, { style: { position: "relative" } }, p2, b2), ks$1.set(y2, 0), Es$1.set(y2, t2);
  }
  return null == p2.data && (p2.data = {}), Object.assign(p2.data, u2), s2 || a2 || (p2 = function(e3, t3) {
    var n3 = t3;
    return Qf$1.forEach(function(r2) {
      n3 = r2(e3, t3);
    }), n3;
  }(t2, p2)), cc$1(function() {
    var e3 = Hs$1(l2);
    null != e3 && (Ns$1.set(i2, e3), Ts$1.set(t2, e3), Cs$1.set(e3, t2));
  }), p2;
}
function od$1(e3, t2) {
  return void 0 === t2 && (t2 = false), jsx("span", { "data-slate-string": true }, t2 ? e3 + "\n" : e3);
}
function id$1(e3, t2) {
  return void 0 === e3 && (e3 = 0), void 0 === t2 && (t2 = false), jsx("span", { "data-slate-zero-width": t2 ? "n" : "z", "data-slate-length": e3 }, "\uFEFF", t2 ? jsx("br", null) : null);
}
function ad$1(t2, o2, i2) {
  if (null == t2.text)
    throw new Error("Current node is not slate Text " + JSON.stringify(t2));
  var s2 = rl$1.findKey(i2, t2), l2 = i2.getConfig().decorate;
  if (null == l2)
    throw new Error("Can not get config.decorate");
  var u2 = rl$1.findPath(i2, t2), c2 = l2([t2, u2]), f2 = Text.decorations(t2, c2), d3 = f2.map(function(a2, s3) {
    var l3 = function(t3, o3, i3, a3, s4) {
      void 0 === o3 && (o3 = false);
      var l4 = t3.text, u3 = rl$1.findPath(s4, i3), c3 = Path.parent(u3);
      if (Editor$1.isEditor(a3))
        throw new Error("Text node " + JSON.stringify(i3) + " parent is Editor");
      return s4.isVoid(a3) ? id$1(Node$1.string(a3).length) : "" !== l4 || a3.children[a3.children.length - 1] !== i3 || s4.isInline(a3) || "" !== Editor$1.string(s4, c3) ? "" === l4 ? id$1() : o3 && "\n" === l4.slice(-1) ? od$1(l4, true) : od$1(l4) : id$1(0, true);
    }(a2, s3 === f2.length - 1, t2, o2, i2);
    return l3 = function(e3, t3) {
      var n2 = t3;
      return Qf$1.forEach(function(t4) {
        n2 = t4(e3, n2);
      }), n2;
    }(a2, l3), jsx("span", { "data-slate-leaf": true }, l3);
  }), h2 = function(e3) {
    return "w-e-text-" + e3;
  }(s2.id), p2 = jsx("span", { "data-slate-node": "text", id: h2, key: s2.id }, d3);
  return cc$1(function() {
    var e3 = Hs$1(h2);
    null != e3 && (Ns$1.set(s2, e3), Ts$1.set(t2, e3), Cs$1.set(e3, t2));
  }), p2;
}
function sd$1(e3, t2, n2, r2) {
  return ks$1.set(e3, t2), Es$1.set(e3, n2), Element$1.isElement(e3) ? rd$1(e3, r2) : ad$1(e3, n2, r2);
}
function ld$1(e3, t2) {
  var n2, r2 = e3.$scroll, o2 = function(e4) {
    return "w-e-textarea-" + e4;
  }(e3.id), i2 = t2.getConfig(), a2 = i2.readOnly, s2 = i2.autoFocus, l2 = function(e4, t3) {
    return void 0 === t3 && (t3 = false), h$3("div#" + e4, { props: { contentEditable: !t3 } });
  }(o2, a2), u2 = t2.children || [];
  l2.children = u2.map(function(e4, n3) {
    var r3 = sd$1(e4, n3, t2, t2);
    return Xf$1(r3), r3;
  });
  var c2 = ws$1.get(e3);
  if (null == c2 && (c2 = true), c2) {
    var d3 = function(e4, t3) {
      return $$6('<div\n        id="' + e4 + '"\n        data-slate-editor\n        data-slate-node="value"\n        suppressContentEditableWarning\n        role="textarea"\n        spellCheck="true"\n        autoCorrect="true"\n        autoCapitalize="true"\n    ></div>');
    }(o2);
    r2.append(d3), e3.$textArea = d3, n2 = d3[0], (p2 = init([classModule, propsModule, styleModule, datasetModule, eventListenersModule]))(n2, l2), ws$1.set(e3, false), xs$1.set(e3, p2);
  } else {
    var h2 = Ss$1.get(e3), p2 = xs$1.get(e3);
    if (null == h2 || null == p2)
      return;
    n2 = h2.elm, p2(h2, l2);
  }
  if (null != n2 || null != (n2 = Hs$1(o2))) {
    if ((c2 ? s2 : t2.isFocused()) && n2.focus({ preventScroll: true }), c2) {
      var g2 = Bs$1(n2);
      g2 && Ms$1.set(t2, g2);
    }
    Os$1.set(t2, n2), Ts$1.set(t2, n2), Cs$1.set(n2, t2), Ss$1.set(e3, l2);
  }
}
function ud$1(e3) {
  return "object" == typeof e3 && null != e3 && 1 === e3.nodeType;
}
function cd$1(e3, t2) {
  return (!t2 || "hidden" !== e3) && "visible" !== e3 && "clip" !== e3;
}
function fd$1(e3, t2) {
  if (e3.clientHeight < e3.scrollHeight || e3.clientWidth < e3.scrollWidth) {
    var n2 = getComputedStyle(e3, null);
    return cd$1(n2.overflowY, t2) || cd$1(n2.overflowX, t2) || function(e4) {
      var t3 = function(e5) {
        if (!e5.ownerDocument || !e5.ownerDocument.defaultView)
          return null;
        try {
          return e5.ownerDocument.defaultView.frameElement;
        } catch (e6) {
          return null;
        }
      }(e4);
      return !!t3 && (t3.clientHeight < e4.scrollHeight || t3.clientWidth < e4.scrollWidth);
    }(e3);
  }
  return false;
}
function dd$1(e3, t2, n2, r2, o2, i2, a2, s2) {
  return i2 < e3 && a2 > t2 || i2 > e3 && a2 < t2 ? 0 : i2 <= e3 && s2 <= n2 || a2 >= t2 && s2 >= n2 ? i2 - e3 - r2 : a2 > t2 && s2 < n2 || i2 < e3 && s2 > n2 ? a2 - t2 + o2 : 0;
}
function hd$1(e3, t2) {
  var n2 = window, r2 = t2.scrollMode, o2 = t2.block, i2 = t2.inline, a2 = t2.boundary, s2 = t2.skipOverflowHiddenElements, l2 = "function" == typeof a2 ? a2 : function(e4) {
    return e4 !== a2;
  };
  if (!ud$1(e3))
    throw new TypeError("Invalid target");
  for (var u2 = document.scrollingElement || document.documentElement, c2 = [], f2 = e3; ud$1(f2) && l2(f2); ) {
    if ((f2 = f2.parentElement) === u2) {
      c2.push(f2);
      break;
    }
    null != f2 && f2 === document.body && fd$1(f2) && !fd$1(document.documentElement) || null != f2 && fd$1(f2, s2) && c2.push(f2);
  }
  for (var d3 = n2.visualViewport ? n2.visualViewport.width : innerWidth, h2 = n2.visualViewport ? n2.visualViewport.height : innerHeight, p2 = window.scrollX || pageXOffset, g2 = window.scrollY || pageYOffset, v2 = e3.getBoundingClientRect(), y2 = v2.height, m2 = v2.width, b2 = v2.top, w2 = v2.right, x2 = v2.bottom, S2 = v2.left, k2 = "start" === o2 || "nearest" === o2 ? b2 : "end" === o2 ? x2 : b2 + y2 / 2, E2 = "center" === i2 ? S2 + m2 / 2 : "end" === i2 ? w2 : S2, O2 = [], C2 = 0; C2 < c2.length; C2++) {
    var N2 = c2[C2], T2 = N2.getBoundingClientRect(), L2 = T2.height, M2 = T2.width, P2 = T2.top, D2 = T2.right, R2 = T2.bottom, j2 = T2.left;
    if ("if-needed" === r2 && b2 >= 0 && S2 >= 0 && x2 <= h2 && w2 <= d3 && b2 >= P2 && x2 <= R2 && S2 >= j2 && w2 <= D2)
      return O2;
    var A2 = getComputedStyle(N2), F2 = parseInt(A2.borderLeftWidth, 10), I2 = parseInt(A2.borderTopWidth, 10), _2 = parseInt(A2.borderRightWidth, 10), B2 = parseInt(A2.borderBottomWidth, 10), $2 = 0, W2 = 0, V2 = "offsetWidth" in N2 ? N2.offsetWidth - N2.clientWidth - F2 - _2 : 0, z2 = "offsetHeight" in N2 ? N2.offsetHeight - N2.clientHeight - I2 - B2 : 0;
    if (u2 === N2)
      $2 = "start" === o2 ? k2 : "end" === o2 ? k2 - h2 : "nearest" === o2 ? dd$1(g2, g2 + h2, h2, I2, B2, g2 + k2, g2 + k2 + y2, y2) : k2 - h2 / 2, W2 = "start" === i2 ? E2 : "center" === i2 ? E2 - d3 / 2 : "end" === i2 ? E2 - d3 : dd$1(p2, p2 + d3, d3, F2, _2, p2 + E2, p2 + E2 + m2, m2), $2 = Math.max(0, $2 + g2), W2 = Math.max(0, W2 + p2);
    else {
      $2 = "start" === o2 ? k2 - P2 - I2 : "end" === o2 ? k2 - R2 + B2 + z2 : "nearest" === o2 ? dd$1(P2, R2, L2, I2, B2 + z2, k2, k2 + y2, y2) : k2 - (P2 + L2 / 2) + z2 / 2, W2 = "start" === i2 ? E2 - j2 - F2 : "center" === i2 ? E2 - (j2 + M2 / 2) + V2 / 2 : "end" === i2 ? E2 - D2 + _2 + V2 : dd$1(j2, D2, M2, F2, _2 + V2, E2, E2 + m2, m2);
      var H2 = N2.scrollLeft, U2 = N2.scrollTop;
      k2 += U2 - ($2 = Math.max(0, Math.min(U2 + $2, N2.scrollHeight - L2 + z2))), E2 += H2 - (W2 = Math.max(0, Math.min(H2 + W2, N2.scrollWidth - M2 + V2)));
    }
    O2.push({ el: N2, top: $2, left: W2 });
  }
  return O2;
}
function pd$1(e3) {
  return e3 === Object(e3) && 0 !== Object.keys(e3).length;
}
function gd$1(e3, t2) {
  var n2 = !e3.ownerDocument.documentElement.contains(e3);
  if (pd$1(t2) && "function" == typeof t2.behavior)
    return t2.behavior(n2 ? [] : hd$1(e3, t2));
  if (!n2) {
    var r2 = function(e4) {
      return false === e4 ? { block: "end", inline: "nearest" } : pd$1(e4) ? e4 : { block: "start", inline: "nearest" };
    }(t2);
    return function(e4, t3) {
      void 0 === t3 && (t3 = "auto");
      var n3 = "scrollBehavior" in document.body.style;
      e4.forEach(function(e5) {
        var r3 = e5.el, o2 = e5.top, i2 = e5.left;
        r3.scroll && n3 ? r3.scroll({ top: o2, left: i2, behavior: t3 }) : (r3.scrollTop = o2, r3.scrollLeft = i2);
      });
    }(hd$1(e3, r2), r2.behavior);
  }
}
function vd$1(e3, t2) {
  return Ws$1(t2) && rl$1.hasDOMNode(e3, t2, { editable: true });
}
function yd$1(t2, n2) {
  if (t2.getConfig().readOnly)
    return false;
  var r2 = md$1(t2, n2) && rl$1.toSlateNode(t2, n2);
  return Editor$1.isVoid(t2, r2);
}
function md$1(e3, t2) {
  return Ws$1(t2) && rl$1.hasDOMNode(e3, t2);
}
function bd$1(e3, t2, n2) {
  void 0 === n2 && (n2 = false);
  var r2 = t2.selection, i2 = t2.getConfig(), a2 = rl$1.findDocumentOrShadowRoot(t2).getSelection();
  if (a2 && (!e3.isComposing || n2) && t2.isFocused()) {
    var s2 = "None" !== a2.type;
    if (r2 || s2) {
      var l2 = Os$1.get(t2), u2 = false;
      if (l2.contains(a2.anchorNode) && l2.contains(a2.focusNode) && (u2 = true), s2 && u2 && r2) {
        var c2 = rl$1.toSlateRange(t2, a2, { exactMatch: true, suppressThrow: true });
        if (c2 && Range.equals(c2, r2)) {
          var f2 = true;
          if (Range.isCollapsed(r2)) {
            var d3 = a2.anchorNode, h2 = a2.anchorOffset;
            if (d3 === l2) {
              var p2 = l2.childNodes, g2 = void 0;
              (g2 = p2[h2]) && g2.matches("table") && (f2 = false), (g2 = p2[h2 - 1]) && g2.matches("table") && (f2 = false);
            }
          }
          if (f2)
            return;
        }
      }
      if (!r2 || rl$1.hasRange(t2, r2)) {
        e3.isUpdatingSelection = true;
        var v2 = r2 && rl$1.toDOMRange(t2, r2);
        if (v2) {
          Range.isBackward(r2) ? a2.setBaseAndExtent(v2.endContainer, v2.endOffset, v2.startContainer, v2.startOffset) : a2.setBaseAndExtent(v2.startContainer, v2.startOffset, v2.endContainer, v2.endOffset);
          var y2 = v2.startContainer.parentElement;
          if (!y2.closest("[data-slate-spacer]")) {
            y2.getBoundingClientRect = v2.getBoundingClientRect.bind(v2);
            var m2 = document.body;
            gd$1(y2, { scrollMode: "if-needed", boundary: i2.scroll ? l2.parentElement : m2, block: "end", behavior: "smooth" }), delete y2.getBoundingClientRect;
          }
        } else
          a2.removeAllRanges();
        setTimeout(function() {
          v2 && Xs$1 && l2.focus(), e3.isUpdatingSelection = false;
        });
      } else
        t2.selection = rl$1.toSlateRange(t2, a2, { exactMatch: false, suppressThrow: false });
    }
  }
}
var wd$1 = /* @__PURE__ */ new WeakMap(), xd$1 = /* @__PURE__ */ new WeakMap();
var Sd$1 = { bold: "mod+b", compose: ["down", "left", "right", "up", "backspace", "enter"], moveBackward: "left", moveForward: "right", moveWordBackward: "ctrl+left", moveWordForward: "ctrl+right", deleteBackward: "shift?+backspace", deleteForward: "shift?+delete", extendBackward: "shift+left", extendForward: "shift+right", italic: "mod+i", splitBlock: "shift?+enter", undo: "mod+z", tab: "tab", selectAll: "mod+a" }, kd$1 = { moveLineBackward: "opt+up", moveLineForward: "opt+down", moveWordBackward: "opt+left", moveWordForward: "opt+right", deleteBackward: ["ctrl+backspace", "ctrl+h"], deleteForward: ["ctrl+delete", "ctrl+d"], deleteLineBackward: "cmd+shift?+backspace", deleteLineForward: ["cmd+shift?+delete", "ctrl+k"], deleteWordBackward: "opt+shift?+backspace", deleteWordForward: "opt+shift?+delete", extendLineBackward: "opt+shift+up", extendLineForward: "opt+shift+down", redo: "cmd+shift+z", transposeCharacter: "ctrl+t" }, Ed$1 = { deleteWordBackward: "ctrl+shift?+backspace", deleteWordForward: "ctrl+shift?+delete", redo: ["ctrl+y", "ctrl+shift+z"] }, Od$1 = function(e3) {
  var t2 = Sd$1[e3], n2 = kd$1[e3], r2 = Ed$1[e3], o2 = t2 && isKeyHotkey_1(t2), i2 = n2 && isKeyHotkey_1(n2), a2 = r2 && isKeyHotkey_1(r2);
  return function(e4) {
    return !(!o2 || !o2(e4)) || (!!(Ys$1 && i2 && i2(e4)) || !(Ys$1 || !a2 || !a2(e4)));
  };
}, Cd$1 = { isBold: Od$1("bold"), isCompose: Od$1("compose"), isMoveBackward: Od$1("moveBackward"), isMoveForward: Od$1("moveForward"), isDeleteBackward: Od$1("deleteBackward"), isDeleteForward: Od$1("deleteForward"), isDeleteLineBackward: Od$1("deleteLineBackward"), isDeleteLineForward: Od$1("deleteLineForward"), isDeleteWordBackward: Od$1("deleteWordBackward"), isDeleteWordForward: Od$1("deleteWordForward"), isExtendBackward: Od$1("extendBackward"), isExtendForward: Od$1("extendForward"), isExtendLineBackward: Od$1("extendLineBackward"), isExtendLineForward: Od$1("extendLineForward"), isItalic: Od$1("italic"), isMoveLineBackward: Od$1("moveLineBackward"), isMoveLineForward: Od$1("moveLineForward"), isMoveWordBackward: Od$1("moveWordBackward"), isMoveWordForward: Od$1("moveWordForward"), isRedo: Od$1("redo"), isSplitBlock: Od$1("splitBlock"), isTransposeCharacter: Od$1("transposeCharacter"), isUndo: Od$1("undo"), isTab: Od$1("tab"), isSelectAll: Od$1("selectAll") };
function Nd$1(e3) {
  e3.preventDefault();
}
var Td$1 = { beforeinput: function(t2, n2, r2) {
  var i2 = t2, a2 = r2.getConfig().readOnly;
  if (nl$1 && !a2 && vd$1(r2, i2.target)) {
    var l2 = r2.selection, u2 = i2.inputType, c2 = i2.dataTransfer || i2.data || void 0;
    if ("insertCompositionText" !== u2 && "deleteCompositionText" !== u2) {
      if (i2.preventDefault(), !u2.startsWith("delete") || u2.startsWith("deleteBy")) {
        var f2 = fa$4(i2.getTargetRanges(), 1)[0];
        if (f2) {
          var d3 = rl$1.toSlateRange(r2, f2, { exactMatch: false, suppressThrow: false });
          l2 && Range.equals(l2, d3) || Transforms.select(r2, d3);
        }
      }
      if (l2 && Range.isExpanded(l2) && u2.startsWith("delete")) {
        var h2 = u2.endsWith("Backward") ? "backward" : "forward";
        Editor$1.deleteFragment(r2, { direction: h2 });
      } else
        switch (u2) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            Editor$1.deleteFragment(r2);
            break;
          case "deleteContent":
          case "deleteContentForward":
            Editor$1.deleteForward(r2);
            break;
          case "deleteContentBackward":
            Editor$1.deleteBackward(r2);
            break;
          case "deleteEntireSoftLine":
            Editor$1.deleteBackward(r2, { unit: "line" }), Editor$1.deleteForward(r2, { unit: "line" });
            break;
          case "deleteHardLineBackward":
            Editor$1.deleteBackward(r2, { unit: "block" });
            break;
          case "deleteSoftLineBackward":
            Editor$1.deleteBackward(r2, { unit: "line" });
            break;
          case "deleteHardLineForward":
            Editor$1.deleteForward(r2, { unit: "block" });
            break;
          case "deleteSoftLineForward":
            Editor$1.deleteForward(r2, { unit: "line" });
            break;
          case "deleteWordBackward":
            Editor$1.deleteBackward(r2, { unit: "word" });
            break;
          case "deleteWordForward":
            Editor$1.deleteForward(r2, { unit: "word" });
            break;
          case "insertLineBreak":
          case "insertParagraph":
            Editor$1.insertBreak(r2);
            break;
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText":
            if ("insertFromPaste" === u2 && !js$1.get(r2))
              break;
            c2 instanceof DataTransfer ? r2.insertData(c2) : "string" == typeof c2 && Editor$1.insertText(r2, c2);
        }
    }
  }
}, blur: function(e3, t2, n2) {
  var r2 = e3, o2 = t2.isUpdatingSelection, a2 = t2.latestElement;
  if (!n2.getConfig().readOnly && !o2 && vd$1(n2, r2.target)) {
    var s2 = rl$1.findDocumentOrShadowRoot(n2);
    if (a2 !== s2.activeElement) {
      var l2 = r2.relatedTarget;
      if (!(l2 === rl$1.toDOMNode(n2, n2) || $s$1(l2) && l2.hasAttribute("data-slate-spacer"))) {
        if (null != l2 && Ws$1(l2) && rl$1.hasDOMNode(n2, l2)) {
          var u2 = rl$1.toSlateNode(n2, l2);
          if (Element$1.isElement(u2) && !n2.isVoid(u2))
            return;
        }
        if (Qs$1) {
          var c2 = s2.getSelection();
          null == c2 || c2.removeAllRanges();
        }
        Ps$1.delete(n2);
      }
    }
  }
}, focus: function(e3, t2, n2) {
  var r2 = rl$1.toDOMNode(n2, n2), o2 = rl$1.findDocumentOrShadowRoot(n2);
  t2.latestElement = o2.activeElement, Xs$1 && e3.target !== r2 ? r2.focus() : Ps$1.set(n2, true);
}, click: function(t2, o2, i2) {
  if (!i2.getConfig().readOnly && md$1(i2, t2.target) && Ws$1(t2.target)) {
    var a2 = rl$1.toSlateNode(i2, t2.target), l2 = rl$1.findPath(i2, a2);
    if (Editor$1.hasPath(i2, l2)) {
      if (Node$1.get(i2, l2) === a2) {
        var u2 = Editor$1.start(i2, l2), c2 = Editor$1.end(i2, l2), f2 = Editor$1.void(i2, { at: u2 }), d3 = Editor$1.void(i2, { at: c2 });
        if (f2 && d3 && Path.equals(f2[1], d3[1])) {
          var h2 = Editor$1.range(i2, u2);
          Transforms.select(i2, h2);
        }
      }
    }
  }
}, compositionstart: function(t2, n2, r2) {
  if (vd$1(r2, t2.target)) {
    var i2 = r2.selection;
    if (i2 && Range.isExpanded(i2) && (Editor$1.deleteFragment(r2), Promise.resolve().then(function() {
      bd$1(n2, r2, true);
    })), i2 && Range.isCollapsed(i2)) {
      var a2 = rl$1.toDOMRange(r2, i2).startContainer, s2 = a2.textContent || "";
      wd$1.set(r2, s2), xd$1.set(r2, a2);
    }
    n2.isComposing = true, function(e3, t3) {
      var n3;
      t3.getConfig().placeholder && t3.isEmpty() && e3.showPlaceholder && (null === (n3 = e3.$placeholder) || void 0 === n3 || n3.hide(), e3.showPlaceholder = false);
    }(n2, r2);
  }
}, compositionend: function(t2, n2, r2) {
  var a2 = t2;
  if (vd$1(r2, a2.target)) {
    n2.isComposing = false;
    var s2 = r2.selection;
    if (null != s2) {
      (tl$1 || Xs$1) && rl$1.cleanExposedTexNodeInSelectionBlock(r2);
      for (var l2 = Range.isBackward(s2) ? s2.focus : s2.anchor, u2 = fa$4(Editor$1.node(r2, [l2.path[0]]), 1)[0], c2 = 0; c2 < l2.path.length; c2++) {
        var f2 = fa$4(Editor$1.node(r2, l2.path.slice(0, c2 + 1)), 1)[0];
        if (Element$1.isElement(f2) && ((Qs$1 || Xs$1) && "link" === f2.type || "code" === f2.type)) {
          rl$1.setNewKey(u2);
          break;
        }
      }
      var d3 = a2.data;
      if (d3) {
        if (r2.getConfig().maxLength) {
          var h2 = rl$1.getLeftLengthOfMaxLength(r2);
          if (h2 < d3.length)
            rl$1.toDOMRange(r2, s2).startContainer.textContent = wd$1.get(r2) || "", h2 > 0 && Editor$1.insertText(r2, d3.slice(0, h2)), n2.changeViewState();
          else
            Editor$1.insertText(r2, d3);
        } else
          Editor$1.insertText(r2, d3);
        Qs$1 || setTimeout(function() {
          var e3 = r2.selection;
          if (null != e3) {
            var t3 = xd$1.get(r2);
            if (null != t3)
              rl$1.toDOMRange(r2, e3).startContainer !== t3 && (t3.textContent = wd$1.get(r2) || "");
          }
        });
      }
    }
  }
}, compositionupdate: function(e3, t2, n2) {
  vd$1(n2, e3.target) && (t2.isComposing = true);
}, keydown: function(t2, n2, a2) {
  var l2 = t2, u2 = a2.selection;
  if (!a2.getConfig().readOnly && !n2.isComposing && vd$1(a2, l2.target)) {
    if (function(e3, t3) {
      var n3 = hs$1.get(e3), r2 = n3 && n3.getMenus(), o2 = gs$1.get(e3), i2 = o2 && o2.getMenus(), a3 = ua$4(ua$4({}, r2), i2);
      for (var s2 in a3) {
        var l3 = a3[s2], u3 = l3.hotkey;
        if (u3 && isHotkey_1(u3, t3) && !l3.isDisabled(e3)) {
          var c3 = l3.getValue(e3);
          l3.exec(e3, c3);
        }
      }
    }(a2, l2), Cd$1.isTab(l2))
      return Nd$1(l2), void a2.handleTab();
    if (Cd$1.isRedo(l2))
      return Nd$1(l2), void ("function" == typeof a2.redo && a2.redo());
    if (Cd$1.isUndo(l2))
      return Nd$1(l2), void ("function" == typeof a2.undo && a2.undo());
    if (Cd$1.isMoveLineBackward(l2))
      return Nd$1(l2), void Transforms.move(a2, { unit: "line", reverse: true });
    if (Cd$1.isMoveLineForward(l2))
      return Nd$1(l2), void Transforms.move(a2, { unit: "line" });
    if (Cd$1.isExtendLineBackward(l2))
      return Nd$1(l2), void Transforms.move(a2, { unit: "line", edge: "focus", reverse: true });
    if (Cd$1.isExtendLineForward(l2))
      return Nd$1(l2), void Transforms.move(a2, { unit: "line", edge: "focus" });
    if (Cd$1.isMoveBackward(l2))
      return Nd$1(l2), void (u2 && Range.isCollapsed(u2) ? Transforms.move(a2, { reverse: true }) : Transforms.collapse(a2, { edge: "start" }));
    if (Cd$1.isMoveForward(l2))
      return Nd$1(l2), void (u2 && Range.isCollapsed(u2) ? Transforms.move(a2) : Transforms.collapse(a2, { edge: "end" }));
    if (Cd$1.isMoveWordBackward(l2))
      return Nd$1(l2), u2 && Range.isExpanded(u2) && Transforms.collapse(a2, { edge: "focus" }), void Transforms.move(a2, { unit: "word", reverse: true });
    if (Cd$1.isMoveWordForward(l2))
      return Nd$1(l2), u2 && Range.isExpanded(u2) && Transforms.collapse(a2, { edge: "focus" }), void Transforms.move(a2, { unit: "word" });
    if (Cd$1.isSelectAll(l2))
      return Nd$1(l2), void a2.selectAll();
    if (nl$1) {
      if ((tl$1 || Qs$1) && u2 && (Cd$1.isDeleteBackward(l2) || Cd$1.isDeleteForward(l2)) && Range.isCollapsed(u2)) {
        var c2 = Node$1.parent(a2, u2.anchor.path);
        if (Element$1.isElement(c2) && Editor$1.isVoid(a2, c2) && Editor$1.isInline(a2, c2))
          return l2.preventDefault(), void Transforms.delete(a2, { unit: "block" });
      }
    } else {
      if (Cd$1.isBold(l2) || Cd$1.isItalic(l2) || Cd$1.isTransposeCharacter(l2))
        return void Nd$1(l2);
      if (Cd$1.isSplitBlock(l2))
        return Nd$1(l2), void Editor$1.insertBreak(a2);
      if (Cd$1.isDeleteBackward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "backward" }) : Editor$1.deleteBackward(a2));
      if (Cd$1.isDeleteForward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "forward" }) : Editor$1.deleteForward(a2));
      if (Cd$1.isDeleteLineBackward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "backward" }) : Editor$1.deleteBackward(a2, { unit: "line" }));
      if (Cd$1.isDeleteLineForward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "forward" }) : Editor$1.deleteForward(a2, { unit: "line" }));
      if (Cd$1.isDeleteWordBackward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "backward" }) : Editor$1.deleteBackward(a2, { unit: "word" }));
      if (Cd$1.isDeleteWordForward(l2))
        return Nd$1(l2), void (u2 && Range.isExpanded(u2) ? Editor$1.deleteFragment(a2, { direction: "forward" }) : Editor$1.deleteForward(a2, { unit: "word" }));
    }
  }
}, keypress: function(t2, n2, r2) {
  if (!nl$1 && !r2.getConfig().readOnly && vd$1(r2, t2.target)) {
    t2.preventDefault();
    var o2 = t2.key;
    Editor$1.insertText(r2, o2);
  }
}, copy: function(e3, t2, n2) {
  var r2 = e3;
  if (vd$1(n2, r2.target)) {
    r2.preventDefault();
    var o2 = r2.clipboardData;
    null != o2 && n2.setFragmentData(o2);
  }
}, cut: function(t2, n2, i2) {
  var a2 = t2, l2 = i2.selection;
  if (!i2.getConfig().readOnly && vd$1(i2, a2.target)) {
    a2.preventDefault();
    var u2 = a2.clipboardData;
    if (null != u2 && (i2.setFragmentData(u2), l2))
      if (Range.isExpanded(l2))
        Editor$1.deleteFragment(i2);
      else {
        var c2 = Node$1.parent(i2, l2.anchor.path);
        Editor$1.isVoid(i2, c2) && Transforms.delete(i2);
      }
  }
}, paste: function(e3, t2, n2) {
  js$1.set(n2, true);
  var r2 = e3;
  if (!n2.getConfig().readOnly && vd$1(n2, r2.target)) {
    var o2 = n2.getConfig().customPaste;
    if (o2) {
      if (false === o2(n2, r2))
        return void js$1.set(n2, false);
    }
    if (!nl$1 || function(e4) {
      return e4.clipboardData && "" !== e4.clipboardData.getData("text/plain") && 1 === e4.clipboardData.types.length;
    }(r2)) {
      r2.preventDefault();
      var i2 = r2.clipboardData;
      null != i2 && n2.insertData(i2);
    }
  }
}, dragover: function(t2, n2, r2) {
  if (md$1(r2, t2.target)) {
    var o2 = rl$1.toSlateNode(r2, t2.target);
    Editor$1.isVoid(r2, o2) && t2.preventDefault();
  }
}, dragstart: function(t2, n2, r2) {
  var o2 = t2;
  if (md$1(r2, o2.target) && !r2.getConfig().readOnly) {
    var i2 = rl$1.toSlateNode(r2, o2.target), a2 = rl$1.findPath(r2, i2);
    if (Editor$1.isVoid(r2, i2) || Editor$1.void(r2, { at: a2, voids: true })) {
      var l2 = Editor$1.range(r2, a2);
      Transforms.select(r2, l2);
    }
    var u2 = o2.dataTransfer;
    null != u2 && (n2.isDraggingInternally = true, r2.setFragmentData(u2));
  }
}, dragend: function(e3, t2, n2) {
  var r2 = e3;
  n2.getConfig().readOnly || t2.isDraggingInternally && md$1(n2, r2.target) && (t2.isDraggingInternally = false);
}, drop: function(e3, t2, n2) {
  var r2 = e3, o2 = r2.dataTransfer;
  if (!n2.getConfig().readOnly && md$1(n2, r2.target) && null != o2 && !(nl$1 && Qs$1 && o2.files.length > 0)) {
    r2.preventDefault();
    var i2 = n2.selection, a2 = rl$1.findEventRange(n2, r2);
    Transforms.select(n2, a2), t2.isDraggingInternally && (i2 && Transforms.delete(n2, { at: i2 }), t2.isDraggingInternally = false), n2.insertData(o2), n2.isFocused() || n2.focus();
  }
} }, Ld$1 = 1, Md$1 = function() {
  function e3(e4) {
    var t2 = this;
    this.id = Ld$1++, this.$textArea = null, this.$progressBar = $$6('<div class="w-e-progress-bar"></div>'), this.$maxLengthInfo = $$6('<div class="w-e-max-length-info"></div>'), this.isComposing = false, this.isUpdatingSelection = false, this.isDraggingInternally = false, this.latestElement = null, this.showPlaceholder = false, this.$placeholder = null, this.latestEditorSelection = null, this.onDOMSelectionChange = lodash_throttle(function() {
      var e5 = t2.editorInstance;
      !function(e6, t3) {
        var n3 = e6.isComposing, r3 = e6.isUpdatingSelection, o3 = e6.isDraggingInternally;
        if (!(t3.getConfig().readOnly || n3 || r3 || o3)) {
          var i2 = rl$1.findDocumentOrShadowRoot(t3), a2 = i2.activeElement, l2 = rl$1.toDOMNode(t3, t3), u2 = i2.getSelection();
          if (a2 === l2 ? (e6.latestElement = a2, Ps$1.set(t3, true)) : Ps$1.delete(t3), !u2)
            return Transforms.deselect(t3);
          var c2 = u2.anchorNode, f2 = u2.focusNode, d3 = vd$1(t3, c2) || yd$1(t3, c2), h2 = vd$1(t3, f2) || yd$1(t3, f2);
          if (d3 && h2) {
            var p2 = rl$1.toSlateRange(t3, u2, { exactMatch: false, suppressThrow: false });
            Transforms.select(t3, p2);
          } else
            Transforms.deselect(t3);
        }
      }(t2, e5);
    }, 100);
    var n2 = $$6(e4);
    if (0 === n2.length)
      throw new Error("Cannot find textarea DOM by selector '" + e4 + "'");
    this.$box = n2;
    var r2 = $$6('<div class="w-e-text-container"></div>');
    r2.append(this.$progressBar), r2.append(this.$maxLengthInfo), n2.append(r2);
    var o2 = $$6('<div class="w-e-scroll"></div>');
    r2.append(o2), this.$scroll = o2, this.$textAreaContainer = r2, cc$1(function() {
      var e5 = t2.editorInstance, n3 = rl$1.getWindow(e5);
      n3.document.addEventListener("selectionchange", t2.onDOMSelectionChange), e5.on("destroyed", function() {
        n3.document.removeEventListener("selectionchange", t2.onDOMSelectionChange);
      }), r2.on("click", function() {
        return e5.hidePanelOrModal();
      }), e5.on("change", t2.changeViewState.bind(t2));
      var o3 = e5.getConfig().onChange;
      o3 && e5.on("change", function() {
        return o3(e5);
      }), t2.onFocusAndOnBlur(), e5.on("change", t2.changeMaxLengthInfo.bind(t2)), t2.bindEvent();
    });
  }
  return Object.defineProperty(e3.prototype, "editorInstance", { get: function() {
    var e4 = fs$1.get(this);
    if (null == e4)
      throw new Error("Can not get editor instance");
    return e4;
  }, enumerable: false, configurable: true }), e3.prototype.bindEvent = function() {
    var e4 = this, t2 = this.$textArea, n2 = this.$scroll, r2 = this.editorInstance;
    null != t2 && (lodash_foreach(Td$1, function(n3, o2) {
      t2.on(o2, function(t3) {
        n3(t3, e4, r2);
      });
    }), r2.getConfig().scroll && (n2.css("overflow-y", "auto"), n2.on("scroll", lodash_throttle(function() {
      r2.emit("scroll");
    }, 100))));
  }, e3.prototype.onFocusAndOnBlur = function() {
    var e4 = this, t2 = this.editorInstance, n2 = t2.getConfig(), r2 = n2.onBlur, o2 = n2.onFocus;
    this.latestEditorSelection = t2.selection, t2.on("change", function() {
      null == e4.latestEditorSelection && null != t2.selection ? o2 && o2(t2) : null != e4.latestEditorSelection && null == t2.selection && r2 && r2(t2), e4.latestEditorSelection = t2.selection;
    });
  }, e3.prototype.changeMaxLengthInfo = function() {
    var e4 = this.editorInstance, t2 = e4.getConfig().maxLength;
    if (t2) {
      var n2 = t2 - rl$1.getLeftLengthOfMaxLength(e4);
      this.$maxLengthInfo[0].innerHTML = n2 + "/" + t2;
    }
  }, e3.prototype.changeProgress = function(e4) {
    var t2 = this.$progressBar;
    t2.css("width", e4 + "%"), e4 >= 100 && setTimeout(function() {
      t2.hide(), t2.css("width", "0"), t2.show();
    }, 1e3);
  }, e3.prototype.changeViewState = function() {
    var e4 = this, t2 = this.editorInstance;
    ld$1(this, t2), function(e5, t3) {
      var n2, r2 = t3.getConfig().placeholder;
      if (r2) {
        var o2 = t3.isEmpty();
        if (o2 && !e5.showPlaceholder && !e5.isComposing) {
          if (null == e5.$placeholder) {
            var i2 = $$6('<div class="w-e-text-placeholder">' + r2 + "</div>");
            e5.$textAreaContainer.append(i2), e5.$placeholder = i2;
          }
          return e5.$placeholder.show(), void (e5.showPlaceholder = true);
        }
        !o2 && e5.showPlaceholder && (null === (n2 = e5.$placeholder) || void 0 === n2 || n2.hide(), e5.showPlaceholder = false);
      }
    }(this, t2), cc$1(function() {
      bd$1(e4, t2);
    });
  }, e3.prototype.destroy = function() {
    this.$textAreaContainer.remove();
  }, e3;
}();
$i$3("match", function(e3, t2, n2) {
  return [function(t3) {
    var n3 = ye$6(this), r2 = null == t3 ? void 0 : ut$6(t3, e3);
    return r2 ? tt$6(r2, t3, n3) : new RegExp(t3)[e3](Sr$5(n3));
  }, function(e4) {
    var r2 = Ze$6(this), o2 = Sr$5(e4), i2 = n2(t2, r2, o2);
    if (i2.done)
      return i2.value;
    if (!r2.global)
      return Xi$3(r2, o2);
    var a2 = r2.unicode;
    r2.lastIndex = 0;
    for (var s2, l2 = [], u2 = 0; null !== (s2 = Xi$3(r2, o2)); ) {
      var c2 = Sr$5(s2[0]);
      l2[u2] = c2, "" === c2 && (r2.lastIndex = Vi$3(o2, fn$6(r2.lastIndex), a2)), u2++;
    }
    return 0 === u2 ? null : l2;
  }];
});
function Pd$1(e3) {
  e3.removeAttr("width"), e3.removeAttr("height"), e3.removeAttr("fill"), e3.removeAttr("class"), e3.removeAttr("t"), e3.removeAttr("p-id");
  var t2 = e3.children();
  t2.length && Pd$1(t2);
}
function Dd$1() {
  return $$6('<svg viewBox="0 0 1024 1024"><path d="M498.7 655.8l-197.6-268c-8.1-10.9-0.3-26.4 13.3-26.4h395.2c13.6 0 21.4 15.4 13.3 26.4l-197.6 268c-6.6 9-20 9-26.6 0z"></path></svg>');
}
function Rd$1() {
  return $$6('<div class="w-e-bar-divider"></div>');
}
function jd$1(e3, t2, n2, r2, o2) {
  if (void 0 === o2 && (o2 = false), t2) {
    if (r2) {
      var i2 = Ys$1 ? "cmd" : "ctrl";
      r2 = r2.replace("mod", i2);
    }
    if (o2)
      r2 && (e3.attr("data-tooltip", r2), e3.addClass("w-e-menu-tooltip-v5"), e3.addClass("tooltip-right"));
    else {
      var a2 = r2 ? n2 + "\n" + r2 : n2;
      e3.attr("data-tooltip", a2), e3.addClass("w-e-menu-tooltip-v5");
    }
  }
}
var Ad$1 = function() {
  function e3(e4, t2) {
    var n2 = this;
    void 0 === t2 && (t2 = false), this.$elem = $$6('<div class="w-e-bar-item"></div>'), this.$button = $$6('<button type="button"></button>'), this.disabled = false, this.menu = e4;
    var r2 = e4.tag, o2 = e4.width;
    if ("button" !== r2)
      throw new Error("Invalid tag '" + r2 + "', expected 'button'");
    var i2 = e4.title, a2 = e4.hotkey, s2 = void 0 === a2 ? "" : a2, l2 = e4.iconSvg, u2 = void 0 === l2 ? "" : l2, c2 = this.$button;
    if (u2) {
      var d3 = $$6(u2);
      Pd$1(d3), c2.append(d3);
    } else
      c2.text(i2);
    jd$1(c2, u2, i2, s2, t2), t2 && u2 && c2.append($$6('<span class="title">' + i2 + "</span>")), o2 && c2.css("width", o2 + "px"), this.$elem.append(c2), cc$1(function() {
      return n2.init();
    });
  }
  return e3.prototype.init = function() {
    var e4 = this;
    this.setActive(), this.setDisabled(), this.$button.on("click", function(t2) {
      t2.preventDefault(), Jd(e4).hidePanelOrModal(), e4.disabled || (e4.exec(), e4.onButtonClick());
    });
  }, e3.prototype.exec = function() {
    var e4 = Jd(this), t2 = this.menu, n2 = t2.getValue(e4);
    t2.exec(e4, n2);
  }, e3.prototype.setActive = function() {
    var e4 = Jd(this), t2 = this.$button, n2 = "active";
    this.menu.isActive(e4) ? t2.addClass(n2) : t2.removeClass(n2);
  }, e3.prototype.setDisabled = function() {
    var e4 = Jd(this), t2 = this.$button, n2 = this.menu.isDisabled(e4);
    (null == e4.selection || e4.isDisabled()) && (n2 = true), this.menu.alwaysEnable && (n2 = false);
    var r2 = "disabled";
    n2 ? t2.addClass(r2) : t2.removeClass(r2), this.disabled = n2;
  }, e3.prototype.changeMenuState = function() {
    this.setActive(), this.setDisabled();
  }, e3;
}(), Fd$1 = function(e3) {
  function t2(t3, n2) {
    return void 0 === n2 && (n2 = false), e3.call(this, t3, n2) || this;
  }
  return la$4(t2, e3), t2.prototype.onButtonClick = function() {
  }, t2;
}(Ad$1), Id$1 = function() {
  function e3(e4) {
    this.isShow = false, this.showTime = 0, this.record(e4);
  }
  return e3.prototype.record = function(e4) {
    var t2 = ys$1.get(e4);
    null == t2 && (t2 = /* @__PURE__ */ new Set(), ys$1.set(e4, t2)), t2.add(this), ms$1.set(this, e4);
  }, e3.prototype.renderContent = function(e4) {
    var t2 = this.$elem;
    t2.empty(), t2.append(e4);
    var n2 = this.genSelfElem();
    n2 && t2.append(n2);
  }, e3.prototype.appendTo = function(e4) {
    var t2 = this.$elem;
    e4.append(t2);
  }, e3.prototype.show = function() {
    if (!this.isShow) {
      this.showTime = Date.now(), this.$elem.show(), this.isShow = true;
      var e4 = ms$1.get(this);
      e4 && e4.emit("modalOrPanelShow", this);
    }
  }, e3.prototype.hide = function() {
    if (this.isShow && !(Date.now() - this.showTime < 200)) {
      this.$elem.hide(), this.isShow = false;
      var e4 = ms$1.get(this);
      e4 && e4.emit("modalOrPanelHide");
    }
  }, e3;
}(), _d$1 = function(e3) {
  function t2(t3) {
    var n2 = e3.call(this, t3) || this;
    return n2.type = "dropPanel", n2.$elem = $$6('<div class="w-e-drop-panel"></div>'), n2;
  }
  return la$4(t2, e3), t2.prototype.genSelfElem = function() {
    return null;
  }, t2;
}(Id$1), Bd$1 = function(e3) {
  function t2(t3, n2) {
    void 0 === n2 && (n2 = false);
    var r2 = e3.call(this, t3, n2) || this;
    if (r2.dropPanel = null, r2.menu = t3, t3.showDropPanel) {
      var o2 = Dd$1();
      r2.$button.append(o2);
    }
    return r2;
  }
  return la$4(t2, e3), t2.prototype.onButtonClick = function() {
    this.menu.showDropPanel && this.handleDropPanel();
  }, t2.prototype.handleDropPanel = function() {
    var e4 = this.menu;
    if (null != e4.getPanelContentElem) {
      var t3 = Jd(this);
      if (null == this.dropPanel) {
        var n2 = new _d$1(t3), r2 = e4.getPanelContentElem(t3);
        n2.renderContent(r2), n2.appendTo(this.$elem), n2.show(), this.dropPanel = n2;
      } else {
        var o2 = this.dropPanel;
        if (o2.isShow)
          o2.hide();
        else {
          r2 = e4.getPanelContentElem(t3);
          o2.renderContent(r2), o2.show();
        }
      }
      var i2 = this.dropPanel;
      if (i2.isShow) {
        var a2 = this.$elem, s2 = a2.offset().left, l2 = a2.parents(".w-e-bar");
        s2 - l2.offset().left >= l2.width() / 2 ? i2.$elem.css({ left: "none", right: "0" }) : i2.$elem.css({ left: "0", right: "none" });
      }
    }
  }, t2;
}(Ad$1), $d$1 = function(e3) {
  function t2(t3, n2) {
    void 0 === n2 && (n2 = 0);
    var r2 = e3.call(this, t3) || this;
    r2.type = "modal", r2.$elem = $$6('<div class="w-e-modal"></div>'), r2.width = 0, n2 && (r2.width = n2);
    var o2 = r2.$elem;
    return o2.on("click", function(e4) {
      return e4.stopPropagation();
    }), o2.on("keyup", function(e4) {
      "Escape" === e4.code && (r2.hide(), t3.restoreSelection());
    }), r2;
  }
  return la$4(t2, e3), t2.prototype.genSelfElem = function() {
    var e4 = this, t3 = $$6('<span class="btn-close"><svg viewBox="0 0 1024 1024"><path d="M1024 896.1024l-128 128L512 640 128 1024 0 896 384 512 0 128 128 0 512 384 896.1024 0l128 128L640 512z"></path></svg></span>'), n2 = ms$1.get(this);
    return t3.on("click", function() {
      e4.hide(), null == n2 || n2.restoreSelection();
    }), t3;
  }, t2.prototype.setStyle = function(e4) {
    var t3 = this.width, n2 = this.$elem;
    n2.attr("style", ""), t3 && n2.css("width", t3 + "px"), n2.css(e4);
  }, t2;
}(Id$1);
function Wd$1(e3, t2, n2) {
  var r2 = $$6('<label class="babel-container"></label>');
  r2.append("<span>" + e3 + "</span>");
  var o2 = $$6('<input type="text" id="' + t2 + '" placeholder="' + (n2 || "") + '">');
  return r2.append(o2), [r2[0], o2[0]];
}
function zd$1(e3, t2) {
  var n2 = $$6('<div class="button-container"></div>'), r2 = $$6('<button type="button" id="' + e3 + '">' + t2 + "</button>");
  return n2.append(r2), [n2[0], r2[0]];
}
var Hd$1 = function(e3) {
  function t2(t3, n2) {
    void 0 === n2 && (n2 = false);
    var r2 = e3.call(this, t3, n2) || this;
    return r2.$body = $$6("body"), r2.modal = null, r2.menu = t3, r2;
  }
  return la$4(t2, e3), t2.prototype.onButtonClick = function() {
    this.menu.showModal && this.handleModal();
  }, t2.prototype.getPosition = function() {
    var e4 = Jd(this), t3 = this.menu.getModalPositionNode(e4);
    return Element$1.isElement(t3) ? jf$1(e4, t3, "modal") : Rf$1(e4);
  }, t2.prototype.handleModal = function() {
    var e4 = Jd(this), t3 = this.menu;
    if (null == this.modal) {
      var n2 = new $d$1(e4, t3.modalWidth);
      this.renderAndShowModal(n2, true), this.modal = n2;
    } else {
      (n2 = this.modal).isShow ? n2.hide() : this.renderAndShowModal(n2, false);
    }
  }, t2.prototype.renderAndShowModal = function(e4, t3) {
    void 0 === t3 && (t3 = false);
    var n2 = Jd(this), r2 = this.menu;
    if (null != r2.getModalContentElem) {
      var o2 = rl$1.getTextarea(n2), i2 = rl$1.getToolbar(n2), a2 = ((null == i2 ? void 0 : i2.getConfig()) || {}).modalAppendToBody, s2 = r2.getModalContentElem(n2);
      if (e4.renderContent(s2), a2)
        e4.setStyle({ left: "0", right: "0" });
      else {
        var l2 = this.getPosition();
        e4.setStyle(l2);
      }
      t3 && (a2 ? e4.appendTo(this.$body) : e4.appendTo(o2.$textAreaContainer)), e4.show(), a2 || Af$1(n2, e4.$elem), setTimeout(function() {
        n2.blur();
      });
    }
  }, t2;
}(Ad$1);
var Ud = function(e3) {
  function t2(t3, n2) {
    var r2 = e3.call(this, t3) || this;
    return r2.type = "selectList", r2.$elem = $$6('<div class="w-e-select-list"></div>'), n2 && r2.$elem.css("width", n2 + "px"), r2.$elem.on("click", function(e4) {
      e4.stopPropagation();
    }), r2;
  }
  return la$4(t2, e3), t2.prototype.renderList = function(e4) {
    var t3 = this.$elem;
    t3.empty();
    var n2 = $$6("<ul></ul>");
    e4.forEach(function(e5) {
      var t4 = e5.value, r2 = e5.text, o2 = e5.selected, i2 = e5.styleForRenderMenuList, a2 = $$6('<li data-value="' + t4 + '"></li>');
      if (i2 && a2.css(i2), o2) {
        var s2 = $$6('<svg viewBox="0 0 1446 1024"><path d="M574.116299 786.736392 1238.811249 48.517862C1272.390222 11.224635 1329.414799 7.827718 1366.75664 41.450462 1403.840015 74.840484 1406.731043 132.084741 1373.10189 169.433699L655.118888 966.834607C653.072421 969.716875 650.835807 972.514337 648.407938 975.210759 615.017957 1012.29409 558.292155 1015.652019 521.195664 982.250188L72.778218 578.493306C35.910826 545.297758 32.859041 488.584019 66.481825 451.242134 99.871807 414.158803 156.597563 410.800834 193.694055 444.202665L574.116299 786.736392Z"></path></svg>');
        a2.append(s2), a2.addClass("selected");
      }
      a2.append($$6('<span data-value="' + t4 + '">' + r2 + "</span>")), a2.attr("title", r2), n2.append(a2);
    }), t3.append(n2);
  }, t2.prototype.genSelfElem = function() {
    return null;
  }, t2;
}(Id$1);
var Kd = function() {
  function e3(e4, t2) {
    var n2 = this;
    void 0 === t2 && (t2 = false), this.$elem = $$6('<div class="w-e-bar-item"></div>'), this.$button = $$6('<button type="button" class="select-button"></button>'), this.disabled = false, this.selectList = null;
    var r2 = e4.tag, o2 = e4.title, i2 = e4.width, a2 = e4.iconSvg, s2 = void 0 === a2 ? "" : a2, l2 = e4.hotkey, u2 = void 0 === l2 ? "" : l2;
    if ("select" !== r2)
      throw new Error("Invalid tag '" + r2 + "', expected 'select'");
    var c2 = this.$button;
    i2 && c2.css("width", i2 + "px"), jd$1(c2, s2, o2, u2, t2), this.$elem.append(c2), this.menu = e4, cc$1(function() {
      return n2.init();
    });
  }
  return e3.prototype.init = function() {
    var e4 = this;
    this.setSelectedValue(), this.$button.on("click", function(t2) {
      t2.preventDefault(), Jd(e4).hidePanelOrModal(), e4.trigger();
    });
  }, e3.prototype.trigger = function() {
    var e4 = this, t2 = Jd(this);
    if (!t2.isDisabled() && !this.disabled) {
      var n2 = this.menu;
      if (null == this.selectList) {
        this.selectList = new Ud(t2, n2.selectPanelWidth);
        var r2 = this.selectList, o2 = n2.getOptions(t2);
        r2.renderList(o2), r2.appendTo(this.$elem), r2.show(), r2.$elem.on("click", "li", function(t3) {
          var n3 = t3.target;
          if (null != n3) {
            t3.preventDefault();
            var r3 = $$6(n3).attr("data-value");
            e4.onChange(r3);
          }
        });
      } else {
        if ((r2 = this.selectList).isShow)
          r2.hide();
        else {
          o2 = n2.getOptions(t2);
          r2.renderList(o2), r2.show();
        }
      }
    }
  }, e3.prototype.onChange = function(e4) {
    var t2 = Jd(this), n2 = this.menu;
    n2.exec && n2.exec(t2, e4);
  }, e3.prototype.setSelectedValue = function() {
    var e4 = Jd(this), t2 = this.menu, n2 = t2.getValue(e4), r2 = function(e5, t3) {
      for (var n3 = e5.length, r3 = "", o3 = 0; o3 < n3; o3++) {
        var i3 = e5[o3];
        if (i3.value === t3) {
          r3 = i3.text;
          break;
        }
      }
      return r3;
    }(t2.getOptions(e4), n2.toString()), o2 = this.$button, i2 = Dd$1();
    o2.empty(), o2.text(r2), o2.append(i2);
  }, e3.prototype.setDisabled = function() {
    var e4 = Jd(this), t2 = this.menu.isDisabled(e4), n2 = this.$button;
    (null == e4.selection || e4.isDisabled()) && (t2 = true);
    var r2 = "disabled";
    t2 ? n2.addClass(r2) : n2.removeClass(r2), this.disabled = t2;
  }, e3.prototype.changeMenuState = function() {
    this.setSelectedValue(), this.setDisabled();
  }, e3;
}(), qd$1 = function() {
  function e3(e4) {
    this.$elem = $$6('<div class="w-e-bar-item w-e-bar-item-group"></div>'), this.$container = $$6('<div class="w-e-bar-item-menus-container"></div>'), this.$button = $$6('<button type="button"></button>');
    var t2 = e4.iconSvg, n2 = e4.title, r2 = this.$elem, o2 = this.$button;
    if (t2) {
      var i2 = $$6(t2);
      Pd$1(i2), o2.append(i2);
    } else
      o2.text(n2);
    var a2 = Dd$1();
    o2.append(a2), r2.append(o2);
    var s2 = this.$container;
    r2.append(s2);
    var l2 = this.createObserver();
    this.observe(l2);
  }
  return e3.prototype.appendBarItem = function(e4) {
    var t2 = e4.$elem;
    this.$container.append(t2);
  }, e3.prototype.observe = function(e4) {
    var t2 = this.$container;
    e4.observe(t2[0], { childList: true, subtree: true, attributes: true });
  }, e3.prototype.createObserver = function() {
    var e4 = this, t2 = this.$container, n2 = this.$button, r2 = new MutationObserver(function() {
      var o2 = t2.find("button"), i2 = o2.length;
      if (0 !== i2) {
        var a2 = 0;
        o2.each(function(e5) {
          $$6(e5).hasClass("disabled") && a2++;
        }), r2.disconnect(), a2 === i2 ? n2.addClass("disabled") : n2.removeClass("disabled"), e4.observe(r2);
      }
    });
    return r2;
  }, e3;
}(), Gd$1 = /* @__PURE__ */ new WeakMap();
function Jd(e3) {
  var t2 = vs$1.get(e3);
  if (null == t2)
    throw new Error("Can not get editor instance");
  return t2;
}
function Yd(e3, t2) {
  void 0 === t2 && (t2 = false);
  var n2 = Gd$1.get(e3);
  if (n2)
    return n2;
  var r2 = e3.tag;
  if ("button" === r2) {
    var o2 = e3.showDropPanel, i2 = e3.showModal;
    n2 = o2 ? new Bd$1(e3, t2) : i2 ? new Hd$1(e3, t2) : new Fd$1(e3, t2);
  }
  if ("select" === r2 && (n2 = new Kd(e3, t2)), null == n2)
    throw new Error("Invalid tag in menu " + JSON.stringify(e3));
  return Gd$1.set(e3, n2), n2;
}
function Xd(e3, t2) {
  var n2 = e3.selection;
  return null != n2 && (!Range.isCollapsed(n2) && (!rl$1.getSelectedElems(e3).some(function(t3) {
    if (e3.isVoid(t3))
      return true;
    var n3 = t3.type;
    return !!["pre", "code", "table"].includes(n3) || void 0;
  }) && !!Text.isText(t2)));
}
var Qd = function() {
  function t2() {
    var e3 = this;
    this.$elem = $$6('<div class="w-e-bar w-e-bar-hidden w-e-hover-bar"></div>'), this.menus = {}, this.hoverbarItems = [], this.prevSelectedNode = null, this.isShow = false, this.changeHoverbarState = lodash_debounce(function() {
      var t3 = e3.isShow, n2 = e3.getSelectedNodeAndMenuKeys() || {}, r2 = n2.node, o2 = void 0 === r2 ? null : r2, a2 = n2.menuKeys, s2 = void 0 === a2 ? [] : a2;
      if ((null != o2 && e3.changeItemsState(), o2 && Element$1.isElement(o2)) && (t3 && e3.isSamePath(o2, e3.prevSelectedNode)))
        return;
      e3.hideAndClean(), null != o2 && (e3.registerItems(s2), e3.setPosition(o2), e3.show()), e3.prevSelectedNode = o2;
    }, 200), cc$1(function() {
      var t3 = e3.getEditorInstance(), n2 = e3.$elem;
      n2.on("mousedown", function(e4) {
        return e4.preventDefault();
      }), rl$1.getTextarea(t3).$textAreaContainer.append(n2), t3.on("change", e3.changeHoverbarState);
      var r2 = e3.hideAndClean.bind(e3);
      t3.on("scroll", r2), t3.on("fullScreen", r2), t3.on("unFullScreen", r2);
    });
  }
  return t2.prototype.getMenus = function() {
    return this.menus;
  }, t2.prototype.hideAndClean = function() {
    var e3 = this.$elem;
    e3.removeClass("w-e-bar-show").addClass("w-e-bar-hidden"), this.hoverbarItems = [], e3.empty(), this.isShow = false;
  }, t2.prototype.checkPositionBottom = function() {
    var e3 = this.$elem, t3 = false, n2 = window.innerHeight;
    n2 && n2 >= 360 && (n2 - e3[0].getBoundingClientRect().bottom < 360 && (t3 = true));
    t3 ? e3.addClass("w-e-bar-bottom") : e3.removeClass("w-e-bar-bottom");
  }, t2.prototype.show = function() {
    this.$elem.removeClass("w-e-bar-hidden").addClass("w-e-bar-show"), this.isShow = true, this.checkPositionBottom();
  }, t2.prototype.changeItemsState = function() {
    var e3 = this;
    cc$1(function() {
      e3.hoverbarItems.forEach(function(e4) {
        e4.changeMenuState();
      });
    });
  }, t2.prototype.registerItems = function(e3) {
    var t3 = this, n2 = this.$elem;
    e3.forEach(function(e4) {
      if ("|" !== e4)
        t3.registerSingleItem(e4);
      else {
        var r2 = Rd$1();
        n2.append(r2);
      }
    });
  }, t2.prototype.registerSingleItem = function(e3) {
    var t3 = this.getEditorInstance(), n2 = this.menus, r2 = n2[e3];
    if (null == r2) {
      var o2 = al$1[e3];
      if (null == o2)
        throw new Error("Not found menu item factory by key '" + e3 + "'");
      if ("function" != typeof o2)
        throw new Error("Menu item factory (key='" + e3 + "') is not a function");
      r2 = o2(), n2[e3] = r2;
    }
    var i2 = Yd(r2);
    this.hoverbarItems.push(i2), vs$1.set(i2, t3), this.$elem.append(i2.$elem);
  }, t2.prototype.setPosition = function(e3) {
    var t3 = this.getEditorInstance(), n2 = this.$elem;
    if (n2.attr("style", ""), Element$1.isElement(e3)) {
      var r2 = jf$1(t3, e3, "bar");
      return n2.css(r2), void Af$1(t3, n2);
    }
    if (Text.isText(e3)) {
      r2 = Rf$1(t3);
      return n2.css(r2), void Af$1(t3, n2);
    }
    throw new Error("hoverbar.setPosition error, current selected node is not elem nor text");
  }, t2.prototype.getSelectedNodeAndMenuKeys = function() {
    var t3 = this.getEditorInstance();
    if (null == t3.selection)
      return null;
    var n2 = this.getHoverbarKeysConf(), r2 = null, o2 = [], i2 = function(i3) {
      var a3 = n2[i3], s2 = a3.match, l2 = a3.menuKeys, u2 = void 0 === l2 ? [] : l2, c2 = s2 || function(e3, t4) {
        return rl$1.checkNodeType(t4, i3);
      }, f2 = fa$4(Editor$1.nodes(t3, { match: function(e3) {
        return c2(t3, e3);
      }, universal: true }), 1), d3 = f2[0];
      if (null != d3)
        return r2 = d3[0], o2 = u2, "break";
    };
    for (var a2 in n2) {
      if ("break" === i2(a2))
        break;
    }
    return null == r2 || 0 === o2.length ? null : { node: r2, menuKeys: o2 };
  }, t2.prototype.getEditorInstance = function() {
    var e3 = ps$1.get(this);
    if (null == e3)
      throw new Error("Can not get editor instance");
    return e3;
  }, t2.prototype.getHoverbarKeysConf = function() {
    var e3 = this.getEditorInstance().getConfig().hoverbarKeys, t3 = void 0 === e3 ? {} : e3, n2 = t3.text;
    return n2 && null == n2.match && (n2.match = Xd), t3;
  }, t2.prototype.isSamePath = function(e3, t3) {
    if (null == e3 || null == t3)
      return false;
    var r2 = rl$1.findPath(null, e3), o2 = rl$1.findPath(null, t3);
    return Path.equals(r2, o2);
  }, t2.prototype.destroy = function() {
    this.changeHoverbarState.cancel(), this.$elem.remove(), this.menus = {}, this.hoverbarItems = [], this.prevSelectedNode = null;
  }, t2;
}();
function Zd(t2, n2, o2, a2) {
  if (ks$1.set(t2, n2), Es$1.set(t2, o2), Element$1.isElement(t2)) {
    var s2 = t2.children;
    if ((void 0 === s2 ? [] : s2).forEach(function(e3, n3) {
      return Zd(e3, n3, t2, a2);
    }), Editor$1.isVoid(a2, t2)) {
      var l2 = fa$4(Node$1.texts(t2), 1), u2 = fa$4(l2[0], 1)[0];
      ks$1.set(u2, 0), Es$1.set(u2, t2);
    }
  }
}
function eh(n2) {
  var i2 = n2.selector, a2 = void 0 === i2 ? "" : i2, c2 = n2.config, d3 = void 0 === c2 ? {} : c2, h2 = n2.content, p2 = n2.html, g2 = n2.plugins, v2 = void 0 === g2 ? [] : g2, y2 = ((n3) => {
    var r2 = n3, { apply: o2 } = r2;
    return r2.history = { undos: [], redos: [] }, r2.redo = () => {
      var { history: t2 } = r2, { redos: n4 } = t2;
      if (n4.length > 0) {
        var o3 = n4[n4.length - 1];
        vr$5.withoutSaving(r2, () => {
          Editor$1.withoutNormalizing(r2, () => {
            for (var e3 of o3)
              r2.apply(e3);
          });
        }), t2.redos.pop(), t2.undos.push(o3);
      }
    }, r2.undo = () => {
      var { history: n4 } = r2, { undos: o3 } = n4;
      if (o3.length > 0) {
        var i3 = o3[o3.length - 1];
        vr$5.withoutSaving(r2, () => {
          Editor$1.withoutNormalizing(r2, () => {
            var e3 = i3.map(Operation.inverse).reverse();
            for (var n5 of e3)
              r2.apply(n5);
          });
        }), n4.redos.push(i3), n4.undos.pop();
      }
    }, r2.apply = (e3) => {
      var { operations: t2, history: n4 } = r2, { undos: i3 } = n4, a3 = i3[i3.length - 1], s2 = a3 && a3[a3.length - 1], l2 = br$5(e3, s2), u2 = vr$5.isSaving(r2), c3 = vr$5.isMerging(r2);
      if (null == u2 && (u2 = mr$5(e3)), u2) {
        if (null == c3 && (c3 = null != a3 && (0 !== t2.length || yr$5(e3, s2) || l2)), a3 && c3)
          l2 && a3.pop(), a3.push(e3);
        else {
          var f2 = [e3];
          i3.push(f2);
        }
        for (; i3.length > 100; )
          i3.shift();
        wr$5(e3) && (n4.redos = []);
      }
      o2(e3);
    }, r2;
  })(function(e3) {
    var t2 = e3, n3 = t2.insertText, o2 = t2.insertNode, i3 = t2.insertFragment;
    return t2.insertText = function(e4) {
      if (t2.getConfig().maxLength) {
        var r2 = rl$1.getLeftLengthOfMaxLength(t2);
        r2 <= 0 || (r2 < e4.length ? n3(e4.slice(0, r2)) : n3(e4));
      } else
        n3(e4);
    }, t2.insertNode = function(e4) {
      if (t2.getConfig().maxLength) {
        var n4 = rl$1.getLeftLengthOfMaxLength(t2);
        n4 <= 0 || n4 < Node$1.string(e4).length || o2(e4);
      } else
        o2(e4);
    }, t2.insertFragment = function(e4) {
      t2.getConfig().maxLength ? e4.forEach(function(e5) {
        t2.insertNode(e5);
      }) : i3(e4);
    }, t2;
  }(function(e3) {
    var t2 = e3;
    return t2.on = function(e4, n3) {
      var r2 = Nf$1(t2);
      if (r2.on(e4, n3), "destroyed" === e4 && Lf$1(t2, n3), "destroyed" !== e4) {
        var o2 = function() {
          return r2.off(e4, n3);
        };
        r2.on("destroyed", o2), Lf$1(t2, o2);
      }
    }, t2.once = function(e4, n3) {
      Nf$1(t2).once(e4, n3);
    }, t2.off = function(e4, n3) {
      Nf$1(t2).off(e4, n3);
    }, t2.emit = function(e4) {
      for (var n3 = [], r2 = 1; r2 < arguments.length; r2++)
        n3[r2 - 1] = arguments[r2];
      var o2 = Nf$1(t2);
      (o2.emit.apply(o2, da$4([e4], fa$4(n3))), "destroyed" === e4) && (Mf$1(t2).forEach(function(e5) {
        return o2.off("destroyed", e5);
      }), Pf$1(t2));
    }, t2;
  }(function(t2) {
    var n3 = t2;
    return n3.select = function(e3) {
      Transforms.select(n3, e3);
    }, n3.deselect = function() {
      var e3 = n3.selection, r2 = rl$1.findDocumentOrShadowRoot(n3).getSelection();
      r2 && r2.rangeCount > 0 && r2.removeAllRanges(), e3 && Transforms.deselect(t2);
    }, n3.move = function(e3, n4) {
      void 0 === n4 && (n4 = false), e3 && (e3 < 0 || Transforms.move(t2, { distance: e3, unit: "character", reverse: n4 }));
    }, n3.moveReverse = function(e3) {
      n3.move(e3, true);
    }, n3.restoreSelection = function() {
      var e3 = Ds$1.get(n3);
      null != e3 && (n3.focus(), Transforms.select(n3, e3));
    }, n3.getSelectionPosition = function() {
      return Rf$1(n3);
    }, n3.getNodePosition = function(e3) {
      return jf$1(n3, e3);
    }, n3.isSelectedAll = function() {
      var t3 = n3.selection;
      if (null == t3)
        return false;
      var r2 = fa$4(Range.edges(t3), 2), i3 = r2[0], a3 = r2[1], s2 = fa$4(Editor$1.edges(n3, []), 2), u2 = s2[0], c3 = s2[1];
      return !(!Point.equals(i3, u2) || !Point.equals(a3, c3));
    }, n3.selectAll = function() {
      var t3 = Editor$1.start(n3, []), r2 = Editor$1.end(n3, []);
      Transforms.select(n3, { anchor: t3, focus: r2 });
    }, n3;
  }(nf$1(function(e3) {
    var t2 = e3;
    return t2.getAllMenuKeys = function() {
      var e4 = [];
      for (var t3 in al$1)
        e4.push(t3);
      return e4;
    }, t2.getConfig = function() {
      var e4 = bs$1.get(t2);
      if (null == e4)
        throw new Error("Can not get editor config");
      return e4;
    }, t2.getMenuConfig = function(e4) {
      var n3 = t2.getConfig().MENU_CONF;
      return (void 0 === n3 ? {} : n3)[e4] || {};
    }, t2.alert = function(e4, n3) {
      void 0 === n3 && (n3 = "info");
      var r2 = t2.getConfig().customAlert;
      r2 && r2(e4, n3);
    }, t2;
  }(function(t2) {
    var n3 = t2;
    return n3.id = "wangEditor-" + ol$1++, n3.isDestroyed = false, n3.isFullScreen = false, n3.focus = function(t3) {
      if (rl$1.toDOMNode(n3, n3).focus({ preventScroll: true }), Ps$1.set(n3, true), t3) {
        var r2 = Editor$1.end(n3, []);
        Transforms.select(n3, r2);
      } else {
        var o2 = Ds$1.get(n3);
        o2 ? Transforms.select(n3, o2) : Transforms.select(n3, Editor$1.start(n3, []));
      }
    }, n3.isFocused = function() {
      return !!Ps$1.get(n3);
    }, n3.blur = function() {
      rl$1.toDOMNode(n3, n3).blur(), Transforms.deselect(n3), Ps$1.set(n3, false);
    }, n3.updateView = function() {
      rl$1.getTextarea(n3).changeViewState();
      var e3 = rl$1.getToolbar(n3);
      e3 && e3.changeToolbarState();
      var t3 = rl$1.getHoverbar(n3);
      t3 && t3.changeHoverbarState();
    }, n3.destroy = function() {
      if (!n3.isDestroyed) {
        var e3 = rl$1.getTextarea(n3);
        e3.destroy(), cs$1.delete(n3), fs$1.delete(e3);
        var t3 = rl$1.getToolbar(n3);
        t3 && (t3.destroy(), hs$1.delete(n3), ds$1.delete(t3));
        var r2 = rl$1.getHoverbar(n3);
        r2 && (r2.destroy(), gs$1.delete(n3), ps$1.delete(r2)), n3.isDestroyed = true, n3.emit("destroyed");
      }
    }, n3.scrollToElem = function(e3) {
      if (!n3.getConfig().scroll) {
        var t3 = "\u7F16\u8F91\u5668\u7981\u7528\u4E86 scroll \uFF0C\u7F16\u8F91\u5668\u5185\u5BB9\u65E0\u6CD5\u6EDA\u52A8\uFF0C\u8BF7\u81EA\u884C\u5B9E\u73B0\u8BE5\u529F\u80FD";
        return t3 += "\nYou has disabled editor scroll, please do this yourself", void console.warn(t3);
      }
      var r2 = $$6("#" + e3);
      if (0 !== r2.length) {
        var o2 = r2[0];
        if (!rl$1.hasDOMNode(n3, o2))
          return t3 = "Element (found by id is '" + e3 + "') is not in editor DOM", t3 += "\n \u901A\u8FC7 id '" + e3 + "' \u627E\u5230\u7684 element \u4E0D\u5728 editor DOM \u4E4B\u5185", void console.error(t3, o2);
        var i3 = rl$1.getTextarea(n3), a3 = i3.$textAreaContainer, s2 = i3.$scroll, l2 = r2.offset().top, u2 = a3.offset().top;
        s2[0].scrollBy({ top: l2 - u2, behavior: "smooth" });
      }
    }, n3.showProgressBar = function(e3) {
      e3 < 1 || rl$1.getTextarea(n3).changeProgress(e3);
    }, n3.hidePanelOrModal = function() {
      var e3 = ys$1.get(n3);
      null != e3 && e3.forEach(function(e4) {
        return e4.hide();
      });
    }, n3.enable = function() {
      n3.getConfig().readOnly = false, n3.updateView();
    }, n3.disable = function() {
      n3.getConfig().readOnly = true, n3.updateView();
    }, n3.isDisabled = function() {
      return n3.getConfig().readOnly;
    }, n3.toDOMNode = function(e3) {
      return rl$1.toDOMNode(n3, e3);
    }, n3.fullScreen = function() {
      if (!n3.isFullScreen) {
        var e3 = null, t3 = rl$1.getToolbar(n3);
        t3 && (e3 = t3.$box);
        var r2 = rl$1.getTextarea(n3).$box.parent();
        if (e3 && e3.parent()[0] !== r2[0])
          throw new Error("Can not set full screen, cause toolbar DOM parent is not equal to textarea DOM parent\n\u4E0D\u80FD\u8BBE\u7F6E\u5168\u5C4F\uFF0C\u56E0\u4E3A toolbar DOM \u7236\u8282\u70B9\u548C textarea DOM \u7236\u8282\u70B9\u4E0D\u4E00\u81F4");
        r2.addClass("w-e-full-screen-container");
        var o2 = r2.css("z-index");
        r2.attr("data-z-index", o2.toString()), n3.isFullScreen = true, n3.emit("fullScreen");
      }
    }, n3.unFullScreen = function() {
      if (n3.isFullScreen) {
        var e3 = rl$1.getTextarea(n3).$box.parent();
        setTimeout(function() {
          e3.removeClass("w-e-full-screen-container"), n3.isFullScreen = false, n3.emit("unFullScreen");
        }, 200);
      }
    }, n3.getEditableContainer = function() {
      return rl$1.getTextarea(n3).$textAreaContainer[0];
    }, n3;
  }(rf$1(createEditor$1()))))))));
  if (a2 && function(e3, t2) {
    return Zc$1(e3, "data-w-e-textarea", t2);
  }(y2, a2))
    throw new Error("Repeated create editor by selector '" + a2 + "'");
  var m2 = function(e3) {
    void 0 === e3 && (e3 = {});
    var t2 = lodash_clonedeep(il$1), n3 = {}, r2 = e3.MENU_CONF, o2 = void 0 === r2 ? {} : r2;
    return lodash_foreach(t2, function(e4, t3) {
      n3[t3] = ua$4(ua$4({}, e4), o2[t3] || {});
    }), delete e3.MENU_CONF, ua$4({ scroll: true, readOnly: false, autoFocus: true, decorate: function() {
      return [];
    }, maxLength: 0, MENU_CONF: n3, hoverbarKeys: {}, customAlert: function(e4, t3) {
      window.alert(t3 + ":\n" + e4);
    } }, e3);
  }(d3);
  bs$1.set(y2, m2);
  var b2 = m2.hoverbarKeys, w2 = void 0 === b2 ? {} : b2;
  if (v2.forEach(function(e3) {
    y2 = e3(y2);
  }), null != p2 && (y2.children = ef$1(y2, p2)), h2 && h2.length && (y2.children = h2), 0 === y2.children.length && (y2.children = [{ type: "paragraph", children: [{ text: "" }] }]), rl$1.normalizeContent(y2), a2) {
    var x2 = new Md$1(a2);
    cs$1.set(y2, x2), fs$1.set(x2, y2), x2.changeViewState(), cc$1(function() {
      var e3 = x2.$scroll;
      if (null != e3 && e3.height() < 300) {
        console.warn("\u7F16\u8F91\u533A\u57DF\u9AD8\u5EA6 < 300px \u8FD9\u53EF\u80FD\u4F1A\u5BFC\u81F4 modal hoverbar \u5B9A\u4F4D\u5F02\u5E38\nTextarea height < 300px . This may be cause modal and hoverbar position error", e3);
      }
    });
    var S2 = void 0;
    Object.keys(w2).length > 0 && (S2 = new Qd(), ps$1.set(S2, y2), gs$1.set(y2, S2)), y2.on("change", function() {
      y2.hidePanelOrModal();
    }), y2.on("scroll", function() {
      y2.hidePanelOrModal();
    });
  } else
    y2.children.forEach(function(e3, t2) {
      return Zd(e3, t2, y2, y2);
    });
  var k2 = m2.onCreated, E2 = m2.onDestroyed;
  return k2 && y2.on("created", function() {
    return k2(y2);
  }), E2 && y2.on("destroyed", function() {
    return E2(y2);
  }), cc$1(function() {
    return y2.emit("created");
  }), y2;
}
var th = ci$4("splice"), nh = ae$6.TypeError, rh = Math.max, oh = Math.min;
ur$5({ target: "Array", proto: true, forced: !th }, { splice: function(e3, t2) {
  var n2, r2, o2, i2, a2, s2, l2 = be$6(this), u2 = dn$6(l2), c2 = Vn$6(e3, u2), f2 = arguments.length;
  if (0 === f2 ? n2 = r2 = 0 : 1 === f2 ? (n2 = 0, r2 = u2 - c2) : (n2 = f2 - 2, r2 = oh(rh(un$6(t2), 0), u2 - c2)), u2 + n2 - r2 > 9007199254740991)
    throw nh("Maximum allowed length exceeded");
  for (o2 = En$6(l2, r2), i2 = 0; i2 < r2; i2++)
    (a2 = c2 + i2) in l2 && io$4(o2, i2, l2[a2]);
  if (o2.length = r2, n2 < r2) {
    for (i2 = c2; i2 < u2 - r2; i2++)
      s2 = i2 + n2, (a2 = i2 + r2) in l2 ? l2[s2] = l2[a2] : delete l2[s2];
    for (i2 = u2; i2 > u2 - r2 + n2; i2--)
      delete l2[i2 - 1];
  } else if (n2 > r2)
    for (i2 = u2 - r2; i2 > c2; i2--)
      s2 = i2 + n2 - 1, (a2 = i2 + r2 - 1) in l2 ? l2[s2] = l2[a2] : delete l2[s2];
  for (i2 = 0; i2 < n2; i2++)
    l2[i2 + c2] = arguments[i2 + 2];
  return l2.length = u2 - r2 + n2, o2;
} });
var ih = function() {
  function e3(e4, t2) {
    var n2 = this;
    this.$toolbar = $$6('<div class="w-e-bar w-e-bar-show w-e-toolbar"></div>'), this.menus = {}, this.toolbarItems = [], this.config = {}, this.changeToolbarState = lodash_debounce(function() {
      n2.toolbarItems.forEach(function(e5) {
        e5.changeMenuState();
      });
    }, 200), this.config = t2;
    var r2 = $$6(e4);
    if (0 === r2.length)
      throw new Error("Cannot find toolbar DOM by selector '" + e4 + "'");
    this.$box = r2;
    var o2 = this.$toolbar;
    o2.on("mousedown", function(e5) {
      return e5.preventDefault();
    }), r2.append(o2), cc$1(function() {
      n2.registerItems(), n2.changeToolbarState(), n2.getEditorInstance().on("change", n2.changeToolbarState);
    });
  }
  return e3.prototype.getMenus = function() {
    return this.menus;
  }, e3.prototype.getConfig = function() {
    return this.config;
  }, e3.prototype.registerItems = function() {
    var e4 = this, t2 = "", n2 = this.$toolbar, r2 = this.config, o2 = r2.toolbarKeys, i2 = void 0 === o2 ? [] : o2, a2 = r2.insertKeys, s2 = void 0 === a2 ? { index: 0, keys: [] } : a2, l2 = r2.excludeKeys, u2 = void 0 === l2 ? [] : l2, c2 = lodash_clonedeep(i2);
    s2.keys.length > 0 && ("string" == typeof s2.keys && (s2.keys = [s2.keys]), s2.keys.forEach(function(e5, t3) {
      c2.splice(s2.index + t3, 0, e5);
    }));
    var f2 = c2.filter(function(e5) {
      if ("string" == typeof e5) {
        if (u2.includes(e5))
          return false;
      } else if (u2.includes(e5.key))
        return false;
      return true;
    }), d3 = f2.length;
    f2.forEach(function(r3, o3) {
      if ("|" === r3) {
        if (0 === o3)
          return;
        if (o3 + 1 === d3)
          return;
        if ("|" === t2)
          return;
        var i3 = Rd$1();
        return n2.append(i3), void (t2 = r3);
      }
      if ("string" == typeof r3)
        return e4.registerSingleItem(r3, e4), void (t2 = r3);
      e4.registerGroup(r3), t2 = "group";
    });
  }, e3.prototype.registerGroup = function(e4) {
    var t2 = this, n2 = this.$toolbar, r2 = function(e5) {
      return new qd$1(e5);
    }(e4), o2 = e4.menuKeys, i2 = void 0 === o2 ? [] : o2, a2 = this.config.excludeKeys, s2 = void 0 === a2 ? [] : a2;
    i2.forEach(function(e5) {
      s2.includes(e5) || t2.registerSingleItem(e5, r2);
    }), n2.append(r2.$elem);
  }, e3.prototype.registerSingleItem = function(e4, t2) {
    var n2 = this.getEditorInstance(), r2 = t2 instanceof qd$1, o2 = this.menus, i2 = o2[e4];
    if (null == i2) {
      var a2 = al$1[e4];
      if (null == a2)
        throw new Error("Not found menu item factory by key '" + e4 + "'");
      if ("function" != typeof a2)
        throw new Error("Menu item factory (key='" + e4 + "') is not a function");
      i2 = a2(), o2[e4] = i2;
    } else
      console.warn("Duplicated toolbar menu key '" + e4 + "'\n\u91CD\u590D\u6CE8\u518C\u4E86\u83DC\u5355\u680F menu '" + e4 + "'");
    var s2 = Yd(i2, r2);
    (this.toolbarItems.push(s2), vs$1.set(s2, n2), r2) ? t2.appendBarItem(s2) : t2.$toolbar.append(s2.$elem);
  }, e3.prototype.getEditorInstance = function() {
    var e4 = ds$1.get(this);
    if (null == e4)
      throw new Error("Can not get editor instance");
    return e4;
  }, e3.prototype.destroy = function() {
    this.$toolbar.remove(), this.menus = {}, this.toolbarItems = [];
  }, e3;
}();
function ah(e3, t2) {
  if (null == e3)
    throw new Error("Cannot create toolbar, because editor is null");
  var n2 = t2.selector, r2 = t2.config, o2 = void 0 === r2 ? {} : r2;
  if (function(e4, t3) {
    return Zc$1(e4, "data-w-e-toolbar", t3);
  }(e3, n2))
    throw new Error("Repeated create toolbar by selector '" + n2 + "'");
  var i2 = ua$4({ toolbarKeys: [], excludeKeys: [], insertKeys: { index: 0, keys: [] }, modalAppendToBody: false }, o2 || {}), a2 = new ih(n2, i2);
  return ds$1.set(a2, e3), hs$1.set(e3, a2), a2;
}
var sh = Wt$6.EXISTS, lh = yt$6.f, uh = Function.prototype, ch = ge$6(uh.toString), fh = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, dh = ge$6(fh.exec);
function hh(e3) {
  var t2 = e3.server, n2 = void 0 === t2 ? "" : t2, r2 = e3.fieldName, o2 = void 0 === r2 ? "" : r2, i2 = e3.maxFileSize, a2 = void 0 === i2 ? 10485760 : i2, s2 = e3.maxNumberOfFiles, l2 = void 0 === s2 ? 100 : s2, u2 = e3.meta, c2 = void 0 === u2 ? {} : u2, f2 = e3.metaWithUrl, d3 = void 0 !== f2 && f2, h2 = e3.headers, p2 = void 0 === h2 ? {} : h2, g2 = e3.withCredentials, v2 = void 0 !== g2 && g2, y2 = e3.timeout, m2 = void 0 === y2 ? 1e4 : y2, b2 = e3.onBeforeUpload, w2 = void 0 === b2 ? function(e4) {
    return e4;
  } : b2, x2 = e3.onSuccess, S2 = void 0 === x2 ? function(e4, t3) {
  } : x2, k2 = e3.onError, E2 = void 0 === k2 ? function(e4, t3, n3) {
    console.error(e4.name + " upload error", t3, n3);
  } : k2, O2 = e3.onProgress, C2 = void 0 === O2 ? function(e4) {
  } : O2;
  if (!n2)
    throw new Error("Cannot get upload server address\n\u6CA1\u6709\u914D\u7F6E\u4E0A\u4F20\u5730\u5740");
  if (!o2)
    throw new Error("Cannot get fieldName\n\u6CA1\u6709\u914D\u7F6E fieldName");
  var N2 = n2;
  d3 && (N2 = function(e4, t3) {
    var n3 = fa$4(e4.split("#"), 2), r3 = n3[0], o3 = n3[1], i3 = [];
    lodash_foreach(t3, function(e5, t4) {
      i3.push(t4 + "=" + e5);
    });
    var a3 = i3.join("&");
    return r3 = r3.indexOf("?") > 0 ? r3 + "&" + a3 : r3 + "?" + a3, o3 ? r3 + "#" + o3 : r3;
  }(N2, c2));
  var T2 = new lib$2({ onBeforeUpload: w2, restrictions: { maxFileSize: a2, maxNumberOfFiles: l2 }, meta: c2 }).use(lib, { endpoint: N2, headers: p2, formData: true, fieldName: o2, bundle: true, withCredentials: v2, timeout: m2 });
  return T2.on("upload-success", function(e4, t3) {
    var n3 = t3.body, r3 = void 0 === n3 ? {} : n3;
    try {
      S2(e4, r3);
    } catch (e5) {
      console.error("wangEditor upload file - onSuccess error", e5);
    }
    T2.removeFile(e4.id);
  }), T2.on("progress", function(e4) {
    e4 < 1 || C2(e4);
  }), T2.on("error", function(e4) {
    console.error("wangEditor file upload error", e4.stack);
  }), T2.on("upload-error", function(e4, t3, n3) {
    try {
      E2(e4, t3, n3);
    } catch (e5) {
      console.error("wangEditor upload file - onError error", e5);
    }
    T2.removeFile(e4.id);
  }), T2.on("restriction-failed", function(e4, t3) {
    try {
      E2(e4, t3);
    } catch (e5) {
      console.error("wangEditor upload file - onError error", e5);
    }
    T2.removeFile(e4.id);
  }), T2;
}
function ph(e3) {
  return ph = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
    return typeof e4;
  } : function(e4) {
    return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
  }, ph(e3);
}
function gh(e3, t2, n2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t2] = n2, e3;
}
function vh(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? Object(arguments[t2]) : {}, r2 = Object.keys(n2);
    "function" == typeof Object.getOwnPropertySymbols && r2.push.apply(r2, Object.getOwnPropertySymbols(n2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(n2, e4).enumerable;
    })), r2.forEach(function(t3) {
      gh(e3, t3, n2[t3]);
    });
  }
  return e3;
}
function yh(e3, t2) {
  if (!(e3 instanceof t2))
    throw new TypeError("Cannot call a class as a function");
}
function mh(e3, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var r2 = t2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e3, r2.key, r2);
  }
}
function bh(e3, t2, n2) {
  return t2 && mh(e3.prototype, t2), n2 && mh(e3, n2), e3;
}
function wh(e3) {
  if (void 0 === e3)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}
function xh(e3, t2) {
  if (t2 && ("object" === ph(t2) || "function" == typeof t2))
    return t2;
  if (void 0 !== t2)
    throw new TypeError("Derived constructors may only return object or undefined");
  return wh(e3);
}
function Sh(e3) {
  return Sh = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
    return e4.__proto__ || Object.getPrototypeOf(e4);
  }, Sh(e3);
}
function kh(e3, t2) {
  return kh = Object.setPrototypeOf || function(e4, t3) {
    return e4.__proto__ = t3, e4;
  }, kh(e3, t2);
}
function Eh(e3, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Super expression must either be null or a function");
  e3.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t2 && kh(e3, t2);
}
Ue$6 && !sh && lh(uh, "name", { configurable: true, get: function() {
  try {
    return dh(fh, ch(this))[1];
  } catch (e3) {
    return "";
  }
} });
var Oh = { type: "logger", log: function(e3) {
  this.output("log", e3);
}, warn: function(e3) {
  this.output("warn", e3);
}, error: function(e3) {
  this.output("error", e3);
}, output: function(e3, t2) {
  console && console[e3] && console[e3].apply(console, t2);
} }, Ch = new (function() {
  function e3(t2) {
    var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    yh(this, e3), this.init(t2, n2);
  }
  return bh(e3, [{ key: "init", value: function(e4) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this.prefix = t2.prefix || "i18next:", this.logger = e4 || Oh, this.options = t2, this.debug = t2.debug;
  } }, { key: "setDebug", value: function(e4) {
    this.debug = e4;
  } }, { key: "log", value: function() {
    for (var e4 = arguments.length, t2 = new Array(e4), n2 = 0; n2 < e4; n2++)
      t2[n2] = arguments[n2];
    return this.forward(t2, "log", "", true);
  } }, { key: "warn", value: function() {
    for (var e4 = arguments.length, t2 = new Array(e4), n2 = 0; n2 < e4; n2++)
      t2[n2] = arguments[n2];
    return this.forward(t2, "warn", "", true);
  } }, { key: "error", value: function() {
    for (var e4 = arguments.length, t2 = new Array(e4), n2 = 0; n2 < e4; n2++)
      t2[n2] = arguments[n2];
    return this.forward(t2, "error", "");
  } }, { key: "deprecate", value: function() {
    for (var e4 = arguments.length, t2 = new Array(e4), n2 = 0; n2 < e4; n2++)
      t2[n2] = arguments[n2];
    return this.forward(t2, "warn", "WARNING DEPRECATED: ", true);
  } }, { key: "forward", value: function(e4, t2, n2, r2) {
    return r2 && !this.debug ? null : ("string" == typeof e4[0] && (e4[0] = "".concat(n2).concat(this.prefix, " ").concat(e4[0])), this.logger[t2](e4));
  } }, { key: "create", value: function(t2) {
    return new e3(this.logger, vh({}, { prefix: "".concat(this.prefix, ":").concat(t2, ":") }, this.options));
  } }]), e3;
}())(), Nh = function() {
  function e3() {
    yh(this, e3), this.observers = {};
  }
  return bh(e3, [{ key: "on", value: function(e4, t2) {
    var n2 = this;
    return e4.split(" ").forEach(function(e5) {
      n2.observers[e5] = n2.observers[e5] || [], n2.observers[e5].push(t2);
    }), this;
  } }, { key: "off", value: function(e4, t2) {
    this.observers[e4] && (t2 ? this.observers[e4] = this.observers[e4].filter(function(e5) {
      return e5 !== t2;
    }) : delete this.observers[e4]);
  } }, { key: "emit", value: function(e4) {
    for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
      n2[r2 - 1] = arguments[r2];
    if (this.observers[e4]) {
      var o2 = [].concat(this.observers[e4]);
      o2.forEach(function(e5) {
        e5.apply(void 0, n2);
      });
    }
    if (this.observers["*"]) {
      var i2 = [].concat(this.observers["*"]);
      i2.forEach(function(t3) {
        t3.apply(t3, [e4].concat(n2));
      });
    }
  } }]), e3;
}();
function Th() {
  var e3, t2, n2 = new Promise(function(n3, r2) {
    e3 = n3, t2 = r2;
  });
  return n2.resolve = e3, n2.reject = t2, n2;
}
function Lh(e3) {
  return null == e3 ? "" : "" + e3;
}
function Mh(e3, t2, n2) {
  e3.forEach(function(e4) {
    t2[e4] && (n2[e4] = t2[e4]);
  });
}
function Ph(e3, t2, n2) {
  function r2(e4) {
    return e4 && e4.indexOf("###") > -1 ? e4.replace(/###/g, ".") : e4;
  }
  function o2() {
    return !e3 || "string" == typeof e3;
  }
  for (var i2 = "string" != typeof t2 ? [].concat(t2) : t2.split("."); i2.length > 1; ) {
    if (o2())
      return {};
    var a2 = r2(i2.shift());
    !e3[a2] && n2 && (e3[a2] = new n2()), e3 = Object.prototype.hasOwnProperty.call(e3, a2) ? e3[a2] : {};
  }
  return o2() ? {} : { obj: e3, k: r2(i2.shift()) };
}
function Dh(e3, t2, n2) {
  var r2 = Ph(e3, t2, Object);
  r2.obj[r2.k] = n2;
}
function Rh(e3, t2) {
  var n2 = Ph(e3, t2), r2 = n2.obj, o2 = n2.k;
  if (r2)
    return r2[o2];
}
function jh(e3, t2, n2) {
  var r2 = Rh(e3, n2);
  return void 0 !== r2 ? r2 : Rh(t2, n2);
}
function Ah(e3, t2, n2) {
  for (var r2 in t2)
    "__proto__" !== r2 && "constructor" !== r2 && (r2 in e3 ? "string" == typeof e3[r2] || e3[r2] instanceof String || "string" == typeof t2[r2] || t2[r2] instanceof String ? n2 && (e3[r2] = t2[r2]) : Ah(e3[r2], t2[r2], n2) : e3[r2] = t2[r2]);
  return e3;
}
function Fh(e3) {
  return e3.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var Ih = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" };
function _h(e3) {
  return "string" == typeof e3 ? e3.replace(/[&<>"'\/]/g, function(e4) {
    return Ih[e4];
  }) : e3;
}
var Bh = "undefined" != typeof window && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
function $h(e3, t2) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ".";
  if (e3) {
    if (e3[t2])
      return e3[t2];
    for (var r2 = t2.split(n2), o2 = e3, i2 = 0; i2 < r2.length; ++i2) {
      if (!o2)
        return;
      if ("string" == typeof o2[r2[i2]] && i2 + 1 < r2.length)
        return;
      if (void 0 === o2[r2[i2]]) {
        for (var a2 = 2, s2 = r2.slice(i2, i2 + a2).join(n2), l2 = o2[s2]; void 0 === l2 && r2.length > i2 + a2; )
          a2++, l2 = o2[s2 = r2.slice(i2, i2 + a2).join(n2)];
        if (void 0 === l2)
          return;
        if ("string" == typeof l2)
          return l2;
        if (s2 && "string" == typeof l2[s2])
          return l2[s2];
        var u2 = r2.slice(i2 + a2).join(n2);
        return u2 ? $h(l2, u2, n2) : void 0;
      }
      o2 = o2[r2[i2]];
    }
    return o2;
  }
}
var Wh = function(e3) {
  function t2(e4) {
    var n2, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { ns: ["translation"], defaultNS: "translation" };
    return yh(this, t2), n2 = xh(this, Sh(t2).call(this)), Bh && Nh.call(wh(n2)), n2.data = e4 || {}, n2.options = r2, void 0 === n2.options.keySeparator && (n2.options.keySeparator = "."), void 0 === n2.options.ignoreJSONStructure && (n2.options.ignoreJSONStructure = true), n2;
  }
  return Eh(t2, Nh), bh(t2, [{ key: "addNamespaces", value: function(e4) {
    this.options.ns.indexOf(e4) < 0 && this.options.ns.push(e4);
  } }, { key: "removeNamespaces", value: function(e4) {
    var t3 = this.options.ns.indexOf(e4);
    t3 > -1 && this.options.ns.splice(t3, 1);
  } }, { key: "getResource", value: function(e4, t3, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, o2 = void 0 !== r2.keySeparator ? r2.keySeparator : this.options.keySeparator, i2 = void 0 !== r2.ignoreJSONStructure ? r2.ignoreJSONStructure : this.options.ignoreJSONStructure, a2 = [e4, t3];
    n2 && "string" != typeof n2 && (a2 = a2.concat(n2)), n2 && "string" == typeof n2 && (a2 = a2.concat(o2 ? n2.split(o2) : n2)), e4.indexOf(".") > -1 && (a2 = e4.split("."));
    var s2 = Rh(this.data, a2);
    return s2 || !i2 || "string" != typeof n2 ? s2 : $h(this.data && this.data[e4] && this.data[e4][t3], n2, o2);
  } }, { key: "addResource", value: function(e4, t3, n2, r2) {
    var o2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : { silent: false }, i2 = this.options.keySeparator;
    void 0 === i2 && (i2 = ".");
    var a2 = [e4, t3];
    n2 && (a2 = a2.concat(i2 ? n2.split(i2) : n2)), e4.indexOf(".") > -1 && (r2 = t3, t3 = (a2 = e4.split("."))[1]), this.addNamespaces(t3), Dh(this.data, a2, r2), o2.silent || this.emit("added", e4, t3, n2, r2);
  } }, { key: "addResources", value: function(e4, t3, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : { silent: false };
    for (var o2 in n2)
      "string" != typeof n2[o2] && "[object Array]" !== Object.prototype.toString.apply(n2[o2]) || this.addResource(e4, t3, o2, n2[o2], { silent: true });
    r2.silent || this.emit("added", e4, t3, n2);
  } }, { key: "addResourceBundle", value: function(e4, t3, n2, r2, o2) {
    var i2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : { silent: false }, a2 = [e4, t3];
    e4.indexOf(".") > -1 && (r2 = n2, n2 = t3, t3 = (a2 = e4.split("."))[1]), this.addNamespaces(t3);
    var s2 = Rh(this.data, a2) || {};
    r2 ? Ah(s2, n2, o2) : s2 = vh({}, s2, n2), Dh(this.data, a2, s2), i2.silent || this.emit("added", e4, t3, n2);
  } }, { key: "removeResourceBundle", value: function(e4, t3) {
    this.hasResourceBundle(e4, t3) && delete this.data[e4][t3], this.removeNamespaces(t3), this.emit("removed", e4, t3);
  } }, { key: "hasResourceBundle", value: function(e4, t3) {
    return void 0 !== this.getResource(e4, t3);
  } }, { key: "getResourceBundle", value: function(e4, t3) {
    return t3 || (t3 = this.options.defaultNS), "v1" === this.options.compatibilityAPI ? vh({}, {}, this.getResource(e4, t3)) : this.getResource(e4, t3);
  } }, { key: "getDataByLanguage", value: function(e4) {
    return this.data[e4];
  } }, { key: "toJSON", value: function() {
    return this.data;
  } }]), t2;
}(), Vh = { processors: {}, addPostProcessor: function(e3) {
  this.processors[e3.name] = e3;
}, handle: function(e3, t2, n2, r2, o2) {
  var i2 = this;
  return e3.forEach(function(e4) {
    i2.processors[e4] && (t2 = i2.processors[e4].process(t2, n2, r2, o2));
  }), t2;
} }, zh = {}, Hh = function(e3) {
  function t2(e4) {
    var n2, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return yh(this, t2), n2 = xh(this, Sh(t2).call(this)), Bh && Nh.call(wh(n2)), Mh(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e4, wh(n2)), n2.options = r2, void 0 === n2.options.keySeparator && (n2.options.keySeparator = "."), n2.logger = Ch.create("translator"), n2;
  }
  return Eh(t2, Nh), bh(t2, [{ key: "changeLanguage", value: function(e4) {
    e4 && (this.language = e4);
  } }, { key: "exists", value: function(e4) {
    var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { interpolation: {} };
    if (null == e4)
      return false;
    var n2 = this.resolve(e4, t3);
    return n2 && void 0 !== n2.res;
  } }, { key: "extractFromKey", value: function(e4, t3) {
    var n2 = void 0 !== t3.nsSeparator ? t3.nsSeparator : this.options.nsSeparator;
    void 0 === n2 && (n2 = ":");
    var r2 = void 0 !== t3.keySeparator ? t3.keySeparator : this.options.keySeparator, o2 = t3.ns || this.options.defaultNS;
    if (n2 && e4.indexOf(n2) > -1) {
      var i2 = e4.match(this.interpolator.nestingRegexp);
      if (i2 && i2.length > 0)
        return { key: e4, namespaces: o2 };
      var a2 = e4.split(n2);
      (n2 !== r2 || n2 === r2 && this.options.ns.indexOf(a2[0]) > -1) && (o2 = a2.shift()), e4 = a2.join(r2);
    }
    return "string" == typeof o2 && (o2 = [o2]), { key: e4, namespaces: o2 };
  } }, { key: "translate", value: function(e4, n2, r2) {
    var o2 = this;
    if ("object" !== ph(n2) && this.options.overloadTranslationOptionHandler && (n2 = this.options.overloadTranslationOptionHandler(arguments)), n2 || (n2 = {}), null == e4)
      return "";
    Array.isArray(e4) || (e4 = [String(e4)]);
    var i2 = void 0 !== n2.keySeparator ? n2.keySeparator : this.options.keySeparator, a2 = this.extractFromKey(e4[e4.length - 1], n2), s2 = a2.key, l2 = a2.namespaces, u2 = l2[l2.length - 1], c2 = n2.lng || this.language, f2 = n2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (c2 && "cimode" === c2.toLowerCase()) {
      if (f2) {
        var d3 = n2.nsSeparator || this.options.nsSeparator;
        return u2 + d3 + s2;
      }
      return s2;
    }
    var h2 = this.resolve(e4, n2), p2 = h2 && h2.res, g2 = h2 && h2.usedKey || s2, v2 = h2 && h2.exactUsedKey || s2, y2 = Object.prototype.toString.apply(p2), m2 = ["[object Number]", "[object Function]", "[object RegExp]"], b2 = void 0 !== n2.joinArrays ? n2.joinArrays : this.options.joinArrays, w2 = !this.i18nFormat || this.i18nFormat.handleAsObject, x2 = "string" != typeof p2 && "boolean" != typeof p2 && "number" != typeof p2;
    if (w2 && p2 && x2 && m2.indexOf(y2) < 0 && ("string" != typeof b2 || "[object Array]" !== y2)) {
      if (!n2.returnObjects && !this.options.returnObjects)
        return this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(g2, p2, vh({}, n2, { ns: l2 })) : "key '".concat(s2, " (").concat(this.language, ")' returned an object instead of string.");
      if (i2) {
        var S2 = "[object Array]" === y2, k2 = S2 ? [] : {}, E2 = S2 ? v2 : g2;
        for (var O2 in p2)
          if (Object.prototype.hasOwnProperty.call(p2, O2)) {
            var C2 = "".concat(E2).concat(i2).concat(O2);
            k2[O2] = this.translate(C2, vh({}, n2, { joinArrays: false, ns: l2 })), k2[O2] === C2 && (k2[O2] = p2[O2]);
          }
        p2 = k2;
      }
    } else if (w2 && "string" == typeof b2 && "[object Array]" === y2)
      (p2 = p2.join(b2)) && (p2 = this.extendTranslation(p2, e4, n2, r2));
    else {
      var N2 = false, T2 = false, L2 = void 0 !== n2.count && "string" != typeof n2.count, M2 = t2.hasDefaultValue(n2), P2 = L2 ? this.pluralResolver.getSuffix(c2, n2.count) : "", D2 = n2["defaultValue".concat(P2)] || n2.defaultValue;
      !this.isValidLookup(p2) && M2 && (N2 = true, p2 = D2), this.isValidLookup(p2) || (T2 = true, p2 = s2);
      var R2 = n2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, j2 = R2 && T2 ? void 0 : p2, A2 = M2 && D2 !== p2 && this.options.updateMissing;
      if (T2 || N2 || A2) {
        if (this.logger.log(A2 ? "updateKey" : "missingKey", c2, u2, s2, A2 ? D2 : p2), i2) {
          var F2 = this.resolve(s2, vh({}, n2, { keySeparator: false }));
          F2 && F2.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        var I2 = [], _2 = this.languageUtils.getFallbackCodes(this.options.fallbackLng, n2.lng || this.language);
        if ("fallback" === this.options.saveMissingTo && _2 && _2[0])
          for (var B2 = 0; B2 < _2.length; B2++)
            I2.push(_2[B2]);
        else
          "all" === this.options.saveMissingTo ? I2 = this.languageUtils.toResolveHierarchy(n2.lng || this.language) : I2.push(n2.lng || this.language);
        var $2 = function(e5, t3, r3) {
          o2.options.missingKeyHandler ? o2.options.missingKeyHandler(e5, u2, t3, A2 ? r3 : j2, A2, n2) : o2.backendConnector && o2.backendConnector.saveMissing && o2.backendConnector.saveMissing(e5, u2, t3, A2 ? r3 : j2, A2, n2), o2.emit("missingKey", e5, u2, t3, p2);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && L2 ? I2.forEach(function(e5) {
          o2.pluralResolver.getSuffixes(e5).forEach(function(t3) {
            $2([e5], s2 + t3, n2["defaultValue".concat(t3)] || D2);
          });
        }) : $2(I2, s2, D2));
      }
      p2 = this.extendTranslation(p2, e4, n2, h2, r2), T2 && p2 === s2 && this.options.appendNamespaceToMissingKey && (p2 = "".concat(u2, ":").concat(s2)), (T2 || N2) && this.options.parseMissingKeyHandler && (p2 = this.options.parseMissingKeyHandler(p2));
    }
    return p2;
  } }, { key: "extendTranslation", value: function(e4, t3, n2, r2, o2) {
    var i2 = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e4 = this.i18nFormat.parse(e4, n2, r2.usedLng, r2.usedNS, r2.usedKey, { resolved: r2 });
    else if (!n2.skipInterpolation) {
      n2.interpolation && this.interpolator.init(vh({}, n2, { interpolation: vh({}, this.options.interpolation, n2.interpolation) }));
      var a2, s2 = n2.interpolation && n2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      if (s2) {
        var l2 = e4.match(this.interpolator.nestingRegexp);
        a2 = l2 && l2.length;
      }
      var u2 = n2.replace && "string" != typeof n2.replace ? n2.replace : n2;
      if (this.options.interpolation.defaultVariables && (u2 = vh({}, this.options.interpolation.defaultVariables, u2)), e4 = this.interpolator.interpolate(e4, u2, n2.lng || this.language, n2), s2) {
        var c2 = e4.match(this.interpolator.nestingRegexp);
        a2 < (c2 && c2.length) && (n2.nest = false);
      }
      false !== n2.nest && (e4 = this.interpolator.nest(e4, function() {
        for (var e5 = arguments.length, r3 = new Array(e5), a3 = 0; a3 < e5; a3++)
          r3[a3] = arguments[a3];
        return o2 && o2[0] === r3[0] && !n2.context ? (i2.logger.warn("It seems you are nesting recursively key: ".concat(r3[0], " in key: ").concat(t3[0])), null) : i2.translate.apply(i2, r3.concat([t3]));
      }, n2)), n2.interpolation && this.interpolator.reset();
    }
    var f2 = n2.postProcess || this.options.postProcess, d3 = "string" == typeof f2 ? [f2] : f2;
    return null != e4 && d3 && d3.length && false !== n2.applyPostProcessor && (e4 = Vh.handle(d3, e4, t3, this.options && this.options.postProcessPassResolved ? vh({ i18nResolved: r2 }, n2) : n2, this)), e4;
  } }, { key: "resolve", value: function(e4) {
    var t3, n2, r2, o2, i2, a2 = this, s2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return "string" == typeof e4 && (e4 = [e4]), e4.forEach(function(e5) {
      if (!a2.isValidLookup(t3)) {
        var l2 = a2.extractFromKey(e5, s2), u2 = l2.key;
        n2 = u2;
        var c2 = l2.namespaces;
        a2.options.fallbackNS && (c2 = c2.concat(a2.options.fallbackNS));
        var f2 = void 0 !== s2.count && "string" != typeof s2.count, d3 = void 0 !== s2.context && ("string" == typeof s2.context || "number" == typeof s2.context) && "" !== s2.context, h2 = s2.lngs ? s2.lngs : a2.languageUtils.toResolveHierarchy(s2.lng || a2.language, s2.fallbackLng);
        c2.forEach(function(e6) {
          a2.isValidLookup(t3) || (i2 = e6, !zh["".concat(h2[0], "-").concat(e6)] && a2.utils && a2.utils.hasLoadedNamespace && !a2.utils.hasLoadedNamespace(i2) && (zh["".concat(h2[0], "-").concat(e6)] = true, a2.logger.warn('key "'.concat(n2, '" for languages "').concat(h2.join(", "), `" won't get resolved as namespace "`).concat(i2, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), h2.forEach(function(n3) {
            if (!a2.isValidLookup(t3)) {
              o2 = n3;
              var i3, l3, c3 = u2, h3 = [c3];
              if (a2.i18nFormat && a2.i18nFormat.addLookupKeys)
                a2.i18nFormat.addLookupKeys(h3, u2, n3, e6, s2);
              else
                f2 && (i3 = a2.pluralResolver.getSuffix(n3, s2.count)), f2 && d3 && h3.push(c3 + i3), d3 && h3.push(c3 += "".concat(a2.options.contextSeparator).concat(s2.context)), f2 && h3.push(c3 += i3);
              for (; l3 = h3.pop(); )
                a2.isValidLookup(t3) || (r2 = l3, t3 = a2.getResource(n3, e6, l3, s2));
            }
          }));
        });
      }
    }), { res: t3, usedKey: n2, exactUsedKey: r2, usedLng: o2, usedNS: i2 };
  } }, { key: "isValidLookup", value: function(e4) {
    return !(void 0 === e4 || !this.options.returnNull && null === e4 || !this.options.returnEmptyString && "" === e4);
  } }, { key: "getResource", value: function(e4, t3, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e4, t3, n2, r2) : this.resourceStore.getResource(e4, t3, n2, r2);
  } }], [{ key: "hasDefaultValue", value: function(e4) {
    var t3 = "defaultValue";
    for (var n2 in e4)
      if (Object.prototype.hasOwnProperty.call(e4, n2) && t3 === n2.substring(0, t3.length) && void 0 !== e4[n2])
        return true;
    return false;
  } }]), t2;
}();
function Uh(e3) {
  return e3.charAt(0).toUpperCase() + e3.slice(1);
}
var Kh = function() {
  function e3(t2) {
    yh(this, e3), this.options = t2, this.whitelist = this.options.supportedLngs || false, this.supportedLngs = this.options.supportedLngs || false, this.logger = Ch.create("languageUtils");
  }
  return bh(e3, [{ key: "getScriptPartFromCode", value: function(e4) {
    if (!e4 || e4.indexOf("-") < 0)
      return null;
    var t2 = e4.split("-");
    return 2 === t2.length ? null : (t2.pop(), "x" === t2[t2.length - 1].toLowerCase() ? null : this.formatLanguageCode(t2.join("-")));
  } }, { key: "getLanguagePartFromCode", value: function(e4) {
    if (!e4 || e4.indexOf("-") < 0)
      return e4;
    var t2 = e4.split("-");
    return this.formatLanguageCode(t2[0]);
  } }, { key: "formatLanguageCode", value: function(e4) {
    if ("string" == typeof e4 && e4.indexOf("-") > -1) {
      var t2 = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], n2 = e4.split("-");
      return this.options.lowerCaseLng ? n2 = n2.map(function(e5) {
        return e5.toLowerCase();
      }) : 2 === n2.length ? (n2[0] = n2[0].toLowerCase(), n2[1] = n2[1].toUpperCase(), t2.indexOf(n2[1].toLowerCase()) > -1 && (n2[1] = Uh(n2[1].toLowerCase()))) : 3 === n2.length && (n2[0] = n2[0].toLowerCase(), 2 === n2[1].length && (n2[1] = n2[1].toUpperCase()), "sgn" !== n2[0] && 2 === n2[2].length && (n2[2] = n2[2].toUpperCase()), t2.indexOf(n2[1].toLowerCase()) > -1 && (n2[1] = Uh(n2[1].toLowerCase())), t2.indexOf(n2[2].toLowerCase()) > -1 && (n2[2] = Uh(n2[2].toLowerCase()))), n2.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e4.toLowerCase() : e4;
  } }, { key: "isWhitelisted", value: function(e4) {
    return this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`), this.isSupportedCode(e4);
  } }, { key: "isSupportedCode", value: function(e4) {
    return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e4 = this.getLanguagePartFromCode(e4)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e4) > -1;
  } }, { key: "getBestMatchFromCodes", value: function(e4) {
    var t2, n2 = this;
    return e4 ? (e4.forEach(function(e5) {
      if (!t2) {
        var r2 = n2.formatLanguageCode(e5);
        n2.options.supportedLngs && !n2.isSupportedCode(r2) || (t2 = r2);
      }
    }), !t2 && this.options.supportedLngs && e4.forEach(function(e5) {
      if (!t2) {
        var r2 = n2.getLanguagePartFromCode(e5);
        if (n2.isSupportedCode(r2))
          return t2 = r2;
        t2 = n2.options.supportedLngs.find(function(e6) {
          if (0 === e6.indexOf(r2))
            return e6;
        });
      }
    }), t2 || (t2 = this.getFallbackCodes(this.options.fallbackLng)[0]), t2) : null;
  } }, { key: "getFallbackCodes", value: function(e4, t2) {
    if (!e4)
      return [];
    if ("function" == typeof e4 && (e4 = e4(t2)), "string" == typeof e4 && (e4 = [e4]), "[object Array]" === Object.prototype.toString.apply(e4))
      return e4;
    if (!t2)
      return e4.default || [];
    var n2 = e4[t2];
    return n2 || (n2 = e4[this.getScriptPartFromCode(t2)]), n2 || (n2 = e4[this.formatLanguageCode(t2)]), n2 || (n2 = e4[this.getLanguagePartFromCode(t2)]), n2 || (n2 = e4.default), n2 || [];
  } }, { key: "toResolveHierarchy", value: function(e4, t2) {
    var n2 = this, r2 = this.getFallbackCodes(t2 || this.options.fallbackLng || [], e4), o2 = [], i2 = function(e5) {
      e5 && (n2.isSupportedCode(e5) ? o2.push(e5) : n2.logger.warn("rejecting language code not found in supportedLngs: ".concat(e5)));
    };
    return "string" == typeof e4 && e4.indexOf("-") > -1 ? ("languageOnly" !== this.options.load && i2(this.formatLanguageCode(e4)), "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && i2(this.getScriptPartFromCode(e4)), "currentOnly" !== this.options.load && i2(this.getLanguagePartFromCode(e4))) : "string" == typeof e4 && i2(this.formatLanguageCode(e4)), r2.forEach(function(e5) {
      o2.indexOf(e5) < 0 && i2(n2.formatLanguageCode(e5));
    }), o2;
  } }]), e3;
}(), qh = [{ lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"], nr: [1, 2], fc: 1 }, { lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"], nr: [1, 2], fc: 2 }, { lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"], nr: [1], fc: 3 }, { lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"], nr: [1, 2, 5], fc: 4 }, { lngs: ["ar"], nr: [0, 1, 2, 3, 11, 100], fc: 5 }, { lngs: ["cs", "sk"], nr: [1, 2, 5], fc: 6 }, { lngs: ["csb", "pl"], nr: [1, 2, 5], fc: 7 }, { lngs: ["cy"], nr: [1, 2, 3, 8], fc: 8 }, { lngs: ["fr"], nr: [1, 2], fc: 9 }, { lngs: ["ga"], nr: [1, 2, 3, 7, 11], fc: 10 }, { lngs: ["gd"], nr: [1, 2, 3, 20], fc: 11 }, { lngs: ["is"], nr: [1, 2], fc: 12 }, { lngs: ["jv"], nr: [0, 1], fc: 13 }, { lngs: ["kw"], nr: [1, 2, 3, 4], fc: 14 }, { lngs: ["lt"], nr: [1, 2, 10], fc: 15 }, { lngs: ["lv"], nr: [1, 2, 0], fc: 16 }, { lngs: ["mk"], nr: [1, 2], fc: 17 }, { lngs: ["mnk"], nr: [0, 1, 2], fc: 18 }, { lngs: ["mt"], nr: [1, 2, 11, 20], fc: 19 }, { lngs: ["or"], nr: [2, 1], fc: 2 }, { lngs: ["ro"], nr: [1, 2, 20], fc: 20 }, { lngs: ["sl"], nr: [5, 1, 2, 3], fc: 21 }, { lngs: ["he", "iw"], nr: [1, 2, 20, 21], fc: 22 }], Gh = { 1: function(e3) {
  return Number(e3 > 1);
}, 2: function(e3) {
  return Number(1 != e3);
}, 3: function(e3) {
  return 0;
}, 4: function(e3) {
  return Number(e3 % 10 == 1 && e3 % 100 != 11 ? 0 : e3 % 10 >= 2 && e3 % 10 <= 4 && (e3 % 100 < 10 || e3 % 100 >= 20) ? 1 : 2);
}, 5: function(e3) {
  return Number(0 == e3 ? 0 : 1 == e3 ? 1 : 2 == e3 ? 2 : e3 % 100 >= 3 && e3 % 100 <= 10 ? 3 : e3 % 100 >= 11 ? 4 : 5);
}, 6: function(e3) {
  return Number(1 == e3 ? 0 : e3 >= 2 && e3 <= 4 ? 1 : 2);
}, 7: function(e3) {
  return Number(1 == e3 ? 0 : e3 % 10 >= 2 && e3 % 10 <= 4 && (e3 % 100 < 10 || e3 % 100 >= 20) ? 1 : 2);
}, 8: function(e3) {
  return Number(1 == e3 ? 0 : 2 == e3 ? 1 : 8 != e3 && 11 != e3 ? 2 : 3);
}, 9: function(e3) {
  return Number(e3 >= 2);
}, 10: function(e3) {
  return Number(1 == e3 ? 0 : 2 == e3 ? 1 : e3 < 7 ? 2 : e3 < 11 ? 3 : 4);
}, 11: function(e3) {
  return Number(1 == e3 || 11 == e3 ? 0 : 2 == e3 || 12 == e3 ? 1 : e3 > 2 && e3 < 20 ? 2 : 3);
}, 12: function(e3) {
  return Number(e3 % 10 != 1 || e3 % 100 == 11);
}, 13: function(e3) {
  return Number(0 !== e3);
}, 14: function(e3) {
  return Number(1 == e3 ? 0 : 2 == e3 ? 1 : 3 == e3 ? 2 : 3);
}, 15: function(e3) {
  return Number(e3 % 10 == 1 && e3 % 100 != 11 ? 0 : e3 % 10 >= 2 && (e3 % 100 < 10 || e3 % 100 >= 20) ? 1 : 2);
}, 16: function(e3) {
  return Number(e3 % 10 == 1 && e3 % 100 != 11 ? 0 : 0 !== e3 ? 1 : 2);
}, 17: function(e3) {
  return Number(1 == e3 || e3 % 10 == 1 && e3 % 100 != 11 ? 0 : 1);
}, 18: function(e3) {
  return Number(0 == e3 ? 0 : 1 == e3 ? 1 : 2);
}, 19: function(e3) {
  return Number(1 == e3 ? 0 : 0 == e3 || e3 % 100 > 1 && e3 % 100 < 11 ? 1 : e3 % 100 > 10 && e3 % 100 < 20 ? 2 : 3);
}, 20: function(e3) {
  return Number(1 == e3 ? 0 : 0 == e3 || e3 % 100 > 0 && e3 % 100 < 20 ? 1 : 2);
}, 21: function(e3) {
  return Number(e3 % 100 == 1 ? 1 : e3 % 100 == 2 ? 2 : e3 % 100 == 3 || e3 % 100 == 4 ? 3 : 0);
}, 22: function(e3) {
  return Number(1 == e3 ? 0 : 2 == e3 ? 1 : (e3 < 0 || e3 > 10) && e3 % 10 == 0 ? 2 : 3);
} };
function Jh() {
  var e3 = {};
  return qh.forEach(function(t2) {
    t2.lngs.forEach(function(n2) {
      e3[n2] = { numbers: t2.nr, plurals: Gh[t2.fc] };
    });
  }), e3;
}
var Yh = function() {
  function e3(t2) {
    var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    yh(this, e3), this.languageUtils = t2, this.options = n2, this.logger = Ch.create("pluralResolver"), this.rules = Jh();
  }
  return bh(e3, [{ key: "addRule", value: function(e4, t2) {
    this.rules[e4] = t2;
  } }, { key: "getRule", value: function(e4) {
    return this.rules[e4] || this.rules[this.languageUtils.getLanguagePartFromCode(e4)];
  } }, { key: "needsPlural", value: function(e4) {
    var t2 = this.getRule(e4);
    return t2 && t2.numbers.length > 1;
  } }, { key: "getPluralFormsOfKey", value: function(e4, t2) {
    return this.getSuffixes(e4).map(function(e5) {
      return t2 + e5;
    });
  } }, { key: "getSuffixes", value: function(e4) {
    var t2 = this, n2 = this.getRule(e4);
    return n2 ? n2.numbers.map(function(n3) {
      return t2.getSuffix(e4, n3);
    }) : [];
  } }, { key: "getSuffix", value: function(e4, t2) {
    var n2 = this, r2 = this.getRule(e4);
    if (r2) {
      var o2 = r2.noAbs ? r2.plurals(t2) : r2.plurals(Math.abs(t2)), i2 = r2.numbers[o2];
      this.options.simplifyPluralSuffix && 2 === r2.numbers.length && 1 === r2.numbers[0] && (2 === i2 ? i2 = "plural" : 1 === i2 && (i2 = ""));
      var a2 = function() {
        return n2.options.prepend && i2.toString() ? n2.options.prepend + i2.toString() : i2.toString();
      };
      return "v1" === this.options.compatibilityJSON ? 1 === i2 ? "" : "number" == typeof i2 ? "_plural_".concat(i2.toString()) : a2() : "v2" === this.options.compatibilityJSON || this.options.simplifyPluralSuffix && 2 === r2.numbers.length && 1 === r2.numbers[0] ? a2() : this.options.prepend && o2.toString() ? this.options.prepend + o2.toString() : o2.toString();
    }
    return this.logger.warn("no plural rule found for: ".concat(e4)), "";
  } }]), e3;
}(), Xh = function() {
  function e3() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    yh(this, e3), this.logger = Ch.create("interpolator"), this.options = t2, this.format = t2.interpolation && t2.interpolation.format || function(e4) {
      return e4;
    }, this.init(t2);
  }
  return bh(e3, [{ key: "init", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    e4.interpolation || (e4.interpolation = { escapeValue: true });
    var t2 = e4.interpolation;
    this.escape = void 0 !== t2.escape ? t2.escape : _h, this.escapeValue = void 0 === t2.escapeValue || t2.escapeValue, this.useRawValueToEscape = void 0 !== t2.useRawValueToEscape && t2.useRawValueToEscape, this.prefix = t2.prefix ? Fh(t2.prefix) : t2.prefixEscaped || "{{", this.suffix = t2.suffix ? Fh(t2.suffix) : t2.suffixEscaped || "}}", this.formatSeparator = t2.formatSeparator ? t2.formatSeparator : t2.formatSeparator || ",", this.unescapePrefix = t2.unescapeSuffix ? "" : t2.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : t2.unescapeSuffix || "", this.nestingPrefix = t2.nestingPrefix ? Fh(t2.nestingPrefix) : t2.nestingPrefixEscaped || Fh("$t("), this.nestingSuffix = t2.nestingSuffix ? Fh(t2.nestingSuffix) : t2.nestingSuffixEscaped || Fh(")"), this.nestingOptionsSeparator = t2.nestingOptionsSeparator ? t2.nestingOptionsSeparator : t2.nestingOptionsSeparator || ",", this.maxReplaces = t2.maxReplaces ? t2.maxReplaces : 1e3, this.alwaysFormat = void 0 !== t2.alwaysFormat && t2.alwaysFormat, this.resetRegExp();
  } }, { key: "reset", value: function() {
    this.options && this.init(this.options);
  } }, { key: "resetRegExp", value: function() {
    var e4 = "".concat(this.prefix, "(.+?)").concat(this.suffix);
    this.regexp = new RegExp(e4, "g");
    var t2 = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
    this.regexpUnescape = new RegExp(t2, "g");
    var n2 = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
    this.nestingRegexp = new RegExp(n2, "g");
  } }, { key: "interpolate", value: function(e4, t2, n2, r2) {
    var o2, i2, a2, s2 = this, l2 = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function u2(e5) {
      return e5.replace(/\$/g, "$$$$");
    }
    var c2 = function(e5) {
      if (e5.indexOf(s2.formatSeparator) < 0) {
        var o3 = jh(t2, l2, e5);
        return s2.alwaysFormat ? s2.format(o3, void 0, n2, vh({}, r2, t2, { interpolationkey: e5 })) : o3;
      }
      var i3 = e5.split(s2.formatSeparator), a3 = i3.shift().trim(), u3 = i3.join(s2.formatSeparator).trim();
      return s2.format(jh(t2, l2, a3), u3, n2, vh({}, r2, t2, { interpolationkey: a3 }));
    };
    this.resetRegExp();
    var f2 = r2 && r2.missingInterpolationHandler || this.options.missingInterpolationHandler, d3 = r2 && r2.interpolation && r2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables, h2 = [{ regex: this.regexpUnescape, safeValue: function(e5) {
      return u2(e5);
    } }, { regex: this.regexp, safeValue: function(e5) {
      return s2.escapeValue ? u2(s2.escape(e5)) : u2(e5);
    } }];
    return h2.forEach(function(t3) {
      for (a2 = 0; o2 = t3.regex.exec(e4); ) {
        if (void 0 === (i2 = c2(o2[1].trim())))
          if ("function" == typeof f2) {
            var n3 = f2(e4, o2, r2);
            i2 = "string" == typeof n3 ? n3 : "";
          } else {
            if (d3) {
              i2 = o2[0];
              continue;
            }
            s2.logger.warn("missed to pass in variable ".concat(o2[1], " for interpolating ").concat(e4)), i2 = "";
          }
        else
          "string" == typeof i2 || s2.useRawValueToEscape || (i2 = Lh(i2));
        var l3 = t3.safeValue(i2);
        if (e4 = e4.replace(o2[0], l3), d3 ? (t3.regex.lastIndex += l3.length, t3.regex.lastIndex -= o2[0].length) : t3.regex.lastIndex = 0, ++a2 >= s2.maxReplaces)
          break;
      }
    }), e4;
  } }, { key: "nest", value: function(e4, t2) {
    var n2, r2, o2 = this, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, a2 = vh({}, i2);
    function s2(e5, t3) {
      var n3 = this.nestingOptionsSeparator;
      if (e5.indexOf(n3) < 0)
        return e5;
      var r3 = e5.split(new RegExp("".concat(n3, "[ ]*{"))), o3 = "{".concat(r3[1]);
      e5 = r3[0], o3 = (o3 = this.interpolate(o3, a2)).replace(/'/g, '"');
      try {
        a2 = JSON.parse(o3), t3 && (a2 = vh({}, t3, a2));
      } catch (t4) {
        return this.logger.warn("failed parsing options string in nesting for key ".concat(e5), t4), "".concat(e5).concat(n3).concat(o3);
      }
      return delete a2.defaultValue, e5;
    }
    for (a2.applyPostProcessor = false, delete a2.defaultValue; n2 = this.nestingRegexp.exec(e4); ) {
      var l2 = [], u2 = false;
      if (-1 !== n2[0].indexOf(this.formatSeparator) && !/{.*}/.test(n2[1])) {
        var c2 = n2[1].split(this.formatSeparator).map(function(e5) {
          return e5.trim();
        });
        n2[1] = c2.shift(), l2 = c2, u2 = true;
      }
      if ((r2 = t2(s2.call(this, n2[1].trim(), a2), a2)) && n2[0] === e4 && "string" != typeof r2)
        return r2;
      "string" != typeof r2 && (r2 = Lh(r2)), r2 || (this.logger.warn("missed to resolve ".concat(n2[1], " for nesting ").concat(e4)), r2 = ""), u2 && (r2 = l2.reduce(function(e5, t3) {
        return o2.format(e5, t3, i2.lng, vh({}, i2, { interpolationkey: n2[1].trim() }));
      }, r2.trim())), e4 = e4.replace(n2[0], r2), this.regexp.lastIndex = 0;
    }
    return e4;
  } }]), e3;
}();
var Qh = function(e3) {
  function t2(e4, n2, r2) {
    var o2, i2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    return yh(this, t2), o2 = xh(this, Sh(t2).call(this)), Bh && Nh.call(wh(o2)), o2.backend = e4, o2.store = n2, o2.services = r2, o2.languageUtils = r2.languageUtils, o2.options = i2, o2.logger = Ch.create("backendConnector"), o2.state = {}, o2.queue = [], o2.backend && o2.backend.init && o2.backend.init(r2, i2.backend, i2), o2;
  }
  return Eh(t2, Nh), bh(t2, [{ key: "queueLoad", value: function(e4, t3, n2, r2) {
    var o2 = this, i2 = [], a2 = [], s2 = [], l2 = [];
    return e4.forEach(function(e5) {
      var r3 = true;
      t3.forEach(function(t4) {
        var s3 = "".concat(e5, "|").concat(t4);
        !n2.reload && o2.store.hasResourceBundle(e5, t4) ? o2.state[s3] = 2 : o2.state[s3] < 0 || (1 === o2.state[s3] ? a2.indexOf(s3) < 0 && a2.push(s3) : (o2.state[s3] = 1, r3 = false, a2.indexOf(s3) < 0 && a2.push(s3), i2.indexOf(s3) < 0 && i2.push(s3), l2.indexOf(t4) < 0 && l2.push(t4)));
      }), r3 || s2.push(e5);
    }), (i2.length || a2.length) && this.queue.push({ pending: a2, loaded: {}, errors: [], callback: r2 }), { toLoad: i2, pending: a2, toLoadLanguages: s2, toLoadNamespaces: l2 };
  } }, { key: "loaded", value: function(e4, t3, n2) {
    var r2 = e4.split("|"), o2 = r2[0], i2 = r2[1];
    t3 && this.emit("failedLoading", o2, i2, t3), n2 && this.store.addResourceBundle(o2, i2, n2), this.state[e4] = t3 ? -1 : 2;
    var a2 = {};
    this.queue.forEach(function(n3) {
      !function(e5, t4, n4, r3) {
        var o3 = Ph(e5, t4, Object), i3 = o3.obj, a3 = o3.k;
        i3[a3] = i3[a3] || [], r3 && (i3[a3] = i3[a3].concat(n4)), r3 || i3[a3].push(n4);
      }(n3.loaded, [o2], i2), function(e5, t4) {
        for (var n4 = e5.indexOf(t4); -1 !== n4; )
          e5.splice(n4, 1), n4 = e5.indexOf(t4);
      }(n3.pending, e4), t3 && n3.errors.push(t3), 0 !== n3.pending.length || n3.done || (Object.keys(n3.loaded).forEach(function(e5) {
        a2[e5] || (a2[e5] = []), n3.loaded[e5].length && n3.loaded[e5].forEach(function(t4) {
          a2[e5].indexOf(t4) < 0 && a2[e5].push(t4);
        });
      }), n3.done = true, n3.errors.length ? n3.callback(n3.errors) : n3.callback());
    }), this.emit("loaded", a2), this.queue = this.queue.filter(function(e5) {
      return !e5.done;
    });
  } }, { key: "read", value: function(e4, t3, n2) {
    var r2 = this, o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 350, a2 = arguments.length > 5 ? arguments[5] : void 0;
    return e4.length ? this.backend[n2](e4, t3, function(s2, l2) {
      s2 && l2 && o2 < 5 ? setTimeout(function() {
        r2.read.call(r2, e4, t3, n2, o2 + 1, 2 * i2, a2);
      }, i2) : a2(s2, l2);
    }) : a2(null, {});
  } }, { key: "prepareLoading", value: function(e4, t3) {
    var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o2 = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), o2 && o2();
    "string" == typeof e4 && (e4 = this.languageUtils.toResolveHierarchy(e4)), "string" == typeof t3 && (t3 = [t3]);
    var i2 = this.queueLoad(e4, t3, r2, o2);
    if (!i2.toLoad.length)
      return i2.pending.length || o2(), null;
    i2.toLoad.forEach(function(e5) {
      n2.loadOne(e5);
    });
  } }, { key: "load", value: function(e4, t3, n2) {
    this.prepareLoading(e4, t3, {}, n2);
  } }, { key: "reload", value: function(e4, t3, n2) {
    this.prepareLoading(e4, t3, { reload: true }, n2);
  } }, { key: "loadOne", value: function(e4) {
    var t3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", r2 = e4.split("|"), o2 = r2[0], i2 = r2[1];
    this.read(o2, i2, "read", void 0, void 0, function(r3, a2) {
      r3 && t3.logger.warn("".concat(n2, "loading namespace ").concat(i2, " for language ").concat(o2, " failed"), r3), !r3 && a2 && t3.logger.log("".concat(n2, "loaded namespace ").concat(i2, " for language ").concat(o2), a2), t3.loaded(e4, r3, a2);
    });
  } }, { key: "saveMissing", value: function(e4, t3, n2, r2, o2) {
    var i2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : {};
    this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t3) ? this.logger.warn('did not save key "'.concat(n2, '" as the namespace "').concat(t3, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!") : null != n2 && "" !== n2 && (this.backend && this.backend.create && this.backend.create(e4, t3, n2, r2, null, vh({}, i2, { isUpdate: o2 })), e4 && e4[0] && this.store.addResource(e4[0], t3, n2, r2));
  } }]), t2;
}();
function Zh() {
  return { debug: false, initImmediate: true, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: false, whitelist: false, nonExplicitWhitelist: false, supportedLngs: false, nonExplicitSupportedLngs: false, load: "all", preload: false, simplifyPluralSuffix: true, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: false, saveMissing: false, updateMissing: false, saveMissingTo: "fallback", saveMissingPlurals: true, missingKeyHandler: false, missingInterpolationHandler: false, postProcess: false, postProcessPassResolved: false, returnNull: true, returnEmptyString: true, returnObjects: false, joinArrays: false, returnedObjectHandler: false, parseMissingKeyHandler: false, appendNamespaceToMissingKey: false, appendNamespaceToCIMode: false, overloadTranslationOptionHandler: function(e3) {
    var t2 = {};
    if ("object" === ph(e3[1]) && (t2 = e3[1]), "string" == typeof e3[1] && (t2.defaultValue = e3[1]), "string" == typeof e3[2] && (t2.tDescription = e3[2]), "object" === ph(e3[2]) || "object" === ph(e3[3])) {
      var n2 = e3[3] || e3[2];
      Object.keys(n2).forEach(function(e4) {
        t2[e4] = n2[e4];
      });
    }
    return t2;
  }, interpolation: { escapeValue: true, format: function(e3, t2, n2, r2) {
    return e3;
  }, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: false } };
}
function ep$1(e3) {
  return "string" == typeof e3.ns && (e3.ns = [e3.ns]), "string" == typeof e3.fallbackLng && (e3.fallbackLng = [e3.fallbackLng]), "string" == typeof e3.fallbackNS && (e3.fallbackNS = [e3.fallbackNS]), e3.whitelist && (e3.whitelist && e3.whitelist.indexOf("cimode") < 0 && (e3.whitelist = e3.whitelist.concat(["cimode"])), e3.supportedLngs = e3.whitelist), e3.nonExplicitWhitelist && (e3.nonExplicitSupportedLngs = e3.nonExplicitWhitelist), e3.supportedLngs && e3.supportedLngs.indexOf("cimode") < 0 && (e3.supportedLngs = e3.supportedLngs.concat(["cimode"])), e3;
}
function tp$1() {
}
var np$1 = function(e3) {
  function t2() {
    var e4, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = arguments.length > 1 ? arguments[1] : void 0;
    if (yh(this, t2), e4 = xh(this, Sh(t2).call(this)), Bh && Nh.call(wh(e4)), e4.options = ep$1(n2), e4.services = {}, e4.logger = Ch, e4.modules = { external: [] }, r2 && !e4.isInitialized && !n2.isClone) {
      if (!e4.options.initImmediate)
        return e4.init(n2, r2), xh(e4, wh(e4));
      setTimeout(function() {
        e4.init(n2, r2);
      }, 0);
    }
    return e4;
  }
  return Eh(t2, Nh), bh(t2, [{ key: "init", value: function() {
    var e4 = this, t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 ? arguments[1] : void 0;
    function r2(e5) {
      return e5 ? "function" == typeof e5 ? new e5() : e5 : null;
    }
    if ("function" == typeof t3 && (n2 = t3, t3 = {}), t3.whitelist && !t3.supportedLngs && this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'), t3.nonExplicitWhitelist && !t3.nonExplicitSupportedLngs && this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'), this.options = vh({}, Zh(), this.options, ep$1(t3)), this.format = this.options.interpolation.format, n2 || (n2 = tp$1), !this.options.isClone) {
      this.modules.logger ? Ch.init(r2(this.modules.logger), this.options) : Ch.init(null, this.options);
      var o2 = new Kh(this.options);
      this.store = new Wh(this.options.resources, this.options);
      var i2 = this.services;
      i2.logger = Ch, i2.resourceStore = this.store, i2.languageUtils = o2, i2.pluralResolver = new Yh(o2, { prepend: this.options.pluralSeparator, compatibilityJSON: this.options.compatibilityJSON, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), i2.interpolator = new Xh(this.options), i2.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, i2.backendConnector = new Qh(r2(this.modules.backend), i2.resourceStore, i2, this.options), i2.backendConnector.on("*", function(t4) {
        for (var n3 = arguments.length, r3 = new Array(n3 > 1 ? n3 - 1 : 0), o3 = 1; o3 < n3; o3++)
          r3[o3 - 1] = arguments[o3];
        e4.emit.apply(e4, [t4].concat(r3));
      }), this.modules.languageDetector && (i2.languageDetector = r2(this.modules.languageDetector), i2.languageDetector.init(i2, this.options.detection, this.options)), this.modules.i18nFormat && (i2.i18nFormat = r2(this.modules.i18nFormat), i2.i18nFormat.init && i2.i18nFormat.init(this)), this.translator = new Hh(this.services, this.options), this.translator.on("*", function(t4) {
        for (var n3 = arguments.length, r3 = new Array(n3 > 1 ? n3 - 1 : 0), o3 = 1; o3 < n3; o3++)
          r3[o3 - 1] = arguments[o3];
        e4.emit.apply(e4, [t4].concat(r3));
      }), this.modules.external.forEach(function(t4) {
        t4.init && t4.init(e4);
      });
    }
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      var a2 = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      a2.length > 0 && "dev" !== a2[0] && (this.options.lng = a2[0]);
    }
    this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined");
    var s2 = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    s2.forEach(function(t4) {
      e4[t4] = function() {
        var n3;
        return (n3 = e4.store)[t4].apply(n3, arguments);
      };
    });
    var l2 = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    l2.forEach(function(t4) {
      e4[t4] = function() {
        var n3;
        return (n3 = e4.store)[t4].apply(n3, arguments), e4;
      };
    });
    var u2 = Th(), c2 = function() {
      var t4 = function(t5, r3) {
        e4.isInitialized && !e4.initializedStoreOnce && e4.logger.warn("init: i18next is already initialized. You should call init just once!"), e4.isInitialized = true, e4.options.isClone || e4.logger.log("initialized", e4.options), e4.emit("initialized", e4.options), u2.resolve(r3), n2(t5, r3);
      };
      if (e4.languages && "v1" !== e4.options.compatibilityAPI && !e4.isInitialized)
        return t4(null, e4.t.bind(e4));
      e4.changeLanguage(e4.options.lng, t4);
    };
    return this.options.resources || !this.options.initImmediate ? c2() : setTimeout(c2, 0), u2;
  } }, { key: "loadResources", value: function(e4) {
    var t3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : tp$1, r2 = n2, o2 = "string" == typeof e4 ? e4 : this.language;
    if ("function" == typeof e4 && (r2 = e4), !this.options.resources || this.options.partialBundledLanguages) {
      if (o2 && "cimode" === o2.toLowerCase())
        return r2();
      var i2 = [], a2 = function(e5) {
        e5 && t3.services.languageUtils.toResolveHierarchy(e5).forEach(function(e6) {
          i2.indexOf(e6) < 0 && i2.push(e6);
        });
      };
      if (o2)
        a2(o2);
      else {
        var s2 = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        s2.forEach(function(e5) {
          return a2(e5);
        });
      }
      this.options.preload && this.options.preload.forEach(function(e5) {
        return a2(e5);
      }), this.services.backendConnector.load(i2, this.options.ns, r2);
    } else
      r2(null);
  } }, { key: "reloadResources", value: function(e4, t3, n2) {
    var r2 = Th();
    return e4 || (e4 = this.languages), t3 || (t3 = this.options.ns), n2 || (n2 = tp$1), this.services.backendConnector.reload(e4, t3, function(e5) {
      r2.resolve(), n2(e5);
    }), r2;
  } }, { key: "use", value: function(e4) {
    if (!e4)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e4.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return "backend" === e4.type && (this.modules.backend = e4), ("logger" === e4.type || e4.log && e4.warn && e4.error) && (this.modules.logger = e4), "languageDetector" === e4.type && (this.modules.languageDetector = e4), "i18nFormat" === e4.type && (this.modules.i18nFormat = e4), "postProcessor" === e4.type && Vh.addPostProcessor(e4), "3rdParty" === e4.type && this.modules.external.push(e4), this;
  } }, { key: "changeLanguage", value: function(e4, t3) {
    var n2 = this;
    this.isLanguageChangingTo = e4;
    var r2 = Th();
    this.emit("languageChanging", e4);
    var o2 = function(o3) {
      e4 || o3 || !n2.services.languageDetector || (o3 = []);
      var i2 = "string" == typeof o3 ? o3 : n2.services.languageUtils.getBestMatchFromCodes(o3);
      i2 && (n2.language || (n2.language = i2, n2.languages = n2.services.languageUtils.toResolveHierarchy(i2)), n2.translator.language || n2.translator.changeLanguage(i2), n2.services.languageDetector && n2.services.languageDetector.cacheUserLanguage(i2)), n2.loadResources(i2, function(e5) {
        !function(e6, o4) {
          o4 ? (n2.language = o4, n2.languages = n2.services.languageUtils.toResolveHierarchy(o4), n2.translator.changeLanguage(o4), n2.isLanguageChangingTo = void 0, n2.emit("languageChanged", o4), n2.logger.log("languageChanged", o4)) : n2.isLanguageChangingTo = void 0, r2.resolve(function() {
            return n2.t.apply(n2, arguments);
          }), t3 && t3(e6, function() {
            return n2.t.apply(n2, arguments);
          });
        }(e5, i2);
      });
    };
    return e4 || !this.services.languageDetector || this.services.languageDetector.async ? !e4 && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(o2) : o2(e4) : o2(this.services.languageDetector.detect()), r2;
  } }, { key: "getFixedT", value: function(e4, t3, n2) {
    var r2 = this, o2 = function e5(t4, o3) {
      var i2;
      if ("object" !== ph(o3)) {
        for (var a2 = arguments.length, s2 = new Array(a2 > 2 ? a2 - 2 : 0), l2 = 2; l2 < a2; l2++)
          s2[l2 - 2] = arguments[l2];
        i2 = r2.options.overloadTranslationOptionHandler([t4, o3].concat(s2));
      } else
        i2 = vh({}, o3);
      i2.lng = i2.lng || e5.lng, i2.lngs = i2.lngs || e5.lngs, i2.ns = i2.ns || e5.ns;
      var u2 = r2.options.keySeparator || ".", c2 = n2 ? "".concat(n2).concat(u2).concat(t4) : t4;
      return r2.t(c2, i2);
    };
    return "string" == typeof e4 ? o2.lng = e4 : o2.lngs = e4, o2.ns = t3, o2.keyPrefix = n2, o2;
  } }, { key: "t", value: function() {
    var e4;
    return this.translator && (e4 = this.translator).translate.apply(e4, arguments);
  } }, { key: "exists", value: function() {
    var e4;
    return this.translator && (e4 = this.translator).exists.apply(e4, arguments);
  } }, { key: "setDefaultNamespace", value: function(e4) {
    this.options.defaultNS = e4;
  } }, { key: "hasLoadedNamespace", value: function(e4) {
    var t3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), false;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), false;
    var r2 = this.languages[0], o2 = !!this.options && this.options.fallbackLng, i2 = this.languages[this.languages.length - 1];
    if ("cimode" === r2.toLowerCase())
      return true;
    var a2 = function(e5, n3) {
      var r3 = t3.services.backendConnector.state["".concat(e5, "|").concat(n3)];
      return -1 === r3 || 2 === r3;
    };
    if (n2.precheck) {
      var s2 = n2.precheck(this, a2);
      if (void 0 !== s2)
        return s2;
    }
    return !!this.hasResourceBundle(r2, e4) || (!this.services.backendConnector.backend || !(!a2(r2, e4) || o2 && !a2(i2, e4)));
  } }, { key: "loadNamespaces", value: function(e4, t3) {
    var n2 = this, r2 = Th();
    return this.options.ns ? ("string" == typeof e4 && (e4 = [e4]), e4.forEach(function(e5) {
      n2.options.ns.indexOf(e5) < 0 && n2.options.ns.push(e5);
    }), this.loadResources(function(e5) {
      r2.resolve(), t3 && t3(e5);
    }), r2) : (t3 && t3(), Promise.resolve());
  } }, { key: "loadLanguages", value: function(e4, t3) {
    var n2 = Th();
    "string" == typeof e4 && (e4 = [e4]);
    var r2 = this.options.preload || [], o2 = e4.filter(function(e5) {
      return r2.indexOf(e5) < 0;
    });
    return o2.length ? (this.options.preload = r2.concat(o2), this.loadResources(function(e5) {
      n2.resolve(), t3 && t3(e5);
    }), n2) : (t3 && t3(), Promise.resolve());
  } }, { key: "dir", value: function(e4) {
    if (e4 || (e4 = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !e4)
      return "rtl";
    return ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e4)) >= 0 ? "rtl" : "ltr";
  } }, { key: "createInstance", value: function() {
    var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = arguments.length > 1 ? arguments[1] : void 0;
    return new t2(e4, n2);
  } }, { key: "cloneInstance", value: function() {
    var e4 = this, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : tp$1, o2 = vh({}, this.options, n2, { isClone: true }), i2 = new t2(o2), a2 = ["store", "services", "language"];
    return a2.forEach(function(t3) {
      i2[t3] = e4[t3];
    }), i2.services = vh({}, this.services), i2.services.utils = { hasLoadedNamespace: i2.hasLoadedNamespace.bind(i2) }, i2.translator = new Hh(i2.services, i2.options), i2.translator.on("*", function(e5) {
      for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
        n3[r3 - 1] = arguments[r3];
      i2.emit.apply(i2, [e5].concat(n3));
    }), i2.init(o2, r2), i2.translator.options = i2.options, i2.translator.backendConnector.services.utils = { hasLoadedNamespace: i2.hasLoadedNamespace.bind(i2) }, i2;
  } }, { key: "toJSON", value: function() {
    return { options: this.options, store: this.store, language: this.language, languages: this.languages };
  } }]), t2;
}(), rp$1 = new np$1(), op$1 = "translation";
function ip$1(e3, t2) {
  rp$1.addResourceBundle(e3, op$1, t2, true, true);
}
rp$1.init({ lng: "zh-CN", resources: {} });
var lp$1 = rp$1.t.bind(rp$1);
var enResources = {
  editor: {
    more: "More",
    justify: "Justify",
    indent: "Indent",
    image: "Image",
    video: "Video"
  }
};
var zhResources = {
  editor: {
    more: "\u66F4\u591A",
    justify: "\u5BF9\u9F50",
    indent: "\u7F29\u8FDB",
    image: "\u56FE\u7247",
    video: "\u89C6\u9891"
  }
};
ip$1("en", enResources);
ip$1("zh-CN", zhResources);
ip$1("en", { common: { ok: "OK", delete: "Delete", enter: "Enter" }, blockQuote: { title: "Quote" }, codeBlock: { title: "Code block" }, color: { color: "Font color", bgColor: "Back color", default: "Default color", clear: "Clear back color" }, divider: { title: "Divider" }, emotion: { title: "Emotion" }, fontSize: { title: "Font size", default: "Default" }, fontFamily: { title: "Font family", default: "Default" }, fullScreen: { title: "Full screen" }, header: { title: "Header", text: "Text" }, image: { netImage: "Net image", delete: "Delete image", edit: "Edit image", viewLink: "View link", src: "Image src", desc: "Description", link: "Image link" }, indent: { decrease: "Decrease", increase: "Increase" }, justify: { left: "Left", right: "Right", center: "Center", justify: "Justify" }, lineHeight: { title: "Line height", default: "Default" }, link: { insert: "Insert link", text: "Link text", url: "Link source", unLink: "Unlink", edit: "Edit link", view: "View link" }, textStyle: { bold: "Bold", clear: "Clear styles", code: "Inline code", italic: "Italic", sub: "Sub", sup: "Sup", through: "Through", underline: "Underline" }, undo: { undo: "undo", redo: "Redo" }, todo: { todo: "Todo" } }), ip$1("zh-CN", { common: { ok: "\u786E\u5B9A", delete: "\u5220\u9664", enter: "\u56DE\u8F66" }, blockQuote: { title: "\u5F15\u7528" }, codeBlock: { title: "\u4EE3\u7801\u5757" }, color: { color: "\u6587\u5B57\u989C\u8272", bgColor: "\u80CC\u666F\u8272", default: "\u9ED8\u8BA4\u989C\u8272", clear: "\u6E05\u9664\u80CC\u666F\u8272" }, divider: { title: "\u5206\u5272\u7EBF" }, emotion: { title: "\u8868\u60C5" }, fontSize: { title: "\u5B57\u53F7", default: "\u9ED8\u8BA4\u5B57\u53F7" }, fontFamily: { title: "\u5B57\u4F53", default: "\u9ED8\u8BA4\u5B57\u4F53" }, fullScreen: { title: "\u5168\u5C4F" }, header: { title: "\u6807\u9898", text: "\u6B63\u6587" }, image: { netImage: "\u7F51\u7EDC\u56FE\u7247", delete: "\u5220\u9664\u56FE\u7247", edit: "\u7F16\u8F91\u56FE\u7247", viewLink: "\u67E5\u770B\u94FE\u63A5", src: "\u56FE\u7247\u5730\u5740", desc: "\u56FE\u7247\u63CF\u8FF0", link: "\u56FE\u7247\u94FE\u63A5" }, indent: { decrease: "\u51CF\u5C11\u7F29\u8FDB", increase: "\u589E\u52A0\u7F29\u8FDB" }, justify: { left: "\u5DE6\u5BF9\u9F50", right: "\u53F3\u5BF9\u9F50", center: "\u5C45\u4E2D\u5BF9\u9F50", justify: "\u4E24\u7AEF\u5BF9\u9F50" }, lineHeight: { title: "\u884C\u9AD8", default: "\u9ED8\u8BA4\u884C\u9AD8" }, link: { insert: "\u63D2\u5165\u94FE\u63A5", text: "\u94FE\u63A5\u6587\u672C", url: "\u94FE\u63A5\u5730\u5740", unLink: "\u53D6\u6D88\u94FE\u63A5", edit: "\u4FEE\u6539\u94FE\u63A5", view: "\u67E5\u770B\u94FE\u63A5" }, textStyle: { bold: "\u7C97\u4F53", clear: "\u6E05\u9664\u683C\u5F0F", code: "\u884C\u5185\u4EE3\u7801", italic: "\u659C\u4F53", sub: "\u4E0B\u6807", sup: "\u4E0A\u6807", through: "\u5220\u9664\u7EBF", underline: "\u4E0B\u5212\u7EBF" }, undo: { undo: "\u64A4\u9500", redo: "\u91CD\u505A" }, todo: { todo: "\u5F85\u529E" } });
var _$5 = { type: "paragraph", renderElem: function(t2, e3, n2) {
  return jsx("p", null, e3);
} };
var $$5 = { type: "paragraph", elemToHtml: function(t2, e3) {
  return "" === e3 ? "<p><br></p>" : "<p>" + e3 + "</p>";
} }, q$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function W$5(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
function G$5(t2) {
  var e3 = { exports: {} };
  return t2(e3, e3.exports), e3.exports;
}
var U$5, X$5, Y$5 = function(t2) {
  return t2 && t2.Math == Math && t2;
}, J$5 = Y$5("object" == typeof globalThis && globalThis) || Y$5("object" == typeof window && window) || Y$5("object" == typeof self && self) || Y$5("object" == typeof q$5 && q$5) || function() {
  return this;
}() || Function("return this")(), K$5 = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, Q$5 = !K$5(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), Z$5 = Function.prototype.call, tt$5 = Z$5.bind ? Z$5.bind(Z$5) : function() {
  return Z$5.apply(Z$5, arguments);
}, et$5 = {}.propertyIsEnumerable, nt$5 = Object.getOwnPropertyDescriptor, rt$5 = nt$5 && !et$5.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = nt$5(this, t2);
  return !!e3 && e3.enumerable;
} : et$5, ot$5 = { f: rt$5 }, it$5 = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, ut$5 = Function.prototype, at$5 = ut$5.bind, ct$5 = ut$5.call, lt$5 = at$5 && at$5.bind(ct$5), st$5 = at$5 ? function(t2) {
  return t2 && lt$5(ct$5, t2);
} : function(t2) {
  return t2 && function() {
    return ct$5.apply(t2, arguments);
  };
}, ft$5 = st$5({}.toString), pt$5 = st$5("".slice), dt$5 = function(t2) {
  return pt$5(ft$5(t2), 8, -1);
}, ht$5 = J$5.Object, vt$5 = st$5("".split), gt$5 = K$5(function() {
  return !ht$5("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == dt$5(t2) ? vt$5(t2, "") : ht$5(t2);
} : ht$5, yt$5 = J$5.TypeError, mt$5 = function(t2) {
  if (null == t2)
    throw yt$5("Can't call method on " + t2);
  return t2;
}, bt$5 = function(t2) {
  return gt$5(mt$5(t2));
}, xt$5 = function(t2) {
  return "function" == typeof t2;
}, wt$5 = function(t2) {
  return "object" == typeof t2 ? null !== t2 : xt$5(t2);
}, St$5 = function(t2) {
  return xt$5(t2) ? t2 : void 0;
}, kt$5 = function(t2, e3) {
  return arguments.length < 2 ? St$5(J$5[t2]) : J$5[t2] && J$5[t2][e3];
}, Et$5 = st$5({}.isPrototypeOf), Tt$5 = kt$5("navigator", "userAgent") || "", Mt$5 = J$5.process, Ht$5 = J$5.Deno, Ot$5 = Mt$5 && Mt$5.versions || Ht$5 && Ht$5.version, It$5 = Ot$5 && Ot$5.v8;
It$5 && (X$5 = (U$5 = It$5.split("."))[0] > 0 && U$5[0] < 4 ? 1 : +(U$5[0] + U$5[1])), !X$5 && Tt$5 && (!(U$5 = Tt$5.match(/Edge\/(\d+)/)) || U$5[1] >= 74) && (U$5 = Tt$5.match(/Chrome\/(\d+)/)) && (X$5 = +U$5[1]);
var Nt$5 = X$5, Lt$5 = !!Object.getOwnPropertySymbols && !K$5(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && Nt$5 && Nt$5 < 41;
}), zt$5 = Lt$5 && !Symbol.sham && "symbol" == typeof Symbol.iterator, jt$5 = J$5.Object, At$5 = zt$5 ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = kt$5("Symbol");
  return xt$5(e3) && Et$5(e3.prototype, jt$5(t2));
}, Pt$5 = J$5.String, Vt$5 = function(t2) {
  try {
    return Pt$5(t2);
  } catch (t3) {
    return "Object";
  }
}, Ct$5 = J$5.TypeError, Dt$5 = function(t2) {
  if (xt$5(t2))
    return t2;
  throw Ct$5(Vt$5(t2) + " is not a function");
}, Bt$5 = function(t2, e3) {
  var n2 = t2[e3];
  return null == n2 ? void 0 : Dt$5(n2);
}, Rt$5 = J$5.TypeError, Ft$5 = Object.defineProperty, _t$5 = function(t2, e3) {
  try {
    Ft$5(J$5, t2, { value: e3, configurable: true, writable: true });
  } catch (n2) {
    J$5[t2] = e3;
  }
  return e3;
}, $t$5 = J$5["__core-js_shared__"] || _t$5("__core-js_shared__", {}), qt$5 = G$5(function(t2) {
  (t2.exports = function(t3, e3) {
    return $t$5[t3] || ($t$5[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), Wt$5 = J$5.Object, Gt$5 = function(t2) {
  return Wt$5(mt$5(t2));
}, Ut$5 = st$5({}.hasOwnProperty), Xt$5 = Object.hasOwn || function(t2, e3) {
  return Ut$5(Gt$5(t2), e3);
}, Yt$5 = 0, Jt$5 = Math.random(), Kt$5 = st$5(1 .toString), Qt$5 = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + Kt$5(++Yt$5 + Jt$5, 36);
}, Zt$5 = qt$5("wks"), te$5 = J$5.Symbol, ee$5 = te$5 && te$5.for, ne$5 = zt$5 ? te$5 : te$5 && te$5.withoutSetter || Qt$5, re$5 = function(t2) {
  if (!Xt$5(Zt$5, t2) || !Lt$5 && "string" != typeof Zt$5[t2]) {
    var e3 = "Symbol." + t2;
    Lt$5 && Xt$5(te$5, t2) ? Zt$5[t2] = te$5[t2] : Zt$5[t2] = zt$5 && ee$5 ? ee$5(e3) : ne$5(e3);
  }
  return Zt$5[t2];
}, oe$5 = J$5.TypeError, ie$5 = re$5("toPrimitive"), ue$5 = function(t2, e3) {
  if (!wt$5(t2) || At$5(t2))
    return t2;
  var n2, r2 = Bt$5(t2, ie$5);
  if (r2) {
    if (void 0 === e3 && (e3 = "default"), n2 = tt$5(r2, t2, e3), !wt$5(n2) || At$5(n2))
      return n2;
    throw oe$5("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var n3, r3;
    if ("string" === e4 && xt$5(n3 = t3.toString) && !wt$5(r3 = tt$5(n3, t3)))
      return r3;
    if (xt$5(n3 = t3.valueOf) && !wt$5(r3 = tt$5(n3, t3)))
      return r3;
    if ("string" !== e4 && xt$5(n3 = t3.toString) && !wt$5(r3 = tt$5(n3, t3)))
      return r3;
    throw Rt$5("Can't convert object to primitive value");
  }(t2, e3);
}, ae$5 = function(t2) {
  var e3 = ue$5(t2, "string");
  return At$5(e3) ? e3 : e3 + "";
}, ce$5 = J$5.document, le$5 = wt$5(ce$5) && wt$5(ce$5.createElement), se$5 = function(t2) {
  return le$5 ? ce$5.createElement(t2) : {};
}, fe$5 = !Q$5 && !K$5(function() {
  return 7 != Object.defineProperty(se$5("div"), "a", { get: function() {
    return 7;
  } }).a;
}), pe$5 = Object.getOwnPropertyDescriptor, de$5 = { f: Q$5 ? pe$5 : function(t2, e3) {
  if (t2 = bt$5(t2), e3 = ae$5(e3), fe$5)
    try {
      return pe$5(t2, e3);
    } catch (t3) {
    }
  if (Xt$5(t2, e3))
    return it$5(!tt$5(ot$5.f, t2, e3), t2[e3]);
} }, he$5 = J$5.String, ve$5 = J$5.TypeError, ge$5 = function(t2) {
  if (wt$5(t2))
    return t2;
  throw ve$5(he$5(t2) + " is not an object");
}, ye$5 = J$5.TypeError, me$5 = Object.defineProperty, be$5 = { f: Q$5 ? me$5 : function(t2, e3, n2) {
  if (ge$5(t2), e3 = ae$5(e3), ge$5(n2), fe$5)
    try {
      return me$5(t2, e3, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw ye$5("Accessors not supported");
  return "value" in n2 && (t2[e3] = n2.value), t2;
} }, xe$5 = Q$5 ? function(t2, e3, n2) {
  return be$5.f(t2, e3, it$5(1, n2));
} : function(t2, e3, n2) {
  return t2[e3] = n2, t2;
}, we$5 = st$5(Function.toString);
xt$5($t$5.inspectSource) || ($t$5.inspectSource = function(t2) {
  return we$5(t2);
});
var Se$5, ke$5, Ee$5, Te$5 = $t$5.inspectSource, Me$5 = J$5.WeakMap, He$5 = xt$5(Me$5) && /native code/.test(Te$5(Me$5)), Oe$5 = qt$5("keys"), Ie$5 = function(t2) {
  return Oe$5[t2] || (Oe$5[t2] = Qt$5(t2));
}, Ne$5 = {}, Le$5 = J$5.TypeError, ze$5 = J$5.WeakMap;
if (He$5 || $t$5.state) {
  var je$5 = $t$5.state || ($t$5.state = new ze$5()), Ae$5 = st$5(je$5.get), Pe$5 = st$5(je$5.has), Ve$5 = st$5(je$5.set);
  Se$5 = function(t2, e3) {
    if (Pe$5(je$5, t2))
      throw new Le$5("Object already initialized");
    return e3.facade = t2, Ve$5(je$5, t2, e3), e3;
  }, ke$5 = function(t2) {
    return Ae$5(je$5, t2) || {};
  }, Ee$5 = function(t2) {
    return Pe$5(je$5, t2);
  };
} else {
  var Ce$5 = Ie$5("state");
  Ne$5[Ce$5] = true, Se$5 = function(t2, e3) {
    if (Xt$5(t2, Ce$5))
      throw new Le$5("Object already initialized");
    return e3.facade = t2, xe$5(t2, Ce$5, e3), e3;
  }, ke$5 = function(t2) {
    return Xt$5(t2, Ce$5) ? t2[Ce$5] : {};
  }, Ee$5 = function(t2) {
    return Xt$5(t2, Ce$5);
  };
}
var De$5 = { set: Se$5, get: ke$5, has: Ee$5, enforce: function(t2) {
  return Ee$5(t2) ? ke$5(t2) : Se$5(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var n2;
    if (!wt$5(e3) || (n2 = ke$5(e3)).type !== t2)
      throw Le$5("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, Be$5 = Function.prototype, Re$5 = Q$5 && Object.getOwnPropertyDescriptor, Fe$5 = Xt$5(Be$5, "name"), _e$5 = { EXISTS: Fe$5, PROPER: Fe$5 && "something" === function() {
}.name, CONFIGURABLE: Fe$5 && (!Q$5 || Q$5 && Re$5(Be$5, "name").configurable) }, $e$5 = G$5(function(t2) {
  var e3 = _e$5.CONFIGURABLE, n2 = De$5.get, r2 = De$5.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, n3, i2, u2) {
    var a2, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, s2 = !!u2 && !!u2.noTargetGet, f2 = u2 && void 0 !== u2.name ? u2.name : n3;
    xt$5(i2) && ("Symbol(" === String(f2).slice(0, 7) && (f2 = "[" + String(f2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Xt$5(i2, "name") || e3 && i2.name !== f2) && xe$5(i2, "name", f2), (a2 = r2(i2)).source || (a2.source = o2.join("string" == typeof f2 ? f2 : ""))), t3 !== J$5 ? (c2 ? !s2 && t3[n3] && (l2 = true) : delete t3[n3], l2 ? t3[n3] = i2 : xe$5(t3, n3, i2)) : l2 ? t3[n3] = i2 : _t$5(n3, i2);
  })(Function.prototype, "toString", function() {
    return xt$5(this) && n2(this).source || Te$5(this);
  });
}), qe$5 = Math.ceil, We$5 = Math.floor, Ge$5 = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? We$5 : qe$5)(e3);
}, Ue$5 = Math.max, Xe$5 = Math.min, Ye$5 = function(t2, e3) {
  var n2 = Ge$5(t2);
  return n2 < 0 ? Ue$5(n2 + e3, 0) : Xe$5(n2, e3);
}, Je$5 = Math.min, Ke$5 = function(t2) {
  return t2 > 0 ? Je$5(Ge$5(t2), 9007199254740991) : 0;
}, Qe$5 = function(t2) {
  return Ke$5(t2.length);
}, Ze$5 = function(t2) {
  return function(e3, n2, r2) {
    var o2, i2 = bt$5(e3), u2 = Qe$5(i2), a2 = Ye$5(r2, u2);
    if (t2 && n2 != n2) {
      for (; u2 > a2; )
        if ((o2 = i2[a2++]) != o2)
          return true;
    } else
      for (; u2 > a2; a2++)
        if ((t2 || a2 in i2) && i2[a2] === n2)
          return t2 || a2 || 0;
    return !t2 && -1;
  };
}, tn$5 = { includes: Ze$5(true), indexOf: Ze$5(false) }, en$5 = tn$5.indexOf, nn$5 = st$5([].push), rn$5 = function(t2, e3) {
  var n2, r2 = bt$5(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !Xt$5(Ne$5, n2) && Xt$5(r2, n2) && nn$5(i2, n2);
  for (; e3.length > o2; )
    Xt$5(r2, n2 = e3[o2++]) && (~en$5(i2, n2) || nn$5(i2, n2));
  return i2;
}, on$5 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], un$5 = on$5.concat("length", "prototype"), an$5 = { f: Object.getOwnPropertyNames || function(t2) {
  return rn$5(t2, un$5);
} }, cn$5 = { f: Object.getOwnPropertySymbols }, ln$5 = st$5([].concat), sn$5 = kt$5("Reflect", "ownKeys") || function(t2) {
  var e3 = an$5.f(ge$5(t2)), n2 = cn$5.f;
  return n2 ? ln$5(e3, n2(t2)) : e3;
}, fn$5 = function(t2, e3) {
  for (var n2 = sn$5(e3), r2 = be$5.f, o2 = de$5.f, i2 = 0; i2 < n2.length; i2++) {
    var u2 = n2[i2];
    Xt$5(t2, u2) || r2(t2, u2, o2(e3, u2));
  }
}, pn$5 = /#|\.prototype\./, dn$5 = function(t2, e3) {
  var n2 = vn$5[hn$5(t2)];
  return n2 == yn$5 || n2 != gn$5 && (xt$5(e3) ? K$5(e3) : !!e3);
}, hn$5 = dn$5.normalize = function(t2) {
  return String(t2).replace(pn$5, ".").toLowerCase();
}, vn$5 = dn$5.data = {}, gn$5 = dn$5.NATIVE = "N", yn$5 = dn$5.POLYFILL = "P", mn$5 = dn$5, bn$5 = de$5.f, xn$5 = function(t2, e3) {
  var n2, r2, o2, i2, u2, a2 = t2.target, c2 = t2.global, l2 = t2.stat;
  if (n2 = c2 ? J$5 : l2 ? J$5[a2] || _t$5(a2, {}) : (J$5[a2] || {}).prototype)
    for (r2 in e3) {
      if (i2 = e3[r2], o2 = t2.noTargetGet ? (u2 = bn$5(n2, r2)) && u2.value : n2[r2], !mn$5(c2 ? r2 : a2 + (l2 ? "." : "#") + r2, t2.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        fn$5(i2, o2);
      }
      (t2.sham || o2 && o2.sham) && xe$5(i2, "sham", true), $e$5(n2, r2, i2, t2);
    }
}, wn$5 = st$5(st$5.bind), Sn$5 = Array.isArray || function(t2) {
  return "Array" == dt$5(t2);
}, kn$5 = {};
kn$5[re$5("toStringTag")] = "z";
var En$5 = "[object z]" === String(kn$5), Tn$5 = re$5("toStringTag"), Mn$5 = J$5.Object, Hn$5 = "Arguments" == dt$5(function() {
  return arguments;
}()), On$5 = En$5 ? dt$5 : function(t2) {
  var e3, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = Mn$5(t2), Tn$5)) ? n2 : Hn$5 ? dt$5(e3) : "Object" == (r2 = dt$5(e3)) && xt$5(e3.callee) ? "Arguments" : r2;
}, In$5 = function() {
}, Nn$5 = [], Ln$5 = kt$5("Reflect", "construct"), zn$5 = /^\s*(?:class|function)\b/, jn$5 = st$5(zn$5.exec), An$5 = !zn$5.exec(In$5), Pn$5 = function(t2) {
  if (!xt$5(t2))
    return false;
  try {
    return Ln$5(In$5, Nn$5, t2), true;
  } catch (t3) {
    return false;
  }
}, Vn$5 = !Ln$5 || K$5(function() {
  var t2;
  return Pn$5(Pn$5.call) || !Pn$5(Object) || !Pn$5(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!xt$5(t2))
    return false;
  switch (On$5(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return An$5 || !!jn$5(zn$5, Te$5(t2));
} : Pn$5, Cn$5 = re$5("species"), Dn$5 = J$5.Array, Bn$5 = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return Sn$5(t3) && (e4 = t3.constructor, (Vn$5(e4) && (e4 === Dn$5 || Sn$5(e4.prototype)) || wt$5(e4) && null === (e4 = e4[Cn$5])) && (e4 = void 0)), void 0 === e4 ? Dn$5 : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, Rn$5 = st$5([].push), Fn$5 = function(t2) {
  var e3 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
  return function(c2, l2, s2, f2) {
    for (var p2, d3, h2 = Gt$5(c2), v2 = gt$5(h2), g2 = function(t3, e4) {
      return Dt$5(t3), void 0 === e4 ? t3 : wn$5 ? wn$5(t3, e4) : function() {
        return t3.apply(e4, arguments);
      };
    }(l2, s2), y2 = Qe$5(v2), m2 = 0, b2 = f2 || Bn$5, x2 = e3 ? b2(c2, y2) : n2 || u2 ? b2(c2, 0) : void 0; y2 > m2; m2++)
      if ((a2 || m2 in v2) && (d3 = g2(p2 = v2[m2], m2, h2), t2))
        if (e3)
          x2[m2] = d3;
        else if (d3)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return p2;
            case 6:
              return m2;
            case 2:
              Rn$5(x2, p2);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              Rn$5(x2, p2);
          }
    return i2 ? -1 : r2 || o2 ? o2 : x2;
  };
}, _n$5 = { forEach: Fn$5(0), map: Fn$5(1), filter: Fn$5(2), some: Fn$5(3), every: Fn$5(4), find: Fn$5(5), findIndex: Fn$5(6), filterReject: Fn$5(7) }, $n$5 = re$5("species"), qn$5 = function(t2) {
  return Nt$5 >= 51 || !K$5(function() {
    var e3 = [];
    return (e3.constructor = {})[$n$5] = function() {
      return { foo: 1 };
    }, 1 !== e3[t2](Boolean).foo;
  });
}, Wn$5 = _n$5.filter;
xn$5({ target: "Array", proto: true, forced: !qn$5("filter") }, { filter: function(t2) {
  return Wn$5(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
var Gn$5 = En$5 ? {}.toString : function() {
  return "[object " + On$5(this) + "]";
};
En$5 || $e$5(Object.prototype, "toString", Gn$5, { unsafe: true });
var Un$5, Xn$5 = J$5.String, Yn$5 = function(t2) {
  if ("Symbol" === On$5(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return Xn$5(t2);
}, Jn$5 = function() {
  var t2 = ge$5(this), e3 = "";
  return t2.global && (e3 += "g"), t2.ignoreCase && (e3 += "i"), t2.multiline && (e3 += "m"), t2.dotAll && (e3 += "s"), t2.unicode && (e3 += "u"), t2.sticky && (e3 += "y"), e3;
}, Kn$5 = J$5.RegExp, Qn$5 = K$5(function() {
  var t2 = Kn$5("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), Zn$5 = Qn$5 || K$5(function() {
  return !Kn$5("a", "y").sticky;
}), tr$4 = { BROKEN_CARET: Qn$5 || K$5(function() {
  var t2 = Kn$5("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}), MISSED_STICKY: Zn$5, UNSUPPORTED_Y: Qn$5 }, er$4 = Object.keys || function(t2) {
  return rn$5(t2, on$5);
}, nr$4 = Q$5 ? Object.defineProperties : function(t2, e3) {
  ge$5(t2);
  for (var n2, r2 = bt$5(e3), o2 = er$4(e3), i2 = o2.length, u2 = 0; i2 > u2; )
    be$5.f(t2, n2 = o2[u2++], r2[n2]);
  return t2;
}, rr$4 = kt$5("document", "documentElement"), or$4 = Ie$5("IE_PROTO"), ir$4 = function() {
}, ur$4 = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, ar$4 = function(t2) {
  t2.write(ur$4("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, cr$4 = function() {
  try {
    Un$5 = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  cr$4 = "undefined" != typeof document ? document.domain && Un$5 ? ar$4(Un$5) : ((e3 = se$5("iframe")).style.display = "none", rr$4.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(ur$4("document.F=Object")), t2.close(), t2.F) : ar$4(Un$5);
  for (var n2 = on$5.length; n2--; )
    delete cr$4.prototype[on$5[n2]];
  return cr$4();
};
Ne$5[or$4] = true;
var lr$4, sr$4, fr$4 = Object.create || function(t2, e3) {
  var n2;
  return null !== t2 ? (ir$4.prototype = ge$5(t2), n2 = new ir$4(), ir$4.prototype = null, n2[or$4] = t2) : n2 = cr$4(), void 0 === e3 ? n2 : nr$4(n2, e3);
}, pr$4 = J$5.RegExp, dr$4 = K$5(function() {
  var t2 = pr$4(".", "s");
  return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
}), hr$4 = J$5.RegExp, vr$4 = K$5(function() {
  var t2 = hr$4("(?<a>b)", "g");
  return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
}), gr$4 = De$5.get, yr$4 = qt$5("native-string-replace", String.prototype.replace), mr$4 = RegExp.prototype.exec, br$4 = mr$4, xr$4 = st$5("".charAt), wr$4 = st$5("".indexOf), Sr$4 = st$5("".replace), kr$4 = st$5("".slice), Er$4 = (sr$4 = /b*/g, tt$5(mr$4, lr$4 = /a/, "a"), tt$5(mr$4, sr$4, "a"), 0 !== lr$4.lastIndex || 0 !== sr$4.lastIndex), Tr$4 = tr$4.BROKEN_CARET, Mr$4 = void 0 !== /()??/.exec("")[1];
(Er$4 || Mr$4 || Tr$4 || dr$4 || vr$4) && (br$4 = function(t2) {
  var e3, n2, r2, o2, i2, u2, a2, c2 = this, l2 = gr$4(c2), s2 = Yn$5(t2), f2 = l2.raw;
  if (f2)
    return f2.lastIndex = c2.lastIndex, e3 = tt$5(br$4, f2, s2), c2.lastIndex = f2.lastIndex, e3;
  var p2 = l2.groups, d3 = Tr$4 && c2.sticky, h2 = tt$5(Jn$5, c2), v2 = c2.source, g2 = 0, y2 = s2;
  if (d3 && (h2 = Sr$4(h2, "y", ""), -1 === wr$4(h2, "g") && (h2 += "g"), y2 = kr$4(s2, c2.lastIndex), c2.lastIndex > 0 && (!c2.multiline || c2.multiline && "\n" !== xr$4(s2, c2.lastIndex - 1)) && (v2 = "(?: " + v2 + ")", y2 = " " + y2, g2++), n2 = new RegExp("^(?:" + v2 + ")", h2)), Mr$4 && (n2 = new RegExp("^" + v2 + "$(?!\\s)", h2)), Er$4 && (r2 = c2.lastIndex), o2 = tt$5(mr$4, d3 ? n2 : c2, y2), d3 ? o2 ? (o2.input = kr$4(o2.input, g2), o2[0] = kr$4(o2[0], g2), o2.index = c2.lastIndex, c2.lastIndex += o2[0].length) : c2.lastIndex = 0 : Er$4 && o2 && (c2.lastIndex = c2.global ? o2.index + o2[0].length : r2), Mr$4 && o2 && o2.length > 1 && tt$5(yr$4, o2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && p2)
    for (o2.groups = u2 = fr$4(null), i2 = 0; i2 < p2.length; i2++)
      u2[(a2 = p2[i2])[0]] = o2[a2[1]];
  return o2;
});
var Hr$4 = br$4;
xn$5({ target: "RegExp", proto: true, forced: /./.exec !== Hr$4 }, { exec: Hr$4 });
var Or$4 = Function.prototype, Ir$4 = Or$4.apply, Nr$4 = Or$4.bind, Lr$4 = Or$4.call, zr$4 = "object" == typeof Reflect && Reflect.apply || (Nr$4 ? Lr$4.bind(Ir$4) : function() {
  return Lr$4.apply(Ir$4, arguments);
}), jr$4 = re$5("species"), Ar$4 = RegExp.prototype, Pr$4 = function(t2, e3, n2, r2) {
  var o2 = re$5(t2), i2 = !K$5(function() {
    var e4 = {};
    return e4[o2] = function() {
      return 7;
    }, 7 != ""[t2](e4);
  }), u2 = i2 && !K$5(function() {
    var e4 = false, n3 = /a/;
    return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[jr$4] = function() {
      return n3;
    }, n3.flags = "", n3[o2] = /./[o2]), n3.exec = function() {
      return e4 = true, null;
    }, n3[o2](""), !e4;
  });
  if (!i2 || !u2 || n2) {
    var a2 = st$5(/./[o2]), c2 = e3(o2, ""[t2], function(t3, e4, n3, r3, o3) {
      var u3 = st$5(t3), c3 = e4.exec;
      return c3 === Hr$4 || c3 === Ar$4.exec ? i2 && !o3 ? { done: true, value: a2(e4, n3, r3) } : { done: true, value: u3(n3, e4, r3) } : { done: false };
    });
    $e$5(String.prototype, t2, c2[0]), $e$5(Ar$4, o2, c2[1]);
  }
  r2 && xe$5(Ar$4[o2], "sham", true);
}, Vr$4 = st$5("".charAt), Cr$4 = st$5("".charCodeAt), Dr$4 = st$5("".slice), Br$4 = function(t2) {
  return function(e3, n2) {
    var r2, o2, i2 = Yn$5(mt$5(e3)), u2 = Ge$5(n2), a2 = i2.length;
    return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = Cr$4(i2, u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = Cr$4(i2, u2 + 1)) < 56320 || o2 > 57343 ? t2 ? Vr$4(i2, u2) : r2 : t2 ? Dr$4(i2, u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Rr$4 = { codeAt: Br$4(false), charAt: Br$4(true) }.charAt, Fr$4 = function(t2, e3, n2) {
  return e3 + (n2 ? Rr$4(t2, e3).length : 1);
}, _r$4 = Math.floor, $r$4 = st$5("".charAt), qr$4 = st$5("".replace), Wr$4 = st$5("".slice), Gr$4 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Ur$4 = /\$([$&'`]|\d{1,2})/g, Xr$4 = function(t2, e3, n2, r2, o2, i2) {
  var u2 = n2 + t2.length, a2 = r2.length, c2 = Ur$4;
  return void 0 !== o2 && (o2 = Gt$5(o2), c2 = Gr$4), qr$4(i2, c2, function(i3, c3) {
    var l2;
    switch ($r$4(c3, 0)) {
      case "$":
        return "$";
      case "&":
        return t2;
      case "`":
        return Wr$4(e3, 0, n2);
      case "'":
        return Wr$4(e3, u2);
      case "<":
        l2 = o2[Wr$4(c3, 1, -1)];
        break;
      default:
        var s2 = +c3;
        if (0 === s2)
          return i3;
        if (s2 > a2) {
          var f2 = _r$4(s2 / 10);
          return 0 === f2 ? i3 : f2 <= a2 ? void 0 === r2[f2 - 1] ? $r$4(c3, 1) : r2[f2 - 1] + $r$4(c3, 1) : i3;
        }
        l2 = r2[s2 - 1];
    }
    return void 0 === l2 ? "" : l2;
  });
}, Yr$4 = J$5.TypeError, Jr$4 = function(t2, e3) {
  var n2 = t2.exec;
  if (xt$5(n2)) {
    var r2 = tt$5(n2, t2, e3);
    return null !== r2 && ge$5(r2), r2;
  }
  if ("RegExp" === dt$5(t2))
    return tt$5(Hr$4, t2, e3);
  throw Yr$4("RegExp#exec called on incompatible receiver");
}, Kr$4 = re$5("replace"), Qr$4 = Math.max, Zr$4 = Math.min, to$4 = st$5([].concat), eo$4 = st$5([].push), no$4 = st$5("".indexOf), ro$4 = st$5("".slice), oo$3 = "$0" === "a".replace(/./, "$0"), io$3 = !!/./[Kr$4] && "" === /./[Kr$4]("a", "$0");
Pr$4("replace", function(t2, e3, n2) {
  var r2 = io$3 ? "$" : "$0";
  return [function(t3, n3) {
    var r3 = mt$5(this), o2 = null == t3 ? void 0 : Bt$5(t3, Kr$4);
    return o2 ? tt$5(o2, t3, r3, n3) : tt$5(e3, Yn$5(r3), t3, n3);
  }, function(t3, o2) {
    var i2 = ge$5(this), u2 = Yn$5(t3);
    if ("string" == typeof o2 && -1 === no$4(o2, r2) && -1 === no$4(o2, "$<")) {
      var a2 = n2(e3, i2, u2, o2);
      if (a2.done)
        return a2.value;
    }
    var c2 = xt$5(o2);
    c2 || (o2 = Yn$5(o2));
    var l2 = i2.global;
    if (l2) {
      var s2 = i2.unicode;
      i2.lastIndex = 0;
    }
    for (var f2 = []; ; ) {
      var p2 = Jr$4(i2, u2);
      if (null === p2)
        break;
      if (eo$4(f2, p2), !l2)
        break;
      "" === Yn$5(p2[0]) && (i2.lastIndex = Fr$4(u2, Ke$5(i2.lastIndex), s2));
    }
    for (var d3, h2 = "", v2 = 0, g2 = 0; g2 < f2.length; g2++) {
      for (var y2 = Yn$5((p2 = f2[g2])[0]), m2 = Qr$4(Zr$4(Ge$5(p2.index), u2.length), 0), b2 = [], x2 = 1; x2 < p2.length; x2++)
        eo$4(b2, void 0 === (d3 = p2[x2]) ? d3 : String(d3));
      var w2 = p2.groups;
      if (c2) {
        var S2 = to$4([y2], b2, m2, u2);
        void 0 !== w2 && eo$4(S2, w2);
        var k2 = Yn$5(zr$4(o2, void 0, S2));
      } else
        k2 = Xr$4(y2, u2, m2, b2, w2, o2);
      m2 >= v2 && (h2 += ro$4(u2, v2, m2) + k2, v2 = m2 + y2.length);
    }
    return h2 + ro$4(u2, v2);
  }];
}, !!K$5(function() {
  var t2 = /./;
  return t2.exec = function() {
    var t3 = [];
    return t3.groups = { a: "7" }, t3;
  }, "7" !== "".replace(t2, "$<a>");
}) || !oo$3 || io$3);
var uo$3 = re$5("unscopables"), ao$3 = Array.prototype;
null == ao$3[uo$3] && be$5.f(ao$3, uo$3, { configurable: true, value: fr$4(null) });
var co$3 = function(t2) {
  ao$3[uo$3][t2] = true;
}, lo$3 = _n$5.find, so$3 = true;
"find" in [] && Array(1).find(function() {
  so$3 = false;
}), xn$5({ target: "Array", proto: true, forced: so$3 }, { find: function(t2) {
  return lo$3(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), co$3("find");
var fo$3 = re$5("match"), po$3 = function(t2) {
  var e3;
  return wt$5(t2) && (void 0 !== (e3 = t2[fo$3]) ? !!e3 : "RegExp" == dt$5(t2));
}, ho$3 = J$5.TypeError, vo$3 = re$5("species"), go$3 = function(t2, e3) {
  var n2, r2 = ge$5(t2).constructor;
  return void 0 === r2 || null == (n2 = ge$5(r2)[vo$3]) ? e3 : function(t3) {
    if (Vn$5(t3))
      return t3;
    throw ho$3(Vt$5(t3) + " is not a constructor");
  }(n2);
}, yo$3 = function(t2, e3, n2) {
  var r2 = ae$5(e3);
  r2 in t2 ? be$5.f(t2, r2, it$5(0, n2)) : t2[r2] = n2;
}, mo$3 = J$5.Array, bo$3 = Math.max, xo$3 = function(t2, e3, n2) {
  for (var r2 = Qe$5(t2), o2 = Ye$5(e3, r2), i2 = Ye$5(void 0 === n2 ? r2 : n2, r2), u2 = mo$3(bo$3(i2 - o2, 0)), a2 = 0; o2 < i2; o2++, a2++)
    yo$3(u2, a2, t2[o2]);
  return u2.length = a2, u2;
}, wo$3 = tr$4.UNSUPPORTED_Y, So$3 = Math.min, ko$3 = [].push, Eo$3 = st$5(/./.exec), To$3 = st$5(ko$3), Mo$3 = st$5("".slice);
Pr$4("split", function(t2, e3, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
    var r3 = Yn$5(mt$5(this)), o2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === o2)
      return [];
    if (void 0 === t3)
      return [r3];
    if (!po$3(t3))
      return tt$5(e3, r3, t3, o2);
    for (var i2, u2, a2, c2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), s2 = 0, f2 = new RegExp(t3.source, l2 + "g"); (i2 = tt$5(Hr$4, f2, r3)) && !((u2 = f2.lastIndex) > s2 && (To$3(c2, Mo$3(r3, s2, i2.index)), i2.length > 1 && i2.index < r3.length && zr$4(ko$3, c2, xo$3(i2, 1)), a2 = i2[0].length, s2 = u2, c2.length >= o2)); )
      f2.lastIndex === i2.index && f2.lastIndex++;
    return s2 === r3.length ? !a2 && Eo$3(f2, "") || To$3(c2, "") : To$3(c2, Mo$3(r3, s2)), c2.length > o2 ? xo$3(c2, 0, o2) : c2;
  } : "0".split(void 0, 0).length ? function(t3, n3) {
    return void 0 === t3 && 0 === n3 ? [] : tt$5(e3, this, t3, n3);
  } : e3, [function(e4, n3) {
    var o2 = mt$5(this), i2 = null == e4 ? void 0 : Bt$5(e4, t2);
    return i2 ? tt$5(i2, e4, o2, n3) : tt$5(r2, Yn$5(o2), e4, n3);
  }, function(t3, o2) {
    var i2 = ge$5(this), u2 = Yn$5(t3), a2 = n2(r2, i2, u2, o2, r2 !== e3);
    if (a2.done)
      return a2.value;
    var c2 = go$3(i2, RegExp), l2 = i2.unicode, s2 = (i2.ignoreCase ? "i" : "") + (i2.multiline ? "m" : "") + (i2.unicode ? "u" : "") + (wo$3 ? "g" : "y"), f2 = new c2(wo$3 ? "^(?:" + i2.source + ")" : i2, s2), p2 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === p2)
      return [];
    if (0 === u2.length)
      return null === Jr$4(f2, u2) ? [u2] : [];
    for (var d3 = 0, h2 = 0, v2 = []; h2 < u2.length; ) {
      f2.lastIndex = wo$3 ? 0 : h2;
      var g2, y2 = Jr$4(f2, wo$3 ? Mo$3(u2, h2) : u2);
      if (null === y2 || (g2 = So$3(Ke$5(f2.lastIndex + (wo$3 ? h2 : 0)), u2.length)) === d3)
        h2 = Fr$4(u2, h2, l2);
      else {
        if (To$3(v2, Mo$3(u2, d3, h2)), v2.length === p2)
          return v2;
        for (var m2 = 1; m2 <= y2.length - 1; m2++)
          if (To$3(v2, y2[m2]), v2.length === p2)
            return v2;
        h2 = d3 = g2;
      }
    }
    return To$3(v2, Mo$3(u2, d3)), v2;
  }];
}, !!K$5(function() {
  var t2 = /(?:)/, e3 = t2.exec;
  t2.exec = function() {
    return e3.apply(this, arguments);
  };
  var n2 = "ab".split(t2);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), wo$3);
var Ho$3, Oo$3 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", Io$3 = st$5("".replace), No$3 = "[" + Oo$3 + "]", Lo$3 = RegExp("^" + No$3 + No$3 + "*"), zo$3 = RegExp(No$3 + No$3 + "*$"), jo$3 = function(t2) {
  return function(e3) {
    var n2 = Yn$5(mt$5(e3));
    return 1 & t2 && (n2 = Io$3(n2, Lo$3, "")), 2 & t2 && (n2 = Io$3(n2, zo$3, "")), n2;
  };
}, Ao$3 = { start: jo$3(1), end: jo$3(2), trim: jo$3(3) }, Po$3 = _e$5.PROPER, Vo$3 = Ao$3.trim;
function Co$3(t2) {
  return 0 === $$6("<div>" + t2 + "</div>").children().filter(function(t3) {
    return "BR" !== t3.tagName;
  }).length;
}
function Do$3(t2) {
  return 0 === t2.length ? "" : t2[0].outerHTML;
}
function Bo$3(t2) {
  return t2.length ? t2[0].tagName.toLowerCase() : "";
}
function Ro$3(t2, e3) {
  for (var n2 = "", r2 = (t2.attr("style") || "").split(";"), o2 = r2.length, i2 = 0; i2 < o2; i2++) {
    var u2 = r2[i2];
    if (u2) {
      var a2 = u2.split(":");
      a2[0].trim() === e3 && (n2 = a2[1].trim());
    }
  }
  return n2;
}
xn$5({ target: "String", proto: true, forced: (Ho$3 = "trim", K$5(function() {
  return !!Oo$3[Ho$3]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[Ho$3]() || Po$3 && Oo$3[Ho$3].name !== Ho$3;
})) }, { trim: function() {
  return Vo$3(this);
} }), xn$5({ global: true }, { globalThis: J$5 }), css && ($$6.fn.css = css), append && ($$6.fn.append = append), prepend && ($$6.fn.prepend = prepend), addClass && ($$6.fn.addClass = addClass), removeClass && ($$6.fn.removeClass = removeClass), hasClass && ($$6.fn.hasClass = hasClass), on$7 && ($$6.fn.on = on$7), off && ($$6.fn.off = off), focus$1 && ($$6.fn.focus = focus$1), attr && ($$6.fn.attr = attr), removeAttr && ($$6.fn.removeAttr = removeAttr), hide && ($$6.fn.hide = hide), show && ($$6.fn.show = show), parents && ($$6.fn.parents = parents), dataset && ($$6.fn.dataset = dataset), val && ($$6.fn.val = val), text && ($$6.fn.text = text), html && ($$6.fn.html = html), children && ($$6.fn.children = children), remove && ($$6.fn.remove = remove), find && ($$6.fn.find = find), width && ($$6.fn.width = width), height && ($$6.fn.height = height), filter && ($$6.fn.filter = filter), empty && ($$6.fn.empty = empty);
var Fo$3 = { selector: "p", parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  return 0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!n2.isInline(t3);
  })).length && (e3 = [{ text: r2.text().replace(/\s+/gm, " ") }]), { type: "paragraph", children: e3 };
} }, _o$3 = function(t2, e3) {
  return _o$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e4) {
    t3.__proto__ = e4;
  } || function(t3, e4) {
    for (var n2 in e4)
      Object.prototype.hasOwnProperty.call(e4, n2) && (t3[n2] = e4[n2]);
  }, _o$3(t2, e3);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function $o$3(t2, e3) {
  if ("function" != typeof e3 && null !== e3)
    throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
  function n2() {
    this.constructor = t2;
  }
  _o$3(t2, e3), t2.prototype = null === e3 ? Object.create(e3) : (n2.prototype = e3.prototype, new n2());
}
var qo$3 = function() {
  return qo$3 = Object.assign || function(t2) {
    for (var e3, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in e3 = arguments[n2])
        Object.prototype.hasOwnProperty.call(e3, o2) && (t2[o2] = e3[o2]);
    return t2;
  }, qo$3.apply(this, arguments);
};
function Wo$3(t2, e3, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function u2(t3) {
      try {
        c2(r2.next(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function a2(t3) {
      try {
        c2(r2.throw(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function c2(t3) {
      var e4;
      t3.done ? o2(t3.value) : (e4 = t3.value, e4 instanceof n2 ? e4 : new n2(function(t4) {
        t4(e4);
      })).then(u2, a2);
    }
    c2((r2 = r2.apply(t2, e3 || [])).next());
  });
}
function Go$3(t2, e3) {
  var n2, r2, o2, i2, u2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function a2(i3) {
    return function(a3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; u2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return u2.label++, { value: i4[1], done: false };
              case 5:
                u2.label++, r2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = u2.ops.pop(), u2.trys.pop();
                continue;
              default:
                if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                  u2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  u2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && u2.label < o2[1]) {
                  u2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && u2.label < o2[2]) {
                  u2.label = o2[2], u2.ops.push(i4);
                  break;
                }
                o2[2] && u2.ops.pop(), u2.trys.pop();
                continue;
            }
            i4 = e3.call(t2, u2);
          } catch (t3) {
            i4 = [6, t3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      }([i3, a3]);
    };
  }
}
function Uo$3(t2) {
  var e3 = "function" == typeof Symbol && Symbol.iterator, n2 = e3 && t2[e3], r2 = 0;
  if (n2)
    return n2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
    } };
  throw new TypeError(e3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Xo$3(t2, e3) {
  var n2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!n2)
    return t2;
  var r2, o2, i2 = n2.call(t2), u2 = [];
  try {
    for (; (void 0 === e3 || e3-- > 0) && !(r2 = i2.next()).done; )
      u2.push(r2.value);
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return u2;
}
function Yo$3(t2) {
  var e3 = Xo$3(Editor$1.nodes(t2, { match: function(e4) {
    return t2.children[0] === e4;
  }, mode: "highest" }), 1), n2 = e3[0];
  if (null == n2)
    return false;
  var r2 = n2[0];
  if (!Element$1.isElement(r2))
    return false;
  if ("paragraph" === r2.type)
    return false;
  if ("" !== Node$1.string(r2))
    return false;
  var o2 = r2.children, i2 = void 0 === o2 ? [] : o2;
  return !!Text.isText(i2[0]) && (Transforms.setNodes(t2, { type: "paragraph" }), true);
}
var Jo$3 = { renderElems: [_$5], elemsToHtml: [$$5], parseElemsHtml: [Fo$3], editorPlugin: function(t2) {
  var e3 = t2.deleteBackward, n2 = t2.deleteForward;
  t2.insertText, t2.insertBreak;
  var r2 = t2;
  return r2.deleteBackward = function(t3) {
    Yo$3(r2) || e3(t3);
  }, r2.deleteForward = function(t3) {
    Yo$3(r2) || n2(t3);
  }, r2;
} }, Ko$3 = /"/g, Qo$3 = st$5("".replace), Zo$3 = function(t2, e3, n2, r2) {
  var o2 = Yn$5(mt$5(t2)), i2 = "<" + e3;
  return "" !== n2 && (i2 += " " + n2 + '="' + Qo$3(Yn$5(r2), Ko$3, "&quot;") + '"'), i2 + ">" + o2 + "</" + e3 + ">";
}, ti$3 = function(t2) {
  return K$5(function() {
    var e3 = ""[t2]('"');
    return e3 !== e3.toLowerCase() || e3.split('"').length > 3;
  });
};
function ei$3(t2, e3) {
  var n2 = e3, r2 = t2, o2 = r2.bold, i2 = r2.italic, u2 = r2.underline;
  return o2 && (n2 = "<strong>" + n2 + "</strong>"), r2.code && (n2 = "<code>" + n2 + "</code>"), i2 && (n2 = "<em>" + n2 + "</em>"), u2 && (n2 = "<u>" + n2 + "</u>"), r2.through && (n2 = "<s>" + n2 + "</s>"), r2.sub && (n2 = "<sub>" + n2 + "</sub>"), r2.sup && (n2 = "<sup>" + n2 + "</sup>"), n2;
}
function ni$3(t2, e3) {
  return 0 !== t2.length && (!!t2[0].matches(e3) || t2.find(e3).length > 0);
}
xn$5({ target: "String", proto: true, forced: ti$3("bold") }, { bold: function() {
  return Zo$3(this, "b", "", "");
} }), xn$5({ target: "String", proto: true, forced: ti$3("italics") }, { italics: function() {
  return Zo$3(this, "i", "", "");
} }), xn$5({ target: "String", proto: true, forced: ti$3("sub") }, { sub: function() {
  return Zo$3(this, "sub", "", "");
} }), xn$5({ target: "String", proto: true, forced: ti$3("sup") }, { sup: function() {
  return Zo$3(this, "sup", "", "");
} });
var ri$3 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, oi$3 = se$5("span").classList, ii$3 = oi$3 && oi$3.constructor && oi$3.constructor.prototype, ui$3 = ii$3 === Object.prototype ? void 0 : ii$3, ai$3 = function(t2, e3) {
  var n2 = [][t2];
  return !!n2 && K$5(function() {
    n2.call(null, e3 || function() {
      throw 1;
    }, 1);
  });
}, ci$3 = _n$5.forEach, li$3 = ai$3("forEach") ? [].forEach : function(t2) {
  return ci$3(this, t2, arguments.length > 1 ? arguments[1] : void 0);
}, si$3 = function(t2) {
  if (t2 && t2.forEach !== li$3)
    try {
      xe$5(t2, "forEach", li$3);
    } catch (e3) {
      t2.forEach = li$3;
    }
};
for (var fi$3 in ri$3)
  ri$3[fi$3] && si$3(J$5[fi$3] && J$5[fi$3].prototype);
function pi$3(t2, n2) {
  return null == t2.selection || !!Xo$3(Editor$1.nodes(t2, { match: function(n3) {
    return "pre" === rl$1.getNodeType(n3) || !!Editor$1.isVoid(t2, n3);
  }, universal: true }), 1)[0];
}
function di$3(t2, e3) {
  Object.keys(e3).forEach(function(e4) {
    "text" !== e4 && Editor$1.removeMark(t2, e4);
  });
}
si$3(ui$3), xn$5({ target: "Object", stat: true, forced: K$5(function() {
  er$4(1);
}) }, { keys: function(t2) {
  return er$4(Gt$5(t2));
} });
var hi$3 = function() {
  function t2() {
    this.marksNeedToRemove = [], this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    var e3 = this.mark, n2 = Editor$1.marks(t3);
    return n2 ? n2[e3] : !!Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      return true === t4[e3];
    } }), 1)[0];
  }, t2.prototype.isActive = function(t3) {
    return !!this.getValue(t3);
  }, t2.prototype.isDisabled = function(t3) {
    return pi$3(t3, this.mark);
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.mark, r2 = this.marksNeedToRemove;
    e3 ? t3.removeMark(n2) : (t3.addMark(n2, true), r2 && r2.forEach(function(e4) {
      return t3.removeMark(e4);
    }));
  }, t2;
}(), vi$3 = '<svg viewBox="0 0 1024 1024"><path d="M707.872 484.64A254.88 254.88 0 0 0 768 320c0-141.152-114.848-256-256-256H192v896h384c141.152 0 256-114.848 256-256a256.096 256.096 0 0 0-124.128-219.36zM384 192h101.504c55.968 0 101.504 57.408 101.504 128s-45.536 128-101.504 128H384V192z m159.008 640H384v-256h159.008c58.464 0 106.016 57.408 106.016 128s-47.552 128-106.016 128z"></path></svg>', gi$3 = '<svg viewBox="0 0 1024 1024"><path d="M704 64l128 0 0 416c0 159.072-143.264 288-320 288s-320-128.928-320-288l0-416 128 0 0 416c0 40.16 18.24 78.688 51.36 108.512 36.896 33.216 86.848 51.488 140.64 51.488s103.744-18.304 140.64-51.488c33.12-29.792 51.36-68.352 51.36-108.512l0-416zM192 832l640 0 0 128-640 0z"></path></svg>', yi$3 = '<svg viewBox="0 0 1024 1024"><path d="M896 64v64h-128L448 896h128v64H128v-64h128L576 128h-128V64z"></path></svg>', mi$2 = '<svg viewBox="0 0 1024 1024"><path d="M1024 512v64h-234.496c27.52 38.496 42.496 82.688 42.496 128 0 70.88-36.672 139.04-100.576 186.976C672.064 935.488 594.144 960 512 960s-160.064-24.512-219.424-69.024C228.64 843.04 192 774.88 192 704h128c0 69.376 87.936 128 192 128s192-58.624 192-128-87.936-128-192-128H0v-64h299.52a385.984 385.984 0 0 1-6.944-5.024C228.64 459.04 192 390.88 192 320s36.672-139.04 100.576-186.976C351.936 88.512 429.856 64 512 64s160.064 24.512 219.424 69.024C795.328 180.96 832 249.12 832 320h-128c0-69.376-87.936-128-192-128s-192 58.624-192 128 87.936 128 192 128c78.976 0 154.048 22.688 212.48 64H1024z"></path></svg>', bi$2 = '<svg viewBox="0 0 1024 1024"><path d="M576 736l96 96 320-320L672 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224z"></path></svg>', xi$2 = '<svg viewBox="0 0 1024 1024"><path d="M864 0a160 160 0 0 1 128 256l-64 64-224-224 64-64c26.752-20.096 59.968-32 96-32zM64 736l-64 288 288-64 592-592-224-224L64 736z m651.584-372.416l-448 448-55.168-55.168 448-448 55.168 55.168z"></path></svg>', wi$2 = '<svg viewBox="0 0 1024 1024"><path d="M924.402464 1023.068211H0.679665V99.345412h461.861399v98.909208H99.596867v725.896389h725.896389V561.206811h98.909208z" p-id="10909"></path><path d="M930.805104 22.977336l69.965436 69.965436-453.492405 453.492404-69.965435-69.901489z" p-id="10910"></path><path d="M1022.464381 304.030081h-98.917201V99.345412H709.230573V0.428211h313.233808z"></path></svg>', Si$2 = '<svg viewBox="0 0 1024 1024"><path d="M64 864h896v96H64zM360.58 576h302.85l81.53 224h102.16L579.24 64H444.77L176.89 800h102.16l81.53-224zM512 159.96L628.49 480H395.52L512 159.96z"></path></svg>', ki$2 = '<svg viewBox="0 0 1024 1024"><path d="M510.030769 315.076923l84.676923 196.923077h-177.230769l76.8-196.923077h15.753846zM945.230769 157.538462v708.923076c0 43.323077-35.446154 78.769231-78.769231 78.769231H157.538462c-43.323077 0-78.769231-35.446154-78.769231-78.769231V157.538462c0-43.323077 35.446154-78.769231 78.769231-78.769231h708.923076c43.323077 0 78.769231 35.446154 78.769231 78.769231z m-108.307692 643.938461L600.615385 216.615385c-5.907692-11.815385-15.753846-19.692308-29.538462-19.692308h-139.815385c-11.815385 0-23.630769 7.876923-27.56923 19.692308l-216.615385 584.861538c-3.938462 11.815385 3.938462 25.6 17.723077 25.6h80.738462c11.815385 0 23.630769-9.846154 27.56923-21.661538l63.015385-175.261539h263.876923l68.923077 175.261539c3.938462 11.815385 15.753846 21.661538 27.569231 21.661538h80.738461c13.784615 0 23.630769-13.784615 19.692308-25.6z"></path></svg>', Ei$2 = '<svg viewBox="0 0 1024 1024"><path d="M64 512h384v128h-128V1024h-128V640h-128z m896-256H708.2496v768h-136.4992V256H320V128h640z"></path></svg>', Ti$2 = '<svg viewBox="0 0 1024 1024"><path d="M956.788364 152.110545h-24.110546l23.924364 9.029819 0.186182 121.018181h-65.070546l-86.574545-130.048H566.551273v650.14691l130.048 64.977454v65.163636h-390.050909v-65.163636l129.954909-64.977454V152.110545H198.283636L111.429818 282.065455H46.545455V69.259636C46.545455 33.792 82.664727 22.062545 98.955636 22.062545h812.683637c23.738182 0 45.056 15.173818 45.056 41.053091V169.425455v-17.221819z"></path></svg>', Mi$2 = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m256-512v384l-256-192z"></path></svg>', Hi$2 = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>', Oi$2 = '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>', Ii$2 = '<svg viewBox="0 0 1024 1024"><path d="M972.8 793.6v102.4H256v-102.4h716.8z m0-230.4v102.4H51.2v-102.4h921.6z m0-230.4v102.4H256v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>', Ni$2 = '<svg viewBox="0 0 1024 1024"><path d="M870.4 793.6v102.4H153.6v-102.4h716.8z m102.4-230.4v102.4H51.2v-102.4h921.6z m-102.4-230.4v102.4H153.6v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>', Li$2 = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z"></path></svg>', zi$2 = '<svg viewBox="0 0 1024 1024"><path d="M768 206.016v50.016h128v64h-192V174.016l128-60V64h-128V0h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>', ji$2 = '<svg viewBox="0 0 1024 1024"><path d="M768 910.016v50.016h128v64h-192v-146.016l128-60V768h-128v-64h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>', Ai$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "bold", e4.title = lp$1("textStyle.bold"), e4.iconSvg = vi$3, e4.hotkey = "mod+b", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Pi$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "code", e4.title = lp$1("textStyle.code"), e4.iconSvg = bi$2, e4.hotkey = "mod+e", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Vi$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "italic", e4.title = lp$1("textStyle.italic"), e4.iconSvg = yi$3, e4.hotkey = "mod+i", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Ci$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "through", e4.title = lp$1("textStyle.through"), e4.iconSvg = mi$2, e4.hotkey = "mod+shift+x", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Di$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "underline", e4.title = lp$1("textStyle.underline"), e4.iconSvg = gi$3, e4.hotkey = "mod+u", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Bi$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "sub", e4.marksNeedToRemove = ["sup"], e4.title = lp$1("textStyle.sub"), e4.iconSvg = ji$2, e4.hotkey = "", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Ri$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.mark = "sup", e4.marksNeedToRemove = ["sub"], e4.title = lp$1("textStyle.sup"), e4.iconSvg = zi$2, e4.hotkey = "", e4;
  }
  return $o$3(e3, t2), e3;
}(hi$3), Fi$2 = function() {
  function t2() {
    this.title = lp$1("textStyle.clear"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M969.382408 288.738615l-319.401123-270.852152a67.074236 67.074236 0 0 0-96.459139 5.74922l-505.931379 574.922021a68.35184 68.35184 0 0 0-17.886463 47.910169 74.101061 74.101061 0 0 0 24.274486 47.910168l156.50655 132.232065h373.060512L975.131628 383.281347a67.074236 67.074236 0 0 0-5.74922-96.459139z m-440.134747 433.746725H264.144729l-90.071117-78.572676c-5.74922-5.74922-12.137243-12.137243-12.137243-17.886463a36.411728 36.411728 0 0 1 5.749221-24.274485l210.804741-240.828447 265.102932 228.691204z m-439.495945 180.781036h843.218964a60.047411 60.047411 0 1 1 0 120.733624H89.751716a60.047411 60.047411 0 1 1 0-120.733624z m0 0"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return pi$3(t3);
  }, t2.prototype.exec = function(t3, e3) {
    var n2, r2, o2 = Editor$1.nodes(t3, { match: function(t4) {
      return Text.isText(t4);
    }, universal: true });
    try {
      for (var i2 = Uo$3(o2), u2 = i2.next(); !u2.done; u2 = i2.next()) {
        di$3(t3, u2.value[0]);
      }
    } catch (t4) {
      n2 = { error: t4 };
    } finally {
      try {
        u2 && !u2.done && (r2 = i2.return) && r2.call(i2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
  }, t2;
}(), _i$2 = { renderStyle: function(t2, e3) {
  var n2 = t2, r2 = n2.bold, o2 = n2.italic, u2 = n2.underline, a2 = n2.code, c2 = n2.through, l2 = n2.sub, s2 = n2.sup, f2 = e3;
  return r2 && (f2 = jsx("strong", null, f2)), a2 && (f2 = jsx("code", null, f2)), o2 && (f2 = jsx("em", null, f2)), u2 && (f2 = jsx("u", null, f2)), c2 && (f2 = jsx("s", null, f2)), l2 && (f2 = jsx("sub", null, f2)), s2 && (f2 = jsx("sup", null, f2)), f2;
}, menus: [{ key: "bold", factory: function() {
  return new Ai$2();
} }, { key: "underline", factory: function() {
  return new Di$2();
} }, { key: "italic", factory: function() {
  return new Vi$2();
} }, { key: "through", factory: function() {
  return new Ci$2();
} }, { key: "code", factory: function() {
  return new Pi$2();
} }, { key: "sub", factory: function() {
  return new Bi$2();
} }, { key: "sup", factory: function() {
  return new Ri$2();
} }, { key: "clearStyle", factory: function() {
  return new Fi$2();
} }], styleToHtml: function(t2, e3) {
  if (!Text.isText(t2))
    return e3;
  if (Co$3(e3))
    return ei$3(t2, e3);
  var n2 = $$6(e3);
  if ("br" === Bo$3(n2))
    return ei$3(t2, "<br>");
  var r2 = n2.html();
  return r2 = ei$3(t2, r2), n2.html(r2), Do$3(n2);
}, parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Text.isText(e3))
    return e3;
  var o2 = e3;
  return ni$3(r2, "b,strong") && (o2.bold = true), ni$3(r2, "i,em") && (o2.italic = true), ni$3(r2, "u") && (o2.underline = true), ni$3(r2, "s,strike") && (o2.through = true), ni$3(r2, "sub") && (o2.sub = true), ni$3(r2, "sup") && (o2.sup = true), ni$3(r2, "code") && (o2.code = true), o2;
} };
function $i$2(t2) {
  return function(e3, n2, r2) {
    return jsx("h" + t2, null, n2);
  };
}
var qi$2 = { type: "header1", renderElem: $i$2(1) }, Wi$2 = { type: "header2", renderElem: $i$2(2) }, Gi$2 = { type: "header3", renderElem: $i$2(3) }, Ui$2 = { type: "header4", renderElem: $i$2(4) }, Xi$2 = { type: "header5", renderElem: $i$2(5) }, Yi$2 = _e$5.PROPER, Ji$2 = RegExp.prototype, Ki$2 = Ji$2.toString, Qi$2 = st$5(Jn$5), Zi$2 = K$5(function() {
  return "/a/b" != Ki$2.call({ source: "a", flags: "b" });
}), tu$2 = Yi$2 && "toString" != Ki$2.name;
(Zi$2 || tu$2) && $e$5(RegExp.prototype, "toString", function() {
  var t2 = ge$5(this), e3 = Yn$5(t2.source), n2 = t2.flags;
  return "/" + e3 + "/" + Yn$5(void 0 === n2 && Et$5(Ji$2, t2) && !("flags" in Ji$2) ? Qi$2(t2) : n2);
}, { unsafe: true });
var eu$2, nu$2 = J$5.TypeError, ru$2 = function(t2) {
  if (po$3(t2))
    throw nu$2("The method doesn't accept regular expressions");
  return t2;
}, ou$2 = re$5("match"), iu$2 = function(t2) {
  var e3 = /./;
  try {
    "/./"[t2](e3);
  } catch (n2) {
    try {
      return e3[ou$2] = false, "/./"[t2](e3);
    } catch (t3) {
    }
  }
  return false;
}, uu$2 = de$5.f, au$2 = st$5("".startsWith), cu$2 = st$5("".slice), lu$2 = Math.min, su$2 = iu$2("startsWith");
function fu$2(t2) {
  var n2 = Xo$3(Editor$1.nodes(t2, { match: function(t3) {
    return rl$1.getNodeType(t3).startsWith("header");
  }, universal: true }), 1), r2 = n2[0];
  if (null == r2)
    return "paragraph";
  var o2 = Xo$3(r2, 1)[0];
  return rl$1.getNodeType(o2);
}
function pu$2(t2) {
  return null == t2.selection || !Xo$3(Editor$1.nodes(t2, { match: function(t3) {
    var n2 = rl$1.getNodeType(t3);
    return "paragraph" === n2 || !!n2.startsWith("header");
  }, universal: true, mode: "highest" }), 1)[0];
}
function du$2(t2, e3) {
  e3 && Transforms.setNodes(t2, { type: e3 });
}
xn$5({ target: "String", proto: true, forced: !!(su$2 || (eu$2 = uu$2(String.prototype, "startsWith"), !eu$2 || eu$2.writable)) && !su$2 }, { startsWith: function(t2) {
  var e3 = Yn$5(mt$5(this));
  ru$2(t2);
  var n2 = Ke$5(lu$2(arguments.length > 1 ? arguments[1] : void 0, e3.length)), r2 = Yn$5(t2);
  return au$2 ? au$2(e3, r2, n2) : cu$2(e3, n2, n2 + r2.length) === r2;
} });
var hu$2 = function() {
  function t2() {
    this.title = lp$1("header.title"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M960 960c-51.2 0-102.4-3.2-153.6-3.2-51.2 0-99.2 3.2-150.4 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 57.6-28.8 86.4-48 19.2-12.8 19.2-60.8 19.2-80v-224-19.2c-9.6-3.2-19.2-3.2-28.8-3.2H320c-9.6 0-19.2 0-28.8 3.2V780.8c0 22.4 0 80 22.4 92.8 28.8 19.2 96-6.4 96 44.8 0 16-9.6 41.6-28.8 41.6-54.4 0-105.6-3.2-160-3.2-48 0-96 3.2-147.2 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 51.2-28.8 80-48 19.2-12.8 19.2-60.8 19.2-83.2V294.4c0-28.8 3.2-115.2-22.4-131.2-25.6-16-86.4 9.6-86.4-41.6 0-16 6.4-41.6 28.8-41.6 51.2 0 105.6 3.2 156.8 3.2 48 0 96-3.2 144-3.2 19.2 0 28.8 22.4 28.8 41.6 0 48-57.6 25.6-83.2 41.6-19.2 12.8-19.2 73.6-19.2 92.8v201.6c6.4 3.2 16 3.2 22.4 3.2h400c6.4 0 12.8 0 22.4-3.2V256c0-22.4 0-80-19.2-92.8-28.8-16-86.4 6.4-86.4-41.6 0-16 9.6-41.6 28.8-41.6 51.2 0 99.2 3.2 150.4 3.2 48 0 99.2-3.2 147.2-3.2 19.2 0 28.8 22.4 28.8 41.6 0 51.2-57.6 25.6-86.4 41.6-19.2 12.8-19.2 70.4-19.2 92.8v537.6c0 19.2 0 67.2 19.2 80 28.8 19.2 89.6-6.4 89.6 44.8 0 19.2-6.4 41.6-28.8 41.6z"></path></svg>', this.tag = "select", this.width = 60;
  }
  return t2.prototype.getOptions = function(t3) {
    var e3 = [{ value: "header1", text: "H1", styleForRenderMenuList: { "font-size": "32px", "font-weight": "bold" } }, { value: "header2", text: "H2", styleForRenderMenuList: { "font-size": "24px", "font-weight": "bold" } }, { value: "header3", text: "H3", styleForRenderMenuList: { "font-size": "18px", "font-weight": "bold" } }, { value: "header4", text: "H4", styleForRenderMenuList: { "font-size": "16px", "font-weight": "bold" } }, { value: "header5", text: "H5", styleForRenderMenuList: { "font-size": "13px", "font-weight": "bold" } }, { value: "paragraph", text: lp$1("header.text") }], r2 = this.getValue(t3).toString();
    return e3.forEach(function(t4) {
      t4.value === r2 ? t4.selected = true : delete t4.selected;
    }), e3;
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getValue = function(t3) {
    return fu$2(t3);
  }, t2.prototype.isDisabled = function(t3) {
    return pu$2(t3);
  }, t2.prototype.exec = function(t3, e3) {
    du$2(t3, e3.toString());
  }, t2;
}(), vu$2 = function() {
  function t2() {
    this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return fu$2(t3);
  }, t2.prototype.isActive = function(t3) {
    return this.getValue(t3) === this.type;
  }, t2.prototype.isDisabled = function(t3) {
    return pu$2(t3);
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.type;
    du$2(t3, e3 === n2 ? "paragraph" : n2);
  }, t2;
}(), gu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "H1", e4.type = "header1", e4;
  }
  return $o$3(e3, t2), e3;
}(vu$2), yu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "H2", e4.type = "header2", e4;
  }
  return $o$3(e3, t2), e3;
}(vu$2), mu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "H3", e4.type = "header3", e4;
  }
  return $o$3(e3, t2), e3;
}(vu$2), bu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "H4", e4.type = "header4", e4;
  }
  return $o$3(e3, t2), e3;
}(vu$2), xu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "H5", e4.type = "header5", e4;
  }
  return $o$3(e3, t2), e3;
}(vu$2), wu$2 = { key: "headerSelect", factory: function() {
  return new hu$2();
} }, Su$2 = { key: "header1", factory: function() {
  return new gu$2();
} }, ku$2 = { key: "header2", factory: function() {
  return new yu$2();
} }, Eu$2 = { key: "header3", factory: function() {
  return new mu$2();
} }, Tu$2 = { key: "header4", factory: function() {
  return new bu$2();
} }, Mu$2 = { key: "header5", factory: function() {
  return new xu$2();
} };
function Hu$2(t2) {
  return function(e3, n2) {
    return "<h" + t2 + ">" + n2 + "</h" + t2 + ">";
  };
}
function Ou$2(t2) {
  return function(e3, n2, r2) {
    var o2 = $$6(e3);
    return 0 === (n2 = n2.filter(function(t3) {
      return !!Text.isText(t3) || !!r2.isInline(t3);
    })).length && (n2 = [{ text: o2.text().replace(/\s+/gm, " ") }]), { type: "header" + t2, children: n2 };
  };
}
var Iu$2 = { renderElems: [qi$2, Wi$2, Gi$2, Ui$2, Xi$2], elemsToHtml: [{ type: "header1", elemToHtml: Hu$2(1) }, { type: "header2", elemToHtml: Hu$2(2) }, { type: "header3", elemToHtml: Hu$2(3) }, { type: "header4", elemToHtml: Hu$2(4) }, { type: "header5", elemToHtml: Hu$2(5) }], parseElemsHtml: [{ selector: "h1", parseElemHtml: Ou$2(1) }, { selector: "h2", parseElemHtml: Ou$2(2) }, { selector: "h3", parseElemHtml: Ou$2(3) }, { selector: "h4", parseElemHtml: Ou$2(4) }, { selector: "h5", parseElemHtml: Ou$2(5) }], menus: [wu$2, Su$2, ku$2, Eu$2, Tu$2, Mu$2], editorPlugin: function(t2) {
  var n2 = t2.insertBreak;
  t2.insertNode;
  var r2 = t2;
  return r2.insertBreak = function() {
    var o2 = Xo$3(Editor$1.nodes(r2, { match: function(t3) {
      return rl$1.getNodeType(t3).startsWith("header");
    }, universal: true }), 1)[0];
    if (o2)
      if (rl$1.isSelectionAtLineEnd(t2, o2[1])) {
        Transforms.insertNodes(r2, { type: "paragraph", children: [{ text: "" }] }, { mode: "highest" });
      } else
        n2();
    else
      n2();
  }, r2;
} }, Nu$2 = Object.assign, Lu$2 = Object.defineProperty, zu$2 = st$5([].concat), ju$2 = !Nu$2 || K$5(function() {
  if (Q$5 && 1 !== Nu$2({ b: 1 }, Nu$2(Lu$2({}, "a", { enumerable: true, get: function() {
    Lu$2(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b)
    return true;
  var t2 = {}, e3 = {}, n2 = Symbol(), r2 = "abcdefghijklmnopqrst";
  return t2[n2] = 7, r2.split("").forEach(function(t3) {
    e3[t3] = t3;
  }), 7 != Nu$2({}, t2)[n2] || er$4(Nu$2({}, e3)).join("") != r2;
}) ? function(t2, e3) {
  for (var n2 = Gt$5(t2), r2 = arguments.length, o2 = 1, i2 = cn$5.f, u2 = ot$5.f; r2 > o2; )
    for (var a2, c2 = gt$5(arguments[o2++]), l2 = i2 ? zu$2(er$4(c2), i2(c2)) : er$4(c2), s2 = l2.length, f2 = 0; s2 > f2; )
      a2 = l2[f2++], Q$5 && !tt$5(u2, c2, a2) || (n2[a2] = c2[a2]);
  return n2;
} : Nu$2;
function Au$2(t2, e3) {
  null == t2.data && (t2.data = {});
  var n2 = t2.data;
  null == n2.style && (n2.style = {}), Object.assign(n2.style, e3);
}
xn$5({ target: "Object", stat: true, forced: Object.assign !== ju$2 }, { assign: ju$2 });
var Pu$2 = { selector: "font", preParseHtml: function(t2) {
  var e3 = $$6(t2);
  if ("font" !== Bo$3(e3))
    return t2;
  var n2 = e3.attr("color") || "";
  return n2 && (e3.removeAttr("color"), e3.css("color", n2)), e3[0];
} };
var Vu$2 = function() {
  function t2() {
    this.tag = "button", this.showDropPanel = true, this.$content = null;
  }
  return t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.mark, n2 = Editor$1.marks(t3);
    return n2 && n2[e3] ? n2[e3] : "";
  }, t2.prototype.isActive = function(t3) {
    return !!this.getValue(t3);
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!Xo$3(Editor$1.nodes(t3, { match: function(n2) {
      return "pre" === rl$1.getNodeType(n2) || !!Editor$1.isVoid(t3, n2);
    }, universal: true }), 1)[0];
  }, t2.prototype.getPanelContentElem = function(t3) {
    var e3 = this.mark;
    if (null == this.$content) {
      var r2 = $$6('<ul class="w-e-panel-content-color"></ul>');
      r2.on("click", "li", function(n2) {
        var r3 = n2.target;
        if (null != r3 && (n2.preventDefault(), null != t3.selection)) {
          var o3 = $$6(r3).attr("data-value");
          "0" === o3 ? Editor$1.removeMark(t3, e3) : Editor$1.addMark(t3, e3, o3);
        }
      }), this.$content = r2;
    }
    var o2 = this.$content;
    if (null == o2)
      return document.createElement("ul");
    o2.empty();
    var i2 = this.getValue(t3), u2 = t3.getMenuConfig(e3).colors;
    (void 0 === u2 ? [] : u2).forEach(function(t4) {
      var e4 = $$6('<div class="color-block" data-value="' + t4 + '"></div>');
      e4.css("background-color", t4);
      var n2 = $$6('<li data-value="' + t4 + '"></li>');
      i2 === t4 && n2.addClass("active"), n2.append(e4), o2.append(n2);
    });
    var a2 = "";
    "color" === e3 && (a2 = lp$1("color.default")), "bgColor" === e3 && (a2 = lp$1("color.clear"));
    var l2 = $$6('\n      <li data-value="0" class="clear">\n        <svg viewBox="0 0 1024 1024"><path d="M236.8 128L896 787.2V128H236.8z m614.4 704L192 172.8V832h659.2zM192 64h704c38.4 0 64 25.6 64 64v704c0 38.4-25.6 64-64 64H192c-38.4 0-64-25.6-64-64V128c0-38.4 25.6-64 64-64z"></path></svg>\n        ' + a2 + "\n      </li>\n    ");
    return o2.prepend(l2), o2[0];
  }, t2;
}(), Cu$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("color.color"), e4.iconSvg = Si$2, e4.mark = "color", e4;
  }
  return $o$3(e3, t2), e3;
}(Vu$2), Du$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("color.bgColor"), e4.iconSvg = ki$2, e4.mark = "bgColor", e4;
  }
  return $o$3(e3, t2), e3;
}(Vu$2), Bu$2 = ["rgb(0, 0, 0)", "rgb(38, 38, 38)", "rgb(89, 89, 89)", "rgb(140, 140, 140)", "rgb(191, 191, 191)", "rgb(217, 217, 217)", "rgb(233, 233, 233)", "rgb(245, 245, 245)", "rgb(250, 250, 250)", "rgb(255, 255, 255)", "rgb(225, 60, 57)", "rgb(231, 95, 51)", "rgb(235, 144, 58)", "rgb(245, 219, 77)", "rgb(114, 192, 64)", "rgb(89, 191, 192)", "rgb(66, 144, 247)", "rgb(54, 88, 226)", "rgb(106, 57, 201)", "rgb(216, 68, 147)", "rgb(251, 233, 230)", "rgb(252, 237, 225)", "rgb(252, 239, 212)", "rgb(252, 251, 207)", "rgb(231, 246, 213)", "rgb(218, 244, 240)", "rgb(217, 237, 250)", "rgb(224, 232, 250)", "rgb(237, 225, 248)", "rgb(246, 226, 234)", "rgb(255, 163, 158)", "rgb(255, 187, 150)", "rgb(255, 213, 145)", "rgb(255, 251, 143)", "rgb(183, 235, 143)", "rgb(135, 232, 222)", "rgb(145, 213, 255)", "rgb(173, 198, 255)", "rgb(211, 173, 247)", "rgb(255, 173, 210)", "rgb(255, 77, 79)", "rgb(255, 122, 69)", "rgb(255, 169, 64)", "rgb(255, 236, 61)", "rgb(115, 209, 61)", "rgb(54, 207, 201)", "rgb(64, 169, 255)", "rgb(89, 126, 247)", "rgb(146, 84, 222)", "rgb(247, 89, 171)", "rgb(207, 19, 34)", "rgb(212, 56, 13)", "rgb(212, 107, 8)", "rgb(212, 177, 6)", "rgb(56, 158, 13)", "rgb(8, 151, 156)", "rgb(9, 109, 217)", "rgb(29, 57, 196)", "rgb(83, 29, 171)", "rgb(196, 29, 127)", "rgb(130, 0, 20)", "rgb(135, 20, 0)", "rgb(135, 56, 0)", "rgb(97, 71, 0)", "rgb(19, 82, 0)", "rgb(0, 71, 79)", "rgb(0, 58, 140)", "rgb(6, 17, 120)", "rgb(34, 7, 94)", "rgb(120, 6, 80)"];
var Ru$2 = { renderStyle: function(t2, e3) {
  var n2 = t2, r2 = n2.color, o2 = n2.bgColor, i2 = e3;
  return r2 && Au$2(i2, { color: r2 }), o2 && Au$2(i2, { backgroundColor: o2 }), i2;
}, styleToHtml: function(t2, e3) {
  if (!Text.isText(t2))
    return e3;
  var n2, r2 = t2, o2 = r2.color, i2 = r2.bgColor;
  return o2 || i2 ? ((Co$3(e3) || "span" !== Bo$3(n2 = $$6(e3))) && (n2 = $$6("<span>" + e3 + "</span>")), o2 && n2.css("color", o2), i2 && n2.css("background-color", i2), Do$3(n2)) : e3;
}, preParseHtml: [Pu$2], parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Text.isText(e3))
    return e3;
  var o2 = e3, i2 = Ro$3(r2, "color");
  i2 && (o2.color = i2);
  var u2 = Ro$3(r2, "background-color");
  return u2 || (u2 = Ro$3(r2, "background")), u2 && (o2.bgColor = u2), o2;
}, menus: [{ key: "color", factory: function() {
  return new Cu$2();
}, config: { colors: Bu$2 } }, { key: "bgColor", factory: function() {
  return new Du$2();
}, config: { colors: Bu$2 } }] }, Fu$2 = function(t2) {
  if ("string" != typeof t2)
    return false;
  var e3 = t2.match(_u$2);
  if (!e3)
    return false;
  var n2 = e3[1];
  if (!n2)
    return false;
  if ($u$2.test(n2) || qu$2.test(n2))
    return true;
  return false;
}, _u$2 = /^(?:\w+:)?\/\/(\S+)$/, $u$2 = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/, qu$2 = /^[^\s\.]+\.\S{2,}$/;
var Wu$2 = tn$5.includes;
function Gu$2(t2) {
  return void 0 === t2 && (t2 = "r"), t2 + "-" + nanoid$3();
}
function Uu$2(t2) {
  return t2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function Xu$2(t2, e3, n2, r2) {
  return Wo$3(this, void 0, void 0, function() {
    var o2, i2;
    return Go$3(this, function(u2) {
      switch (u2.label) {
        case 0:
          return (o2 = e3.getMenuConfig(t2).checkLink) ? [4, o2(n2, r2)] : [3, 2];
        case 1:
          if ("string" == typeof (i2 = u2.sent()))
            return e3.alert(i2, "error"), [2, false];
          if (null == i2)
            return [2, false];
          u2.label = 2;
        case 2:
          return [2, true];
      }
    });
  });
}
function Yu$2(t2, e3, n2) {
  return Wo$3(this, void 0, void 0, function() {
    var r2;
    return Go$3(this, function(o2) {
      switch (o2.label) {
        case 0:
          return (r2 = e3.getMenuConfig(t2).parseLinkUrl) ? [4, r2(n2)] : [3, 2];
        case 1:
          return [2, o2.sent()];
        case 2:
          return [2, n2];
      }
    });
  });
}
function Ju$2(t2) {
  return null == t2.selection || !!rl$1.getSelectedElems(t2).some(function(e3) {
    var n2 = e3.type;
    return !!t2.isVoid(e3) || (!!["pre", "code", "link"].includes(n2) || void 0);
  });
}
function Ku$2(t2, e3) {
  return { type: "link", url: Uu$2(t2), children: e3 ? [{ text: e3 }] : [] };
}
function Qu$2(t2, e3, n2) {
  return Wo$3(this, void 0, void 0, function() {
    var r2, o2, i2;
    return Go$3(this, function(u2) {
      switch (u2.label) {
        case 0:
          return n2 ? (e3 || (e3 = n2), t2.restoreSelection(), Ju$2(t2) ? [2] : [4, Xu$2("insertLink", t2, e3, n2)]) : [2];
        case 1:
          return u2.sent() ? [4, Yu$2("insertLink", t2, n2)] : [2];
        case 2:
          return r2 = u2.sent(), null == (o2 = t2.selection) ? [2] : (Range.isCollapsed(o2) ? (t2.insertText(" "), i2 = Ku$2(r2, e3), Transforms.insertNodes(t2, i2), t2.insertFragment([{ text: " " }])) : Editor$1.string(t2, o2) !== e3 ? (t2.deleteFragment(), i2 = Ku$2(r2, e3), Transforms.insertNodes(t2, i2)) : (i2 = Ku$2(r2), Transforms.wrapNodes(t2, i2, { split: true }), Transforms.collapse(t2, { edge: "end" })), [2]);
      }
    });
  });
}
xn$5({ target: "Array", proto: true }, { includes: function(t2) {
  return Wu$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), co$3("includes");
var Zu$2 = { type: "link", renderElem: function(t2, e3, n2) {
  var r2 = t2, o2 = r2.url, u2 = r2.target;
  return jsx("a", { href: o2, target: void 0 === u2 ? "_blank" : u2 }, e3);
} };
var ta$3 = { type: "link", elemToHtml: function(t2, e3) {
  var n2 = t2, r2 = n2.url, o2 = n2.target;
  return '<a href="' + r2 + '" target="' + (void 0 === o2 ? "_blank" : o2) + '">' + e3 + "</a>";
} };
var ea$3 = { selector: "a", parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  return 0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!n2.isInline(t3);
  })).length && (e3 = [{ text: r2.text().replace(/\s+/gm, " ") }]), { type: "link", url: r2.attr("href") || "", target: r2.attr("target") || "", children: e3 };
} };
function na$3() {
  return Gu$2("w-e-insert-link");
}
var ra$3 = function() {
  function t2() {
    this.title = lp$1("link.insert"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M440.224 635.776a51.84 51.84 0 0 1-36.768-15.232c-95.136-95.136-95.136-249.92 0-345.056l192-192C641.536 37.408 702.816 12.032 768 12.032s126.432 25.376 172.544 71.456c95.136 95.136 95.136 249.92 0 345.056l-87.776 87.776a51.968 51.968 0 1 1-73.536-73.536l87.776-87.776a140.16 140.16 0 0 0 0-197.984c-26.432-26.432-61.6-40.992-99.008-40.992s-72.544 14.56-99.008 40.992l-192 192a140.16 140.16 0 0 0 0 197.984 51.968 51.968 0 0 1-36.768 88.768z"></path><path d="M256 1012a242.4 242.4 0 0 1-172.544-71.456c-95.136-95.136-95.136-249.92 0-345.056l87.776-87.776a51.968 51.968 0 1 1 73.536 73.536l-87.776 87.776a140.16 140.16 0 0 0 0 197.984c26.432 26.432 61.6 40.992 99.008 40.992s72.544-14.56 99.008-40.992l192-192a140.16 140.16 0 0 0 0-197.984 51.968 51.968 0 1 1 73.536-73.536c95.136 95.136 95.136 249.92 0 345.056l-192 192A242.4 242.4 0 0 1 256 1012z"></path></svg>', this.tag = "button", this.showModal = true, this.modalWidth = 300, this.$content = null, this.textInputId = na$3(), this.urlInputId = na$3(), this.buttonId = na$3();
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    return Ju$2(t3);
  }, t2.prototype.getModalPositionNode = function(t3) {
    return null;
  }, t2.prototype.getModalContentElem = function(t3) {
    var e3 = t3.selection, i2 = this, u2 = i2.textInputId, a2 = i2.urlInputId, l2 = i2.buttonId, s2 = Xo$3(Wd$1(lp$1("link.text"), u2), 2), f2 = s2[0], d3 = s2[1], v2 = $$6(d3), g2 = Xo$3(Wd$1(lp$1("link.url"), a2), 2), y2 = g2[0], m2 = g2[1], b2 = $$6(m2), x2 = Xo$3(zd$1(l2, lp$1("common.ok")), 1)[0];
    if (null == this.$content) {
      var w2 = $$6("<div></div>");
      w2.on("click", "#" + l2, function(e4) {
        e4.preventDefault();
        var n2 = w2.find("#" + u2).val(), r2 = w2.find("#" + a2).val();
        Qu$2(t3, n2, r2), t3.hidePanelOrModal();
      }), this.$content = w2;
    }
    var S2 = this.$content;
    if (S2.empty(), S2.append(f2), S2.append(y2), S2.append(x2), null == e3 || Range.isCollapsed(e3))
      v2.val("");
    else {
      var k2 = Editor$1.string(t3, e3);
      v2.val(k2);
    }
    return b2.val(""), setTimeout(function() {
      v2.focus();
    }), S2[0];
  }, t2;
}();
function oa$3() {
  return Gu$2("w-e-update-link");
}
var ia$3 = function() {
  function t2() {
    this.title = lp$1("link.edit"), this.iconSvg = xi$2, this.tag = "button", this.showModal = true, this.modalWidth = 300, this.$content = null, this.urlInputId = oa$3(), this.buttonId = oa$3();
  }
  return t2.prototype.getSelectedLinkElem = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "link");
    return null == n2 ? null : n2;
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.getSelectedLinkElem(t3);
    return e3 && e3.url || "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == this.getSelectedLinkElem(t3);
  }, t2.prototype.getModalPositionNode = function(t3) {
    return rl$1.getSelectedNodeByType(t3, "link");
  }, t2.prototype.getModalContentElem = function(t3) {
    var i2 = this.urlInputId, u2 = this.buttonId, a2 = Xo$3(Wd$1(lp$1("link.url"), i2), 2), c2 = a2[0], l2 = a2[1], p2 = $$6(l2), d3 = Xo$3(zd$1(u2, lp$1("common.ok")), 1)[0];
    if (null == this.$content) {
      var v2 = $$6("<div></div>");
      v2.on("click", "button", function(n2) {
        n2.preventDefault(), t3.restoreSelection();
        var r2 = rl$1.getSelectedNodeByType(t3, "link"), o2 = r2 ? Node$1.string(r2) : "", u3 = v2.find("#" + i2).val();
        !function(t4, n3, r3) {
          Wo$3(this, void 0, void 0, function() {
            var o3, i3;
            return Go$3(this, function(u4) {
              switch (u4.label) {
                case 0:
                  return r3 ? [4, Xu$2("editLink", t4, n3, r3)] : [2];
                case 1:
                  return u4.sent() ? [4, Yu$2("editLink", t4, r3)] : [2];
                case 2:
                  return o3 = u4.sent(), i3 = { url: Uu$2(o3) }, Transforms.setNodes(t4, i3, { match: function(t5) {
                    return rl$1.checkNodeType(t5, "link");
                  } }), [2];
              }
            });
          });
        }(t3, o2, u3), t3.hidePanelOrModal();
      }), this.$content = v2;
    }
    var g2 = this.$content;
    g2.empty(), g2.append(c2), g2.append(d3);
    var y2 = this.getValue(t3);
    return p2.val(y2), setTimeout(function() {
      p2.focus();
    }), g2[0];
  }, t2;
}(), ua$3 = function() {
  function t2() {
    this.title = lp$1("link.unLink"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M608.16328 811.815036c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.347563 89.347564c-118.525421 118.523421-311.38448 118.531421-429.919901 0-118.527421-118.529421-118.527421-311.39048 0-429.917901l89.349564-89.349563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.195613 79.195613c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.349563 89.347564c-56.143726 56.145726-56.143726 147.49928 0 203.645005 56.143726 56.143726 147.49928 56.145726 203.647005 0l89.347564-89.347563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.193613 79.195613z m-113.135447-520.429459c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.347564-89.347564c56.143726-56.149726 147.49928-56.145726 203.647006 0 56.143726 56.145726 56.143726 147.49928 0 203.645006l-89.349564 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.195613 79.195613c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.349564-89.349563c118.529421-118.529421 118.529421-311.38848 0-429.917901-118.531421-118.527421-311.38848-118.527421-429.919901 0l-89.347563 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.193613 79.195613z m469.653707 718.556492l45.253779-45.253779c18.745908-18.745908 18.745908-49.13776 0-67.881669L127.195629 14.062931c-18.745908-18.745908-49.13776-18.745908-67.881669 0L14.058181 59.31871c-18.745908 18.745908-18.745908 49.13776 0 67.881669l882.74169 882.74169c18.745908 18.743908 49.13776 18.743908 67.881669 0z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == rl$1.getSelectedNodeByType(t3, "link");
  }, t2.prototype.exec = function(t3, n2) {
    this.isDisabled(t3) || Transforms.unwrapNodes(t3, { match: function(t4) {
      return rl$1.checkNodeType(t4, "link");
    } });
  }, t2;
}(), aa$3 = function() {
  function t2() {
    this.title = lp$1("link.view"), this.iconSvg = wi$2, this.tag = "button";
  }
  return t2.prototype.getSelectedLinkElem = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "link");
    return null == n2 ? null : n2;
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.getSelectedLinkElem(t3);
    return e3 && e3.url || "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == this.getSelectedLinkElem(t3);
  }, t2.prototype.exec = function(t3, e3) {
    if (!this.isDisabled(t3)) {
      if (!e3 || "string" != typeof e3)
        throw new Error("View link failed, link url is '" + e3 + "'");
      window.open(e3, "_blank");
    }
  }, t2;
}();
var ca$3 = { checkLink: function(t2, e3) {
  return true;
}, parseLinkUrl: function(t2) {
  return t2;
} }, la$3 = { renderElems: [Zu$2], elemsToHtml: [ta$3], parseElemsHtml: [ea$3], menus: [{ key: "insertLink", factory: function() {
  return new ra$3();
}, config: ca$3 }, { key: "editLink", factory: function() {
  return new ia$3();
}, config: ca$3 }, { key: "unLink", factory: function() {
  return new ua$3();
} }, { key: "viewLink", factory: function() {
  return new aa$3();
} }], editorPlugin: function(t2) {
  var n2 = t2.isInline, r2 = t2.insertData, o2 = t2.normalizeNode;
  t2.insertNode, t2.insertText;
  var i2 = t2;
  return i2.isInline = function(t3) {
    return "link" === t3.type || n2(t3);
  }, i2.insertData = function(t3) {
    var e3 = t3.getData("text/plain");
    if (Fu$2(e3)) {
      if (!Ju$2(i2)) {
        var n3 = i2.selection;
        if (null != n3) {
          var o3 = Editor$1.string(i2, n3);
          Qu$2(i2, o3, e3);
        }
      }
    } else
      r2(t3);
  }, i2.normalizeNode = function(t3) {
    var n3 = Xo$3(t3, 2), r3 = n3[0], u2 = n3[1];
    return "link" !== rl$1.getNodeType(r3) ? o2([r3, u2]) : "" === Node$1.string(r3) ? Transforms.removeNodes(i2, { at: u2 }) : o2([r3, u2]);
  }, i2;
} };
var sa$3 = st$5(1 .valueOf), fa$3 = J$5.RangeError, pa$3 = J$5.RangeError, da$3 = J$5.String, ha$2 = Math.floor, va$3 = st$5(function(t2) {
  var e3 = Yn$5(mt$5(this)), n2 = "", r2 = Ge$5(t2);
  if (r2 < 0 || r2 == 1 / 0)
    throw fa$3("Wrong number of repetitions");
  for (; r2 > 0; (r2 >>>= 1) && (e3 += e3))
    1 & r2 && (n2 += e3);
  return n2;
}), ga$2 = st$5("".slice), ya$2 = st$5(1 .toFixed), ma$2 = function(t2, e3, n2) {
  return 0 === e3 ? n2 : e3 % 2 == 1 ? ma$2(t2, e3 - 1, n2 * t2) : ma$2(t2 * t2, e3 / 2, n2);
}, ba$2 = function(t2, e3, n2) {
  for (var r2 = -1, o2 = n2; ++r2 < 6; )
    o2 += e3 * t2[r2], t2[r2] = o2 % 1e7, o2 = ha$2(o2 / 1e7);
}, xa$2 = function(t2, e3) {
  for (var n2 = 6, r2 = 0; --n2 >= 0; )
    r2 += t2[n2], t2[n2] = ha$2(r2 / e3), r2 = r2 % e3 * 1e7;
}, wa$2 = function(t2) {
  for (var e3 = 6, n2 = ""; --e3 >= 0; )
    if ("" !== n2 || 0 === e3 || 0 !== t2[e3]) {
      var r2 = da$3(t2[e3]);
      n2 = "" === n2 ? r2 : n2 + va$3("0", 7 - r2.length) + r2;
    }
  return n2;
};
function Sa$2(t2, n2) {
  return "w-e-image-container-" + rl$1.findKey(t2, n2).id;
}
function ka$2(t2, n2, r2, o2) {
  var u2 = $$6("body"), a2 = Sa$2(t2, n2), c2 = o2.width, l2 = o2.height, s2 = 0, p2 = 0, d3 = 0, v2 = false, g2 = null;
  function y2(n3) {
    g2 = function() {
      var t3 = $$6("#" + a2);
      if (0 === t3.length)
        throw new Error("Cannot find image container elem");
      return t3;
    }(), s2 = n3;
    var r3 = g2.find("img");
    if (0 === r3.length)
      throw new Error("Cannot find image elem");
    p2 = r3.width(), d3 = r3.height(), u2.on("mousemove", m2), u2.on("mouseup", b2);
    var o3 = rl$1.getHoverbar(t2);
    o3 && o3.hideAndClean();
  }
  var m2 = lodash_throttle(function(t3) {
    t3.preventDefault();
    var e3 = t3.clientX, n3 = p2 + (v2 ? s2 - e3 : e3 - s2), r3 = d3 * (n3 / p2);
    null != g2 && (n3 <= 15 || r3 <= 15 || (g2.css("width", n3 + "px"), g2.css("height", r3 + "px")));
  }, 100);
  function b2(r3) {
    if (u2.off("mousemove", m2), null != g2) {
      var o3 = g2.width().toFixed(2), i2 = g2.height().toFixed(2), a3 = { style: qo$3(qo$3({}, n2.style), { width: o3 + "px", height: i2 + "px" }) };
      Transforms.setNodes(t2, a3, { at: rl$1.findPath(t2, n2) }), u2.off("mouseup", b2);
    }
  }
  var x2 = {};
  return c2 && (x2.width = c2), l2 && (x2.height = l2), jsx("div", { id: a2, style: x2, className: "w-e-image-container w-e-selected-image-container", on: { mousedown: function(t3) {
    var e3 = $$6(t3.target);
    e3.hasClass("w-e-image-dragger") && (t3.preventDefault(), (e3.hasClass("left-top") || e3.hasClass("left-bottom")) && (v2 = true), y2(t3.clientX));
  } } }, r2, jsx("div", { className: "w-e-image-dragger left-top" }), jsx("div", { className: "w-e-image-dragger right-top" }), jsx("div", { className: "w-e-image-dragger left-bottom" }), jsx("div", { className: "w-e-image-dragger right-bottom" }));
}
xn$5({ target: "Number", proto: true, forced: K$5(function() {
  return "0.000" !== ya$2(8e-5, 3) || "1" !== ya$2(0.9, 0) || "1.25" !== ya$2(1.255, 2) || "1000000000000000128" !== ya$2(1000000000000000100, 0);
}) || !K$5(function() {
  ya$2({});
}) }, { toFixed: function(t2) {
  var e3, n2, r2, o2, i2 = sa$3(this), u2 = Ge$5(t2), a2 = [0, 0, 0, 0, 0, 0], c2 = "", l2 = "0";
  if (u2 < 0 || u2 > 20)
    throw pa$3("Incorrect fraction digits");
  if (i2 != i2)
    return "NaN";
  if (i2 <= -1e21 || i2 >= 1e21)
    return da$3(i2);
  if (i2 < 0 && (c2 = "-", i2 = -i2), i2 > 1e-21)
    if (n2 = (e3 = function(t3) {
      for (var e4 = 0, n3 = t3; n3 >= 4096; )
        e4 += 12, n3 /= 4096;
      for (; n3 >= 2; )
        e4 += 1, n3 /= 2;
      return e4;
    }(i2 * ma$2(2, 69, 1)) - 69) < 0 ? i2 * ma$2(2, -e3, 1) : i2 / ma$2(2, e3, 1), n2 *= 4503599627370496, (e3 = 52 - e3) > 0) {
      for (ba$2(a2, 0, n2), r2 = u2; r2 >= 7; )
        ba$2(a2, 1e7, 0), r2 -= 7;
      for (ba$2(a2, ma$2(10, r2, 1), 0), r2 = e3 - 1; r2 >= 23; )
        xa$2(a2, 1 << 23), r2 -= 23;
      xa$2(a2, 1 << r2), ba$2(a2, 1, 1), xa$2(a2, 2), l2 = wa$2(a2);
    } else
      ba$2(a2, 0, n2), ba$2(a2, 1 << -e3, 0), l2 = wa$2(a2) + va$3("0", u2);
  return l2 = u2 > 0 ? c2 + ((o2 = l2.length) <= u2 ? "0." + va$3("0", u2 - o2) + l2 : ga$2(l2, 0, o2 - u2) + "." + ga$2(l2, o2 - u2)) : c2 + l2;
} });
var Ea$2 = { type: "image", renderElem: function(t2, n2, r2) {
  var o2 = t2, u2 = o2.src, a2 = o2.alt, c2 = void 0 === a2 ? "" : a2, l2 = o2.href, s2 = void 0 === l2 ? "" : l2, f2 = o2.style, p2 = void 0 === f2 ? {} : f2, d3 = p2.width, h2 = void 0 === d3 ? "" : d3, v2 = p2.height, g2 = void 0 === v2 ? "" : v2, y2 = rl$1.isNodeSelected(r2, t2), m2 = {};
  h2 && (m2.width = "100%"), g2 && (m2.height = "100%");
  var b2 = jsx("img", { style: m2, src: u2, alt: c2, "data-href": s2 }), x2 = r2.isDisabled();
  return y2 && !x2 ? ka$2(r2, t2, b2, { width: h2, height: g2 }) : function(t3, e3, n3, r3) {
    var o3 = r3.width, u3 = r3.height, a3 = {};
    o3 && (a3.width = o3), u3 && (a3.height = u3);
    var c3 = Sa$2(t3, e3);
    return jsx("div", { id: c3, style: a3, className: "w-e-image-container" }, n3);
  }(r2, t2, b2, { width: h2, height: g2 });
} };
var Ta$2 = { type: "image", elemToHtml: function(t2, e3) {
  var n2 = t2, r2 = n2.src, o2 = n2.alt, i2 = void 0 === o2 ? "" : o2, u2 = n2.href, a2 = void 0 === u2 ? "" : u2, c2 = n2.style, l2 = void 0 === c2 ? {} : c2, s2 = l2.width, f2 = void 0 === s2 ? "" : s2, p2 = l2.height, d3 = void 0 === p2 ? "" : p2, h2 = "";
  return f2 && (h2 += "width: " + f2 + ";"), d3 && (h2 += "height: " + d3 + ";"), '<img src="' + r2 + '" alt="' + i2 + '" data-href="' + a2 + '" style="' + h2 + '"/>';
} };
var Ma$2 = { selector: "img", parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2), o2 = r2.attr("data-href") || "";
  return o2 = decodeURIComponent(o2), { type: "image", src: r2.attr("src") || "", alt: r2.attr("alt") || "", href: o2, style: { width: Ro$3(r2, "width"), height: Ro$3(r2, "height") }, children: [{ text: "" }] };
} };
function Ha$1(t2, e3, n2, r2, o2) {
  return void 0 === r2 && (r2 = ""), void 0 === o2 && (o2 = ""), Wo$3(this, void 0, void 0, function() {
    var i2, u2;
    return Go$3(this, function(a2) {
      switch (a2.label) {
        case 0:
          return (i2 = e3.getMenuConfig(t2).checkImage) ? [4, i2(n2, r2, o2)] : [3, 2];
        case 1:
          if ("string" == typeof (u2 = a2.sent()))
            return e3.alert(u2, "error"), [2, false];
          if (null == u2)
            return [2, false];
          a2.label = 2;
        case 2:
          return [2, true];
      }
    });
  });
}
function Oa$2(t2, e3, n2) {
  return Wo$3(this, void 0, void 0, function() {
    var r2;
    return Go$3(this, function(o2) {
      switch (o2.label) {
        case 0:
          return (r2 = e3.getMenuConfig(t2).parseImageSrc) ? [4, r2(n2)] : [3, 2];
        case 1:
          return [2, o2.sent()];
        case 2:
          return [2, n2];
      }
    });
  });
}
function Ia$2(t2, n2, r2, o2) {
  return void 0 === r2 && (r2 = ""), void 0 === o2 && (o2 = ""), Wo$3(this, void 0, void 0, function() {
    var i2, u2, a2;
    return Go$3(this, function(c2) {
      switch (c2.label) {
        case 0:
          return [4, Ha$1("insertImage", t2, n2, r2, o2)];
        case 1:
          return c2.sent() ? [4, Oa$2("insertImage", t2, n2)] : [2];
        case 2:
          return i2 = c2.sent(), u2 = { type: "image", src: Uu$2(i2), href: o2, alt: r2, style: {}, children: [{ text: "" }] }, null === t2.selection && t2.restoreSelection(), rl$1.getSelectedNodeByType(t2, "image") && t2.move(1), La$2(t2) ? [2] : (Transforms.insertNodes(t2, u2), (a2 = t2.getMenuConfig("insertImage").onInsertedImage) && a2(u2), [2]);
      }
    });
  });
}
function Na$2(t2, n2, r2, o2, i2) {
  return void 0 === r2 && (r2 = ""), void 0 === o2 && (o2 = ""), void 0 === i2 && (i2 = {}), Wo$3(this, void 0, void 0, function() {
    var u2, a2, c2, l2, s2, p2;
    return Go$3(this, function(d3) {
      switch (d3.label) {
        case 0:
          return [4, Ha$1("editImage", t2, n2, r2, o2)];
        case 1:
          return d3.sent() ? [4, Oa$2("editImage", t2, n2)] : [2];
        case 2:
          return u2 = d3.sent(), null == (a2 = rl$1.getSelectedNodeByType(t2, "image")) ? [2] : (c2 = a2.style, l2 = { src: u2, alt: r2, href: o2, style: qo$3(qo$3({}, void 0 === c2 ? {} : c2), i2) }, Transforms.setNodes(t2, l2, { match: function(t3) {
            return rl$1.checkNodeType(t3, "image");
          } }), s2 = rl$1.getSelectedNodeByType(t2, "image"), (p2 = t2.getMenuConfig("editImage").onUpdatedImage) && p2(s2), [2]);
      }
    });
  });
}
function La$2(t2) {
  var n2 = t2.selection;
  return null == n2 || (!Range.isCollapsed(n2) || !!Xo$3(Editor$1.nodes(t2, { match: function(n3) {
    var r2 = rl$1.getNodeType(n3);
    return "code" === r2 || ("pre" === r2 || ("link" === r2 || ("list-item" === r2 || (!!r2.startsWith("header") || ("blockquote" === r2 || !!Editor$1.isVoid(t2, n3))))));
  }, universal: true }), 1)[0]);
}
function za$1() {
  return Gu$2("w-e-insert-image");
}
var ja$1 = function() {
  function t2() {
    this.title = lp$1("image.netImage"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>', this.tag = "button", this.showModal = true, this.modalWidth = 300, this.$content = null, this.srcInputId = za$1(), this.altInputId = za$1(), this.hrefInputId = za$1(), this.buttonId = za$1();
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    return La$2(t3);
  }, t2.prototype.getModalPositionNode = function(t3) {
    return null;
  }, t2.prototype.getModalContentElem = function(t3) {
    var e3 = this, i2 = this, u2 = i2.srcInputId, a2 = i2.altInputId, c2 = i2.hrefInputId, l2 = i2.buttonId, s2 = Xo$3(Wd$1(lp$1("image.src"), u2), 2), f2 = s2[0], p2 = s2[1], d3 = $$6(p2), v2 = Xo$3(Wd$1(lp$1("image.desc"), a2), 2), g2 = v2[0], y2 = v2[1], m2 = $$6(y2), b2 = Xo$3(Wd$1(lp$1("image.link"), c2), 2), x2 = b2[0], w2 = b2[1], S2 = $$6(w2), k2 = Xo$3(zd$1(l2, lp$1("common.ok")), 1)[0];
    if (null == this.$content) {
      var E2 = $$6("<div></div>");
      E2.on("click", "#" + l2, function(n2) {
        n2.preventDefault();
        var r2 = E2.find("#" + u2).val().trim(), o2 = E2.find("#" + a2).val().trim(), i3 = E2.find("#" + c2).val().trim();
        e3.insertImage(t3, r2, o2, i3), t3.hidePanelOrModal();
      }), this.$content = E2;
    }
    var T2 = this.$content;
    return T2.empty(), T2.append(f2), T2.append(g2), T2.append(x2), T2.append(k2), d3.val(""), m2.val(""), S2.val(""), setTimeout(function() {
      d3.focus();
    }), T2[0];
  }, t2.prototype.insertImage = function(t3, e3, n2, r2) {
    void 0 === n2 && (n2 = ""), void 0 === r2 && (r2 = ""), e3 && (t3.restoreSelection(), this.isDisabled(t3) || Ia$2(t3, e3, n2, r2));
  }, t2;
}(), Aa$2 = function() {
  function t2() {
    this.title = lp$1("image.delete"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == rl$1.getSelectedNodeByType(t3, "image");
  }, t2.prototype.exec = function(t3, n2) {
    this.isDisabled(t3) || Transforms.removeNodes(t3, { match: function(t4) {
      return rl$1.checkNodeType(t4, "image");
    } });
  }, t2;
}();
function Pa$2() {
  return Gu$2("w-e-edit-image");
}
var Va$1 = function() {
  function t2() {
    this.title = lp$1("image.edit"), this.iconSvg = xi$2, this.tag = "button", this.showModal = true, this.modalWidth = 300, this.$content = null, this.srcInputId = Pa$2(), this.altInputId = Pa$2(), this.hrefInputId = Pa$2(), this.buttonId = Pa$2();
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.getImageNode = function(t3) {
    return rl$1.getSelectedNodeByType(t3, "image");
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "image"));
  }, t2.prototype.getModalPositionNode = function(t3) {
    return this.getImageNode(t3);
  }, t2.prototype.getModalContentElem = function(t3) {
    var e3 = this, i2 = this, u2 = i2.srcInputId, a2 = i2.altInputId, c2 = i2.hrefInputId, l2 = i2.buttonId, s2 = this.getImageNode(t3);
    if (null == s2)
      throw new Error("Not found selected image node");
    var f2 = Xo$3(Wd$1(lp$1("image.src"), u2), 2), p2 = f2[0], d3 = f2[1], v2 = $$6(d3), g2 = Xo$3(Wd$1(lp$1("image.desc"), a2), 2), y2 = g2[0], m2 = g2[1], b2 = $$6(m2), x2 = Xo$3(Wd$1(lp$1("image.link"), c2), 2), w2 = x2[0], S2 = x2[1], k2 = $$6(S2), E2 = Xo$3(zd$1(l2, lp$1("common.ok")), 1)[0];
    if (null == this.$content) {
      var T2 = $$6("<div></div>");
      T2.on("click", "#" + l2, function(n2) {
        n2.preventDefault();
        var r2 = T2.find("#" + u2).val(), o2 = T2.find("#" + a2).val(), i3 = T2.find("#" + c2).val();
        e3.updateImage(t3, r2, o2, i3), t3.hidePanelOrModal();
      }), this.$content = T2;
    }
    var M2 = this.$content;
    M2.empty(), M2.append(p2), M2.append(y2), M2.append(w2), M2.append(E2);
    var H2 = s2, O2 = H2.src, I2 = H2.alt, N2 = void 0 === I2 ? "" : I2, L2 = H2.href, z2 = void 0 === L2 ? "" : L2;
    return v2.val(O2), b2.val(N2), k2.val(z2), setTimeout(function() {
      v2.focus();
    }), M2[0];
  }, t2.prototype.updateImage = function(t3, e3, n2, r2, o2) {
    void 0 === n2 && (n2 = ""), void 0 === r2 && (r2 = ""), void 0 === o2 && (o2 = {}), e3 && (t3.restoreSelection(), this.isDisabled(t3) || Na$2(t3, e3, n2, r2, o2));
  }, t2;
}(), Ca$2 = function() {
  function t2() {
    this.title = lp$1("image.viewLink"), this.iconSvg = wi$2, this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "image");
    return n2 && n2.href || "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !this.getValue(t3);
  }, t2.prototype.exec = function(t3, e3) {
    if (!this.isDisabled(t3)) {
      if (!e3 || "string" != typeof e3)
        throw new Error("View image link failed, image.href is '" + e3 + "'");
      window.open(e3, "_blank");
    }
  }, t2;
}(), Da$2 = function() {
  function t2() {
    this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getSelectedNode = function(t3) {
    return rl$1.getSelectedNodeByType(t3, "image");
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == this.getSelectedNode(t3);
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var r2 = this.getSelectedNode(t3);
      if (null != r2) {
        var o2 = rl$1.getHoverbar(t3);
        o2 && o2.hideAndClean();
        var i2 = r2.style, u2 = { style: qo$3(qo$3({}, void 0 === i2 ? {} : i2), { width: this.value, height: "" }) };
        Transforms.setNodes(t3, u2, { match: function(t4) {
          return rl$1.checkNodeType(t4, "image");
        } });
      }
    }
  }, t2;
}(), Ba$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "30%", e4.value = "30%", e4;
  }
  return $o$3(e3, t2), e3;
}(Da$2), Ra$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "50%", e4.value = "50%", e4;
  }
  return $o$3(e3, t2), e3;
}(Da$2), Fa$2 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = "100%", e4.value = "100%", e4;
  }
  return $o$3(e3, t2), e3;
}(Da$2);
var _a$2 = { onInsertedImage: function(t2) {
}, onUpdatedImage: function(t2) {
}, checkImage: function(t2, e3, n2) {
  return true;
}, parseImageSrc: function(t2) {
  return t2;
} }, $a$2 = { renderElems: [Ea$2], elemsToHtml: [Ta$2], parseElemsHtml: [Ma$2], menus: [{ key: "insertImage", factory: function() {
  return new ja$1();
}, config: _a$2 }, { key: "deleteImage", factory: function() {
  return new Aa$2();
} }, { key: "editImage", factory: function() {
  return new Va$1();
}, config: _a$2 }, { key: "viewImageLink", factory: function() {
  return new Ca$2();
} }, { key: "imageWidth30", factory: function() {
  return new Ba$2();
} }, { key: "imageWidth50", factory: function() {
  return new Ra$2();
} }, { key: "imageWidth100", factory: function() {
  return new Fa$2();
} }], editorPlugin: function(t2) {
  var e3 = t2.isInline, n2 = t2.isVoid;
  t2.insertNode;
  var r2 = t2;
  return r2.isInline = function(t3) {
    return "image" === t3.type || e3(t3);
  }, r2.isVoid = function(t3) {
    return "image" === t3.type || n2(t3);
  }, r2;
} };
var qa$1 = { type: "todo", renderElem: function(t2, n2, r2) {
  var o2 = false;
  r2.isDisabled() && (o2 = true);
  var u2 = t2.checked, a2 = jsx("div", { style: { margin: "5px 0" } }, jsx("span", { contentEditable: false, style: { marginRight: "0.5em" } }, jsx("input", { type: "checkbox", checked: u2, disabled: o2, on: { change: function(n3) {
    var o3 = rl$1.findPath(r2, t2), i2 = { checked: n3.target.checked };
    Transforms.setNodes(r2, i2, { at: o3 });
  } } })), jsx("span", null, n2));
  return a2;
} };
var Wa$1 = function() {
  function t2() {
    this.title = lp$1("todo.todo"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M278.755556 403.911111l-79.644445 79.644445L455.111111 739.555556l568.888889-568.888889-79.644444-79.644445L455.111111 580.266667l-176.355555-176.355556zM910.222222 910.222222H113.777778V113.777778h568.888889V0H113.777778C51.2 0 0 51.2 0 113.777778v796.444444c0 62.577778 51.2 113.777778 113.777778 113.777778h796.444444c62.577778 0 113.777778-51.2 113.777778-113.777778V455.111111h-113.777778v455.111111z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return !!rl$1.getSelectedNodeByType(t3, "todo");
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!rl$1.getSelectedElems(t3).some(function(e3) {
      if (Editor$1.isVoid(t3, e3) && Editor$1.isBlock(t3, e3))
        return true;
      var n2 = e3.type;
      return !!["pre", "table", "bulleted-list", "numbered-list"].includes(n2) || void 0;
    });
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.isActive(t3);
    Transforms.setNodes(t3, { type: n2 ? "paragraph" : "todo" });
  }, t2;
}();
var Ga$1 = { selector: 'div[data-w-e-type="todo"]', parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!n2.isInline(t3);
  })).length && (e3 = [{ text: r2.text().replace(/\s+/gm, " ") }]);
  var o2 = false;
  return null != r2.find('input[type="checkbox"]').attr("checked") && (o2 = true), { type: "todo", checked: o2, children: e3 };
} };
var Ua$2 = { renderElems: [qa$1], elemsToHtml: [{ type: "todo", elemToHtml: function(t2, e3) {
  return '<div data-w-e-type="todo"><input type="checkbox" disabled ' + (t2.checked ? "checked" : "") + ">" + e3 + "</div>";
} }], preParseHtml: [{ selector: "ul.w-e-todo", preParseHtml: function(t2) {
  var e3 = $$6(t2).find("li"), n2 = $$6('<div data-w-e-type="todo"></div>'), r2 = e3.find("input[type]");
  return n2.append(r2), e3.children()[0].remove(), n2[0].innerHTML = n2[0].innerHTML + e3[0].innerHTML, n2[0];
} }], parseElemsHtml: [Ga$1], menus: [{ key: "todo", factory: function() {
  return new Wa$1();
} }], editorPlugin: function(t2) {
  var n2 = t2.deleteBackward, r2 = t2;
  return r2.deleteBackward = function(r3) {
    var o2 = t2.selection;
    if (o2 && Range.isCollapsed(o2)) {
      var i2 = rl$1.getSelectedNodeByType(t2, "todo");
      if (i2 && 0 === Node$1.string(i2).length)
        return void Transforms.setNodes(t2, { type: "paragraph" }, { mode: "highest" });
    }
    n2(r3);
  }, r2;
} };
var Xa$1 = { type: "blockquote", renderElem: function(t2, e3, n2) {
  return jsx("blockquote", null, e3);
} };
var Ya$1 = { type: "blockquote", elemToHtml: function(t2, e3) {
  return "<blockquote>" + e3 + "</blockquote>";
} };
var Ja$1 = { selector: "blockquote", parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  return 0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!n2.isInline(t3);
  })).length && (e3 = [{ text: r2.text().replace(/\s+/gm, " ") }]), { type: "blockquote", children: e3 };
} }, Ka$1 = function() {
  function t2() {
    this.title = lp$1("blockQuote.title"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M894.6 907.1H605.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C752.7 180.4 711.3 315.8 711.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z m-472 0H133.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C280.7 180.4 239.3 315.8 239.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return !!rl$1.getSelectedNodeByType(t3, "blockquote");
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      var n2 = rl$1.getNodeType(t4);
      return "paragraph" === n2 || "blockquote" === n2;
    }, universal: true, mode: "highest" }), 1)[0];
  }, t2.prototype.exec = function(t3, e3) {
    if (!this.isDisabled(t3)) {
      var n2 = this.isActive(t3) ? "paragraph" : "blockquote";
      Transforms.setNodes(t3, { type: n2 }, { mode: "highest" });
    }
  }, t2;
}(), Qa$1 = { key: "blockquote", factory: function() {
  return new Ka$1();
} }, Za = st$5([].slice), tc = qn$5("slice"), ec = re$5("species"), nc = J$5.Array, rc = Math.max;
xn$5({ target: "Array", proto: true, forced: !tc }, { slice: function(t2, e3) {
  var n2, r2, o2, i2 = bt$5(this), u2 = Qe$5(i2), a2 = Ye$5(t2, u2), c2 = Ye$5(void 0 === e3 ? u2 : e3, u2);
  if (Sn$5(i2) && (n2 = i2.constructor, (Vn$5(n2) && (n2 === nc || Sn$5(n2.prototype)) || wt$5(n2) && null === (n2 = n2[ec])) && (n2 = void 0), n2 === nc || void 0 === n2))
    return Za(i2, a2, c2);
  for (r2 = new (void 0 === n2 ? nc : n2)(rc(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++)
    a2 in i2 && yo$3(r2, o2, i2[a2]);
  return r2.length = o2, r2;
} });
var oc = { renderElems: [Xa$1], elemsToHtml: [Ya$1], parseElemsHtml: [Ja$1], menus: [Qa$1], editorPlugin: function(t2) {
  var n2 = t2.insertBreak, r2 = t2.insertText, o2 = t2;
  return o2.insertBreak = function() {
    var i2 = o2.selection;
    if (null == i2)
      return n2();
    var u2 = Xo$3(Editor$1.nodes(t2, { match: function(t3) {
      return rl$1.checkNodeType(t3, "blockquote");
    }, universal: true }), 1)[0];
    if (!u2)
      return n2();
    var a2 = u2[0], l2 = rl$1.findPath(t2, a2), p2 = Editor$1.end(t2, l2);
    if (Point.equals(p2, i2.focus)) {
      var h2 = Node$1.string(a2);
      if (h2 && "\n" === h2.slice(-1)) {
        t2.deleteBackward("character");
        return void Transforms.insertNodes(o2, { type: "paragraph", children: [{ text: "" }] }, { mode: "highest" });
      }
    }
    r2("\n");
  }, o2;
} }, ic = function() {
  function t2() {
    this.title = lp$1("emotion.title"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M512 1024C230.4 1024 0 793.6 0 512S230.4 0 512 0s512 230.4 512 512-230.4 512-512 512z m0-102.4c226.742857 0 409.6-182.857143 409.6-409.6S738.742857 102.4 512 102.4 102.4 285.257143 102.4 512s182.857143 409.6 409.6 409.6z m-204.8-358.4h409.6c0 113.371429-91.428571 204.8-204.8 204.8s-204.8-91.428571-204.8-204.8z m0-102.4c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8 76.8 32.914286 76.8 76.8-32.914286 76.8-76.8 76.8z m409.6 0c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8c43.885714 0 76.8 32.914286 76.8 76.8s-32.914286 76.8-76.8 76.8z"></path></svg>', this.tag = "button", this.showDropPanel = true, this.$content = null;
  }
  return t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!Xo$3(Editor$1.nodes(t3, { match: function(n2) {
      return "pre" === rl$1.getNodeType(n2) || !!Editor$1.isVoid(t3, n2);
    }, universal: true }), 1)[0];
  }, t2.prototype.getPanelContentElem = function(t3) {
    if (null == this.$content) {
      var e3 = $$6('<ul class="w-e-panel-content-emotion"></ul>');
      e3.on("click", "li", function(e4) {
        var n3 = e4.target;
        if (null != n3) {
          e4.preventDefault();
          var r3 = $$6(n3).text();
          t3.insertText(r3);
        }
      }), this.$content = e3;
    }
    var n2 = this.$content;
    if (null == n2)
      return document.createElement("ul");
    n2.empty();
    var r2 = t3.getMenuConfig("emotion").emotions;
    return (void 0 === r2 ? [] : r2).forEach(function(t4) {
      var e4 = $$6("<li>" + t4 + "</li>");
      n2.append(e4);
    }), n2[0];
  }, t2;
}();
var uc = { menus: [{ key: "emotion", factory: function() {
  return new ic();
}, config: { emotions: "\u{1F600} \u{1F603} \u{1F604} \u{1F601} \u{1F606} \u{1F605} \u{1F602} \u{1F923} \u{1F60A} \u{1F607} \u{1F642} \u{1F643} \u{1F609} \u{1F60C} \u{1F60D} \u{1F618} \u{1F617} \u{1F619} \u{1F61A} \u{1F60B} \u{1F61B} \u{1F61D} \u{1F61C} \u{1F913} \u{1F60E} \u{1F60F} \u{1F612} \u{1F61E} \u{1F614} \u{1F61F} \u{1F615} \u{1F641} \u{1F623} \u{1F616} \u{1F62B} \u{1F629} \u{1F622} \u{1F62D} \u{1F624} \u{1F620} \u{1F621} \u{1F633} \u{1F631} \u{1F628} \u{1F917} \u{1F914} \u{1F636} \u{1F611} \u{1F62C} \u{1F644} \u{1F62F} \u{1F634} \u{1F637} \u{1F911} \u{1F608} \u{1F921} \u{1F4A9} \u{1F47B} \u{1F480} \u{1F440} \u{1F463} \u{1F450} \u{1F64C} \u{1F44F} \u{1F91D} \u{1F44D} \u{1F44E} \u{1F44A} \u270A \u{1F91B} \u{1F91C} \u{1F91E} \u270C\uFE0F \u{1F918} \u{1F44C} \u{1F448} \u{1F449} \u{1F446} \u{1F447} \u261D\uFE0F \u270B \u{1F91A} \u{1F590} \u{1F596} \u{1F44B} \u{1F919} \u{1F4AA} \u{1F595} \u270D\uFE0F \u{1F64F}".split(" ") } }] };
var ac = { 1: "12px", 2: "14px", 3: "16px", 4: "19px", 5: "24px", 6: "32px", 7: "48px" };
var cc = { selector: "font", preParseHtml: function(t2) {
  var e3 = $$6(t2);
  if ("font" !== Bo$3(e3))
    return t2;
  var n2 = e3.attr("size") || "";
  n2 && (e3.removeAttr("size"), e3.css("font-size", ac[n2]));
  var r2 = e3.attr("face") || "";
  return r2 && (e3.removeAttr("face"), e3.css("font-family", r2)), e3[0];
} }, lc = st$5("".indexOf);
xn$5({ target: "String", proto: true, forced: !iu$2("includes") }, { includes: function(t2) {
  return !!~lc(Yn$5(mt$5(this)), Yn$5(ru$2(t2)), arguments.length > 1 ? arguments[1] : void 0);
} });
var sc, fc, pc = function() {
  function t2() {
    this.tag = "select", this.width = 80;
  }
  return t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.mark, n2 = Editor$1.marks(t3);
    return n2 && n2[e3] ? n2[e3] : "";
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || (this.mark, !!Xo$3(Editor$1.nodes(t3, { match: function(n2) {
      return "pre" === rl$1.getNodeType(n2) || !!Editor$1.isVoid(t3, n2);
    }, universal: true }), 1)[0]);
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.mark;
    e3 ? t3.addMark(n2, e3) : t3.removeMark(n2);
  }, t2;
}(), dc = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("fontSize.title"), e4.iconSvg = Ei$2, e4.mark = "fontSize", e4;
  }
  return $o$3(e3, t2), e3.prototype.getOptions = function(t3) {
    var e4 = [], r2 = t3.getMenuConfig(this.mark).fontSizeList, o2 = void 0 === r2 ? [] : r2;
    e4.push({ text: lp$1("fontSize.default"), value: "" }), o2.forEach(function(t4) {
      e4.push({ text: t4, value: t4 });
    });
    var i2 = this.getValue(t3);
    return e4.forEach(function(t4) {
      t4.value === i2 ? t4.selected = true : delete t4.selected;
    }), e4;
  }, e3;
}(pc), hc = function(t2) {
  return t2 && t2.Math == Math && t2;
}, vc = hc("object" == typeof globalThis && globalThis) || hc("object" == typeof window && window) || hc("object" == typeof self && self) || hc("object" == typeof q$5 && q$5) || function() {
  return this;
}() || Function("return this")(), gc = Function.prototype, yc = gc.apply, mc = gc.bind, bc = gc.call, xc = "object" == typeof Reflect && Reflect.apply || (mc ? bc.bind(yc) : function() {
  return bc.apply(yc, arguments);
}), wc = Function.prototype, Sc = wc.bind, kc = wc.call, Ec = Sc && Sc.bind(kc), Tc = Sc ? function(t2) {
  return t2 && Ec(kc, t2);
} : function(t2) {
  return t2 && function() {
    return kc.apply(t2, arguments);
  };
}, Mc = function(t2) {
  return "function" == typeof t2;
}, Hc = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, Oc = !Hc(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), Ic = Function.prototype.call, Nc = Ic.bind ? Ic.bind(Ic) : function() {
  return Ic.apply(Ic, arguments);
}, Lc = {}.propertyIsEnumerable, zc = Object.getOwnPropertyDescriptor, jc = zc && !Lc.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = zc(this, t2);
  return !!e3 && e3.enumerable;
} : Lc, Ac = { f: jc }, Pc = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, Vc = Tc({}.toString), Cc = Tc("".slice), Dc = function(t2) {
  return Cc(Vc(t2), 8, -1);
}, Bc = vc.Object, Rc = Tc("".split), Fc = Hc(function() {
  return !Bc("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == Dc(t2) ? Rc(t2, "") : Bc(t2);
} : Bc, _c = vc.TypeError, $c = function(t2) {
  if (null == t2)
    throw _c("Can't call method on " + t2);
  return t2;
}, qc = function(t2) {
  return Fc($c(t2));
}, Wc = function(t2) {
  return "object" == typeof t2 ? null !== t2 : Mc(t2);
}, Gc = {}, Uc = function(t2) {
  return Mc(t2) ? t2 : void 0;
}, Xc = function(t2, e3) {
  return arguments.length < 2 ? Uc(Gc[t2]) || Uc(vc[t2]) : Gc[t2] && Gc[t2][e3] || vc[t2] && vc[t2][e3];
}, Yc = Tc({}.isPrototypeOf), Jc = Xc("navigator", "userAgent") || "", Kc = vc.process, Qc = vc.Deno, Zc = Kc && Kc.versions || Qc && Qc.version, tl = Zc && Zc.v8;
tl && (fc = (sc = tl.split("."))[0] > 0 && sc[0] < 4 ? 1 : +(sc[0] + sc[1])), !fc && Jc && (!(sc = Jc.match(/Edge\/(\d+)/)) || sc[1] >= 74) && (sc = Jc.match(/Chrome\/(\d+)/)) && (fc = +sc[1]);
var el = fc, nl = !!Object.getOwnPropertySymbols && !Hc(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && el && el < 41;
}), rl = nl && !Symbol.sham && "symbol" == typeof Symbol.iterator, ol = vc.Object, il = rl ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = Xc("Symbol");
  return Mc(e3) && Yc(e3.prototype, ol(t2));
}, ul = vc.String, al = vc.TypeError, cl = function(t2) {
  if (Mc(t2))
    return t2;
  throw al(function(t3) {
    try {
      return ul(t3);
    } catch (t4) {
      return "Object";
    }
  }(t2) + " is not a function");
}, ll = vc.TypeError, sl = Object.defineProperty, fl = vc["__core-js_shared__"] || function(t2, e3) {
  try {
    sl(vc, t2, { value: e3, configurable: true, writable: true });
  } catch (n2) {
    vc[t2] = e3;
  }
  return e3;
}("__core-js_shared__", {}), pl = G$5(function(t2) {
  (t2.exports = function(t3, e3) {
    return fl[t3] || (fl[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "pure", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), dl = vc.Object, hl = function(t2) {
  return dl($c(t2));
}, vl = Tc({}.hasOwnProperty), gl = Object.hasOwn || function(t2, e3) {
  return vl(hl(t2), e3);
}, yl = 0, ml = Math.random(), bl = Tc(1 .toString), xl = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + bl(++yl + ml, 36);
}, wl = pl("wks"), Sl = vc.Symbol, kl = Sl && Sl.for, El = rl ? Sl : Sl && Sl.withoutSetter || xl, Tl = function(t2) {
  if (!gl(wl, t2) || !nl && "string" != typeof wl[t2]) {
    var e3 = "Symbol." + t2;
    nl && gl(Sl, t2) ? wl[t2] = Sl[t2] : wl[t2] = rl && kl ? kl(e3) : El(e3);
  }
  return wl[t2];
}, Ml = vc.TypeError, Hl = Tl("toPrimitive"), Ol = function(t2, e3) {
  if (!Wc(t2) || il(t2))
    return t2;
  var n2, r2, o2 = null == (n2 = t2[Hl]) ? void 0 : cl(n2);
  if (o2) {
    if (void 0 === e3 && (e3 = "default"), r2 = Nc(o2, t2, e3), !Wc(r2) || il(r2))
      return r2;
    throw Ml("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var n3, r3;
    if ("string" === e4 && Mc(n3 = t3.toString) && !Wc(r3 = Nc(n3, t3)))
      return r3;
    if (Mc(n3 = t3.valueOf) && !Wc(r3 = Nc(n3, t3)))
      return r3;
    if ("string" !== e4 && Mc(n3 = t3.toString) && !Wc(r3 = Nc(n3, t3)))
      return r3;
    throw ll("Can't convert object to primitive value");
  }(t2, e3);
}, Il = function(t2) {
  var e3 = Ol(t2, "string");
  return il(e3) ? e3 : e3 + "";
}, Nl = vc.document, Ll = Wc(Nl) && Wc(Nl.createElement), zl = function(t2) {
  return Ll ? Nl.createElement(t2) : {};
}, jl = !Oc && !Hc(function() {
  return 7 != Object.defineProperty(zl("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Al = Object.getOwnPropertyDescriptor, Pl = { f: Oc ? Al : function(t2, e3) {
  if (t2 = qc(t2), e3 = Il(e3), jl)
    try {
      return Al(t2, e3);
    } catch (t3) {
    }
  if (gl(t2, e3))
    return Pc(!Nc(Ac.f, t2, e3), t2[e3]);
} }, Vl = /#|\.prototype\./, Cl = function(t2, e3) {
  var n2 = Bl[Dl(t2)];
  return n2 == Fl || n2 != Rl && (Mc(e3) ? Hc(e3) : !!e3);
}, Dl = Cl.normalize = function(t2) {
  return String(t2).replace(Vl, ".").toLowerCase();
}, Bl = Cl.data = {}, Rl = Cl.NATIVE = "N", Fl = Cl.POLYFILL = "P", _l = Cl, $l = Tc(Tc.bind), ql = function(t2, e3) {
  return cl(t2), void 0 === e3 ? t2 : $l ? $l(t2, e3) : function() {
    return t2.apply(e3, arguments);
  };
}, Wl = vc.String, Gl = vc.TypeError, Ul = function(t2) {
  if (Wc(t2))
    return t2;
  throw Gl(Wl(t2) + " is not an object");
}, Xl = vc.TypeError, Yl = Object.defineProperty, Jl = { f: Oc ? Yl : function(t2, e3, n2) {
  if (Ul(t2), e3 = Il(e3), Ul(n2), jl)
    try {
      return Yl(t2, e3, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw Xl("Accessors not supported");
  return "value" in n2 && (t2[e3] = n2.value), t2;
} }, Kl = Oc ? function(t2, e3, n2) {
  return Jl.f(t2, e3, Pc(1, n2));
} : function(t2, e3, n2) {
  return t2[e3] = n2, t2;
}, Ql = Pl.f, Zl = function(t2) {
  var e3 = function(n2, r2, o2) {
    if (this instanceof e3) {
      switch (arguments.length) {
        case 0:
          return new t2();
        case 1:
          return new t2(n2);
        case 2:
          return new t2(n2, r2);
      }
      return new t2(n2, r2, o2);
    }
    return xc(t2, this, arguments);
  };
  return e3.prototype = t2.prototype, e3;
}, ts = function(t2, e3) {
  var n2, r2, o2, i2, u2, a2, c2, l2, s2 = t2.target, f2 = t2.global, p2 = t2.stat, d3 = t2.proto, h2 = f2 ? vc : p2 ? vc[s2] : (vc[s2] || {}).prototype, v2 = f2 ? Gc : Gc[s2] || Kl(Gc, s2, {})[s2], g2 = v2.prototype;
  for (o2 in e3)
    n2 = !_l(f2 ? o2 : s2 + (p2 ? "." : "#") + o2, t2.forced) && h2 && gl(h2, o2), u2 = v2[o2], n2 && (a2 = t2.noTargetGet ? (l2 = Ql(h2, o2)) && l2.value : h2[o2]), i2 = n2 && a2 ? a2 : e3[o2], n2 && typeof u2 == typeof i2 || (c2 = t2.bind && n2 ? ql(i2, vc) : t2.wrap && n2 ? Zl(i2) : d3 && Mc(i2) ? Tc(i2) : i2, (t2.sham || i2 && i2.sham || u2 && u2.sham) && Kl(c2, "sham", true), Kl(v2, o2, c2), d3 && (gl(Gc, r2 = s2 + "Prototype") || Kl(Gc, r2, {}), Kl(Gc[r2], o2, i2), t2.real && g2 && !g2[o2] && Kl(g2, o2, i2)));
}, es = Array.isArray || function(t2) {
  return "Array" == Dc(t2);
}, ns = Math.ceil, rs = Math.floor, os = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? rs : ns)(e3);
}, is = Math.min, us = function(t2) {
  return (e3 = t2.length) > 0 ? is(os(e3), 9007199254740991) : 0;
  var e3;
}, as = function(t2, e3, n2) {
  var r2 = Il(e3);
  r2 in t2 ? Jl.f(t2, r2, Pc(0, n2)) : t2[r2] = n2;
}, cs = {};
cs[Tl("toStringTag")] = "z";
var ls = "[object z]" === String(cs), ss = Tl("toStringTag"), fs = vc.Object, ps = "Arguments" == Dc(function() {
  return arguments;
}()), ds = ls ? Dc : function(t2) {
  var e3, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = fs(t2), ss)) ? n2 : ps ? Dc(e3) : "Object" == (r2 = Dc(e3)) && Mc(e3.callee) ? "Arguments" : r2;
}, hs = Tc(Function.toString);
Mc(fl.inspectSource) || (fl.inspectSource = function(t2) {
  return hs(t2);
});
var vs = fl.inspectSource, gs = function() {
}, ys = [], ms = Xc("Reflect", "construct"), bs = /^\s*(?:class|function)\b/, xs = Tc(bs.exec), ws = !bs.exec(gs), Ss = function(t2) {
  if (!Mc(t2))
    return false;
  try {
    return ms(gs, ys, t2), true;
  } catch (t3) {
    return false;
  }
}, ks = !ms || Hc(function() {
  var t2;
  return Ss(Ss.call) || !Ss(Object) || !Ss(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!Mc(t2))
    return false;
  switch (ds(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return ws || !!xs(bs, vs(t2));
} : Ss, Es = Tl("species"), Ts = vc.Array, Ms = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return es(t3) && (e4 = t3.constructor, (ks(e4) && (e4 === Ts || es(e4.prototype)) || Wc(e4) && null === (e4 = e4[Es])) && (e4 = void 0)), void 0 === e4 ? Ts : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, Hs = Tl("species"), Os = Tl("isConcatSpreadable"), Is = vc.TypeError, Ns = el >= 51 || !Hc(function() {
  var t2 = [];
  return t2[Os] = false, t2.concat()[0] !== t2;
}), Ls = function(t2) {
  return el >= 51 || !Hc(function() {
    var e3 = [];
    return (e3.constructor = {})[Hs] = function() {
      return { foo: 1 };
    }, 1 !== e3[t2](Boolean).foo;
  });
}("concat"), zs = function(t2) {
  if (!Wc(t2))
    return false;
  var e3 = t2[Os];
  return void 0 !== e3 ? !!e3 : es(t2);
};
ts({ target: "Array", proto: true, forced: !Ns || !Ls }, { concat: function(t2) {
  var e3, n2, r2, o2, i2, u2 = hl(this), a2 = Ms(u2, 0), c2 = 0;
  for (e3 = -1, r2 = arguments.length; e3 < r2; e3++)
    if (zs(i2 = -1 === e3 ? u2 : arguments[e3])) {
      if (c2 + (o2 = us(i2)) > 9007199254740991)
        throw Is("Maximum allowed index exceeded");
      for (n2 = 0; n2 < o2; n2++, c2++)
        n2 in i2 && as(a2, c2, i2[n2]);
    } else {
      if (c2 >= 9007199254740991)
        throw Is("Maximum allowed index exceeded");
      as(a2, c2++, i2);
    }
  return a2.length = c2, a2;
} });
var js, As = vc.String, Ps = function(t2) {
  if ("Symbol" === ds(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return As(t2);
}, Vs = Math.max, Cs = Math.min, Ds = function(t2, e3) {
  var n2 = os(t2);
  return n2 < 0 ? Vs(n2 + e3, 0) : Cs(n2, e3);
}, Bs = function(t2) {
  return function(e3, n2, r2) {
    var o2, i2 = qc(e3), u2 = us(i2), a2 = Ds(r2, u2);
    if (t2 && n2 != n2) {
      for (; u2 > a2; )
        if ((o2 = i2[a2++]) != o2)
          return true;
    } else
      for (; u2 > a2; a2++)
        if ((t2 || a2 in i2) && i2[a2] === n2)
          return t2 || a2 || 0;
    return !t2 && -1;
  };
}, Rs = { includes: Bs(true), indexOf: Bs(false) }, Fs = {}, _s = Rs.indexOf, $s = Tc([].push), qs = function(t2, e3) {
  var n2, r2 = qc(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !gl(Fs, n2) && gl(r2, n2) && $s(i2, n2);
  for (; e3.length > o2; )
    gl(r2, n2 = e3[o2++]) && (~_s(i2, n2) || $s(i2, n2));
  return i2;
}, Ws = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Gs = Object.keys || function(t2) {
  return qs(t2, Ws);
}, Us = Oc ? Object.defineProperties : function(t2, e3) {
  Ul(t2);
  for (var n2, r2 = qc(e3), o2 = Gs(e3), i2 = o2.length, u2 = 0; i2 > u2; )
    Jl.f(t2, n2 = o2[u2++], r2[n2]);
  return t2;
}, Xs = Xc("document", "documentElement"), Ys = pl("keys"), Js = function(t2) {
  return Ys[t2] || (Ys[t2] = xl(t2));
}, Ks = Js("IE_PROTO"), Qs = function() {
}, Zs = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, tf = function(t2) {
  t2.write(Zs("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, ef = function() {
  try {
    js = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  ef = "undefined" != typeof document ? document.domain && js ? tf(js) : ((e3 = zl("iframe")).style.display = "none", Xs.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(Zs("document.F=Object")), t2.close(), t2.F) : tf(js);
  for (var n2 = Ws.length; n2--; )
    delete ef.prototype[Ws[n2]];
  return ef();
};
Fs[Ks] = true;
var nf, rf, of, uf = Object.create || function(t2, e3) {
  var n2;
  return null !== t2 ? (Qs.prototype = Ul(t2), n2 = new Qs(), Qs.prototype = null, n2[Ks] = t2) : n2 = ef(), void 0 === e3 ? n2 : Us(n2, e3);
}, af = Ws.concat("length", "prototype"), cf = { f: Object.getOwnPropertyNames || function(t2) {
  return qs(t2, af);
} }, lf = vc.Array, sf = Math.max, ff = cf.f, pf = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], df = function(t2) {
  try {
    return ff(t2);
  } catch (t3) {
    return function(t4, e3, n2) {
      for (var r2 = us(t4), o2 = Ds(e3, r2), i2 = Ds(void 0 === n2 ? r2 : n2, r2), u2 = lf(sf(i2 - o2, 0)), a2 = 0; o2 < i2; o2++, a2++)
        as(u2, a2, t4[o2]);
      return u2.length = a2, u2;
    }(pf);
  }
}, hf = { f: function(t2) {
  return pf && "Window" == Dc(t2) ? df(t2) : ff(qc(t2));
} }, vf = { f: Object.getOwnPropertySymbols }, gf = Tc([].slice), yf = function(t2, e3, n2, r2) {
  r2 && r2.enumerable ? t2[e3] = n2 : Kl(t2, e3, n2);
}, mf = { f: Tl }, bf = Jl.f, xf = function(t2) {
  var e3 = Gc.Symbol || (Gc.Symbol = {});
  gl(e3, t2) || bf(e3, t2, { value: mf.f(t2) });
}, wf = ls ? {}.toString : function() {
  return "[object " + ds(this) + "]";
}, Sf = Jl.f, kf = Tl("toStringTag"), Ef = function(t2, e3, n2, r2) {
  if (t2) {
    var o2 = n2 ? t2 : t2.prototype;
    gl(o2, kf) || Sf(o2, kf, { configurable: true, value: e3 }), r2 && !ls && Kl(o2, "toString", wf);
  }
}, Tf = vc.WeakMap, Mf = Mc(Tf) && /native code/.test(vs(Tf)), Hf = vc.TypeError, Of = vc.WeakMap;
if (Mf || fl.state) {
  var If = fl.state || (fl.state = new Of()), Nf = Tc(If.get), Lf = Tc(If.has), zf = Tc(If.set);
  nf = function(t2, e3) {
    if (Lf(If, t2))
      throw new Hf("Object already initialized");
    return e3.facade = t2, zf(If, t2, e3), e3;
  }, rf = function(t2) {
    return Nf(If, t2) || {};
  }, of = function(t2) {
    return Lf(If, t2);
  };
} else {
  var jf = Js("state");
  Fs[jf] = true, nf = function(t2, e3) {
    if (gl(t2, jf))
      throw new Hf("Object already initialized");
    return e3.facade = t2, Kl(t2, jf, e3), e3;
  }, rf = function(t2) {
    return gl(t2, jf) ? t2[jf] : {};
  }, of = function(t2) {
    return gl(t2, jf);
  };
}
var Af = { set: nf, get: rf, has: of, enforce: function(t2) {
  return of(t2) ? rf(t2) : nf(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var n2;
    if (!Wc(e3) || (n2 = rf(e3)).type !== t2)
      throw Hf("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, Pf = Tc([].push), Vf = function(t2) {
  var e3 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
  return function(c2, l2, s2, f2) {
    for (var p2, d3, h2 = hl(c2), v2 = Fc(h2), g2 = ql(l2, s2), y2 = us(v2), m2 = 0, b2 = f2 || Ms, x2 = e3 ? b2(c2, y2) : n2 || u2 ? b2(c2, 0) : void 0; y2 > m2; m2++)
      if ((a2 || m2 in v2) && (d3 = g2(p2 = v2[m2], m2, h2), t2))
        if (e3)
          x2[m2] = d3;
        else if (d3)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return p2;
            case 6:
              return m2;
            case 2:
              Pf(x2, p2);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              Pf(x2, p2);
          }
    return i2 ? -1 : r2 || o2 ? o2 : x2;
  };
}, Cf = { forEach: Vf(0), map: Vf(1), filter: Vf(2), some: Vf(3), every: Vf(4), find: Vf(5), findIndex: Vf(6), filterReject: Vf(7) }.forEach, Df = Js("hidden"), Bf = Tl("toPrimitive"), Rf = Af.set, Ff = Af.getterFor("Symbol"), _f = Object.prototype, $f = vc.Symbol, qf = $f && $f.prototype, Wf = vc.TypeError, Gf = vc.QObject, Uf = Xc("JSON", "stringify"), Xf = Pl.f, Yf = Jl.f, Jf = hf.f, Kf = Ac.f, Qf = Tc([].push), Zf = pl("symbols"), tp = pl("op-symbols"), ep = pl("string-to-symbol-registry"), np = pl("symbol-to-string-registry"), rp = pl("wks"), op = !Gf || !Gf.prototype || !Gf.prototype.findChild, ip = Oc && Hc(function() {
  return 7 != uf(Yf({}, "a", { get: function() {
    return Yf(this, "a", { value: 7 }).a;
  } })).a;
}) ? function(t2, e3, n2) {
  var r2 = Xf(_f, e3);
  r2 && delete _f[e3], Yf(t2, e3, n2), r2 && t2 !== _f && Yf(_f, e3, r2);
} : Yf, up = function(t2, e3) {
  var n2 = Zf[t2] = uf(qf);
  return Rf(n2, { type: "Symbol", tag: t2, description: e3 }), Oc || (n2.description = e3), n2;
}, ap = function(t2, e3, n2) {
  t2 === _f && ap(tp, e3, n2), Ul(t2);
  var r2 = Il(e3);
  return Ul(n2), gl(Zf, r2) ? (n2.enumerable ? (gl(t2, Df) && t2[Df][r2] && (t2[Df][r2] = false), n2 = uf(n2, { enumerable: Pc(0, false) })) : (gl(t2, Df) || Yf(t2, Df, Pc(1, {})), t2[Df][r2] = true), ip(t2, r2, n2)) : Yf(t2, r2, n2);
}, cp = function(t2, e3) {
  Ul(t2);
  var n2 = qc(e3), r2 = Gs(n2).concat(pp(n2));
  return Cf(r2, function(e4) {
    Oc && !Nc(lp, n2, e4) || ap(t2, e4, n2[e4]);
  }), t2;
}, lp = function(t2) {
  var e3 = Il(t2), n2 = Nc(Kf, this, e3);
  return !(this === _f && gl(Zf, e3) && !gl(tp, e3)) && (!(n2 || !gl(this, e3) || !gl(Zf, e3) || gl(this, Df) && this[Df][e3]) || n2);
}, sp = function(t2, e3) {
  var n2 = qc(t2), r2 = Il(e3);
  if (n2 !== _f || !gl(Zf, r2) || gl(tp, r2)) {
    var o2 = Xf(n2, r2);
    return !o2 || !gl(Zf, r2) || gl(n2, Df) && n2[Df][r2] || (o2.enumerable = true), o2;
  }
}, fp = function(t2) {
  var e3 = Jf(qc(t2)), n2 = [];
  return Cf(e3, function(t3) {
    gl(Zf, t3) || gl(Fs, t3) || Qf(n2, t3);
  }), n2;
}, pp = function(t2) {
  var e3 = t2 === _f, n2 = Jf(e3 ? tp : qc(t2)), r2 = [];
  return Cf(n2, function(t3) {
    !gl(Zf, t3) || e3 && !gl(_f, t3) || Qf(r2, Zf[t3]);
  }), r2;
};
if (nl || (qf = ($f = function() {
  if (Yc(qf, this))
    throw Wf("Symbol is not a constructor");
  var t2 = arguments.length && void 0 !== arguments[0] ? Ps(arguments[0]) : void 0, e3 = xl(t2), n2 = function(t3) {
    this === _f && Nc(n2, tp, t3), gl(this, Df) && gl(this[Df], e3) && (this[Df][e3] = false), ip(this, e3, Pc(1, t3));
  };
  return Oc && op && ip(_f, e3, { configurable: true, set: n2 }), up(e3, t2);
}).prototype, yf(qf, "toString", function() {
  return Ff(this).tag;
}), yf($f, "withoutSetter", function(t2) {
  return up(xl(t2), t2);
}), Ac.f = lp, Jl.f = ap, Pl.f = sp, cf.f = hf.f = fp, vf.f = pp, mf.f = function(t2) {
  return up(Tl(t2), t2);
}, Oc && Yf(qf, "description", { configurable: true, get: function() {
  return Ff(this).description;
} })), ts({ global: true, wrap: true, forced: !nl, sham: !nl }, { Symbol: $f }), Cf(Gs(rp), function(t2) {
  xf(t2);
}), ts({ target: "Symbol", stat: true, forced: !nl }, { for: function(t2) {
  var e3 = Ps(t2);
  if (gl(ep, e3))
    return ep[e3];
  var n2 = $f(e3);
  return ep[e3] = n2, np[n2] = e3, n2;
}, keyFor: function(t2) {
  if (!il(t2))
    throw Wf(t2 + " is not a symbol");
  if (gl(np, t2))
    return np[t2];
}, useSetter: function() {
  op = true;
}, useSimple: function() {
  op = false;
} }), ts({ target: "Object", stat: true, forced: !nl, sham: !Oc }, { create: function(t2, e3) {
  return void 0 === e3 ? uf(t2) : cp(uf(t2), e3);
}, defineProperty: ap, defineProperties: cp, getOwnPropertyDescriptor: sp }), ts({ target: "Object", stat: true, forced: !nl }, { getOwnPropertyNames: fp, getOwnPropertySymbols: pp }), ts({ target: "Object", stat: true, forced: Hc(function() {
  vf.f(1);
}) }, { getOwnPropertySymbols: function(t2) {
  return vf.f(hl(t2));
} }), Uf) {
  var dp = !nl || Hc(function() {
    var t2 = $f();
    return "[null]" != Uf([t2]) || "{}" != Uf({ a: t2 }) || "{}" != Uf(Object(t2));
  });
  ts({ target: "JSON", stat: true, forced: dp }, { stringify: function(t2, e3, n2) {
    var r2 = gf(arguments), o2 = e3;
    if ((Wc(e3) || void 0 !== t2) && !il(t2))
      return es(e3) || (e3 = function(t3, e4) {
        if (Mc(o2) && (e4 = Nc(o2, this, t3, e4)), !il(e4))
          return e4;
      }), r2[1] = e3, xc(Uf, null, r2);
  } });
}
if (!qf[Bf]) {
  var hp = qf.valueOf;
  yf(qf, Bf, function(t2) {
    return Nc(hp, this);
  });
}
Ef($f, "Symbol"), Fs[Df] = true, xf("asyncIterator"), xf("hasInstance"), xf("isConcatSpreadable"), xf("iterator"), xf("match"), xf("matchAll"), xf("replace"), xf("search"), xf("species"), xf("split"), xf("toPrimitive"), xf("toStringTag"), xf("unscopables"), Ef(vc.JSON, "JSON", true);
var vp, gp, yp, mp = Gc.Symbol, bp = {}, xp = Function.prototype, wp = Oc && Object.getOwnPropertyDescriptor, Sp = gl(xp, "name"), kp = { EXISTS: Sp, PROPER: Sp && "something" === function() {
}.name, CONFIGURABLE: Sp && (!Oc || Oc && wp(xp, "name").configurable) }, Ep = !Hc(function() {
  function t2() {
  }
  return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
}), Tp = Js("IE_PROTO"), Mp = vc.Object, Hp = Mp.prototype, Op = Ep ? Mp.getPrototypeOf : function(t2) {
  var e3 = hl(t2);
  if (gl(e3, Tp))
    return e3[Tp];
  var n2 = e3.constructor;
  return Mc(n2) && e3 instanceof n2 ? n2.prototype : e3 instanceof Mp ? Hp : null;
}, Ip = Tl("iterator"), Np = false;
[].keys && ("next" in (yp = [].keys()) ? (gp = Op(Op(yp))) !== Object.prototype && (vp = gp) : Np = true);
var Lp = null == vp || Hc(function() {
  var t2 = {};
  return vp[Ip].call(t2) !== t2;
});
vp = Lp ? {} : uf(vp), Mc(vp[Ip]) || yf(vp, Ip, function() {
  return this;
});
var zp = { IteratorPrototype: vp, BUGGY_SAFARI_ITERATORS: Np }, jp = zp.IteratorPrototype, Ap = function() {
  return this;
};
vc.String, vc.TypeError;
Object.setPrototypeOf || "__proto__" in {} && function() {
  var t2, e3 = false, n2 = {};
  try {
    (t2 = Tc(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n2, []), e3 = n2 instanceof Array;
  } catch (t3) {
  }
}();
var Pp = kp.PROPER, Vp = zp.BUGGY_SAFARI_ITERATORS, Cp = Tl("iterator"), Dp = function() {
  return this;
}, Bp = function(t2, e3, n2, r2, o2, i2, u2) {
  !function(t3, e4, n3, r3) {
    var o3 = e4 + " Iterator";
    t3.prototype = uf(jp, { next: Pc(+!r3, n3) }), Ef(t3, o3, false, true), bp[o3] = Ap;
  }(n2, e3, r2);
  var a2, c2, l2, s2 = function(t3) {
    if (t3 === o2 && v2)
      return v2;
    if (!Vp && t3 in d3)
      return d3[t3];
    switch (t3) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, t3);
        };
    }
    return function() {
      return new n2(this);
    };
  }, f2 = e3 + " Iterator", p2 = false, d3 = t2.prototype, h2 = d3[Cp] || d3["@@iterator"] || o2 && d3[o2], v2 = !Vp && h2 || s2(o2), g2 = "Array" == e3 && d3.entries || h2;
  if (g2 && (a2 = Op(g2.call(new t2()))) !== Object.prototype && a2.next && (Ef(a2, f2, true, true), bp[f2] = Dp), Pp && "values" == o2 && h2 && "values" !== h2.name && (p2 = true, v2 = function() {
    return Nc(h2, this);
  }), o2)
    if (c2 = { values: s2("values"), keys: i2 ? v2 : s2("keys"), entries: s2("entries") }, u2)
      for (l2 in c2)
        (Vp || p2 || !(l2 in d3)) && yf(d3, l2, c2[l2]);
    else
      ts({ target: e3, proto: true, forced: Vp || p2 }, c2);
  return u2 && d3[Cp] !== v2 && yf(d3, Cp, v2, { name: o2 }), bp[e3] = v2, c2;
}, Rp = Af.set, Fp = Af.getterFor("Array Iterator");
Bp(Array, "Array", function(t2, e3) {
  Rp(this, { type: "Array Iterator", target: qc(t2), index: 0, kind: e3 });
}, function() {
  var t2 = Fp(this), e3 = t2.target, n2 = t2.kind, r2 = t2.index++;
  return !e3 || r2 >= e3.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e3[r2], done: false } : { value: [r2, e3[r2]], done: false };
}, "values"), bp.Arguments = bp.Array;
var _p = Tl("toStringTag");
for (var $p in { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }) {
  var qp = vc[$p], Wp = qp && qp.prototype;
  Wp && ds(Wp) !== _p && Kl(Wp, _p, $p), bp[$p] = bp.Array;
}
var Gp = mp;
xf("asyncDispose"), xf("dispose"), xf("matcher"), xf("metadata"), xf("observable"), xf("patternMatch"), xf("replaceAll");
var Up = Gp, Xp = Tc("".charAt), Yp = Tc("".charCodeAt), Jp = Tc("".slice), Kp = function(t2) {
  return function(e3, n2) {
    var r2, o2, i2 = Ps($c(e3)), u2 = os(n2), a2 = i2.length;
    return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = Yp(i2, u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = Yp(i2, u2 + 1)) < 56320 || o2 > 57343 ? t2 ? Xp(i2, u2) : r2 : t2 ? Jp(i2, u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Qp = { codeAt: Kp(false), charAt: Kp(true) }.charAt, Zp = Af.set, td = Af.getterFor("String Iterator");
Bp(String, "String", function(t2) {
  Zp(this, { type: "String Iterator", string: Ps(t2), index: 0 });
}, function() {
  var t2, e3 = td(this), n2 = e3.string, r2 = e3.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (t2 = Qp(n2, r2), e3.index += t2.length, { value: t2, done: false });
});
var ed = mf.f("iterator"), nd = G$5(function(t2) {
  function e3(n2) {
    return "function" == typeof Up && "symbol" == typeof ed ? (t2.exports = e3 = function(t3) {
      return typeof t3;
    }, t2.exports.default = t2.exports, t2.exports.__esModule = true) : (t2.exports = e3 = function(t3) {
      return t3 && "function" == typeof Up && t3.constructor === Up && t3 !== Up.prototype ? "symbol" : typeof t3;
    }, t2.exports.default = t2.exports, t2.exports.__esModule = true), e3(n2);
  }
  t2.exports = e3, t2.exports.default = t2.exports, t2.exports.__esModule = true;
}), rd = W$5(nd), od = _e$5.EXISTS, id = be$5.f, ud = Function.prototype, ad = st$5(ud.toString), cd = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, ld = st$5(cd.exec);
Q$5 && !od && id(ud, "name", { configurable: true, get: function() {
  try {
    return ld(cd, ad(this))[1];
  } catch (t2) {
    return "";
  }
} });
var sd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("fontFamily.title"), e4.iconSvg = Ti$2, e4.mark = "fontFamily", e4.selectPanelWidth = 150, e4;
  }
  return $o$3(e3, t2), e3.prototype.getOptions = function(t3) {
    var e4 = [], r2 = t3.getMenuConfig(this.mark).fontFamilyList, o2 = void 0 === r2 ? [] : r2;
    e4.push({ text: lp$1("fontFamily.default"), value: "" }), o2.forEach(function(t4) {
      if ("string" == typeof t4)
        e4.push({ text: t4, value: t4, styleForRenderMenuList: { "font-family": t4 } });
      else if ("object" === rd(t4)) {
        var n2 = t4.name, r3 = t4.value;
        e4.push({ text: n2, value: r3, styleForRenderMenuList: { "font-family": r3 } });
      }
    });
    var i2 = this.getValue(t3);
    return e4.forEach(function(t4) {
      t4.value === i2 ? t4.selected = true : delete t4.selected;
    }), e4;
  }, e3;
}(pc);
var fd = { renderStyle: function(t2, e3) {
  var n2 = t2, r2 = n2.fontSize, o2 = n2.fontFamily, i2 = e3;
  return r2 && Au$2(i2, { fontSize: r2 }), o2 && Au$2(i2, { fontFamily: o2 }), i2;
}, styleToHtml: function(t2, e3) {
  if (!Text.isText(t2))
    return e3;
  var n2, r2 = t2, o2 = r2.fontSize, i2 = r2.fontFamily;
  return o2 || i2 ? ((Co$3(e3) || "span" !== Bo$3(n2 = $$6(e3))) && (n2 = $$6("<span>" + e3 + "</span>")), o2 && n2.css("font-size", o2), i2 && n2.css("font-family", i2), Do$3(n2)) : e3;
}, preParseHtml: [cc], parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Text.isText(e3))
    return e3;
  var o2 = e3, i2 = n2.getMenuConfig("fontSize").fontSizeList, u2 = void 0 === i2 ? [] : i2, c2 = Ro$3(r2, "font-size");
  c2 && u2.includes(c2) && (o2.fontSize = c2);
  var l2 = n2.getMenuConfig("fontFamily").fontFamilyList, s2 = void 0 === l2 ? [] : l2, f2 = Ro$3(r2, "font-family"), p2 = s2.find(function(t3) {
    return t3.value && t3.value === f2;
  }) || s2.includes(f2);
  return f2 && p2 && (o2.fontFamily = f2), o2;
}, menus: [{ key: "fontSize", factory: function() {
  return new dc();
}, config: { fontSizeList: ["12px", "13px", "14px", "15px", "16px", "19px", "22px", "24px", "29px", "32px", "40px", "48px"] } }, { key: "fontFamily", factory: function() {
  return new sd();
}, config: { fontFamilyList: ["\u9ED1\u4F53", { name: "\u4EFF\u5B8B", value: "\u4EFF\u5B8B" }, "\u6977\u4F53", "\u6807\u6977\u4F53", "\u534E\u6587\u4EFF\u5B8B", "\u534E\u6587\u6977\u4F53", { name: "\u5B8B\u4F53", value: "\u5B8B\u4F53" }, "\u5FAE\u8F6F\u96C5\u9ED1", "Arial", "Tahoma", "Verdana", "Times New Roman", "Courier New"] } }] };
var pd = { selector: "p,h1,h2,h3,h4,h5", preParseHtml: function(t2) {
  var e3 = $$6(t2), n2 = Ro$3(e3, "padding-left");
  return /\dem/.test(n2) && e3.css("text-indent", "2em"), /\dpx/.test(n2) && parseInt(n2, 10) % 32 == 0 && e3.css("text-indent", "2em"), e3[0];
} };
var dd = function() {
  function t2() {
    this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    var e3 = Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      return !!t4.indent;
    }, universal: true }), 1), n2 = e3[0];
    return null == n2 ? "" : Xo$3(n2, 1)[0].indent || "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getMatchNode = function(t3) {
    var n2 = Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      var n3 = rl$1.getNodeType(t4);
      return "paragraph" === n3 || !!n3.startsWith("header");
    }, universal: true, mode: "highest" }), 1)[0];
    return null == n2 ? null : n2[0];
  }, t2;
}(), hd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("indent.decrease"), e4.iconSvg = Mi$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.isDisabled = function(t3) {
    var e4 = this.getMatchNode(t3);
    return null == e4 || !e4.indent;
  }, e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { indent: null }, { match: function(t4) {
      return Element$1.isElement(t4);
    } });
  }, e3;
}(dd), vd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("indent.increase"), e4.iconSvg = Hi$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.isDisabled = function(t3) {
    var e4 = this.getMatchNode(t3);
    return null == e4 || !!e4.indent;
  }, e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { indent: "2em" }, { match: function(t4) {
      return Element$1.isElement(t4);
    }, mode: "highest" });
  }, e3;
}(dd), gd = { renderStyle: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.indent, r2 = e3;
  return n2 && Au$2(r2, { textIndent: n2 }), r2;
}, styleToHtml: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.indent;
  if (!n2)
    return e3;
  var r2 = $$6(e3);
  return r2.css("text-indent", n2), Do$3(r2);
}, preParseHtml: [pd], parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Element$1.isElement(e3))
    return e3;
  var o2 = e3, i2 = Ro$3(r2, "text-indent"), u2 = parseInt(i2, 10);
  return i2 && u2 > 0 && (o2.indent = i2), o2;
}, menus: [{ key: "indent", factory: function() {
  return new vd();
} }, { key: "delIndent", factory: function() {
  return new hd();
} }] };
var yd = function() {
  function t2() {
    this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getMatchNode = function(t3) {
    var n2 = Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      var n3 = rl$1.getNodeType(t4);
      return "paragraph" === n3 || ("blockquote" === n3 || !!n3.startsWith("header"));
    }, universal: true, mode: "highest" }), 1)[0];
    return null == n2 ? null : n2[0];
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!rl$1.getSelectedElems(t3).some(function(e3) {
      if (Editor$1.isVoid(t3, e3) && Editor$1.isBlock(t3, e3))
        return true;
      var n2 = e3.type;
      return !!["pre", "code"].includes(n2) || void 0;
    });
  }, t2;
}(), md = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("justify.left"), e4.iconSvg = Oi$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { textAlign: "left" }, { match: function(e5) {
      return Element$1.isElement(e5) && !t3.isInline(e5);
    } });
  }, e3;
}(yd), bd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("justify.right"), e4.iconSvg = Ii$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { textAlign: "right" }, { match: function(e5) {
      return Element$1.isElement(e5) && !t3.isInline(e5);
    } });
  }, e3;
}(yd), xd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("justify.center"), e4.iconSvg = Ni$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { textAlign: "center" }, { match: function(e5) {
      return Element$1.isElement(e5) && !t3.isInline(e5);
    } });
  }, e3;
}(yd), wd = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.title = lp$1("justify.justify"), e4.iconSvg = Li$2, e4;
  }
  return $o$3(e3, t2), e3.prototype.exec = function(t3, e4) {
    Transforms.setNodes(t3, { textAlign: "justify" }, { match: function(e5) {
      return Element$1.isElement(e5) && !t3.isInline(e5);
    } });
  }, e3;
}(yd), Sd = { renderStyle: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.textAlign, r2 = e3;
  return n2 && Au$2(r2, { textAlign: n2 }), r2;
}, styleToHtml: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.textAlign;
  if (!n2)
    return e3;
  var r2 = $$6(e3);
  return r2.css("text-align", n2), Do$3(r2);
}, parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Element$1.isElement(e3))
    return e3;
  var o2 = e3, i2 = Ro$3(r2, "text-align");
  return i2 && (o2.textAlign = i2), o2;
}, menus: [{ key: "justifyLeft", factory: function() {
  return new md();
} }, { key: "justifyRight", factory: function() {
  return new bd();
} }, { key: "justifyCenter", factory: function() {
  return new xd();
} }, { key: "justifyJustify", factory: function() {
  return new wd();
} }] };
var kd = function() {
  function t2() {
    this.title = lp$1("lineHeight.title"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M964 788a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526zM198.93 144.306c6.668-5.798 16.774-5.094 22.573 1.574l122.26 140.582a16 16 0 0 1 3.927 10.5c0 8.836-7.164 16-16 16h-61.8a8 8 0 0 0-8 8v390.077h69.819a16 16 0 0 1 10.502 3.928c6.666 5.8 7.37 15.906 1.57 22.573L221.476 878.123a16 16 0 0 1-1.57 1.57c-6.668 5.8-16.774 5.097-22.574-1.57L75.051 737.538a16 16 0 0 1-3.928-10.5c0-8.837 7.163-16 16-16h69.822V312.96H87.127a16 16 0 0 1-10.502-3.928c-6.666-5.8-7.37-15.906-1.57-22.573l122.303-140.582a16 16 0 0 1 1.572-1.572zM964 465a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z m0-323a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z"></path></svg>', this.tag = "select", this.width = 80;
  }
  return t2.prototype.getOptions = function(t3) {
    var e3 = [], r2 = t3.getMenuConfig("lineHeight").lineHeightList, o2 = void 0 === r2 ? [] : r2;
    e3.push({ text: lp$1("lineHeight.default"), value: "" }), o2.forEach(function(t4) {
      e3.push({ text: t4, value: t4 });
    });
    var i2 = this.getValue(t3);
    return e3.forEach(function(t4) {
      t4.value === i2 ? t4.selected = true : delete t4.selected;
    }), e3;
  }, t2.prototype.getMatchNode = function(t3) {
    var n2 = Xo$3(Editor$1.nodes(t3, { match: function(t4) {
      var n3 = rl$1.getNodeType(t4);
      return !!n3.startsWith("header") || !!["paragraph", "blockquote", "bulleted-list", "numbered-list"].includes(n3);
    }, universal: true, mode: "highest" }), 1)[0];
    return null == n2 ? null : n2[0];
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.getMatchNode(t3);
    return null == e3 ? "" : Element$1.isElement(e3) && e3.lineHeight || "";
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == this.getMatchNode(t3);
  }, t2.prototype.exec = function(t3, e3) {
    Transforms.setNodes(t3, { lineHeight: e3.toString() }, { mode: "highest" });
  }, t2;
}();
var Ed = { renderStyle: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.lineHeight, r2 = e3;
  return n2 && Au$2(r2, { lineHeight: n2 }), r2;
}, styleToHtml: function(t2, e3) {
  if (!Element$1.isElement(t2))
    return e3;
  var n2 = t2.lineHeight;
  if (!n2)
    return e3;
  var r2 = $$6(e3);
  return r2.css("line-height", n2), Do$3(r2);
}, parseStyleHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  if (!Element$1.isElement(e3))
    return e3;
  var o2 = e3, i2 = n2.getMenuConfig("lineHeight").lineHeightList, u2 = void 0 === i2 ? [] : i2, a2 = Ro$3(r2, "line-height");
  return a2 && u2.includes(a2) && (o2.lineHeight = a2), o2;
}, menus: [{ key: "lineHeight", factory: function() {
  return new kd();
}, config: { lineHeightList: ["1", "1.15", "1.5", "2", "2.5", "3"] } }] }, Td = function() {
  function t2() {
    this.title = lp$1("undo.redo"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0.00032 576a510.72 510.72 0 0 0 173.344 384l84.672-96A383.136 383.136 0 0 1 128.00032 576C128.00032 363.936 299.93632 192 512.00032 192c106.048 0 202.048 42.976 271.52 112.48L640.00032 448h384V64l-149.984 149.984A510.272 510.272 0 0 0 512.00032 64C229.21632 64 0.00032 293.216 0.00032 576z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection;
  }, t2.prototype.exec = function(t3, e3) {
    "function" == typeof t3.redo && t3.redo();
  }, t2;
}(), Md = function() {
  function t2() {
    this.title = lp$1("undo.undo"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M512 64A510.272 510.272 0 0 0 149.984 213.984L0.032 64v384h384L240.512 304.48A382.784 382.784 0 0 1 512.032 192c212.064 0 384 171.936 384 384 0 114.688-50.304 217.632-130.016 288l84.672 96a510.72 510.72 0 0 0 173.344-384c0-282.784-229.216-512-512-512z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection;
  }, t2.prototype.exec = function(t3, e3) {
    "function" == typeof t3.undo && t3.undo();
  }, t2;
}(), Hd = { menus: [{ key: "redo", factory: function() {
  return new Td();
} }, { key: "undo", factory: function() {
  return new Md();
} }] };
var Od = { type: "divider", renderElem: function(t2, n2, r2) {
  var o2 = rl$1.isNodeSelected(r2, t2);
  return h$3("div", { props: { contentEditable: false, className: "w-e-textarea-divider" }, dataset: { selected: o2 ? "true" : "" }, style: {}, on: { mousedown: function(t3) {
    return t3.preventDefault();
  } } }, [h$3("hr")]);
} };
var Id = { type: "divider", elemToHtml: function(t2, e3) {
  return "<hr/>";
} };
var Nd = { selector: "hr", parseElemHtml: function(t2, e3, n2) {
  return { type: "divider", children: [{ text: "" }] };
} }, Ld = function() {
  function t2() {
    this.title = lp$1("divider.title"), this.iconSvg = '<svg viewBox="0 0 1092 1024"><path d="M0 51.2m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M819.2 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M409.6 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 870.4m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!rl$1.getSelectedElems(t3).some(function(n2) {
      if (t3.isVoid(n2))
        return true;
      var r2 = rl$1.getNodeType(n2);
      return "table" === r2 || ("pre" === r2 || void 0);
    });
  }, t2.prototype.exec = function(t3, e3) {
    Transforms.insertNodes(t3, { type: "divider", children: [{ text: "" }] }, { mode: "highest" });
  }, t2;
}(), zd = { renderElems: [Od], elemsToHtml: [Id], parseElemsHtml: [Nd], menus: [{ key: "divider", factory: function() {
  return new Ld();
} }], editorPlugin: function(t2) {
  var n2 = t2.isVoid, r2 = t2.normalizeNode, o2 = t2;
  return o2.isVoid = function(t3) {
    return "divider" === t3.type || n2(t3);
  }, o2.normalizeNode = function(t3) {
    var n3 = Xo$3(t3, 2), i2 = n3[0], u2 = n3[1];
    if ("divider" !== rl$1.getNodeType(i2))
      return r2([i2, u2]);
    rl$1.isLastNode(o2, i2) && Transforms.insertNodes(o2, rl$1.genEmptyParagraph(), { at: [u2[0] + 1] });
  }, o2;
} }, jd = _n$5.map;
xn$5({ target: "Array", proto: true, forced: !qn$5("map") }, { map: function(t2) {
  return jd(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
var Ad = st$5([].join), Pd = gt$5 != Object, Vd = ai$3("join", ",");
xn$5({ target: "Array", proto: true, forced: Pd || !Vd }, { join: function(t2) {
  return Ad(bt$5(this), void 0 === t2 ? "," : t2);
} });
var Cd = function() {
  function t2() {
    this.title = lp$1("codeBlock.title"), this.iconSvg = '<svg viewBox="0 0 1280 1024"><path d="M832 736l96 96 320-320L928 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224zM701.312 150.528l69.472 18.944-192 704.032-69.472-18.944 192-704.032z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getSelectCodeElem = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "code");
    if (null == n2)
      return null;
    var r2 = rl$1.getParentNode(t3, n2);
    return null == r2 || "pre" !== rl$1.getNodeType(r2) ? null : n2;
  }, t2.prototype.getValue = function(t3) {
    var e3 = this.getSelectCodeElem(t3);
    return null == e3 ? "" : e3.language || "";
  }, t2.prototype.isActive = function(t3) {
    return !!this.getSelectCodeElem(t3);
  }, t2.prototype.isDisabled = function(t3) {
    if (null == t3.selection)
      return true;
    var n2 = rl$1.getSelectedElems(t3);
    return !!n2.some(function(e3) {
      return t3.isVoid(e3);
    }) || !n2.some(function(t4) {
      var n3 = rl$1.getNodeType(t4);
      if ("pre" === n3 || "paragraph" === n3)
        return true;
    });
  }, t2.prototype.exec = function(t3, e3) {
    this.isActive(t3) ? this.changeToPlainText(t3) : this.changeToCodeBlock(t3, e3.toString());
  }, t2.prototype.changeToPlainText = function(t3) {
    var e3 = this.getSelectCodeElem(t3);
    if (null != e3) {
      var n2 = Node$1.string(e3);
      Transforms.removeNodes(t3, { mode: "highest" });
      var r2 = n2.split("\n").map(function(t4) {
        return { type: "paragraph", children: [{ text: t4 }] };
      });
      Transforms.insertNodes(t3, r2, { mode: "highest" });
    }
  }, t2.prototype.changeToCodeBlock = function(t3, e3) {
    var n2, r2, o2 = [], i2 = Editor$1.nodes(t3, { match: function(e4) {
      return t3.children.includes(e4);
    }, universal: true });
    try {
      for (var u2 = Uo$3(i2), a2 = u2.next(); !a2.done; a2 = u2.next()) {
        var l2 = Xo$3(a2.value, 1)[0];
        l2 && o2.push(Node$1.string(l2));
      }
    } catch (t4) {
      n2 = { error: t4 };
    } finally {
      try {
        a2 && !a2.done && (r2 = u2.return) && r2.call(u2);
      } finally {
        if (n2)
          throw n2.error;
      }
    }
    Transforms.removeNodes(t3, { mode: "highest" });
    var p2 = { type: "pre", children: [{ type: "code", language: e3, children: [{ text: o2.join("\n") }] }] };
    Transforms.insertNodes(t3, p2, { mode: "highest" });
  }, t2;
}(), Dd = { key: "codeBlock", factory: function() {
  return new Cd();
} };
xn$5({ target: "String", proto: true, forced: ti$3("anchor") }, { anchor: function(t2) {
  return Zo$3(this, "a", "name", t2);
} }), Pr$4("match", function(t2, e3, n2) {
  return [function(e4) {
    var n3 = mt$5(this), r2 = null == e4 ? void 0 : Bt$5(e4, t2);
    return r2 ? tt$5(r2, e4, n3) : new RegExp(e4)[t2](Yn$5(n3));
  }, function(t3) {
    var r2 = ge$5(this), o2 = Yn$5(t3), i2 = n2(e3, r2, o2);
    if (i2.done)
      return i2.value;
    if (!r2.global)
      return Jr$4(r2, o2);
    var u2 = r2.unicode;
    r2.lastIndex = 0;
    for (var a2, c2 = [], l2 = 0; null !== (a2 = Jr$4(r2, o2)); ) {
      var s2 = Yn$5(a2[0]);
      c2[l2] = s2, "" === s2 && (r2.lastIndex = Fr$4(o2, Ke$5(r2.lastIndex), u2)), l2++;
    }
    return 0 === l2 ? null : c2;
  }];
});
var Bd = { type: "pre", renderElem: function(t2, e3, n2) {
  return jsx("pre", null, e3);
} }, Rd = { type: "code", renderElem: function(t2, e3, n2) {
  return jsx("code", null, e3);
} };
var Fd = { selector: "pre", parseElemHtml: function(t2, n2, r2) {
  var o2 = $$6(t2);
  return 0 === (n2 = n2.filter(function(t3) {
    return "code" === rl$1.getNodeType(t3);
  })).length && (n2 = [{ type: "code", language: "", children: [{ text: o2[0].textContent || "" }] }]), { type: "pre", children: n2.filter(function(t3) {
    return "code" === rl$1.getNodeType(t3);
  }) };
} };
var _d = { menus: [Dd], editorPlugin: function(t2) {
  var n2 = t2.insertBreak, r2 = t2.normalizeNode, o2 = t2.insertData;
  t2.insertNode;
  var i2 = t2;
  return i2.insertBreak = function() {
    var t3 = rl$1.getSelectedNodeByType(i2, "code");
    if (null != t3) {
      var r3 = function(t4, e3) {
        var n3 = e3.selection;
        if (null == n3)
          return "";
        var r4 = Node$1.string(t4), o4 = n3.anchor.offset, i3 = r4.slice(0, o4).split("\n"), u3 = i3.length;
        return 0 === u3 ? "" : i3[u3 - 1];
      }(t3, i2);
      if (r3) {
        var o3 = r3.match(/^\s+/);
        if (null != o3 && null != o3[0]) {
          var u2 = o3[0];
          return void i2.insertText("\n" + u2);
        }
      }
      i2.insertText("\n");
    } else
      n2();
  }, i2.normalizeNode = function(t3) {
    var n3 = Xo$3(t3, 2), o3 = n3[0], u2 = n3[1], a2 = rl$1.getNodeType(o3);
    ("code" === a2 && u2.length <= 1 && Transforms.setNodes(i2, { type: "paragraph" }, { at: u2 }), "pre" === a2) && (rl$1.isLastNode(i2, o3) && Transforms.insertNodes(i2, rl$1.genEmptyParagraph(), { at: [u2[0] + 1] }), "code" !== rl$1.getNodeType(o3.children[0]) && (Transforms.unwrapNodes(i2), Transforms.setNodes(i2, { type: "paragraph" }, { mode: "highest" })));
    return r2([o3, u2]);
  }, i2.insertData = function(t3) {
    if (null != rl$1.getSelectedNodeByType(i2, "code")) {
      var n3 = t3.getData("text/plain");
      Editor$1.insertText(i2, n3);
    } else
      o2(t3);
  }, i2;
}, renderElems: [Bd, Rd], elemsToHtml: [{ type: "code", elemToHtml: function(t2, e3) {
  return "<code>" + e3 + "</code>";
} }, { type: "pre", elemToHtml: function(t2, e3) {
  return "<pre>" + e3 + "</pre>";
} }], preParseHtml: [{ selector: "pre>code", preParseHtml: function(t2) {
  var e3 = $$6(t2);
  if ("code" !== Bo$3(e3))
    return t2;
  var n2 = e3.find("xmp");
  if (0 === n2.length)
    return t2;
  var r2 = n2.text();
  return n2.remove(), e3.text(r2), e3[0];
} }], parseElemsHtml: [{ selector: "pre>code", parseElemHtml: function(t2, e3, n2) {
  return { type: "code", language: "", children: [{ text: $$6(t2)[0].textContent || "" }] };
} }, Fd] }, $d = function() {
  function t2() {
    this.title = lp$1("fullScreen.title"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M133.705143 335.433143V133.851429h201.581714a29.622857 29.622857 0 0 0 29.622857-29.549715V68.754286a29.622857 29.622857 0 0 0-29.622857-29.622857H61.732571A22.893714 22.893714 0 0 0 38.765714 62.025143V335.725714c0 16.310857 13.238857 29.622857 29.622857 29.622857h35.547429a29.842286 29.842286 0 0 0 29.696-29.842285zM690.980571 133.851429h201.581715v201.654857c0 16.310857 13.238857 29.549714 29.622857 29.549714h35.547428a29.622857 29.622857 0 0 0 29.549715-29.549714V61.952a22.893714 22.893714 0 0 0-22.820572-22.893714h-273.554285a29.622857 29.622857 0 0 0-29.549715 29.622857v35.547428c0 16.310857 13.238857 29.696 29.622857 29.696zM335.286857 892.781714H133.705143V691.2a29.622857 29.622857 0 0 0-29.622857-29.622857H68.534857a29.622857 29.622857 0 0 0-29.549714 29.622857v273.554286c0 12.653714 10.24 22.893714 22.820571 22.893714h273.554286a29.622857 29.622857 0 0 0 29.696-29.622857v-35.547429a29.769143 29.769143 0 0 0-29.769143-29.696z m557.348572-201.581714v201.581714H690.907429a29.622857 29.622857 0 0 0-29.622858 29.622857v35.547429c0 16.310857 13.238857 29.622857 29.622858 29.622857h273.554285c12.580571 0 22.893714-10.313143 22.893715-22.893714V691.2a29.622857 29.622857 0 0 0-29.622858-29.622857h-35.547428a29.622857 29.622857 0 0 0-29.696 29.622857z"></path></svg>', this.tag = "button", this.alwaysEnable = true;
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return t3.isFullScreen;
  }, t2.prototype.isDisabled = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
    t3.isFullScreen ? t3.unFullScreen() : t3.fullScreen();
  }, t2;
}(), qd = { menus: [{ key: "fullScreen", factory: function() {
  return new $d();
} }] }, Wd = function() {
  function t2() {
    this.title = lp$1("common.enter"), this.iconSvg = '<svg viewBox="0 0 1255 1024"><path d="M1095.111111 731.477333h-625.777778V1024L0 658.318222 469.333333 292.408889v292.636444h625.777778V0h156.444445v731.477333z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    var e3 = t3.selection;
    return null == e3 || !!Range.isExpanded(e3);
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = t3.selection;
    if (null != n2) {
      var r2 = [n2.anchor.path[0]];
      Transforms.insertNodes(t3, { type: "paragraph", children: [{ text: "" }] }, { at: r2 }), t3.select(Editor$1.start(t3, r2));
    }
  }, t2;
}(), Gd = [_i$2, Ru$2, fd, gd, Sd, Ed, $a$2, zd, uc, la$3, _d, oc, Iu$2, Jo$3, Ua$2, Hd, qd, { menus: [{ key: "enter", factory: function() {
  return new Wd();
} }] }];
ip$1("en", { listModule: { unOrderedList: "Unordered list", orderedList: "Ordered list" } }), ip$1("zh-CN", { listModule: { unOrderedList: "\u65E0\u5E8F\u5217\u8868", orderedList: "\u6709\u5E8F\u5217\u8868" } });
var f$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function s(t2) {
  var e3 = { exports: {} };
  return t2(e3, e3.exports), e3.exports;
}
var p$2, d$2, v$2 = function(t2) {
  return t2 && t2.Math == Math && t2;
}, y$2 = v$2("object" == typeof globalThis && globalThis) || v$2("object" == typeof window && window) || v$2("object" == typeof self && self) || v$2("object" == typeof f$1 && f$1) || function() {
  return this;
}() || Function("return this")(), h$2 = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, g$2 = !h$2(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), m$2 = Function.prototype.call, b$2 = m$2.bind ? m$2.bind(m$2) : function() {
  return m$2.apply(m$2, arguments);
}, x$3 = {}.propertyIsEnumerable, w$2 = Object.getOwnPropertyDescriptor, O$4 = { f: w$2 && !x$3.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = w$2(this, t2);
  return !!e3 && e3.enumerable;
} : x$3 }, S$3 = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, E$3 = Function.prototype, j$4 = E$3.bind, T$3 = E$3.call, I$4 = j$4 && j$4.bind(T$3), A$4 = j$4 ? function(t2) {
  return t2 && I$4(T$3, t2);
} : function(t2) {
  return t2 && function() {
    return T$3.apply(t2, arguments);
  };
}, N$3 = A$4({}.toString), P$4 = A$4("".slice), M$3 = function(t2) {
  return P$4(N$3(t2), 8, -1);
}, R$4 = y$2.Object, _$4 = A$4("".split), k$4 = h$2(function() {
  return !R$4("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == M$3(t2) ? _$4(t2, "") : R$4(t2);
} : R$4, H$4 = y$2.TypeError, z$4 = function(t2) {
  if (null == t2)
    throw H$4("Can't call method on " + t2);
  return t2;
}, L$4 = function(t2) {
  return k$4(z$4(t2));
}, C$4 = function(t2) {
  return "function" == typeof t2;
}, F$4 = function(t2) {
  return "object" == typeof t2 ? null !== t2 : C$4(t2);
}, $$4 = function(t2) {
  return C$4(t2) ? t2 : void 0;
}, B$4 = function(t2, e3) {
  return arguments.length < 2 ? $$4(y$2[t2]) : y$2[t2] && y$2[t2][e3];
}, D$4 = A$4({}.isPrototypeOf), V$4 = B$4("navigator", "userAgent") || "", G$4 = y$2.process, U$4 = y$2.Deno, K$4 = G$4 && G$4.versions || U$4 && U$4.version, W$4 = K$4 && K$4.v8;
W$4 && (d$2 = (p$2 = W$4.split("."))[0] > 0 && p$2[0] < 4 ? 1 : +(p$2[0] + p$2[1])), !d$2 && V$4 && (!(p$2 = V$4.match(/Edge\/(\d+)/)) || p$2[1] >= 74) && (p$2 = V$4.match(/Chrome\/(\d+)/)) && (d$2 = +p$2[1]);
var Y$4 = d$2, q$4 = !!Object.getOwnPropertySymbols && !h$2(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && Y$4 && Y$4 < 41;
}), X$4 = q$4 && !Symbol.sham && "symbol" == typeof Symbol.iterator, J$4 = y$2.Object, Q$4 = X$4 ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = B$4("Symbol");
  return C$4(e3) && D$4(e3.prototype, J$4(t2));
}, Z$4 = y$2.String, tt$4 = y$2.TypeError, et$4 = function(t2) {
  if (C$4(t2))
    return t2;
  throw tt$4(function(t3) {
    try {
      return Z$4(t3);
    } catch (t4) {
      return "Object";
    }
  }(t2) + " is not a function");
}, rt$4 = function(t2, e3) {
  var r2 = t2[e3];
  return null == r2 ? void 0 : et$4(r2);
}, nt$4 = y$2.TypeError, ot$4 = Object.defineProperty, it$4 = function(t2, e3) {
  try {
    ot$4(y$2, t2, { value: e3, configurable: true, writable: true });
  } catch (r2) {
    y$2[t2] = e3;
  }
  return e3;
}, ut$4 = y$2["__core-js_shared__"] || it$4("__core-js_shared__", {}), ct$4 = s(function(t2) {
  (t2.exports = function(t3, e3) {
    return ut$4[t3] || (ut$4[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), at$4 = y$2.Object, lt$4 = function(t2) {
  return at$4(z$4(t2));
}, ft$4 = A$4({}.hasOwnProperty), st$4 = Object.hasOwn || function(t2, e3) {
  return ft$4(lt$4(t2), e3);
}, pt$4 = 0, dt$4 = Math.random(), vt$4 = A$4(1 .toString), yt$4 = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + vt$4(++pt$4 + dt$4, 36);
}, ht$4 = ct$4("wks"), gt$4 = y$2.Symbol, mt$4 = gt$4 && gt$4.for, bt$4 = X$4 ? gt$4 : gt$4 && gt$4.withoutSetter || yt$4, xt$4 = function(t2) {
  if (!st$4(ht$4, t2) || !q$4 && "string" != typeof ht$4[t2]) {
    var e3 = "Symbol." + t2;
    q$4 && st$4(gt$4, t2) ? ht$4[t2] = gt$4[t2] : ht$4[t2] = X$4 && mt$4 ? mt$4(e3) : bt$4(e3);
  }
  return ht$4[t2];
}, wt$4 = y$2.TypeError, Ot$4 = xt$4("toPrimitive"), St$4 = function(t2, e3) {
  if (!F$4(t2) || Q$4(t2))
    return t2;
  var r2, n2 = rt$4(t2, Ot$4);
  if (n2) {
    if (void 0 === e3 && (e3 = "default"), r2 = b$2(n2, t2, e3), !F$4(r2) || Q$4(r2))
      return r2;
    throw wt$4("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var r3, n3;
    if ("string" === e4 && C$4(r3 = t3.toString) && !F$4(n3 = b$2(r3, t3)))
      return n3;
    if (C$4(r3 = t3.valueOf) && !F$4(n3 = b$2(r3, t3)))
      return n3;
    if ("string" !== e4 && C$4(r3 = t3.toString) && !F$4(n3 = b$2(r3, t3)))
      return n3;
    throw nt$4("Can't convert object to primitive value");
  }(t2, e3);
}, Et$4 = function(t2) {
  var e3 = St$4(t2, "string");
  return Q$4(e3) ? e3 : e3 + "";
}, jt$4 = y$2.document, Tt$4 = F$4(jt$4) && F$4(jt$4.createElement), It$4 = function(t2) {
  return Tt$4 ? jt$4.createElement(t2) : {};
}, At$4 = !g$2 && !h$2(function() {
  return 7 != Object.defineProperty(It$4("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Nt$4 = Object.getOwnPropertyDescriptor, Pt$4 = { f: g$2 ? Nt$4 : function(t2, e3) {
  if (t2 = L$4(t2), e3 = Et$4(e3), At$4)
    try {
      return Nt$4(t2, e3);
    } catch (t3) {
    }
  if (st$4(t2, e3))
    return S$3(!b$2(O$4.f, t2, e3), t2[e3]);
} }, Mt$4 = y$2.String, Rt$4 = y$2.TypeError, _t$4 = function(t2) {
  if (F$4(t2))
    return t2;
  throw Rt$4(Mt$4(t2) + " is not an object");
}, kt$4 = y$2.TypeError, Ht$4 = Object.defineProperty, zt$4 = { f: g$2 ? Ht$4 : function(t2, e3, r2) {
  if (_t$4(t2), e3 = Et$4(e3), _t$4(r2), At$4)
    try {
      return Ht$4(t2, e3, r2);
    } catch (t3) {
    }
  if ("get" in r2 || "set" in r2)
    throw kt$4("Accessors not supported");
  return "value" in r2 && (t2[e3] = r2.value), t2;
} }, Lt$4 = g$2 ? function(t2, e3, r2) {
  return zt$4.f(t2, e3, S$3(1, r2));
} : function(t2, e3, r2) {
  return t2[e3] = r2, t2;
}, Ct$4 = A$4(Function.toString);
C$4(ut$4.inspectSource) || (ut$4.inspectSource = function(t2) {
  return Ct$4(t2);
});
var Ft$4, $t$4, Bt$4, Dt$4 = ut$4.inspectSource, Vt$4 = y$2.WeakMap, Gt$4 = C$4(Vt$4) && /native code/.test(Dt$4(Vt$4)), Ut$4 = ct$4("keys"), Kt$4 = function(t2) {
  return Ut$4[t2] || (Ut$4[t2] = yt$4(t2));
}, Wt$4 = {}, Yt$4 = y$2.TypeError, qt$4 = y$2.WeakMap;
if (Gt$4 || ut$4.state) {
  var Xt$4 = ut$4.state || (ut$4.state = new qt$4()), Jt$4 = A$4(Xt$4.get), Qt$4 = A$4(Xt$4.has), Zt$4 = A$4(Xt$4.set);
  Ft$4 = function(t2, e3) {
    if (Qt$4(Xt$4, t2))
      throw new Yt$4("Object already initialized");
    return e3.facade = t2, Zt$4(Xt$4, t2, e3), e3;
  }, $t$4 = function(t2) {
    return Jt$4(Xt$4, t2) || {};
  }, Bt$4 = function(t2) {
    return Qt$4(Xt$4, t2);
  };
} else {
  var te$4 = Kt$4("state");
  Wt$4[te$4] = true, Ft$4 = function(t2, e3) {
    if (st$4(t2, te$4))
      throw new Yt$4("Object already initialized");
    return e3.facade = t2, Lt$4(t2, te$4, e3), e3;
  }, $t$4 = function(t2) {
    return st$4(t2, te$4) ? t2[te$4] : {};
  }, Bt$4 = function(t2) {
    return st$4(t2, te$4);
  };
}
var ee$4, re$4 = { set: Ft$4, get: $t$4, has: Bt$4, enforce: function(t2) {
  return Bt$4(t2) ? $t$4(t2) : Ft$4(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var r2;
    if (!F$4(e3) || (r2 = $t$4(e3)).type !== t2)
      throw Yt$4("Incompatible receiver, " + t2 + " required");
    return r2;
  };
} }, ne$4 = Function.prototype, oe$4 = g$2 && Object.getOwnPropertyDescriptor, ie$4 = st$4(ne$4, "name"), ue$4 = { EXISTS: ie$4, PROPER: ie$4 && "something" === function() {
}.name, CONFIGURABLE: ie$4 && (!g$2 || g$2 && oe$4(ne$4, "name").configurable) }, ce$4 = s(function(t2) {
  var e3 = ue$4.CONFIGURABLE, r2 = re$4.get, n2 = re$4.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, r3, i2, u2) {
    var c2, a2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet, s2 = u2 && void 0 !== u2.name ? u2.name : r3;
    C$4(i2) && ("Symbol(" === String(s2).slice(0, 7) && (s2 = "[" + String(s2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!st$4(i2, "name") || e3 && i2.name !== s2) && Lt$4(i2, "name", s2), (c2 = n2(i2)).source || (c2.source = o2.join("string" == typeof s2 ? s2 : ""))), t3 !== y$2 ? (a2 ? !f2 && t3[r3] && (l2 = true) : delete t3[r3], l2 ? t3[r3] = i2 : Lt$4(t3, r3, i2)) : l2 ? t3[r3] = i2 : it$4(r3, i2);
  })(Function.prototype, "toString", function() {
    return C$4(this) && r2(this).source || Dt$4(this);
  });
}), ae$4 = Math.ceil, le$4 = Math.floor, fe$4 = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? le$4 : ae$4)(e3);
}, se$4 = Math.max, pe$4 = Math.min, de$4 = Math.min, ve$4 = function(t2) {
  return t2 > 0 ? de$4(fe$4(t2), 9007199254740991) : 0;
}, ye$4 = function(t2) {
  return ve$4(t2.length);
}, he$4 = function(t2) {
  return function(e3, r2, n2) {
    var o2, i2 = L$4(e3), u2 = ye$4(i2), c2 = function(t3, e4) {
      var r3 = fe$4(t3);
      return r3 < 0 ? se$4(r3 + e4, 0) : pe$4(r3, e4);
    }(n2, u2);
    if (t2 && r2 != r2) {
      for (; u2 > c2; )
        if ((o2 = i2[c2++]) != o2)
          return true;
    } else
      for (; u2 > c2; c2++)
        if ((t2 || c2 in i2) && i2[c2] === r2)
          return t2 || c2 || 0;
    return !t2 && -1;
  };
}, ge$4 = { includes: he$4(true), indexOf: he$4(false) }, me$4 = ge$4.indexOf, be$4 = A$4([].push), xe$4 = function(t2, e3) {
  var r2, n2 = L$4(t2), o2 = 0, i2 = [];
  for (r2 in n2)
    !st$4(Wt$4, r2) && st$4(n2, r2) && be$4(i2, r2);
  for (; e3.length > o2; )
    st$4(n2, r2 = e3[o2++]) && (~me$4(i2, r2) || be$4(i2, r2));
  return i2;
}, we$4 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Oe$4 = we$4.concat("length", "prototype"), Se$4 = { f: Object.getOwnPropertyNames || function(t2) {
  return xe$4(t2, Oe$4);
} }, Ee$4 = { f: Object.getOwnPropertySymbols }, je$4 = A$4([].concat), Te$4 = B$4("Reflect", "ownKeys") || function(t2) {
  var e3 = Se$4.f(_t$4(t2)), r2 = Ee$4.f;
  return r2 ? je$4(e3, r2(t2)) : e3;
}, Ie$4 = function(t2, e3) {
  for (var r2 = Te$4(e3), n2 = zt$4.f, o2 = Pt$4.f, i2 = 0; i2 < r2.length; i2++) {
    var u2 = r2[i2];
    st$4(t2, u2) || n2(t2, u2, o2(e3, u2));
  }
}, Ae$4 = /#|\.prototype\./, Ne$4 = function(t2, e3) {
  var r2 = Me$4[Pe$4(t2)];
  return r2 == _e$4 || r2 != Re$4 && (C$4(e3) ? h$2(e3) : !!e3);
}, Pe$4 = Ne$4.normalize = function(t2) {
  return String(t2).replace(Ae$4, ".").toLowerCase();
}, Me$4 = Ne$4.data = {}, Re$4 = Ne$4.NATIVE = "N", _e$4 = Ne$4.POLYFILL = "P", ke$4 = Ne$4, He$4 = Pt$4.f, ze$4 = function(t2, e3) {
  var r2, n2, o2, i2, u2, c2 = t2.target, a2 = t2.global, l2 = t2.stat;
  if (r2 = a2 ? y$2 : l2 ? y$2[c2] || it$4(c2, {}) : (y$2[c2] || {}).prototype)
    for (n2 in e3) {
      if (i2 = e3[n2], o2 = t2.noTargetGet ? (u2 = He$4(r2, n2)) && u2.value : r2[n2], !ke$4(a2 ? n2 : c2 + (l2 ? "." : "#") + n2, t2.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        Ie$4(i2, o2);
      }
      (t2.sham || o2 && o2.sham) && Lt$4(i2, "sham", true), ce$4(r2, n2, i2, t2);
    }
}, Le$4 = Object.keys || function(t2) {
  return xe$4(t2, we$4);
}, Ce$4 = g$2 ? Object.defineProperties : function(t2, e3) {
  _t$4(t2);
  for (var r2, n2 = L$4(e3), o2 = Le$4(e3), i2 = o2.length, u2 = 0; i2 > u2; )
    zt$4.f(t2, r2 = o2[u2++], n2[r2]);
  return t2;
}, Fe$4 = B$4("document", "documentElement"), $e$4 = Kt$4("IE_PROTO"), Be$4 = function() {
}, De$4 = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, Ve$4 = function(t2) {
  t2.write(De$4("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, Ge$4 = function() {
  try {
    ee$4 = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  Ge$4 = "undefined" != typeof document ? document.domain && ee$4 ? Ve$4(ee$4) : ((e3 = It$4("iframe")).style.display = "none", Fe$4.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(De$4("document.F=Object")), t2.close(), t2.F) : Ve$4(ee$4);
  for (var r2 = we$4.length; r2--; )
    delete Ge$4.prototype[we$4[r2]];
  return Ge$4();
};
Wt$4[$e$4] = true;
var Ue$4 = Object.create || function(t2, e3) {
  var r2;
  return null !== t2 ? (Be$4.prototype = _t$4(t2), r2 = new Be$4(), Be$4.prototype = null, r2[$e$4] = t2) : r2 = Ge$4(), void 0 === e3 ? r2 : Ce$4(r2, e3);
}, Ke$4 = xt$4("unscopables"), We$4 = Array.prototype;
null == We$4[Ke$4] && zt$4.f(We$4, Ke$4, { configurable: true, value: Ue$4(null) });
var Ye$4, qe$4 = ge$4.includes;
function Xe$4(t2) {
  if ("bulleted-list" === t2)
    return "ul";
  if ("numbered-list" === t2)
    return "ol";
  if ("list-item" === t2)
    return "li";
  throw new Error("list type '" + t2 + "' is invalid");
}
function Je$4(t2) {
  var r2 = rl$1.getNodeType(t2);
  return ["bulleted-list", "numbered-list"].includes(r2);
}
function Qe$4(t2) {
  return function(e3, r2, o2) {
    var i2 = Xe$4(t2);
    return jsx(i2, null, r2);
  };
}
ze$4({ target: "Array", proto: true }, { includes: function(t2) {
  return qe$4(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), Ye$4 = "includes", We$4[Ke$4][Ye$4] = true;
var Ze$4 = { type: "bulleted-list", renderElem: Qe$4("bulleted-list") }, tr$3 = { type: "numbered-list", renderElem: Qe$4("numbered-list") }, er$3 = { type: "list-item", renderElem: Qe$4("list-item") };
function rr$3(t2) {
  var e3 = Xe$4(t2);
  return function(t3, r2) {
    return "<" + e3 + ">" + r2 + "</" + e3 + ">";
  };
}
var nr$3 = { type: "bulleted-list", elemToHtml: rr$3("bulleted-list") }, or$3 = { type: "numbered-list", elemToHtml: rr$3("numbered-list") }, ir$3 = { type: "list-item", elemToHtml: rr$3("list-item") }, ur$3 = A$4(A$4.bind), cr$3 = Array.isArray || function(t2) {
  return "Array" == M$3(t2);
}, ar$3 = {};
ar$3[xt$4("toStringTag")] = "z";
var lr$3 = "[object z]" === String(ar$3), fr$3 = xt$4("toStringTag"), sr$3 = y$2.Object, pr$3 = "Arguments" == M$3(function() {
  return arguments;
}()), dr$3 = lr$3 ? M$3 : function(t2) {
  var e3, r2, n2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (r2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = sr$3(t2), fr$3)) ? r2 : pr$3 ? M$3(e3) : "Object" == (n2 = M$3(e3)) && C$4(e3.callee) ? "Arguments" : n2;
}, vr$3 = function() {
}, yr$3 = [], hr$3 = B$4("Reflect", "construct"), gr$3 = /^\s*(?:class|function)\b/, mr$3 = A$4(gr$3.exec), br$3 = !gr$3.exec(vr$3), xr$3 = function(t2) {
  if (!C$4(t2))
    return false;
  try {
    return hr$3(vr$3, yr$3, t2), true;
  } catch (t3) {
    return false;
  }
}, wr$3 = !hr$3 || h$2(function() {
  var t2;
  return xr$3(xr$3.call) || !xr$3(Object) || !xr$3(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!C$4(t2))
    return false;
  switch (dr$3(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return br$3 || !!mr$3(gr$3, Dt$4(t2));
} : xr$3, Or$3 = xt$4("species"), Sr$3 = y$2.Array, Er$3 = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return cr$3(t3) && (e4 = t3.constructor, (wr$3(e4) && (e4 === Sr$3 || cr$3(e4.prototype)) || F$4(e4) && null === (e4 = e4[Or$3])) && (e4 = void 0)), void 0 === e4 ? Sr$3 : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, jr$3 = A$4([].push), Tr$3 = function(t2) {
  var e3 = 1 == t2, r2 = 2 == t2, n2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, c2 = 5 == t2 || i2;
  return function(a2, l2, f2, s2) {
    for (var p2, d3, v2 = lt$4(a2), y2 = k$4(v2), h2 = function(t3, e4) {
      return et$4(t3), void 0 === e4 ? t3 : ur$3 ? ur$3(t3, e4) : function() {
        return t3.apply(e4, arguments);
      };
    }(l2, f2), g2 = ye$4(y2), m2 = 0, b2 = s2 || Er$3, x2 = e3 ? b2(a2, g2) : r2 || u2 ? b2(a2, 0) : void 0; g2 > m2; m2++)
      if ((c2 || m2 in y2) && (d3 = h2(p2 = y2[m2], m2, v2), t2))
        if (e3)
          x2[m2] = d3;
        else if (d3)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return p2;
            case 6:
              return m2;
            case 2:
              jr$3(x2, p2);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              jr$3(x2, p2);
          }
    return i2 ? -1 : n2 || o2 ? o2 : x2;
  };
}, Ir$3 = { forEach: Tr$3(0), map: Tr$3(1), filter: Tr$3(2), some: Tr$3(3), every: Tr$3(4), find: Tr$3(5), findIndex: Tr$3(6), filterReject: Tr$3(7) }, Ar$3 = xt$4("species"), Nr$3 = function(t2) {
  return Y$4 >= 51 || !h$2(function() {
    var e3 = [];
    return (e3.constructor = {})[Ar$3] = function() {
      return { foo: 1 };
    }, 1 !== e3[t2](Boolean).foo;
  });
}, Pr$3 = Ir$3.filter;
ze$4({ target: "Array", proto: true, forced: !Nr$3("filter") }, { filter: function(t2) {
  return Pr$3(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
var Mr$3 = lr$3 ? {}.toString : function() {
  return "[object " + dr$3(this) + "]";
};
lr$3 || ce$4(Object.prototype, "toString", Mr$3, { unsafe: true });
var Rr$3, _r$3, kr$3 = y$2.String, Hr$3 = function(t2) {
  if ("Symbol" === dr$3(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return kr$3(t2);
}, zr$3 = function() {
  var t2 = _t$4(this), e3 = "";
  return t2.global && (e3 += "g"), t2.ignoreCase && (e3 += "i"), t2.multiline && (e3 += "m"), t2.dotAll && (e3 += "s"), t2.unicode && (e3 += "u"), t2.sticky && (e3 += "y"), e3;
}, Lr$3 = y$2.RegExp, Cr$3 = h$2(function() {
  var t2 = Lr$3("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), Fr$3 = Cr$3 || h$2(function() {
  return !Lr$3("a", "y").sticky;
}), $r$3 = { BROKEN_CARET: Cr$3 || h$2(function() {
  var t2 = Lr$3("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}), MISSED_STICKY: Fr$3, UNSUPPORTED_Y: Cr$3 }, Br$3 = y$2.RegExp, Dr$3 = h$2(function() {
  var t2 = Br$3(".", "s");
  return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
}), Vr$3 = y$2.RegExp, Gr$3 = h$2(function() {
  var t2 = Vr$3("(?<a>b)", "g");
  return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
}), Ur$3 = re$4.get, Kr$3 = ct$4("native-string-replace", String.prototype.replace), Wr$3 = RegExp.prototype.exec, Yr$3 = Wr$3, qr$3 = A$4("".charAt), Xr$3 = A$4("".indexOf), Jr$3 = A$4("".replace), Qr$3 = A$4("".slice), Zr$3 = (_r$3 = /b*/g, b$2(Wr$3, Rr$3 = /a/, "a"), b$2(Wr$3, _r$3, "a"), 0 !== Rr$3.lastIndex || 0 !== _r$3.lastIndex), tn$4 = $r$3.BROKEN_CARET, en$4 = void 0 !== /()??/.exec("")[1];
(Zr$3 || en$4 || tn$4 || Dr$3 || Gr$3) && (Yr$3 = function(t2) {
  var e3, r2, n2, o2, i2, u2, c2, a2 = this, l2 = Ur$3(a2), f2 = Hr$3(t2), s2 = l2.raw;
  if (s2)
    return s2.lastIndex = a2.lastIndex, e3 = b$2(Yr$3, s2, f2), a2.lastIndex = s2.lastIndex, e3;
  var p2 = l2.groups, d3 = tn$4 && a2.sticky, v2 = b$2(zr$3, a2), y2 = a2.source, h2 = 0, g2 = f2;
  if (d3 && (v2 = Jr$3(v2, "y", ""), -1 === Xr$3(v2, "g") && (v2 += "g"), g2 = Qr$3(f2, a2.lastIndex), a2.lastIndex > 0 && (!a2.multiline || a2.multiline && "\n" !== qr$3(f2, a2.lastIndex - 1)) && (y2 = "(?: " + y2 + ")", g2 = " " + g2, h2++), r2 = new RegExp("^(?:" + y2 + ")", v2)), en$4 && (r2 = new RegExp("^" + y2 + "$(?!\\s)", v2)), Zr$3 && (n2 = a2.lastIndex), o2 = b$2(Wr$3, d3 ? r2 : a2, g2), d3 ? o2 ? (o2.input = Qr$3(o2.input, h2), o2[0] = Qr$3(o2[0], h2), o2.index = a2.lastIndex, a2.lastIndex += o2[0].length) : a2.lastIndex = 0 : Zr$3 && o2 && (a2.lastIndex = a2.global ? o2.index + o2[0].length : n2), en$4 && o2 && o2.length > 1 && b$2(Kr$3, o2[0], r2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && p2)
    for (o2.groups = u2 = Ue$4(null), i2 = 0; i2 < p2.length; i2++)
      u2[(c2 = p2[i2])[0]] = o2[c2[1]];
  return o2;
});
var rn$4 = Yr$3;
ze$4({ target: "RegExp", proto: true, forced: /./.exec !== rn$4 }, { exec: rn$4 });
var nn$4 = Function.prototype, on$4 = nn$4.apply, un$4 = nn$4.bind, cn$4 = nn$4.call, an$4 = "object" == typeof Reflect && Reflect.apply || (un$4 ? cn$4.bind(on$4) : function() {
  return cn$4.apply(on$4, arguments);
}), ln$4 = xt$4("species"), fn$4 = RegExp.prototype, sn$4 = A$4("".charAt), pn$4 = A$4("".charCodeAt), dn$4 = A$4("".slice), vn$4 = function(t2) {
  return function(e3, r2) {
    var n2, o2, i2 = Hr$3(z$4(e3)), u2 = fe$4(r2), c2 = i2.length;
    return u2 < 0 || u2 >= c2 ? t2 ? "" : void 0 : (n2 = pn$4(i2, u2)) < 55296 || n2 > 56319 || u2 + 1 === c2 || (o2 = pn$4(i2, u2 + 1)) < 56320 || o2 > 57343 ? t2 ? sn$4(i2, u2) : n2 : t2 ? dn$4(i2, u2, u2 + 2) : o2 - 56320 + (n2 - 55296 << 10) + 65536;
  };
}, yn$4 = { codeAt: vn$4(false), charAt: vn$4(true) }.charAt, hn$4 = function(t2, e3, r2) {
  return e3 + (r2 ? yn$4(t2, e3).length : 1);
}, gn$4 = Math.floor, mn$4 = A$4("".charAt), bn$4 = A$4("".replace), xn$4 = A$4("".slice), wn$4 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, On$4 = /\$([$&'`]|\d{1,2})/g, Sn$4 = function(t2, e3, r2, n2, o2, i2) {
  var u2 = r2 + t2.length, c2 = n2.length, a2 = On$4;
  return void 0 !== o2 && (o2 = lt$4(o2), a2 = wn$4), bn$4(i2, a2, function(i3, a3) {
    var l2;
    switch (mn$4(a3, 0)) {
      case "$":
        return "$";
      case "&":
        return t2;
      case "`":
        return xn$4(e3, 0, r2);
      case "'":
        return xn$4(e3, u2);
      case "<":
        l2 = o2[xn$4(a3, 1, -1)];
        break;
      default:
        var f2 = +a3;
        if (0 === f2)
          return i3;
        if (f2 > c2) {
          var s2 = gn$4(f2 / 10);
          return 0 === s2 ? i3 : s2 <= c2 ? void 0 === n2[s2 - 1] ? mn$4(a3, 1) : n2[s2 - 1] + mn$4(a3, 1) : i3;
        }
        l2 = n2[f2 - 1];
    }
    return void 0 === l2 ? "" : l2;
  });
}, En$4 = y$2.TypeError, jn$4 = function(t2, e3) {
  var r2 = t2.exec;
  if (C$4(r2)) {
    var n2 = b$2(r2, t2, e3);
    return null !== n2 && _t$4(n2), n2;
  }
  if ("RegExp" === M$3(t2))
    return b$2(rn$4, t2, e3);
  throw En$4("RegExp#exec called on incompatible receiver");
}, Tn$4 = xt$4("replace"), In$4 = Math.max, An$4 = Math.min, Nn$4 = A$4([].concat), Pn$4 = A$4([].push), Mn$4 = A$4("".indexOf), Rn$4 = A$4("".slice), _n$4 = "$0" === "a".replace(/./, "$0"), kn$4 = !!/./[Tn$4] && "" === /./[Tn$4]("a", "$0");
!function(t2, e3, r2, n2) {
  var o2 = xt$4(t2), i2 = !h$2(function() {
    var e4 = {};
    return e4[o2] = function() {
      return 7;
    }, 7 != ""[t2](e4);
  }), u2 = i2 && !h$2(function() {
    var e4 = false, r3 = /a/;
    return "split" === t2 && ((r3 = {}).constructor = {}, r3.constructor[ln$4] = function() {
      return r3;
    }, r3.flags = "", r3[o2] = /./[o2]), r3.exec = function() {
      return e4 = true, null;
    }, r3[o2](""), !e4;
  });
  if (!i2 || !u2 || r2) {
    var c2 = A$4(/./[o2]), a2 = e3(o2, ""[t2], function(t3, e4, r3, n3, o3) {
      var u3 = A$4(t3), a3 = e4.exec;
      return a3 === rn$4 || a3 === fn$4.exec ? i2 && !o3 ? { done: true, value: c2(e4, r3, n3) } : { done: true, value: u3(r3, e4, n3) } : { done: false };
    });
    ce$4(String.prototype, t2, a2[0]), ce$4(fn$4, o2, a2[1]);
  }
  n2 && Lt$4(fn$4[o2], "sham", true);
}("replace", function(t2, e3, r2) {
  var n2 = kn$4 ? "$" : "$0";
  return [function(t3, r3) {
    var n3 = z$4(this), o2 = null == t3 ? void 0 : rt$4(t3, Tn$4);
    return o2 ? b$2(o2, t3, n3, r3) : b$2(e3, Hr$3(n3), t3, r3);
  }, function(t3, o2) {
    var i2 = _t$4(this), u2 = Hr$3(t3);
    if ("string" == typeof o2 && -1 === Mn$4(o2, n2) && -1 === Mn$4(o2, "$<")) {
      var c2 = r2(e3, i2, u2, o2);
      if (c2.done)
        return c2.value;
    }
    var a2 = C$4(o2);
    a2 || (o2 = Hr$3(o2));
    var l2 = i2.global;
    if (l2) {
      var f2 = i2.unicode;
      i2.lastIndex = 0;
    }
    for (var s2 = []; ; ) {
      var p2 = jn$4(i2, u2);
      if (null === p2)
        break;
      if (Pn$4(s2, p2), !l2)
        break;
      "" === Hr$3(p2[0]) && (i2.lastIndex = hn$4(u2, ve$4(i2.lastIndex), f2));
    }
    for (var d3, v2 = "", y2 = 0, h2 = 0; h2 < s2.length; h2++) {
      for (var g2 = Hr$3((p2 = s2[h2])[0]), m2 = In$4(An$4(fe$4(p2.index), u2.length), 0), b2 = [], x2 = 1; x2 < p2.length; x2++)
        Pn$4(b2, void 0 === (d3 = p2[x2]) ? d3 : String(d3));
      var w2 = p2.groups;
      if (a2) {
        var O2 = Nn$4([g2], b2, m2, u2);
        void 0 !== w2 && Pn$4(O2, w2);
        var S2 = Hr$3(an$4(o2, void 0, O2));
      } else
        S2 = Sn$4(g2, u2, m2, b2, w2, o2);
      m2 >= y2 && (v2 += Rn$4(u2, y2, m2) + S2, y2 = m2 + g2.length);
    }
    return v2 + Rn$4(u2, y2);
  }];
}, !!h$2(function() {
  var t2 = /./;
  return t2.exec = function() {
    var t3 = [];
    return t3.groups = { a: "7" }, t3;
  }, "7" !== "".replace(t2, "$<a>");
}) || !_n$4 || kn$4), ze$4({ global: true }, { globalThis: y$2 });
var Hn$4 = { selector: "li", parseElemHtml: function(t2, e3, r2) {
  var n2 = $$6(t2);
  return 0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!r2.isInline(t3);
  })).length && (e3 = [{ text: n2.text().replace(/\s+/gm, " ") }]), { type: "list-item", children: e3 };
} };
var zn$4 = { selector: "ul", parseElemHtml: function(t2, r2, n2) {
  return { type: "bulleted-list", children: r2.filter(function(t3) {
    return "list-item" === rl$1.getNodeType(t3);
  }) };
} };
var Ln$4 = { selector: "ol", parseElemHtml: function(t2, r2, n2) {
  return { type: "numbered-list", children: r2.filter(function(t3) {
    return "list-item" === rl$1.getNodeType(t3);
  }) };
} }, Cn$4 = function(t2, e3) {
  return Cn$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e4) {
    t3.__proto__ = e4;
  } || function(t3, e4) {
    for (var r2 in e4)
      Object.prototype.hasOwnProperty.call(e4, r2) && (t3[r2] = e4[r2]);
  }, Cn$4(t2, e3);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Fn$4(t2, e3) {
  if ("function" != typeof e3 && null !== e3)
    throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
  function r2() {
    this.constructor = t2;
  }
  Cn$4(t2, e3), t2.prototype = null === e3 ? Object.create(e3) : (r2.prototype = e3.prototype, new r2());
}
function $n$4(t2, e3) {
  var r2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!r2)
    return t2;
  var n2, o2, i2 = r2.call(t2), u2 = [];
  try {
    for (; (void 0 === e3 || e3-- > 0) && !(n2 = i2.next()).done; )
      u2.push(n2.value);
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      n2 && !n2.done && (r2 = i2.return) && r2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return u2;
}
var Bn$4, Dn$4 = function() {
  function t2() {
    this.tag = "button";
  }
  return t2.prototype.getListNode = function(t3) {
    var r2 = this.type;
    return rl$1.getSelectedNodeByType(t3, r2);
  }, t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return !!this.getListNode(t3);
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || !!rl$1.getSelectedElems(t3).some(function(e3) {
      if (Editor$1.isVoid(t3, e3) && Editor$1.isBlock(t3, e3))
        return true;
      var r2 = e3.type;
      return !!["pre", "code", "table"].includes(r2) || void 0;
    });
  }, t2.prototype.getMatchListType = function(t3) {
    var r2 = $n$4(Editor$1.nodes(t3, { match: function(t4) {
      return Je$4(t4);
    }, universal: true }), 1), n2 = r2[0];
    if (null == n2)
      return "";
    var o2 = $n$4(n2, 1)[0];
    return rl$1.getNodeType(o2);
  }, t2.prototype.exec = function(t3, e3) {
    var r2 = this.type, n2 = this.isActive(t3);
    Transforms.unwrapNodes(t3, { match: function(t4) {
      return Je$4(t4);
    }, split: true }), Transforms.setNodes(t3, { type: n2 ? "paragraph" : "list-item" });
    var o2 = { type: r2, children: [] };
    n2 || Transforms.wrapNodes(t3, o2);
    var i2 = this.getMatchListType(t3);
    "" != i2 && i2 !== r2 && Transforms.wrapNodes(t3, o2);
  }, t2;
}(), Vn$4 = '<svg viewBox="0 0 1024 1024"><path d="M384 64h640v128H384V64z m0 384h640v128H384v-128z m0 384h640v128H384v-128zM0 128a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z"></path></svg>', Gn$4 = '<svg viewBox="0 0 1024 1024"><path d="M384 832h640v128H384z m0-384h640v128H384z m0-384h640v128H384zM192 0v256H128V64H64V0zM128 526.016v50.016h128v64H64v-146.016l128-60V384H64v-64h192v146.016zM256 704v320H64v-64h128v-64H64v-64h128v-64H64v-64z"></path></svg>', Un$4 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.type = "bulleted-list", e4.title = lp$1("listModule.unOrderedList"), e4.iconSvg = Vn$4, e4;
  }
  return Fn$4(e3, t2), e3;
}(Dn$4), Kn$4 = function(t2) {
  function e3() {
    var e4 = null !== t2 && t2.apply(this, arguments) || this;
    return e4.type = "numbered-list", e4.title = lp$1("listModule.orderedList"), e4.iconSvg = Gn$4, e4;
  }
  return Fn$4(e3, t2), e3;
}(Dn$4), Wn$4 = { key: "bulletedList", factory: function() {
  return new Un$4();
} }, Yn$4 = { key: "numberedList", factory: function() {
  return new Kn$4();
} }, qn$4 = /"/g, Xn$4 = A$4("".replace);
ze$4({ target: "String", proto: true, forced: (Bn$4 = "anchor", h$2(function() {
  var t2 = ""[Bn$4]('"');
  return t2 !== t2.toLowerCase() || t2.split('"').length > 3;
})) }, { anchor: function(t2) {
  return e3 = "a", r2 = "name", n2 = t2, o2 = Hr$3(z$4(this)), i2 = "<" + e3, "" !== r2 && (i2 += " " + r2 + '="' + Xn$4(Hr$3(n2), qn$4, "&quot;") + '"'), i2 + ">" + o2 + "</" + e3 + ">";
  var e3, r2, n2, o2, i2;
} });
var Jn$4 = function(t2, e3, r2) {
  var n2 = Et$4(e3);
  n2 in t2 ? zt$4.f(t2, n2, S$3(0, r2)) : t2[n2] = r2;
}, Qn$4 = xt$4("isConcatSpreadable"), Zn$4 = y$2.TypeError, to$3 = Y$4 >= 51 || !h$2(function() {
  var t2 = [];
  return t2[Qn$4] = false, t2.concat()[0] !== t2;
}), eo$3 = Nr$3("concat"), ro$3 = function(t2) {
  if (!F$4(t2))
    return false;
  var e3 = t2[Qn$4];
  return void 0 !== e3 ? !!e3 : cr$3(t2);
};
ze$4({ target: "Array", proto: true, forced: !to$3 || !eo$3 }, { concat: function(t2) {
  var e3, r2, n2, o2, i2, u2 = lt$4(this), c2 = Er$3(u2, 0), a2 = 0;
  for (e3 = -1, n2 = arguments.length; e3 < n2; e3++)
    if (ro$3(i2 = -1 === e3 ? u2 : arguments[e3])) {
      if (a2 + (o2 = ye$4(i2)) > 9007199254740991)
        throw Zn$4("Maximum allowed index exceeded");
      for (r2 = 0; r2 < o2; r2++, a2++)
        r2 in i2 && Jn$4(c2, a2, i2[r2]);
    } else {
      if (a2 >= 9007199254740991)
        throw Zn$4("Maximum allowed index exceeded");
      Jn$4(c2, a2++, i2);
    }
  return c2.length = a2, c2;
} });
var no$3 = { renderElems: [Ze$4, tr$3, er$3], elemsToHtml: [nr$3, or$3, ir$3], parseElemsHtml: [Hn$4, Ln$4, zn$4], menus: [Wn$4, Yn$4], editorPlugin: function(t2) {
  var r2 = t2.insertBreak, n2 = t2.deleteBackward;
  t2.insertNode;
  var o2 = t2;
  return o2.insertBreak = function() {
    var t3 = o2.selection;
    if (null != t3) {
      var n3 = rl$1.getSelectedNodeByType(o2, "list-item");
      if (null != n3) {
        var i2 = rl$1.getParentNode(o2, n3), a2 = (null == i2 ? void 0 : i2.children) || [];
        if (n3 === a2[a2.length - 1]) {
          if ("" === Node$1.string(n3)) {
            Transforms.removeNodes(o2, { match: function(t4) {
              return rl$1.checkNodeType(t4, "list-item");
            } });
            var l2 = [t3.anchor.path[0] + 1];
            return Transforms.insertNodes(o2, rl$1.genEmptyParagraph(), { at: l2 }), void o2.select({ path: l2.concat(0), offset: 0 });
          }
        }
        r2();
      } else
        r2();
    } else
      r2();
  }, o2.deleteBackward = function(t3) {
    var e3 = function(t4) {
      var e4 = $n$4(Editor$1.nodes(t4, { match: function(e5) {
        return t4.children[0] === e5;
      }, mode: "highest" }), 1), r3 = e4[0];
      if (null == r3)
        return false;
      var n3 = r3[0];
      return !(!Element$1.isElement(n3) || Node$1.string(n3) || !Je$4(n3) || (Transforms.unwrapNodes(t4, { match: function(t5) {
        return Je$4(t5);
      }, split: true }), Transforms.setNodes(t4, { type: "paragraph" }), 0));
    }(o2);
    e3 || n2(t3);
  }, o2;
} };
var lodash_isequal = createCommonjsModule(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag2 = "[object Arguments]", arrayTag = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var reIsUint2 = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag2] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag2] = typedArrayTags[numberTag] = typedArrayTags[objectTag2] = typedArrayTags[regexpTag] = typedArrayTags[setTag2] = typedArrayTags[stringTag2] = typedArrayTags[weakMapTag2] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter2(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index < length2) {
      var value = array2[index];
      if (predicate(value, index, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array2, values2) {
    var index = -1, length2 = values2.length, offset2 = array2.length;
    while (++index < length2) {
      array2[offset2 + index] = values2[index];
    }
    return array2;
  }
  function arraySome(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index < length2) {
      if (predicate(array2[index], index, array2)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes2(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray2(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg2(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray2(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData2 = root2["__core-js_shared__"];
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString2 = objectProto2.toString;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys2 = overArg2(Object.keys, Object);
  var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
  var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash2(entries2) {
    var index = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet2(key) {
    var data5 = this.__data__;
    if (nativeCreate2) {
      var result = data5[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data5, key) ? data5[key] : void 0;
  }
  function hashHas2(key) {
    var data5 = this.__data__;
    return nativeCreate2 ? data5[key] !== void 0 : hasOwnProperty2.call(data5, key);
  }
  function hashSet2(key, value) {
    var data5 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data5[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  function ListCache2(entries2) {
    var index = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete2(key) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data5.length - 1;
    if (index == lastIndex) {
      data5.pop();
    } else {
      splice2.call(data5, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet2(key) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    return index < 0 ? void 0 : data5[index][1];
  }
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  function listCacheSet2(key, value) {
    var data5 = this.__data__, index = assocIndexOf2(data5, key);
    if (index < 0) {
      ++this.size;
      data5.push([key, value]);
    } else {
      data5[index][1] = value;
    }
    return this;
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  function MapCache2(entries2) {
    var index = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index < length2) {
      var entry = entries2[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  function mapCacheSet2(key, value) {
    var data5 = getMapData2(this, key), size = data5.size;
    data5.set(key, value);
    this.size += data5.size == size ? 0 : 1;
    return this;
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  function SetCache(values2) {
    var index = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache2();
    while (++index < length2) {
      this.add(values2[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries2) {
    var data5 = this.__data__ = new ListCache2(entries2);
    this.size = data5.size;
  }
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  function stackDelete(key) {
    var data5 = this.__data__, result = data5["delete"](key);
    this.size = data5.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data5 = this.__data__;
    if (data5 instanceof ListCache2) {
      var pairs = data5.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data5.size;
        return this;
      }
      data5 = this.__data__ = new MapCache2(pairs);
    }
    data5.set(key, value);
    this.size = data5.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys2(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf2(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag2(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag2 : nullTag2;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag2(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag2(object), othTag = othIsArr ? arrayTag : getTag2(other);
    objTag = objTag == argsTag2 ? objectTag2 : objTag;
    othTag = othTag == argsTag2 ? objectTag2 : othTag;
    var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags[baseGetTag2(value)];
  }
  function baseKeys2(object) {
    if (!isPrototype2(object)) {
      return nativeKeys2(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty2.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array2);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index < arrLength) {
      var arrValue = array2[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag2:
        return object == other + "";
      case mapTag2:
        var convert = mapToArray2;
      case setTag2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray2);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys2, getSymbols);
  }
  function getMapData2(map2, key) {
    var data5 = map2.__data__;
    return isKeyable2(key) ? data5[typeof key == "string" ? "string" : "hash"] : data5.map;
  }
  function getNative2(object, key) {
    var value = getValue2(object, key);
    return baseIsNative2(value) ? value : void 0;
  }
  function getRawTag2(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
    try {
      value[symToStringTag2] = void 0;
      var unmasked = true;
    } catch (e3) {
    }
    var result = nativeObjectToString2.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag2] = tag;
      } else {
        delete value[symToStringTag2];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter2(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable2.call(object, symbol);
    });
  };
  var getTag2 = baseGetTag2;
  if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
    getTag2 = function(value) {
      var result = baseGetTag2(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString2:
            return dataViewTag2;
          case mapCtorString2:
            return mapTag2;
          case promiseCtorString2:
            return promiseTag2;
          case setCtorString2:
            return setTag2;
          case weakMapCtorString2:
            return weakMapTag2;
        }
      }
      return result;
    };
  }
  function isIndex2(value, length2) {
    length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
    return !!length2 && (typeof value == "number" || reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  function isPrototype2(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  function objectToString2(value) {
    return nativeObjectToString2.call(value);
  }
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e3) {
      }
      try {
        return func + "";
      } catch (e3) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments2 = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
  };
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength2(value.length) && !isFunction2(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag2(value);
    return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
  }
  function isLength2(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys2(object) {
    return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
});
ip$1("en", { tableModule: { deleteCol: "Delete column", deleteRow: "Delete row", deleteTable: "Delete table", widthAuto: "Width auto", insertCol: "Insert column", insertRow: "Insert row", insertTable: "Insert table", header: "Header" } }), ip$1("zh-CN", { tableModule: { deleteCol: "\u5220\u9664\u5217", deleteRow: "\u5220\u9664\u884C", deleteTable: "\u5220\u9664\u8868\u683C", widthAuto: "\u5BBD\u5EA6\u81EA\u9002\u5E94", insertCol: "\u63D2\u5165\u5217", insertRow: "\u63D2\u5165\u884C", insertTable: "\u63D2\u5165\u8868\u683C", header: "\u8868\u5934" } });
var O$3 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function H$3(t2) {
  var e3 = { exports: {} };
  return t2(e3, e3.exports), e3.exports;
}
var V$3, z$3, P$3 = function(t2) {
  return t2 && t2.Math == Math && t2;
}, L$3 = P$3("object" == typeof globalThis && globalThis) || P$3("object" == typeof window && window) || P$3("object" == typeof self && self) || P$3("object" == typeof O$3 && O$3) || function() {
  return this;
}() || Function("return this")(), R$3 = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, A$3 = !R$3(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), C$3 = Function.prototype.call, I$3 = C$3.bind ? C$3.bind(C$3) : function() {
  return C$3.apply(C$3, arguments);
}, j$3 = {}.propertyIsEnumerable, D$3 = Object.getOwnPropertyDescriptor, k$3 = { f: D$3 && !j$3.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = D$3(this, t2);
  return !!e3 && e3.enumerable;
} : j$3 }, B$3 = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, F$3 = Function.prototype, $$3 = F$3.bind, _$3 = F$3.call, G$3 = $$3 && $$3.bind(_$3), q$3 = $$3 ? function(t2) {
  return t2 && G$3(_$3, t2);
} : function(t2) {
  return t2 && function() {
    return _$3.apply(t2, arguments);
  };
}, U$3 = q$3({}.toString), W$3 = q$3("".slice), X$3 = function(t2) {
  return W$3(U$3(t2), 8, -1);
}, Y$3 = L$3.Object, K$3 = q$3("".split), J$3 = R$3(function() {
  return !Y$3("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == X$3(t2) ? K$3(t2, "") : Y$3(t2);
} : Y$3, Q$3 = L$3.TypeError, Z$3 = function(t2) {
  if (null == t2)
    throw Q$3("Can't call method on " + t2);
  return t2;
}, tt$3 = function(t2) {
  return J$3(Z$3(t2));
}, et$3 = function(t2) {
  return "function" == typeof t2;
}, nt$3 = function(t2) {
  return "object" == typeof t2 ? null !== t2 : et$3(t2);
}, rt$3 = function(t2) {
  return et$3(t2) ? t2 : void 0;
}, ot$3 = function(t2, e3) {
  return arguments.length < 2 ? rt$3(L$3[t2]) : L$3[t2] && L$3[t2][e3];
}, it$3 = q$3({}.isPrototypeOf), at$3 = ot$3("navigator", "userAgent") || "", lt$3 = L$3.process, ut$3 = L$3.Deno, ct$3 = lt$3 && lt$3.versions || ut$3 && ut$3.version, st$3 = ct$3 && ct$3.v8;
st$3 && (z$3 = (V$3 = st$3.split("."))[0] > 0 && V$3[0] < 4 ? 1 : +(V$3[0] + V$3[1])), !z$3 && at$3 && (!(V$3 = at$3.match(/Edge\/(\d+)/)) || V$3[1] >= 74) && (V$3 = at$3.match(/Chrome\/(\d+)/)) && (z$3 = +V$3[1]);
var ft$3 = z$3, dt$3 = !!Object.getOwnPropertySymbols && !R$3(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && ft$3 && ft$3 < 41;
}), pt$3 = dt$3 && !Symbol.sham && "symbol" == typeof Symbol.iterator, vt$3 = L$3.Object, ht$3 = pt$3 ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = ot$3("Symbol");
  return et$3(e3) && it$3(e3.prototype, vt$3(t2));
}, gt$3 = L$3.String, yt$3 = function(t2) {
  try {
    return gt$3(t2);
  } catch (t3) {
    return "Object";
  }
}, bt$3 = L$3.TypeError, mt$3 = function(t2) {
  if (et$3(t2))
    return t2;
  throw bt$3(yt$3(t2) + " is not a function");
}, wt$3 = function(t2, e3) {
  var n2 = t2[e3];
  return null == n2 ? void 0 : mt$3(n2);
}, St$3 = L$3.TypeError, xt$3 = Object.defineProperty, Tt$3 = function(t2, e3) {
  try {
    xt$3(L$3, t2, { value: e3, configurable: true, writable: true });
  } catch (n2) {
    L$3[t2] = e3;
  }
  return e3;
}, Et$3 = L$3["__core-js_shared__"] || Tt$3("__core-js_shared__", {}), Nt$3 = H$3(function(t2) {
  (t2.exports = function(t3, e3) {
    return Et$3[t3] || (Et$3[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), Mt$3 = L$3.Object, Ot$3 = function(t2) {
  return Mt$3(Z$3(t2));
}, Ht$3 = q$3({}.hasOwnProperty), Vt$3 = Object.hasOwn || function(t2, e3) {
  return Ht$3(Ot$3(t2), e3);
}, zt$3 = 0, Pt$3 = Math.random(), Lt$3 = q$3(1 .toString), Rt$3 = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + Lt$3(++zt$3 + Pt$3, 36);
}, At$3 = Nt$3("wks"), Ct$3 = L$3.Symbol, It$3 = Ct$3 && Ct$3.for, jt$3 = pt$3 ? Ct$3 : Ct$3 && Ct$3.withoutSetter || Rt$3, Dt$3 = function(t2) {
  if (!Vt$3(At$3, t2) || !dt$3 && "string" != typeof At$3[t2]) {
    var e3 = "Symbol." + t2;
    dt$3 && Vt$3(Ct$3, t2) ? At$3[t2] = Ct$3[t2] : At$3[t2] = pt$3 && It$3 ? It$3(e3) : jt$3(e3);
  }
  return At$3[t2];
}, kt$3 = L$3.TypeError, Bt$3 = Dt$3("toPrimitive"), Ft$3 = function(t2, e3) {
  if (!nt$3(t2) || ht$3(t2))
    return t2;
  var n2, r2 = wt$3(t2, Bt$3);
  if (r2) {
    if (void 0 === e3 && (e3 = "default"), n2 = I$3(r2, t2, e3), !nt$3(n2) || ht$3(n2))
      return n2;
    throw kt$3("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var n3, r3;
    if ("string" === e4 && et$3(n3 = t3.toString) && !nt$3(r3 = I$3(n3, t3)))
      return r3;
    if (et$3(n3 = t3.valueOf) && !nt$3(r3 = I$3(n3, t3)))
      return r3;
    if ("string" !== e4 && et$3(n3 = t3.toString) && !nt$3(r3 = I$3(n3, t3)))
      return r3;
    throw St$3("Can't convert object to primitive value");
  }(t2, e3);
}, $t$3 = function(t2) {
  var e3 = Ft$3(t2, "string");
  return ht$3(e3) ? e3 : e3 + "";
}, _t$3 = L$3.document, Gt$3 = nt$3(_t$3) && nt$3(_t$3.createElement), qt$3 = function(t2) {
  return Gt$3 ? _t$3.createElement(t2) : {};
}, Ut$3 = !A$3 && !R$3(function() {
  return 7 != Object.defineProperty(qt$3("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Wt$3 = Object.getOwnPropertyDescriptor, Xt$3 = { f: A$3 ? Wt$3 : function(t2, e3) {
  if (t2 = tt$3(t2), e3 = $t$3(e3), Ut$3)
    try {
      return Wt$3(t2, e3);
    } catch (t3) {
    }
  if (Vt$3(t2, e3))
    return B$3(!I$3(k$3.f, t2, e3), t2[e3]);
} }, Yt$3 = L$3.String, Kt$3 = L$3.TypeError, Jt$3 = function(t2) {
  if (nt$3(t2))
    return t2;
  throw Kt$3(Yt$3(t2) + " is not an object");
}, Qt$3 = L$3.TypeError, Zt$3 = Object.defineProperty, te$3 = { f: A$3 ? Zt$3 : function(t2, e3, n2) {
  if (Jt$3(t2), e3 = $t$3(e3), Jt$3(n2), Ut$3)
    try {
      return Zt$3(t2, e3, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw Qt$3("Accessors not supported");
  return "value" in n2 && (t2[e3] = n2.value), t2;
} }, ee$3 = A$3 ? function(t2, e3, n2) {
  return te$3.f(t2, e3, B$3(1, n2));
} : function(t2, e3, n2) {
  return t2[e3] = n2, t2;
}, ne$3 = q$3(Function.toString);
et$3(Et$3.inspectSource) || (Et$3.inspectSource = function(t2) {
  return ne$3(t2);
});
var re$3, oe$3, ie$3, ae$3 = Et$3.inspectSource, le$3 = L$3.WeakMap, ue$3 = et$3(le$3) && /native code/.test(ae$3(le$3)), ce$3 = Nt$3("keys"), se$3 = function(t2) {
  return ce$3[t2] || (ce$3[t2] = Rt$3(t2));
}, fe$3 = {}, de$3 = L$3.TypeError, pe$3 = L$3.WeakMap;
if (ue$3 || Et$3.state) {
  var ve$3 = Et$3.state || (Et$3.state = new pe$3()), he$3 = q$3(ve$3.get), ge$3 = q$3(ve$3.has), ye$3 = q$3(ve$3.set);
  re$3 = function(t2, e3) {
    if (ge$3(ve$3, t2))
      throw new de$3("Object already initialized");
    return e3.facade = t2, ye$3(ve$3, t2, e3), e3;
  }, oe$3 = function(t2) {
    return he$3(ve$3, t2) || {};
  }, ie$3 = function(t2) {
    return ge$3(ve$3, t2);
  };
} else {
  var be$3 = se$3("state");
  fe$3[be$3] = true, re$3 = function(t2, e3) {
    if (Vt$3(t2, be$3))
      throw new de$3("Object already initialized");
    return e3.facade = t2, ee$3(t2, be$3, e3), e3;
  }, oe$3 = function(t2) {
    return Vt$3(t2, be$3) ? t2[be$3] : {};
  }, ie$3 = function(t2) {
    return Vt$3(t2, be$3);
  };
}
var me$3 = { set: re$3, get: oe$3, has: ie$3, enforce: function(t2) {
  return ie$3(t2) ? oe$3(t2) : re$3(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var n2;
    if (!nt$3(e3) || (n2 = oe$3(e3)).type !== t2)
      throw de$3("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, we$3 = Function.prototype, Se$3 = A$3 && Object.getOwnPropertyDescriptor, xe$3 = Vt$3(we$3, "name"), Te$3 = { EXISTS: xe$3, PROPER: xe$3 && "something" === function() {
}.name, CONFIGURABLE: xe$3 && (!A$3 || A$3 && Se$3(we$3, "name").configurable) }, Ee$3 = H$3(function(t2) {
  var e3 = Te$3.CONFIGURABLE, n2 = me$3.get, r2 = me$3.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, n3, i2, a2) {
    var l2, u2 = !!a2 && !!a2.unsafe, c2 = !!a2 && !!a2.enumerable, s2 = !!a2 && !!a2.noTargetGet, f2 = a2 && void 0 !== a2.name ? a2.name : n3;
    et$3(i2) && ("Symbol(" === String(f2).slice(0, 7) && (f2 = "[" + String(f2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Vt$3(i2, "name") || e3 && i2.name !== f2) && ee$3(i2, "name", f2), (l2 = r2(i2)).source || (l2.source = o2.join("string" == typeof f2 ? f2 : ""))), t3 !== L$3 ? (u2 ? !s2 && t3[n3] && (c2 = true) : delete t3[n3], c2 ? t3[n3] = i2 : ee$3(t3, n3, i2)) : c2 ? t3[n3] = i2 : Tt$3(n3, i2);
  })(Function.prototype, "toString", function() {
    return et$3(this) && n2(this).source || ae$3(this);
  });
}), Ne$3 = Math.ceil, Me$3 = Math.floor, Oe$3 = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? Me$3 : Ne$3)(e3);
}, He$3 = Math.max, Ve$3 = Math.min, ze$3 = function(t2, e3) {
  var n2 = Oe$3(t2);
  return n2 < 0 ? He$3(n2 + e3, 0) : Ve$3(n2, e3);
}, Pe$3 = Math.min, Le$3 = function(t2) {
  return t2 > 0 ? Pe$3(Oe$3(t2), 9007199254740991) : 0;
}, Re$3 = function(t2) {
  return Le$3(t2.length);
}, Ae$3 = function(t2) {
  return function(e3, n2, r2) {
    var o2, i2 = tt$3(e3), a2 = Re$3(i2), l2 = ze$3(r2, a2);
    if (t2 && n2 != n2) {
      for (; a2 > l2; )
        if ((o2 = i2[l2++]) != o2)
          return true;
    } else
      for (; a2 > l2; l2++)
        if ((t2 || l2 in i2) && i2[l2] === n2)
          return t2 || l2 || 0;
    return !t2 && -1;
  };
}, Ce$3 = { includes: Ae$3(true), indexOf: Ae$3(false) }.indexOf, Ie$3 = q$3([].push), je$3 = function(t2, e3) {
  var n2, r2 = tt$3(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !Vt$3(fe$3, n2) && Vt$3(r2, n2) && Ie$3(i2, n2);
  for (; e3.length > o2; )
    Vt$3(r2, n2 = e3[o2++]) && (~Ce$3(i2, n2) || Ie$3(i2, n2));
  return i2;
}, De$3 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ke$3 = De$3.concat("length", "prototype"), Be$3 = { f: Object.getOwnPropertyNames || function(t2) {
  return je$3(t2, ke$3);
} }, Fe$3 = { f: Object.getOwnPropertySymbols }, $e$3 = q$3([].concat), _e$3 = ot$3("Reflect", "ownKeys") || function(t2) {
  var e3 = Be$3.f(Jt$3(t2)), n2 = Fe$3.f;
  return n2 ? $e$3(e3, n2(t2)) : e3;
}, Ge$3 = function(t2, e3) {
  for (var n2 = _e$3(e3), r2 = te$3.f, o2 = Xt$3.f, i2 = 0; i2 < n2.length; i2++) {
    var a2 = n2[i2];
    Vt$3(t2, a2) || r2(t2, a2, o2(e3, a2));
  }
}, qe$3 = /#|\.prototype\./, Ue$3 = function(t2, e3) {
  var n2 = Xe$3[We$3(t2)];
  return n2 == Ke$3 || n2 != Ye$3 && (et$3(e3) ? R$3(e3) : !!e3);
}, We$3 = Ue$3.normalize = function(t2) {
  return String(t2).replace(qe$3, ".").toLowerCase();
}, Xe$3 = Ue$3.data = {}, Ye$3 = Ue$3.NATIVE = "N", Ke$3 = Ue$3.POLYFILL = "P", Je$3 = Ue$3, Qe$3 = Xt$3.f, Ze$3 = function(t2, e3) {
  var n2, r2, o2, i2, a2, l2 = t2.target, u2 = t2.global, c2 = t2.stat;
  if (n2 = u2 ? L$3 : c2 ? L$3[l2] || Tt$3(l2, {}) : (L$3[l2] || {}).prototype)
    for (r2 in e3) {
      if (i2 = e3[r2], o2 = t2.noTargetGet ? (a2 = Qe$3(n2, r2)) && a2.value : n2[r2], !Je$3(u2 ? r2 : l2 + (c2 ? "." : "#") + r2, t2.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        Ge$3(i2, o2);
      }
      (t2.sham || o2 && o2.sham) && ee$3(i2, "sham", true), Ee$3(n2, r2, i2, t2);
    }
}, tn$3 = {};
tn$3[Dt$3("toStringTag")] = "z";
var en$3, nn$3 = "[object z]" === String(tn$3), rn$3 = Dt$3("toStringTag"), on$3 = L$3.Object, an$3 = "Arguments" == X$3(function() {
  return arguments;
}()), ln$3 = nn$3 ? X$3 : function(t2) {
  var e3, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = on$3(t2), rn$3)) ? n2 : an$3 ? X$3(e3) : "Object" == (r2 = X$3(e3)) && et$3(e3.callee) ? "Arguments" : r2;
}, un$3 = L$3.String, cn$3 = function(t2) {
  if ("Symbol" === ln$3(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return un$3(t2);
}, sn$3 = /"/g, fn$3 = q$3("".replace);
Ze$3({ target: "String", proto: true, forced: (en$3 = "anchor", R$3(function() {
  var t2 = ""[en$3]('"');
  return t2 !== t2.toLowerCase() || t2.split('"').length > 3;
})) }, { anchor: function(t2) {
  return e3 = "a", n2 = "name", r2 = t2, o2 = cn$3(Z$3(this)), i2 = "<" + e3, "" !== n2 && (i2 += " " + n2 + '="' + fn$3(cn$3(r2), sn$3, "&quot;") + '"'), i2 + ">" + o2 + "</" + e3 + ">";
  var e3, n2, r2, o2, i2;
} });
var dn$3, pn$3 = function() {
  var t2 = Jt$3(this), e3 = "";
  return t2.global && (e3 += "g"), t2.ignoreCase && (e3 += "i"), t2.multiline && (e3 += "m"), t2.dotAll && (e3 += "s"), t2.unicode && (e3 += "u"), t2.sticky && (e3 += "y"), e3;
}, vn$3 = L$3.RegExp, hn$3 = R$3(function() {
  var t2 = vn$3("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), gn$3 = hn$3 || R$3(function() {
  return !vn$3("a", "y").sticky;
}), yn$3 = { BROKEN_CARET: hn$3 || R$3(function() {
  var t2 = vn$3("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}), MISSED_STICKY: gn$3, UNSUPPORTED_Y: hn$3 }, bn$3 = Object.keys || function(t2) {
  return je$3(t2, De$3);
}, mn$3 = A$3 ? Object.defineProperties : function(t2, e3) {
  Jt$3(t2);
  for (var n2, r2 = tt$3(e3), o2 = bn$3(e3), i2 = o2.length, a2 = 0; i2 > a2; )
    te$3.f(t2, n2 = o2[a2++], r2[n2]);
  return t2;
}, wn$3 = ot$3("document", "documentElement"), Sn$3 = se$3("IE_PROTO"), xn$3 = function() {
}, Tn$3 = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, En$3 = function(t2) {
  t2.write(Tn$3("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, Nn$3 = function() {
  try {
    dn$3 = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  Nn$3 = "undefined" != typeof document ? document.domain && dn$3 ? En$3(dn$3) : ((e3 = qt$3("iframe")).style.display = "none", wn$3.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(Tn$3("document.F=Object")), t2.close(), t2.F) : En$3(dn$3);
  for (var n2 = De$3.length; n2--; )
    delete Nn$3.prototype[De$3[n2]];
  return Nn$3();
};
fe$3[Sn$3] = true;
var Mn$3, On$3, Hn$3 = Object.create || function(t2, e3) {
  var n2;
  return null !== t2 ? (xn$3.prototype = Jt$3(t2), n2 = new xn$3(), xn$3.prototype = null, n2[Sn$3] = t2) : n2 = Nn$3(), void 0 === e3 ? n2 : mn$3(n2, e3);
}, Vn$3 = L$3.RegExp, zn$3 = R$3(function() {
  var t2 = Vn$3(".", "s");
  return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
}), Pn$3 = L$3.RegExp, Ln$3 = R$3(function() {
  var t2 = Pn$3("(?<a>b)", "g");
  return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
}), Rn$3 = me$3.get, An$3 = Nt$3("native-string-replace", String.prototype.replace), Cn$3 = RegExp.prototype.exec, In$3 = Cn$3, jn$3 = q$3("".charAt), Dn$3 = q$3("".indexOf), kn$3 = q$3("".replace), Bn$3 = q$3("".slice), Fn$3 = (On$3 = /b*/g, I$3(Cn$3, Mn$3 = /a/, "a"), I$3(Cn$3, On$3, "a"), 0 !== Mn$3.lastIndex || 0 !== On$3.lastIndex), $n$3 = yn$3.BROKEN_CARET, _n$3 = void 0 !== /()??/.exec("")[1];
(Fn$3 || _n$3 || $n$3 || zn$3 || Ln$3) && (In$3 = function(t2) {
  var e3, n2, r2, o2, i2, a2, l2, u2 = this, c2 = Rn$3(u2), s2 = cn$3(t2), f2 = c2.raw;
  if (f2)
    return f2.lastIndex = u2.lastIndex, e3 = I$3(In$3, f2, s2), u2.lastIndex = f2.lastIndex, e3;
  var d3 = c2.groups, p2 = $n$3 && u2.sticky, v2 = I$3(pn$3, u2), h2 = u2.source, g2 = 0, y2 = s2;
  if (p2 && (v2 = kn$3(v2, "y", ""), -1 === Dn$3(v2, "g") && (v2 += "g"), y2 = Bn$3(s2, u2.lastIndex), u2.lastIndex > 0 && (!u2.multiline || u2.multiline && "\n" !== jn$3(s2, u2.lastIndex - 1)) && (h2 = "(?: " + h2 + ")", y2 = " " + y2, g2++), n2 = new RegExp("^(?:" + h2 + ")", v2)), _n$3 && (n2 = new RegExp("^" + h2 + "$(?!\\s)", v2)), Fn$3 && (r2 = u2.lastIndex), o2 = I$3(Cn$3, p2 ? n2 : u2, y2), p2 ? o2 ? (o2.input = Bn$3(o2.input, g2), o2[0] = Bn$3(o2[0], g2), o2.index = u2.lastIndex, u2.lastIndex += o2[0].length) : u2.lastIndex = 0 : Fn$3 && o2 && (u2.lastIndex = u2.global ? o2.index + o2[0].length : r2), _n$3 && o2 && o2.length > 1 && I$3(An$3, o2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && d3)
    for (o2.groups = a2 = Hn$3(null), i2 = 0; i2 < d3.length; i2++)
      a2[(l2 = d3[i2])[0]] = o2[l2[1]];
  return o2;
});
var Gn$3 = In$3;
Ze$3({ target: "RegExp", proto: true, forced: /./.exec !== Gn$3 }, { exec: Gn$3 });
var qn$3 = Array.isArray || function(t2) {
  return "Array" == X$3(t2);
}, Un$3 = function() {
}, Wn$3 = [], Xn$3 = ot$3("Reflect", "construct"), Yn$3 = /^\s*(?:class|function)\b/, Kn$3 = q$3(Yn$3.exec), Jn$3 = !Yn$3.exec(Un$3), Qn$3 = function(t2) {
  if (!et$3(t2))
    return false;
  try {
    return Xn$3(Un$3, Wn$3, t2), true;
  } catch (t3) {
    return false;
  }
}, Zn$3 = !Xn$3 || R$3(function() {
  var t2;
  return Qn$3(Qn$3.call) || !Qn$3(Object) || !Qn$3(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!et$3(t2))
    return false;
  switch (ln$3(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return Jn$3 || !!Kn$3(Yn$3, ae$3(t2));
} : Qn$3, tr$2 = function(t2, e3, n2) {
  var r2 = $t$3(e3);
  r2 in t2 ? te$3.f(t2, r2, B$3(0, n2)) : t2[r2] = n2;
}, er$2 = Dt$3("species"), nr$2 = function(t2) {
  return ft$3 >= 51 || !R$3(function() {
    var e3 = [];
    return (e3.constructor = {})[er$2] = function() {
      return { foo: 1 };
    }, 1 !== e3[t2](Boolean).foo;
  });
}, rr$2 = q$3([].slice), or$2 = nr$2("slice"), ir$2 = Dt$3("species"), ar$2 = L$3.Array, lr$2 = Math.max;
function ur$2(t2, e3) {
  var n2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!n2)
    return t2;
  var r2, o2, i2 = n2.call(t2), a2 = [];
  try {
    for (; (void 0 === e3 || e3-- > 0) && !(r2 = i2.next()).done; )
      a2.push(r2.value);
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return a2;
}
function cr$2(t2) {
  var n2 = t2.selection;
  if (null == n2)
    return false;
  var o2 = ur$2(Editor$1.nodes(t2, { match: function(t3) {
    return rl$1.checkNodeType(t3, "table-cell");
  } }), 1)[0];
  if (o2) {
    var i2 = ur$2(o2, 2)[1], a2 = Editor$1.start(t2, i2);
    if (Point.equals(n2.anchor, a2))
      return true;
  }
  return false;
}
function sr$2(t2, n2) {
  var o2, i2, a2 = Editor$1.nodes(t2, { at: n2, match: function(t3) {
    return "table" === rl$1.getNodeType(t3);
  } }), l2 = false;
  try {
    for (var u2 = function(t3) {
      var e3 = "function" == typeof Symbol && Symbol.iterator, n3 = e3 && t3[e3], r2 = 0;
      if (n3)
        return n3.call(t3);
      if (t3 && "number" == typeof t3.length)
        return { next: function() {
          return t3 && r2 >= t3.length && (t3 = void 0), { value: t3 && t3[r2++], done: !t3 };
        } };
      throw new TypeError(e3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }(a2), c2 = u2.next(); !c2.done; c2 = u2.next()) {
      c2.value;
      l2 = true;
    }
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      c2 && !c2.done && (i2 = u2.return) && i2.call(u2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return l2;
}
Ze$3({ target: "Array", proto: true, forced: !or$2 }, { slice: function(t2, e3) {
  var n2, r2, o2, i2 = tt$3(this), a2 = Re$3(i2), l2 = ze$3(t2, a2), u2 = ze$3(void 0 === e3 ? a2 : e3, a2);
  if (qn$3(i2) && (n2 = i2.constructor, (Zn$3(n2) && (n2 === ar$2 || qn$3(n2.prototype)) || nt$3(n2) && null === (n2 = n2[ir$2])) && (n2 = void 0), n2 === ar$2 || void 0 === n2))
    return rr$2(i2, l2, u2);
  for (r2 = new (void 0 === n2 ? ar$2 : n2)(lr$2(u2 - l2, 0)), o2 = 0; l2 < u2; l2++, o2++)
    l2 in i2 && tr$2(r2, o2, i2[l2]);
  return r2.length = o2, r2;
} });
var fr$2 = q$3(q$3.bind), dr$2 = Dt$3("species"), pr$2 = L$3.Array, vr$2 = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return qn$3(t3) && (e4 = t3.constructor, (Zn$3(e4) && (e4 === pr$2 || qn$3(e4.prototype)) || nt$3(e4) && null === (e4 = e4[dr$2])) && (e4 = void 0)), void 0 === e4 ? pr$2 : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, hr$2 = q$3([].push), gr$2 = function(t2) {
  var e3 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, a2 = 7 == t2, l2 = 5 == t2 || i2;
  return function(u2, c2, s2, f2) {
    for (var d3, p2, v2 = Ot$3(u2), h2 = J$3(v2), g2 = function(t3, e4) {
      return mt$3(t3), void 0 === e4 ? t3 : fr$2 ? fr$2(t3, e4) : function() {
        return t3.apply(e4, arguments);
      };
    }(c2, s2), y2 = Re$3(h2), b2 = 0, m2 = f2 || vr$2, w2 = e3 ? m2(u2, y2) : n2 || a2 ? m2(u2, 0) : void 0; y2 > b2; b2++)
      if ((l2 || b2 in h2) && (p2 = g2(d3 = h2[b2], b2, v2), t2))
        if (e3)
          w2[b2] = p2;
        else if (p2)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return d3;
            case 6:
              return b2;
            case 2:
              hr$2(w2, d3);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              hr$2(w2, d3);
          }
    return i2 ? -1 : r2 || o2 ? o2 : w2;
  };
}, yr$2 = { forEach: gr$2(0), map: gr$2(1), filter: gr$2(2), some: gr$2(3), every: gr$2(4), find: gr$2(5), findIndex: gr$2(6), filterReject: gr$2(7) }, br$2 = yr$2.map;
Ze$3({ target: "Array", proto: true, forced: !nr$2("map") }, { map: function(t2) {
  return br$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
var mr$2 = nn$3 ? {}.toString : function() {
  return "[object " + ln$3(this) + "]";
};
function wr$2(t2) {
  var e3 = t2.children || [];
  return 0 === e3.length ? [] : (e3[0] || {}).children || [];
}
function Sr$2(t2) {
  return wr$2(t2).every(function(t3) {
    return !!t3.isHeader;
  });
}
nn$3 || Ee$3(Object.prototype, "toString", mr$2, { unsafe: true });
var xr$2 = Te$3.PROPER, Tr$2 = RegExp.prototype, Er$2 = Tr$2.toString, Nr$2 = q$3(pn$3), Mr$2 = R$3(function() {
  return "/a/b" != Er$2.call({ source: "a", flags: "b" });
}), Or$2 = xr$2 && "toString" != Er$2.name;
(Mr$2 || Or$2) && Ee$3(RegExp.prototype, "toString", function() {
  var t2 = Jt$3(this), e3 = cn$3(t2.source), n2 = t2.flags;
  return "/" + e3 + "/" + cn$3(void 0 === n2 && it$3(Tr$2, t2) && !("flags" in Tr$2) ? Nr$2(t2) : n2);
}, { unsafe: true });
var Hr$2 = Dt$3("unscopables"), Vr$2 = Array.prototype;
null == Vr$2[Hr$2] && te$3.f(Vr$2, Hr$2, { configurable: true, value: Hn$3(null) });
var zr$2, Pr$2 = yr$2.find, Lr$2 = true;
"find" in [] && Array(1).find(function() {
  Lr$2 = false;
}), Ze$3({ target: "Array", proto: true, forced: Lr$2 }, { find: function(t2) {
  return Pr$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), zr$2 = "find", Vr$2[Hr$2][zr$2] = true;
var Rr$2 = Function.prototype, Ar$2 = Rr$2.apply, Cr$2 = Rr$2.bind, Ir$2 = Rr$2.call, jr$2 = "object" == typeof Reflect && Reflect.apply || (Cr$2 ? Ir$2.bind(Ar$2) : function() {
  return Ir$2.apply(Ar$2, arguments);
}), Dr$2 = Dt$3("species"), kr$2 = RegExp.prototype, Br$2 = function(t2, e3, n2, r2) {
  var o2 = Dt$3(t2), i2 = !R$3(function() {
    var e4 = {};
    return e4[o2] = function() {
      return 7;
    }, 7 != ""[t2](e4);
  }), a2 = i2 && !R$3(function() {
    var e4 = false, n3 = /a/;
    return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[Dr$2] = function() {
      return n3;
    }, n3.flags = "", n3[o2] = /./[o2]), n3.exec = function() {
      return e4 = true, null;
    }, n3[o2](""), !e4;
  });
  if (!i2 || !a2 || n2) {
    var l2 = q$3(/./[o2]), u2 = e3(o2, ""[t2], function(t3, e4, n3, r3, o3) {
      var a3 = q$3(t3), u3 = e4.exec;
      return u3 === Gn$3 || u3 === kr$2.exec ? i2 && !o3 ? { done: true, value: l2(e4, n3, r3) } : { done: true, value: a3(n3, e4, r3) } : { done: false };
    });
    Ee$3(String.prototype, t2, u2[0]), Ee$3(kr$2, o2, u2[1]);
  }
  r2 && ee$3(kr$2[o2], "sham", true);
}, Fr$2 = Dt$3("match"), $r$2 = L$3.TypeError, _r$2 = Dt$3("species"), Gr$2 = function(t2, e3) {
  var n2, r2 = Jt$3(t2).constructor;
  return void 0 === r2 || null == (n2 = Jt$3(r2)[_r$2]) ? e3 : function(t3) {
    if (Zn$3(t3))
      return t3;
    throw $r$2(yt$3(t3) + " is not a constructor");
  }(n2);
}, qr$2 = q$3("".charAt), Ur$2 = q$3("".charCodeAt), Wr$2 = q$3("".slice), Xr$2 = function(t2) {
  return function(e3, n2) {
    var r2, o2, i2 = cn$3(Z$3(e3)), a2 = Oe$3(n2), l2 = i2.length;
    return a2 < 0 || a2 >= l2 ? t2 ? "" : void 0 : (r2 = Ur$2(i2, a2)) < 55296 || r2 > 56319 || a2 + 1 === l2 || (o2 = Ur$2(i2, a2 + 1)) < 56320 || o2 > 57343 ? t2 ? qr$2(i2, a2) : r2 : t2 ? Wr$2(i2, a2, a2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Yr$2 = { codeAt: Xr$2(false), charAt: Xr$2(true) }.charAt, Kr$2 = function(t2, e3, n2) {
  return e3 + (n2 ? Yr$2(t2, e3).length : 1);
}, Jr$2 = L$3.Array, Qr$2 = Math.max, Zr$2 = function(t2, e3, n2) {
  for (var r2 = Re$3(t2), o2 = ze$3(e3, r2), i2 = ze$3(void 0 === n2 ? r2 : n2, r2), a2 = Jr$2(Qr$2(i2 - o2, 0)), l2 = 0; o2 < i2; o2++, l2++)
    tr$2(a2, l2, t2[o2]);
  return a2.length = l2, a2;
}, to$2 = L$3.TypeError, eo$2 = function(t2, e3) {
  var n2 = t2.exec;
  if (et$3(n2)) {
    var r2 = I$3(n2, t2, e3);
    return null !== r2 && Jt$3(r2), r2;
  }
  if ("RegExp" === X$3(t2))
    return I$3(Gn$3, t2, e3);
  throw to$2("RegExp#exec called on incompatible receiver");
}, no$2 = yn$3.UNSUPPORTED_Y, ro$2 = Math.min, oo$2 = [].push, io$2 = q$3(/./.exec), ao$2 = q$3(oo$2), lo$2 = q$3("".slice);
Br$2("split", function(t2, e3, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
    var r3, o2, i2 = cn$3(Z$3(this)), a2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === a2)
      return [];
    if (void 0 === t3)
      return [i2];
    if (!nt$3(r3 = t3) || !(void 0 !== (o2 = r3[Fr$2]) ? o2 : "RegExp" == X$3(r3)))
      return I$3(e3, i2, t3, a2);
    for (var l2, u2, c2, s2 = [], f2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), d3 = 0, p2 = new RegExp(t3.source, f2 + "g"); (l2 = I$3(Gn$3, p2, i2)) && !((u2 = p2.lastIndex) > d3 && (ao$2(s2, lo$2(i2, d3, l2.index)), l2.length > 1 && l2.index < i2.length && jr$2(oo$2, s2, Zr$2(l2, 1)), c2 = l2[0].length, d3 = u2, s2.length >= a2)); )
      p2.lastIndex === l2.index && p2.lastIndex++;
    return d3 === i2.length ? !c2 && io$2(p2, "") || ao$2(s2, "") : ao$2(s2, lo$2(i2, d3)), s2.length > a2 ? Zr$2(s2, 0, a2) : s2;
  } : "0".split(void 0, 0).length ? function(t3, n3) {
    return void 0 === t3 && 0 === n3 ? [] : I$3(e3, this, t3, n3);
  } : e3, [function(e4, n3) {
    var o2 = Z$3(this), i2 = null == e4 ? void 0 : wt$3(e4, t2);
    return i2 ? I$3(i2, e4, o2, n3) : I$3(r2, cn$3(o2), e4, n3);
  }, function(t3, o2) {
    var i2 = Jt$3(this), a2 = cn$3(t3), l2 = n2(r2, i2, a2, o2, r2 !== e3);
    if (l2.done)
      return l2.value;
    var u2 = Gr$2(i2, RegExp), c2 = i2.unicode, s2 = (i2.ignoreCase ? "i" : "") + (i2.multiline ? "m" : "") + (i2.unicode ? "u" : "") + (no$2 ? "g" : "y"), f2 = new u2(no$2 ? "^(?:" + i2.source + ")" : i2, s2), d3 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === d3)
      return [];
    if (0 === a2.length)
      return null === eo$2(f2, a2) ? [a2] : [];
    for (var p2 = 0, v2 = 0, h2 = []; v2 < a2.length; ) {
      f2.lastIndex = no$2 ? 0 : v2;
      var g2, y2 = eo$2(f2, no$2 ? lo$2(a2, v2) : a2);
      if (null === y2 || (g2 = ro$2(Le$3(f2.lastIndex + (no$2 ? v2 : 0)), a2.length)) === p2)
        v2 = Kr$2(a2, v2, c2);
      else {
        if (ao$2(h2, lo$2(a2, p2, v2)), h2.length === d3)
          return h2;
        for (var b2 = 1; b2 <= y2.length - 1; b2++)
          if (ao$2(h2, y2[b2]), h2.length === d3)
            return h2;
        v2 = p2 = g2;
      }
    }
    return ao$2(h2, lo$2(a2, p2)), h2;
  }];
}, !!R$3(function() {
  var t2 = /(?:)/, e3 = t2.exec;
  t2.exec = function() {
    return e3.apply(this, arguments);
  };
  var n2 = "ab".split(t2);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), no$2);
var uo$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", co$2 = q$3("".replace), so$2 = "[" + uo$2 + "]", fo$2 = RegExp("^" + so$2 + so$2 + "*"), po$2 = RegExp(so$2 + so$2 + "*$"), vo$2 = function(t2) {
  return function(e3) {
    var n2 = cn$3(Z$3(e3));
    return 1 & t2 && (n2 = co$2(n2, fo$2, "")), 2 & t2 && (n2 = co$2(n2, po$2, "")), n2;
  };
}, ho$2 = { start: vo$2(1), end: vo$2(2), trim: vo$2(3) }, go$2 = Te$3.PROPER, yo$2 = ho$2.trim;
function bo$2(t2) {
  return t2.length ? t2[0].tagName.toLowerCase() : "";
}
Ze$3({ target: "String", proto: true, forced: function(t2) {
  return R$3(function() {
    return !!uo$2[t2]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[t2]() || go$2 && uo$2[t2].name !== t2;
  });
}("trim") }, { trim: function() {
  return yo$2(this);
} }), Ze$3({ global: true }, { globalThis: L$3 }), append && ($$6.fn.append = append), on$7 && ($$6.fn.on = on$7), focus$1 && ($$6.fn.focus = focus$1), attr && ($$6.fn.attr = attr), val && ($$6.fn.val = val), html && ($$6.fn.html = html), dataset && ($$6.fn.dataset = dataset), addClass && ($$6.fn.addClass = addClass), removeClass && ($$6.fn.removeClass = removeClass), children && ($$6.fn.children = children), each && ($$6.fn.each = each), find && ($$6.fn.find = find);
var mo$2 = false, wo$2 = 0, So$2 = 0, xo$2 = null, To$2 = null, Eo$2 = $$6("body");
function No$2(t2) {
  mo$2 = false, To$2 = null, xo$2 = null, Eo$2.off("mousemove", Mo$2), Eo$2.off("mouseup", No$2);
}
Eo$2.on("mousedown", function(t2) {
  var e3 = t2.target;
  if (("TH" === e3.tagName || "TD" === e3.tagName) && "col-resize" === e3.style.cursor) {
    e3.style.cursor = "auto", t2.preventDefault(), mo$2 = true;
    var n2 = t2.clientX;
    wo$2 = n2;
    var r2 = e3.getBoundingClientRect().width;
    So$2 = r2, Eo$2.on("mousemove", Mo$2), Eo$2.on("mouseup", No$2);
  }
});
var Mo$2 = lodash_throttle(function(t2) {
  if (mo$2 && null != To$2 && null != xo$2) {
    t2.preventDefault();
    var e3 = t2.clientX, n2 = So$2 + (e3 - wo$2);
    (n2 = Math.floor(100 * n2) / 100) < 30 && (n2 = 30), Transforms.setNodes(To$2, { width: n2.toString() }, { at: xo$2 });
  }
}, 100);
var Oo$2 = { type: "table", renderElem: function(t2, n2, o2) {
  var a2 = function(t3, n3) {
    if (t3.isDisabled())
      return false;
    var o3 = t3.selection;
    if (null == o3)
      return true;
    if (Range.isCollapsed(o3))
      return true;
    var a3 = o3.anchor, c3 = o3.focus, s3 = rl$1.findPath(t3, n3), f2 = Editor$1.start(t3, s3), d4 = Editor$1.end(t3, s3), p3 = Point.compare(a3, d4) <= 0 && Point.compare(a3, f2) >= 0, v3 = Point.compare(c3, d4) <= 0 && Point.compare(c3, f2) >= 0;
    return !!(p3 && v3 && Path.equals(a3.path.slice(0, 3), c3.path.slice(0, 3)));
  }(o2, t2), c2 = t2.width, s2 = void 0 === c2 ? "auto" : c2, d3 = rl$1.isNodeSelected(o2, t2), p2 = wr$2(t2), v2 = jsx("div", { className: "table-container", "data-selected": d3, on: { mousedown: function(n3) {
    if ("DIV" === n3.target.tagName && n3.preventDefault(), !o2.isDisabled()) {
      var i2 = rl$1.findPath(o2, t2), a3 = Editor$1.start(o2, i2), l2 = o2.selection;
      if (null != l2)
        l2.anchor.path[0] !== i2[0] && o2.select(a3);
      else
        o2.select(a3);
    }
  } } }, jsx("table", { width: s2, contentEditable: a2 }, jsx("colgroup", null, p2.map(function(t3) {
    var e3 = t3.width;
    return jsx("col", { width: void 0 === e3 ? "auto" : e3 });
  })), jsx("tbody", null, n2)));
  return v2;
} }, Ho$2 = { type: "table-row", renderElem: function(t2, e3, n2) {
  return jsx("tr", null, e3);
} }, Vo$2 = { type: "table-cell", renderElem: function(t2, n2, r2) {
  var o2 = function(t3, n3) {
    var r3 = rl$1.getParentNode(t3, n3);
    if (null == r3)
      return false;
    var o3 = rl$1.getParentNode(t3, r3);
    return null != o3 && wr$2(o3).some(function(t4) {
      return t4 === n3;
    });
  }(r2, t2), i2 = t2, a2 = i2.colSpan, l2 = void 0 === a2 ? 1 : a2, u2 = i2.rowSpan, c2 = void 0 === u2 ? 1 : u2, s2 = i2.isHeader, p2 = void 0 !== s2 && s2;
  if (!o2)
    return jsx("td", { colSpan: l2, rowSpan: c2 }, n2);
  var v2 = jsx(p2 ? "th" : "td", { colSpan: l2, rowSpan: c2, style: { borderRightWidth: "3px" }, on: { mousemove: lodash_throttle(function(n3) {
    var o3 = this.elm;
    if (null != o3) {
      var i3 = o3.getBoundingClientRect(), a3 = i3.left, l3 = i3.width, u3 = i3.top, c3 = i3.height, s3 = n3.clientX, f2 = n3.clientY;
      if (!mo$2)
        s3 > a3 + l3 - 5 && s3 < a3 + l3 && (f2 > u3 && f2 < u3 + c3) ? (o3.style.cursor = "col-resize", To$2 = r2, xo$2 = rl$1.findPath(r2, t2)) : mo$2 || (o3.style.cursor = "auto", To$2 = null, xo$2 = null);
    }
  }, 100) } }, n2);
  return v2;
} };
var zo$2 = { type: "table", elemToHtml: function(t2, e3) {
  var n2 = t2.width;
  return '<table style="width: ' + (void 0 === n2 ? "auto" : n2) + ';"><tbody>' + e3 + "</tbody></table>";
} }, Po$2 = { type: "table-row", elemToHtml: function(t2, e3) {
  return "<tr>" + e3 + "</tr>";
} }, Lo$2 = { type: "table-cell", elemToHtml: function(t2, e3) {
  var n2 = t2, r2 = n2.colSpan, o2 = void 0 === r2 ? 1 : r2, i2 = n2.rowSpan, a2 = void 0 === i2 ? 1 : i2, l2 = n2.isHeader, u2 = void 0 !== l2 && l2, c2 = n2.width, s2 = u2 ? "th" : "td";
  return "<" + s2 + ' colSpan="' + o2 + '" rowSpan="' + a2 + '" width="' + (void 0 === c2 ? "auto" : c2) + '">' + e3 + "</" + s2 + ">";
} };
var Ro$2 = { selector: "table", preParseHtml: function(t2) {
  var e3 = $$6(t2);
  if ("table" !== bo$2(e3))
    return t2;
  var n2 = e3.find("tbody");
  if (0 === n2.length)
    return t2;
  var r2 = e3.find("tr");
  return e3.append(r2), n2.remove(), e3[0];
} }, Ao$2 = yr$2.filter;
Ze$3({ target: "Array", proto: true, forced: !nr$2("filter") }, { filter: function(t2) {
  return Ao$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
var Co$2 = Math.floor, Io$2 = q$3("".charAt), jo$2 = q$3("".replace), Do$2 = q$3("".slice), ko$2 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Bo$2 = /\$([$&'`]|\d{1,2})/g, Fo$2 = function(t2, e3, n2, r2, o2, i2) {
  var a2 = n2 + t2.length, l2 = r2.length, u2 = Bo$2;
  return void 0 !== o2 && (o2 = Ot$3(o2), u2 = ko$2), jo$2(i2, u2, function(i3, u3) {
    var c2;
    switch (Io$2(u3, 0)) {
      case "$":
        return "$";
      case "&":
        return t2;
      case "`":
        return Do$2(e3, 0, n2);
      case "'":
        return Do$2(e3, a2);
      case "<":
        c2 = o2[Do$2(u3, 1, -1)];
        break;
      default:
        var s2 = +u3;
        if (0 === s2)
          return i3;
        if (s2 > l2) {
          var f2 = Co$2(s2 / 10);
          return 0 === f2 ? i3 : f2 <= l2 ? void 0 === r2[f2 - 1] ? Io$2(u3, 1) : r2[f2 - 1] + Io$2(u3, 1) : i3;
        }
        c2 = r2[s2 - 1];
    }
    return void 0 === c2 ? "" : c2;
  });
}, $o$2 = Dt$3("replace"), _o$2 = Math.max, Go$2 = Math.min, qo$2 = q$3([].concat), Uo$2 = q$3([].push), Wo$2 = q$3("".indexOf), Xo$2 = q$3("".slice), Yo$2 = "$0" === "a".replace(/./, "$0"), Ko$2 = !!/./[$o$2] && "" === /./[$o$2]("a", "$0");
Br$2("replace", function(t2, e3, n2) {
  var r2 = Ko$2 ? "$" : "$0";
  return [function(t3, n3) {
    var r3 = Z$3(this), o2 = null == t3 ? void 0 : wt$3(t3, $o$2);
    return o2 ? I$3(o2, t3, r3, n3) : I$3(e3, cn$3(r3), t3, n3);
  }, function(t3, o2) {
    var i2 = Jt$3(this), a2 = cn$3(t3);
    if ("string" == typeof o2 && -1 === Wo$2(o2, r2) && -1 === Wo$2(o2, "$<")) {
      var l2 = n2(e3, i2, a2, o2);
      if (l2.done)
        return l2.value;
    }
    var u2 = et$3(o2);
    u2 || (o2 = cn$3(o2));
    var c2 = i2.global;
    if (c2) {
      var s2 = i2.unicode;
      i2.lastIndex = 0;
    }
    for (var f2 = []; ; ) {
      var d3 = eo$2(i2, a2);
      if (null === d3)
        break;
      if (Uo$2(f2, d3), !c2)
        break;
      "" === cn$3(d3[0]) && (i2.lastIndex = Kr$2(a2, Le$3(i2.lastIndex), s2));
    }
    for (var p2, v2 = "", h2 = 0, g2 = 0; g2 < f2.length; g2++) {
      for (var y2 = cn$3((d3 = f2[g2])[0]), b2 = _o$2(Go$2(Oe$3(d3.index), a2.length), 0), m2 = [], w2 = 1; w2 < d3.length; w2++)
        Uo$2(m2, void 0 === (p2 = d3[w2]) ? p2 : String(p2));
      var S2 = d3.groups;
      if (u2) {
        var x2 = qo$2([y2], m2, b2, a2);
        void 0 !== S2 && Uo$2(x2, S2);
        var T2 = cn$3(jr$2(o2, void 0, x2));
      } else
        T2 = Fo$2(y2, a2, b2, m2, S2, o2);
      b2 >= h2 && (v2 += Xo$2(a2, h2, b2) + T2, h2 = b2 + y2.length);
    }
    return v2 + Xo$2(a2, h2);
  }];
}, !!R$3(function() {
  var t2 = /./;
  return t2.exec = function() {
    var t3 = [];
    return t3.groups = { a: "7" }, t3;
  }, "7" !== "".replace(t2, "$<a>");
}) || !Yo$2 || Ko$2);
var Jo$2 = { selector: "td,th", parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2);
  0 === (e3 = e3.filter(function(t3) {
    return !!Text.isText(t3) || !!n2.isInline(t3);
  })).length && (e3 = [{ text: r2.text().replace(/\s+/gm, " ") }]);
  var o2 = parseInt(r2.attr("colSpan") || "1"), i2 = parseInt(r2.attr("rowSpan") || "1"), a2 = r2.attr("width") || "auto";
  return { type: "table-cell", isHeader: "th" === bo$2(r2), colSpan: o2, rowSpan: i2, width: a2, children: e3 };
} };
var Qo$2 = { selector: "tr", parseElemHtml: function(t2, n2, r2) {
  return { type: "table-row", children: n2.filter(function(t3) {
    return "table-cell" === rl$1.getNodeType(t3);
  }) };
} };
var Zo$2 = { selector: "table", parseElemHtml: function(t2, n2, r2) {
  var o2 = $$6(t2), i2 = "auto";
  return "100%" === function(t3, e3) {
    for (var n3 = "", r3 = (t3.attr("style") || "").split(";"), o3 = r3.length, i3 = 0; i3 < o3; i3++) {
      var a2 = r3[i3];
      if (a2) {
        var l2 = a2.split(":");
        l2[0].trim() === e3 && (n3 = l2[1].trim());
      }
    }
    return n3;
  }(o2, "width") && (i2 = "100%"), "100%" === o2.attr("width") && (i2 = "100%"), { type: "table", width: i2, children: n2.filter(function(t3) {
    return "table-row" === rl$1.getNodeType(t3);
  }) };
} };
var ti$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.insertTable"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M0 64v896h1024V64H0z m384 576v-192h256v192h-256z m256 64v192h-256v-192h256z m0-512v192h-256V192h256zM320 192v192H64V192h256z m-256 256h256v192H64v-192z m640 0h256v192h-256v-192z m0-64V192h256v192h-256zM64 704h256v192H64v-192z m640 192v-192h256v192h-256z"></path></svg>', this.tag = "button", this.showDropPanel = true, this.$content = null;
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || !!rl$1.getSelectedElems(t3).some(function(n3) {
      var r2 = rl$1.getNodeType(n3);
      return "pre" === r2 || ("table" === r2 || !!t3.isVoid(n3));
    }));
  }, t2.prototype.getPanelContentElem = function(t3) {
    var e3 = this;
    if (this.$content)
      return this.$content[0];
    for (var n2 = $$6('<div class="w-e-panel-content-table"></div>'), r2 = $$6("<span>0 &times; 0</span>"), o2 = $$6("<table></table>"), i2 = 0; i2 < 10; i2++) {
      for (var a2 = $$6("<tr></tr>"), l2 = 0; l2 < 10; l2++) {
        var u2 = $$6("<td></td>");
        u2.attr("data-x", l2.toString()), u2.attr("data-y", i2.toString()), a2.append(u2), u2.on("mouseenter", function(t4) {
          var e4 = t4.target;
          if (null != e4) {
            var n3 = $$6(e4).dataset(), i3 = n3.x, a3 = n3.y;
            r2[0].innerHTML = i3 + 1 + " &times; " + (a3 + 1), o2.children().each(function(t5) {
              $$6(t5).children().each(function(t6) {
                var e5 = $$6(t6), n4 = e5.dataset(), r3 = n4.x, o3 = n4.y;
                r3 <= i3 && o3 <= a3 ? e5.addClass("active") : e5.removeClass("active");
              });
            });
          }
        }), u2.on("click", function(n3) {
          n3.preventDefault();
          var r3 = n3.target;
          if (null != r3) {
            var o3 = $$6(r3).dataset(), i3 = o3.x, a3 = o3.y;
            e3.insertTable(t3, a3 + 1, i3 + 1);
          }
        });
      }
      o2.append(a2);
    }
    return n2.append(o2), n2.append(r2), this.$content = n2, n2[0];
  }, t2.prototype.insertTable = function(t3, n2, r2) {
    var i2 = parseInt(n2, 10), l2 = parseInt(r2, 10);
    if (i2 && l2 && !(i2 <= 0 || l2 <= 0)) {
      var u2 = rl$1.getSelectedNodeByType(t3, "paragraph");
      u2 && "" === Node$1.string(u2) && Transforms.removeNodes(t3, { mode: "highest" });
      var c2 = function(t4, e3) {
        for (var n3 = [], r3 = 0; r3 < t4; r3++) {
          for (var o2 = [], i3 = 0; i3 < e3; i3++) {
            var a2 = { type: "table-cell", children: [{ text: "" }] };
            0 === r3 && (a2.isHeader = true), o2.push(a2);
          }
          n3.push({ type: "table-row", children: o2 });
        }
        return { type: "table", width: "auto", children: n3 };
      }(i2, l2);
      Transforms.insertNodes(t3, c2, { mode: "highest" });
    }
  }, t2;
}(), ei$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.deleteTable"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == rl$1.getSelectedNodeByType(t3, "table");
  }, t2.prototype.exec = function(t3, e3) {
    this.isDisabled(t3) || Transforms.removeNodes(t3, { mode: "highest" });
  }, t2;
}(), ni$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.insertRow"), this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M707.7888 521.0112h-147.456v-147.456H488.2432v147.456h-147.456v68.8128h147.456v147.456h72.0896v-147.456h147.456zM0 917.504V0h1048.576v917.504H0zM327.68 65.536H65.536v196.608H327.68V65.536z m327.68 0H393.216v196.608h262.144V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 258.8672H65.536v462.0288H983.04V324.4032z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table"));
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var a2 = ur$2(Editor$1.nodes(t3, { match: function(t4) {
        return rl$1.checkNodeType(t4, "table-cell");
      }, universal: true }), 1), l2 = ur$2(a2[0], 2), u2 = l2[0], c2 = l2[1], s2 = rl$1.getParentNode(t3, u2), f2 = (null == s2 ? void 0 : s2.children.length) || 0;
      if (0 !== f2) {
        for (var d3 = { type: "table-row", children: [] }, p2 = 0; p2 < f2; p2++) {
          d3.children.push({ type: "table-cell", children: [{ text: "" }] });
        }
        var v2 = Path.parent(c2), h2 = Path.next(v2);
        Transforms.insertNodes(t3, d3, { at: h2 });
      }
    }
  }, t2;
}(), ri$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.deleteRow"), this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M907.6736 586.5472L747.1104 425.984l163.84-163.84-78.6432-78.6432-163.84 163.84L507.904 186.7776 429.2608 262.144l163.84 163.84-167.1168 167.1168 78.6432 78.6432 167.1168-167.1168 160.5632 160.5632 75.3664-78.6432zM0 917.504V0h1048.576v917.504H0z m983.04-327.68h-22.9376l-65.536-65.536H983.04V327.68h-91.7504l65.536-65.536h26.2144V65.536H65.536v196.608h317.8496l65.536 65.536H65.536v196.608h380.1088l-65.536 65.536H65.536v196.608H983.04v-196.608z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table-row"));
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var i2 = ur$2(Editor$1.nodes(t3, { match: function(t4) {
        return rl$1.checkNodeType(t4, "table-row");
      }, universal: true }), 1), a2 = ur$2(i2[0], 2), l2 = a2[0], u2 = a2[1], c2 = rl$1.getParentNode(t3, l2);
      ((null == c2 ? void 0 : c2.children.length) || 0) <= 1 ? Transforms.removeNodes(t3, { mode: "highest" }) : Transforms.removeNodes(t3, { at: u2 });
    }
  }, t2;
}(), oi$2 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, ii$2 = qt$3("span").classList, ai$2 = ii$2 && ii$2.constructor && ii$2.constructor.prototype, li$2 = ai$2 === Object.prototype ? void 0 : ai$2, ui$2 = yr$2.forEach, ci$2 = function(t2, e3) {
  var n2 = [][t2];
  return !!n2 && R$3(function() {
    n2.call(null, e3 || function() {
      throw 1;
    }, 1);
  });
}("forEach"), si$2 = ci$2 ? [].forEach : function(t2) {
  return ui$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
}, fi$2 = function(t2) {
  if (t2 && t2.forEach !== si$2)
    try {
      ee$3(t2, "forEach", si$2);
    } catch (e3) {
      t2.forEach = si$2;
    }
};
for (var di$2 in oi$2)
  oi$2[di$2] && fi$2(L$3[di$2] && L$3[di$2].prototype);
fi$2(li$2);
var pi$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.insertCol"), this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M327.68 193.3312v186.7776H140.9024v91.7504H327.68v186.7776h88.4736V471.8592h190.0544V380.1088H416.1536V193.3312zM0 917.504V0h1048.576v917.504H0zM655.36 65.536H65.536v720.896H655.36V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 262.144h-262.144v196.608h262.144V327.68z m0 262.144h-262.144v196.608h262.144v-196.608z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table"));
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var i2 = ur$2(Editor$1.nodes(t3, { match: function(t4) {
        return rl$1.checkNodeType(t4, "table-cell");
      }, universal: true }), 1), a2 = ur$2(i2[0], 2), l2 = a2[0], u2 = a2[1], c2 = rl$1.getParentNode(t3, l2);
      if (null != c2) {
        var f2 = rl$1.getParentNode(t3, c2);
        if (null != f2)
          (f2.children || []).forEach(function(n3, r2) {
            Element$1.isElement(n3) && (n3.children || []).forEach(function(n4) {
              var i3 = rl$1.findPath(t3, n4);
              if (i3.length === u2.length && lodash_isequal(i3.slice(-1), u2.slice(-1))) {
                var a3 = { type: "table-cell", children: [{ text: "" }] };
                0 === r2 && Sr$2(f2) && (a3.isHeader = true), Transforms.insertNodes(t3, a3, { at: i3 });
              }
            });
          });
      }
    }
  }, t2;
}(), vi$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.deleteCol"), this.iconSvg = '<svg viewBox="0 0 1048 1024"><path d="M327.68 510.976L393.216 445.44v-13.1072L327.68 366.7968V510.976z m327.68-78.4384l65.536-65.536V507.904L655.36 442.368v-9.8304z m393.216 484.9664V0H0v917.504h1048.576z m-65.536-131.072h-262.144v-52.4288l-13.1072 13.1072-52.4288-52.4288v91.7504H393.216v-91.7504l-52.4288 52.4288-13.1072-13.1072v52.4288H65.536V65.536H327.68v121.2416l36.0448-36.0448 29.4912 29.4912V62.2592h262.144V180.224l49.152-49.152 16.384 16.384V62.2592h262.144V786.432z m-294.912-108.1344l-160.5632-160.5632-167.1168 167.1168-78.6432-78.6432 167.1168-167.1168L288.3584 278.528l78.6432-78.6432 160.5632 160.5632 163.84-163.84 78.6432 78.6432-163.84 163.84 160.5632 160.5632-78.6432 78.6432z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table-cell"));
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var i2 = ur$2(Editor$1.nodes(t3, { match: function(t4) {
        return rl$1.checkNodeType(t4, "table-cell");
      }, universal: true }), 1), a2 = ur$2(i2[0], 2), l2 = a2[0], u2 = a2[1], c2 = rl$1.getParentNode(t3, l2), f2 = (null == c2 ? void 0 : c2.children.length) || 0;
      if (!c2 || f2 <= 1)
        Transforms.removeNodes(t3, { mode: "highest" });
      else {
        var d3 = rl$1.getParentNode(t3, c2);
        if (null != d3)
          (d3.children || []).forEach(function(n3) {
            Element$1.isElement(n3) && (n3.children || []).forEach(function(n4) {
              var r2 = rl$1.findPath(t3, n4);
              r2.length === u2.length && lodash_isequal(r2.slice(-1), u2.slice(-1)) && Transforms.removeNodes(t3, { at: r2 });
            });
          });
      }
    }
  }, t2;
}(), hi$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.header"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M704 128l-64 0L384 128 320 128 0 128l0 256 0 64 0 192 0 64 0 256 320 0 64 0 256 0 64 0 320 0 0-256 0-64L1024 448 1024 384 1024 128 704 128zM640 640 384 640 384 448l256 0L640 640zM64 448l256 0 0 192L64 640 64 448zM320 896 64 896l0-192 256 0L320 896zM640 896 384 896l0-192 256 0L640 896zM960 896l-256 0 0-192 256 0L960 896zM960 640l-256 0L704 448l256 0L960 640z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "table");
    return null != n2 && Sr$2(n2);
  }, t2.prototype.isActive = function(t3) {
    return !!this.getValue(t3);
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table"));
  }, t2.prototype.exec = function(t3, n2) {
    if (!this.isDisabled(t3)) {
      var r2 = !n2, i2 = rl$1.getSelectedNodeByType(t3, "table");
      if (null != i2)
        wr$2(i2).forEach(function(n3) {
          return Transforms.setNodes(t3, { isHeader: r2 }, { at: rl$1.findPath(t3, n3) });
        });
    }
  }, t2;
}(), gi$2 = function() {
  function t2() {
    this.title = lp$1("tableModule.widthAuto"), this.iconSvg = '<svg viewBox="0 0 1228 1024"><path d="M862.514337 563.200461H404.581995v121.753478a13.311987 13.311987 0 0 1-6.655993 11.468789 10.23999 10.23999 0 0 1-12.083188-1.433599l-204.799795-179.199821a13.721586 13.721586 0 0 1 0-20.479979l204.799795-179.302221a10.23999 10.23999 0 0 1 12.185588-1.535998 13.209587 13.209587 0 0 1 6.553593 11.673588v115.097485h457.932342V319.693504a11.571188 11.571188 0 0 1 18.841582-10.239989l204.799795 179.19982a13.721586 13.721586 0 0 1 0 20.47998l-204.799795 179.199821a10.23999 10.23999 0 0 1-12.185588 1.535998 13.311987 13.311987 0 0 1-6.655994-11.571188V563.200461zM136.499064 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785H15.155185A15.155185 15.155185 0 0 1 0 1008.844815V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086294a15.155185 15.155185 0 0 1 15.257585 15.155185zM1228.798771 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785h-106.188693a15.155185 15.155185 0 0 1-15.155185-15.052785V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086293A15.155185 15.155185 0 0 1 1228.798771 15.053809z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    var n2 = rl$1.getSelectedNodeByType(t3, "table");
    return null != n2 && "100%" === n2.width;
  }, t2.prototype.isActive = function(t3) {
    return !!this.getValue(t3);
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || null == rl$1.getSelectedNodeByType(t3, "table"));
  }, t2.prototype.exec = function(t3, e3) {
    if (!this.isDisabled(t3)) {
      var n2 = { width: e3 ? "auto" : "100%" };
      Transforms.setNodes(t3, n2, { mode: "highest" });
    }
  }, t2;
}(), yi$2 = { renderElems: [Oo$2, Ho$2, Vo$2], elemsToHtml: [zo$2, Po$2, Lo$2], preParseHtml: [Ro$2], parseElemsHtml: [Jo$2, Qo$2, Zo$2], menus: [{ key: "insertTable", factory: function() {
  return new ti$2();
} }, { key: "deleteTable", factory: function() {
  return new ei$2();
} }, { key: "insertTableRow", factory: function() {
  return new ni$2();
} }, { key: "deleteTableRow", factory: function() {
  return new ri$2();
} }, { key: "insertTableCol", factory: function() {
  return new pi$2();
} }, { key: "deleteTableCol", factory: function() {
  return new vi$2();
} }, { key: "tableHeader", factory: function() {
  return new hi$2();
} }, { key: "tableFullWidth", factory: function() {
  return new gi$2();
} }], editorPlugin: function(t2) {
  var n2 = t2.insertBreak, l2 = t2.deleteBackward, u2 = t2.deleteForward, c2 = t2.normalizeNode, s2 = t2.insertData, f2 = t2.handleTab, d3 = t2.selectAll, p2 = t2;
  return p2.insertBreak = function() {
    null == rl$1.getSelectedNodeByType(p2, "table") ? n2() : p2.insertText("\n");
  }, p2.deleteBackward = function(t3) {
    if (!cr$2(p2)) {
      var e3 = p2.selection;
      if (e3) {
        var n3 = Editor$1.before(p2, e3);
        if (n3) {
          var o2 = sr$2(p2, n3), i2 = sr$2(p2, e3);
          if (o2 && !i2)
            return;
        }
      }
      l2(t3);
    }
  }, p2.handleTab = function() {
    var n3;
    if (rl$1.getSelectedNodeByType(p2, "table")) {
      var i2 = Editor$1.above(t2);
      rl$1.checkNodeType(i2[0], "table-cell") && Transforms.select(t2, i2[1]);
      var a2 = Editor$1.next(t2);
      if (a2)
        a2[0] && a2[0].text && (a2 = null !== (n3 = Editor$1.above(t2, { at: a2[1] })) && void 0 !== n3 ? n3 : a2), Transforms.select(t2, a2[1]);
      else {
        var l3 = p2.children || [], u3 = l3.length;
        if (rl$1.checkNodeType(l3[u3 - 1], "table")) {
          var c3 = rl$1.genEmptyParagraph();
          Transforms.insertNodes(p2, c3, { at: [u3] }), p2.handleTab();
        }
      }
    } else
      f2();
  }, p2.deleteForward = function(t3) {
    cr$2(p2) || u2(t3);
  }, p2.normalizeNode = function(t3) {
    var n3 = ur$2(t3, 2), r2 = n3[0], i2 = n3[1];
    if ("table" !== rl$1.getNodeType(r2))
      return c2([r2, i2]);
    if (rl$1.isLastNode(p2, r2)) {
      var a2 = rl$1.genEmptyParagraph();
      Transforms.insertNodes(p2, a2, { at: [i2[0] + 1] });
    }
  }, p2.insertData = function(t3) {
    if (null != rl$1.getSelectedNodeByType(p2, "table")) {
      var n3 = t3.getData("text/plain");
      "\n" === n3 || /<img[^>]+>/.test(t3.getData("text/html")) ? s2(t3) : Editor$1.insertText(p2, n3);
    } else
      s2(t3);
  }, p2.selectAll = function() {
    var t3 = p2.selection;
    if (null != t3) {
      var n3 = rl$1.getSelectedNodeByType(p2, "table-cell");
      if (null != n3) {
        var o2 = t3.anchor, l3 = t3.focus;
        if (Path.equals(o2.path.slice(0, 3), l3.path.slice(0, 3)))
          if (0 !== Node$1.string(n3).length) {
            var u3 = rl$1.findPath(p2, n3), c3 = { anchor: Editor$1.start(p2, u3), focus: Editor$1.end(p2, u3) };
            p2.select(c3);
          } else
            d3();
        else
          d3();
      } else
        d3();
    } else
      d3();
  }, p2;
} };
ip$1("en", { videoModule: { delete: "Delete", uploadVideo: "Upload video", insertVideo: "Insert video", videoSrc: "Video source", videoSrcPlaceHolder: "Video file url, or third-party <iframe>", videoPoster: "Video poster", videoPosterPlaceHolder: "Poster image url", ok: "Ok", editSize: "Edit size", width: "Width", height: "Height" } }), ip$1("zh-CN", { videoModule: { delete: "\u5220\u9664\u89C6\u9891", uploadVideo: "\u4E0A\u4F20\u89C6\u9891", insertVideo: "\u63D2\u5165\u89C6\u9891", videoSrc: "\u89C6\u9891\u5730\u5740", videoSrcPlaceHolder: "\u89C6\u9891\u6587\u4EF6 url \u6216\u7B2C\u4E09\u65B9 <iframe>", videoPoster: "\u89C6\u9891\u5C01\u9762", videoPosterPlaceHolder: "\u5C01\u9762\u56FE\u7247 url", ok: "\u786E\u5B9A", editSize: "\u4FEE\u6539\u5C3A\u5BF8", width: "\u5BBD\u5EA6", height: "\u9AD8\u5EA6" } });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var S$2 = function() {
  return S$2 = Object.assign || function(t2) {
    for (var e3, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in e3 = arguments[n2])
        Object.prototype.hasOwnProperty.call(e3, o2) && (t2[o2] = e3[o2]);
    return t2;
  }, S$2.apply(this, arguments);
};
function x$2(t2, e3, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function u2(t3) {
      try {
        c2(r2.next(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function a2(t3) {
      try {
        c2(r2.throw(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function c2(t3) {
      var e4;
      t3.done ? o2(t3.value) : (e4 = t3.value, e4 instanceof n2 ? e4 : new n2(function(t4) {
        t4(e4);
      })).then(u2, a2);
    }
    c2((r2 = r2.apply(t2, e3 || [])).next());
  });
}
function O$2(t2, e3) {
  var n2, r2, o2, i2, u2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function a2(i3) {
    return function(a3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; u2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return u2.label++, { value: i4[1], done: false };
              case 5:
                u2.label++, r2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = u2.ops.pop(), u2.trys.pop();
                continue;
              default:
                if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                  u2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  u2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && u2.label < o2[1]) {
                  u2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && u2.label < o2[2]) {
                  u2.label = o2[2], u2.ops.push(i4);
                  break;
                }
                o2[2] && u2.ops.pop(), u2.trys.pop();
                continue;
            }
            i4 = e3.call(t2, u2);
          } catch (t3) {
            i4 = [6, t3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      }([i3, a3]);
    };
  }
}
function E$2(t2) {
  var e3 = "function" == typeof Symbol && Symbol.iterator, n2 = e3 && t2[e3], r2 = 0;
  if (n2)
    return n2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
    } };
  throw new TypeError(e3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function j$2(t2, e3) {
  var n2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!n2)
    return t2;
  var r2, o2, i2 = n2.call(t2), u2 = [];
  try {
    for (; (void 0 === e3 || e3-- > 0) && !(r2 = i2.next()).done; )
      u2.push(r2.value);
  } catch (t3) {
    o2 = { error: t3 };
  } finally {
    try {
      r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
    } finally {
      if (o2)
        throw o2.error;
    }
  }
  return u2;
}
function I$2(t2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e3, n2 = t2[Symbol.asyncIterator];
  return n2 ? n2.call(t2) : (t2 = E$2(t2), e3 = {}, r2("next"), r2("throw"), r2("return"), e3[Symbol.asyncIterator] = function() {
    return this;
  }, e3);
  function r2(n3) {
    e3[n3] = t2[n3] && function(e4) {
      return new Promise(function(r3, o2) {
        (function(t3, e5, n4, r4) {
          Promise.resolve(r4).then(function(e6) {
            t3({ value: e6, done: n4 });
          }, e5);
        })(r3, o2, (e4 = t2[n3](e4)).done, e4.value);
      });
    };
  }
}
var P$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function T$2(t2) {
  var e3 = { exports: {} };
  return t2(e3, e3.exports), e3.exports;
}
var M$2, A$2, k$2 = function(t2) {
  return t2 && t2.Math == Math && t2;
}, R$2 = k$2("object" == typeof globalThis && globalThis) || k$2("object" == typeof window && window) || k$2("object" == typeof self && self) || k$2("object" == typeof P$2 && P$2) || function() {
  return this;
}() || Function("return this")(), C$2 = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, N$2 = !C$2(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), L$2 = Function.prototype.call, V$2 = L$2.bind ? L$2.bind(L$2) : function() {
  return L$2.apply(L$2, arguments);
}, z$2 = {}.propertyIsEnumerable, F$2 = Object.getOwnPropertyDescriptor, _$2 = { f: F$2 && !z$2.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = F$2(this, t2);
  return !!e3 && e3.enumerable;
} : z$2 }, D$2 = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, $$2 = Function.prototype, H$2 = $$2.bind, B$2 = $$2.call, G$2 = H$2 && H$2.bind(B$2), W$2 = H$2 ? function(t2) {
  return t2 && G$2(B$2, t2);
} : function(t2) {
  return t2 && function() {
    return B$2.apply(t2, arguments);
  };
}, U$2 = W$2({}.toString), K$2 = W$2("".slice), X$2 = function(t2) {
  return K$2(U$2(t2), 8, -1);
}, Y$2 = R$2.Object, q$2 = W$2("".split), J$2 = C$2(function() {
  return !Y$2("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == X$2(t2) ? q$2(t2, "") : Y$2(t2);
} : Y$2, Q$2 = R$2.TypeError, Z$2 = function(t2) {
  if (null == t2)
    throw Q$2("Can't call method on " + t2);
  return t2;
}, tt$2 = function(t2) {
  return J$2(Z$2(t2));
}, et$2 = function(t2) {
  return "function" == typeof t2;
}, nt$2 = function(t2) {
  return "object" == typeof t2 ? null !== t2 : et$2(t2);
}, rt$2 = function(t2) {
  return et$2(t2) ? t2 : void 0;
}, ot$2 = function(t2, e3) {
  return arguments.length < 2 ? rt$2(R$2[t2]) : R$2[t2] && R$2[t2][e3];
}, it$2 = W$2({}.isPrototypeOf), ut$2 = ot$2("navigator", "userAgent") || "", at$2 = R$2.process, ct$2 = R$2.Deno, st$2 = at$2 && at$2.versions || ct$2 && ct$2.version, ft$2 = st$2 && st$2.v8;
ft$2 && (A$2 = (M$2 = ft$2.split("."))[0] > 0 && M$2[0] < 4 ? 1 : +(M$2[0] + M$2[1])), !A$2 && ut$2 && (!(M$2 = ut$2.match(/Edge\/(\d+)/)) || M$2[1] >= 74) && (M$2 = ut$2.match(/Chrome\/(\d+)/)) && (A$2 = +M$2[1]);
var lt$2 = A$2, dt$2 = !!Object.getOwnPropertySymbols && !C$2(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && lt$2 && lt$2 < 41;
}), pt$2 = dt$2 && !Symbol.sham && "symbol" == typeof Symbol.iterator, vt$2 = R$2.Object, ht$2 = pt$2 ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = ot$2("Symbol");
  return et$2(e3) && it$2(e3.prototype, vt$2(t2));
}, yt$2 = R$2.String, gt$2 = function(t2) {
  try {
    return yt$2(t2);
  } catch (t3) {
    return "Object";
  }
}, mt$2 = R$2.TypeError, bt$2 = function(t2) {
  if (et$2(t2))
    return t2;
  throw mt$2(gt$2(t2) + " is not a function");
}, wt$2 = function(t2, e3) {
  var n2 = t2[e3];
  return null == n2 ? void 0 : bt$2(n2);
}, St$2 = R$2.TypeError, xt$2 = Object.defineProperty, Ot$2 = function(t2, e3) {
  try {
    xt$2(R$2, t2, { value: e3, configurable: true, writable: true });
  } catch (n2) {
    R$2[t2] = e3;
  }
  return e3;
}, Et$2 = R$2["__core-js_shared__"] || Ot$2("__core-js_shared__", {}), jt$2 = T$2(function(t2) {
  (t2.exports = function(t3, e3) {
    return Et$2[t3] || (Et$2[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), It$2 = R$2.Object, Pt$2 = function(t2) {
  return It$2(Z$2(t2));
}, Tt$2 = W$2({}.hasOwnProperty), Mt$2 = Object.hasOwn || function(t2, e3) {
  return Tt$2(Pt$2(t2), e3);
}, At$2 = 0, kt$2 = Math.random(), Rt$2 = W$2(1 .toString), Ct$2 = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + Rt$2(++At$2 + kt$2, 36);
}, Nt$2 = jt$2("wks"), Lt$2 = R$2.Symbol, Vt$2 = Lt$2 && Lt$2.for, zt$2 = pt$2 ? Lt$2 : Lt$2 && Lt$2.withoutSetter || Ct$2, Ft$2 = function(t2) {
  if (!Mt$2(Nt$2, t2) || !dt$2 && "string" != typeof Nt$2[t2]) {
    var e3 = "Symbol." + t2;
    dt$2 && Mt$2(Lt$2, t2) ? Nt$2[t2] = Lt$2[t2] : Nt$2[t2] = pt$2 && Vt$2 ? Vt$2(e3) : zt$2(e3);
  }
  return Nt$2[t2];
}, _t$2 = R$2.TypeError, Dt$2 = Ft$2("toPrimitive"), $t$2 = function(t2, e3) {
  if (!nt$2(t2) || ht$2(t2))
    return t2;
  var n2, r2 = wt$2(t2, Dt$2);
  if (r2) {
    if (void 0 === e3 && (e3 = "default"), n2 = V$2(r2, t2, e3), !nt$2(n2) || ht$2(n2))
      return n2;
    throw _t$2("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var n3, r3;
    if ("string" === e4 && et$2(n3 = t3.toString) && !nt$2(r3 = V$2(n3, t3)))
      return r3;
    if (et$2(n3 = t3.valueOf) && !nt$2(r3 = V$2(n3, t3)))
      return r3;
    if ("string" !== e4 && et$2(n3 = t3.toString) && !nt$2(r3 = V$2(n3, t3)))
      return r3;
    throw St$2("Can't convert object to primitive value");
  }(t2, e3);
}, Ht$2 = function(t2) {
  var e3 = $t$2(t2, "string");
  return ht$2(e3) ? e3 : e3 + "";
}, Bt$2 = R$2.document, Gt$2 = nt$2(Bt$2) && nt$2(Bt$2.createElement), Wt$2 = function(t2) {
  return Gt$2 ? Bt$2.createElement(t2) : {};
}, Ut$2 = !N$2 && !C$2(function() {
  return 7 != Object.defineProperty(Wt$2("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Kt$2 = Object.getOwnPropertyDescriptor, Xt$2 = { f: N$2 ? Kt$2 : function(t2, e3) {
  if (t2 = tt$2(t2), e3 = Ht$2(e3), Ut$2)
    try {
      return Kt$2(t2, e3);
    } catch (t3) {
    }
  if (Mt$2(t2, e3))
    return D$2(!V$2(_$2.f, t2, e3), t2[e3]);
} }, Yt$2 = R$2.String, qt$2 = R$2.TypeError, Jt$2 = function(t2) {
  if (nt$2(t2))
    return t2;
  throw qt$2(Yt$2(t2) + " is not an object");
}, Qt$2 = R$2.TypeError, Zt$2 = Object.defineProperty, te$2 = { f: N$2 ? Zt$2 : function(t2, e3, n2) {
  if (Jt$2(t2), e3 = Ht$2(e3), Jt$2(n2), Ut$2)
    try {
      return Zt$2(t2, e3, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw Qt$2("Accessors not supported");
  return "value" in n2 && (t2[e3] = n2.value), t2;
} }, ee$2 = N$2 ? function(t2, e3, n2) {
  return te$2.f(t2, e3, D$2(1, n2));
} : function(t2, e3, n2) {
  return t2[e3] = n2, t2;
}, ne$2 = W$2(Function.toString);
et$2(Et$2.inspectSource) || (Et$2.inspectSource = function(t2) {
  return ne$2(t2);
});
var re$2, oe$2, ie$2, ue$2 = Et$2.inspectSource, ae$2 = R$2.WeakMap, ce$2 = et$2(ae$2) && /native code/.test(ue$2(ae$2)), se$2 = jt$2("keys"), fe$2 = function(t2) {
  return se$2[t2] || (se$2[t2] = Ct$2(t2));
}, le$2 = {}, de$2 = R$2.TypeError, pe$2 = R$2.WeakMap;
if (ce$2 || Et$2.state) {
  var ve$2 = Et$2.state || (Et$2.state = new pe$2()), he$2 = W$2(ve$2.get), ye$2 = W$2(ve$2.has), ge$2 = W$2(ve$2.set);
  re$2 = function(t2, e3) {
    if (ye$2(ve$2, t2))
      throw new de$2("Object already initialized");
    return e3.facade = t2, ge$2(ve$2, t2, e3), e3;
  }, oe$2 = function(t2) {
    return he$2(ve$2, t2) || {};
  }, ie$2 = function(t2) {
    return ye$2(ve$2, t2);
  };
} else {
  var me$2 = fe$2("state");
  le$2[me$2] = true, re$2 = function(t2, e3) {
    if (Mt$2(t2, me$2))
      throw new de$2("Object already initialized");
    return e3.facade = t2, ee$2(t2, me$2, e3), e3;
  }, oe$2 = function(t2) {
    return Mt$2(t2, me$2) ? t2[me$2] : {};
  }, ie$2 = function(t2) {
    return Mt$2(t2, me$2);
  };
}
var be$2 = { set: re$2, get: oe$2, has: ie$2, enforce: function(t2) {
  return ie$2(t2) ? oe$2(t2) : re$2(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var n2;
    if (!nt$2(e3) || (n2 = oe$2(e3)).type !== t2)
      throw de$2("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, we$2 = Function.prototype, Se$2 = N$2 && Object.getOwnPropertyDescriptor, xe$2 = Mt$2(we$2, "name"), Oe$2 = { EXISTS: xe$2, PROPER: xe$2 && "something" === function() {
}.name, CONFIGURABLE: xe$2 && (!N$2 || N$2 && Se$2(we$2, "name").configurable) }, Ee$2 = T$2(function(t2) {
  var e3 = Oe$2.CONFIGURABLE, n2 = be$2.get, r2 = be$2.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, n3, i2, u2) {
    var a2, c2 = !!u2 && !!u2.unsafe, s2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet, l2 = u2 && void 0 !== u2.name ? u2.name : n3;
    et$2(i2) && ("Symbol(" === String(l2).slice(0, 7) && (l2 = "[" + String(l2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Mt$2(i2, "name") || e3 && i2.name !== l2) && ee$2(i2, "name", l2), (a2 = r2(i2)).source || (a2.source = o2.join("string" == typeof l2 ? l2 : ""))), t3 !== R$2 ? (c2 ? !f2 && t3[n3] && (s2 = true) : delete t3[n3], s2 ? t3[n3] = i2 : ee$2(t3, n3, i2)) : s2 ? t3[n3] = i2 : Ot$2(n3, i2);
  })(Function.prototype, "toString", function() {
    return et$2(this) && n2(this).source || ue$2(this);
  });
}), je$2 = Math.ceil, Ie$2 = Math.floor, Pe$2 = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? Ie$2 : je$2)(e3);
}, Te$2 = Math.max, Me$2 = Math.min, Ae$2 = function(t2, e3) {
  var n2 = Pe$2(t2);
  return n2 < 0 ? Te$2(n2 + e3, 0) : Me$2(n2, e3);
}, ke$2 = Math.min, Re$2 = function(t2) {
  return t2 > 0 ? ke$2(Pe$2(t2), 9007199254740991) : 0;
}, Ce$2 = function(t2) {
  return Re$2(t2.length);
}, Ne$2 = function(t2) {
  return function(e3, n2, r2) {
    var o2, i2 = tt$2(e3), u2 = Ce$2(i2), a2 = Ae$2(r2, u2);
    if (t2 && n2 != n2) {
      for (; u2 > a2; )
        if ((o2 = i2[a2++]) != o2)
          return true;
    } else
      for (; u2 > a2; a2++)
        if ((t2 || a2 in i2) && i2[a2] === n2)
          return t2 || a2 || 0;
    return !t2 && -1;
  };
}, Le$2 = { includes: Ne$2(true), indexOf: Ne$2(false) }, Ve$2 = Le$2.indexOf, ze$2 = W$2([].push), Fe$2 = function(t2, e3) {
  var n2, r2 = tt$2(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !Mt$2(le$2, n2) && Mt$2(r2, n2) && ze$2(i2, n2);
  for (; e3.length > o2; )
    Mt$2(r2, n2 = e3[o2++]) && (~Ve$2(i2, n2) || ze$2(i2, n2));
  return i2;
}, _e$2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], De$2 = _e$2.concat("length", "prototype"), $e$2 = { f: Object.getOwnPropertyNames || function(t2) {
  return Fe$2(t2, De$2);
} }, He$2 = { f: Object.getOwnPropertySymbols }, Be$2 = W$2([].concat), Ge$2 = ot$2("Reflect", "ownKeys") || function(t2) {
  var e3 = $e$2.f(Jt$2(t2)), n2 = He$2.f;
  return n2 ? Be$2(e3, n2(t2)) : e3;
}, We$2 = function(t2, e3) {
  for (var n2 = Ge$2(e3), r2 = te$2.f, o2 = Xt$2.f, i2 = 0; i2 < n2.length; i2++) {
    var u2 = n2[i2];
    Mt$2(t2, u2) || r2(t2, u2, o2(e3, u2));
  }
}, Ue$2 = /#|\.prototype\./, Ke$2 = function(t2, e3) {
  var n2 = Ye$2[Xe$2(t2)];
  return n2 == Je$2 || n2 != qe$2 && (et$2(e3) ? C$2(e3) : !!e3);
}, Xe$2 = Ke$2.normalize = function(t2) {
  return String(t2).replace(Ue$2, ".").toLowerCase();
}, Ye$2 = Ke$2.data = {}, qe$2 = Ke$2.NATIVE = "N", Je$2 = Ke$2.POLYFILL = "P", Qe$2 = Ke$2, Ze$2 = Xt$2.f, tn$2 = function(t2, e3) {
  var n2, r2, o2, i2, u2, a2 = t2.target, c2 = t2.global, s2 = t2.stat;
  if (n2 = c2 ? R$2 : s2 ? R$2[a2] || Ot$2(a2, {}) : (R$2[a2] || {}).prototype)
    for (r2 in e3) {
      if (i2 = e3[r2], o2 = t2.noTargetGet ? (u2 = Ze$2(n2, r2)) && u2.value : n2[r2], !Qe$2(c2 ? r2 : a2 + (s2 ? "." : "#") + r2, t2.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        We$2(i2, o2);
      }
      (t2.sham || o2 && o2.sham) && ee$2(i2, "sham", true), Ee$2(n2, r2, i2, t2);
    }
}, en$2 = {};
en$2[Ft$2("toStringTag")] = "z";
var nn$2, rn$2 = "[object z]" === String(en$2), on$2 = Ft$2("toStringTag"), un$2 = R$2.Object, an$2 = "Arguments" == X$2(function() {
  return arguments;
}()), cn$2 = rn$2 ? X$2 : function(t2) {
  var e3, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = un$2(t2), on$2)) ? n2 : an$2 ? X$2(e3) : "Object" == (r2 = X$2(e3)) && et$2(e3.callee) ? "Arguments" : r2;
}, sn$2 = R$2.String, fn$2 = function(t2) {
  if ("Symbol" === cn$2(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return sn$2(t2);
}, ln$2 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", dn$2 = W$2("".replace), pn$2 = "[" + ln$2 + "]", vn$2 = RegExp("^" + pn$2 + pn$2 + "*"), hn$2 = RegExp(pn$2 + pn$2 + "*$"), yn$2 = function(t2) {
  return function(e3) {
    var n2 = fn$2(Z$2(e3));
    return 1 & t2 && (n2 = dn$2(n2, vn$2, "")), 2 & t2 && (n2 = dn$2(n2, hn$2, "")), n2;
  };
}, gn$2 = { start: yn$2(1), end: yn$2(2), trim: yn$2(3) }, mn$2 = Oe$2.PROPER, bn$2 = gn$2.trim;
function wn$2(t2) {
  return t2.length ? t2[0].tagName.toLowerCase() : "";
}
function Sn$2(t2, e3, n2) {
  void 0 === e3 && (e3 = "auto"), void 0 === n2 && (n2 = "auto");
  var r2 = $$6(t2);
  return r2.attr("width", e3), r2.attr("height", n2), r2[0].outerHTML;
}
tn$2({ target: "String", proto: true, forced: (nn$2 = "trim", C$2(function() {
  return !!ln$2[nn$2]() || "\u200B\x85\u180E" !== "\u200B\x85\u180E"[nn$2]() || mn$2 && ln$2[nn$2].name !== nn$2;
})) }, { trim: function() {
  return bn$2(this);
} }), tn$2({ global: true }, { globalThis: R$2 }), append && ($$6.fn.append = append), on$7 && ($$6.fn.on = on$7), focus$1 && ($$6.fn.focus = focus$1), attr && ($$6.fn.attr = attr), val && ($$6.fn.val = val), html && ($$6.fn.html = html), parent && ($$6.fn.parent = parent), hasClass && ($$6.fn.hasClass = hasClass), empty && ($$6.fn.empty = empty);
var xn$2 = { type: "video", renderElem: function(t2, n2, r2) {
  var o2, i2 = t2, u2 = i2.src, a2 = void 0 === u2 ? "" : u2, f2 = i2.poster, l2 = void 0 === f2 ? "" : f2, d3 = i2.width, p2 = void 0 === d3 ? "auto" : d3, v2 = i2.height, h2 = void 0 === v2 ? "auto" : v2, y2 = rl$1.isNodeSelected(r2, t2);
  if (0 === a2.trim().indexOf("<iframe ")) {
    var g2 = Sn$2(a2, p2, h2);
    o2 = jsx("div", { className: "w-e-textarea-video-container", "data-selected": y2 ? "true" : "", innerHTML: g2 });
  } else {
    var m2 = jsx("video", { poster: l2, controls: true }, jsx("source", { src: a2, type: "video/mp4" }), "Sorry, your browser doesn't support embedded videos.\n \u62B1\u6B49\uFF0C\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 video \u89C6\u9891");
    "auto" !== p2 && (m2.data.width = p2), "auto" !== h2 && (m2.data.height = h2), o2 = jsx("div", { className: "w-e-textarea-video-container", "data-selected": y2 ? "true" : "" }, m2);
  }
  return h$3("div", { props: { contentEditable: false }, on: { mousedown: function(t3) {
    return t3.preventDefault();
  } } }, o2);
} };
var On$2, En$2 = { type: "video", elemToHtml: function(t2, e3) {
  var n2 = t2, r2 = n2.src, o2 = void 0 === r2 ? "" : r2, i2 = n2.poster, u2 = void 0 === i2 ? "" : i2, a2 = n2.width, c2 = void 0 === a2 ? "auto" : a2, s2 = n2.height, f2 = void 0 === s2 ? "auto" : s2, l2 = '<div data-w-e-type="video" data-w-e-is-void>\n';
  return 0 === o2.trim().indexOf("<iframe ") ? l2 += Sn$2(o2, c2, f2) : l2 += '<video poster="' + u2 + '" controls="true" width="' + c2 + '" height="' + f2 + '"><source src="' + o2 + '" type="video/mp4"/></video>', l2 += "\n</div>";
} }, jn$2 = Object.keys || function(t2) {
  return Fe$2(t2, _e$2);
}, In$2 = N$2 ? Object.defineProperties : function(t2, e3) {
  Jt$2(t2);
  for (var n2, r2 = tt$2(e3), o2 = jn$2(e3), i2 = o2.length, u2 = 0; i2 > u2; )
    te$2.f(t2, n2 = o2[u2++], r2[n2]);
  return t2;
}, Pn$2 = ot$2("document", "documentElement"), Tn$2 = fe$2("IE_PROTO"), Mn$2 = function() {
}, An$2 = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, kn$2 = function(t2) {
  t2.write(An$2("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, Rn$2 = function() {
  try {
    On$2 = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  Rn$2 = "undefined" != typeof document ? document.domain && On$2 ? kn$2(On$2) : ((e3 = Wt$2("iframe")).style.display = "none", Pn$2.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(An$2("document.F=Object")), t2.close(), t2.F) : kn$2(On$2);
  for (var n2 = _e$2.length; n2--; )
    delete Rn$2.prototype[_e$2[n2]];
  return Rn$2();
};
le$2[Tn$2] = true;
var Cn$2 = Object.create || function(t2, e3) {
  var n2;
  return null !== t2 ? (Mn$2.prototype = Jt$2(t2), n2 = new Mn$2(), Mn$2.prototype = null, n2[Tn$2] = t2) : n2 = Rn$2(), void 0 === e3 ? n2 : In$2(n2, e3);
}, Nn$2 = Ft$2("unscopables"), Ln$2 = Array.prototype;
null == Ln$2[Nn$2] && te$2.f(Ln$2, Nn$2, { configurable: true, value: Cn$2(null) });
var Vn$2 = function(t2) {
  Ln$2[Nn$2][t2] = true;
}, zn$2 = Le$2.includes;
tn$2({ target: "Array", proto: true }, { includes: function(t2) {
  return zn$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), Vn$2("includes");
var Fn$2 = { selector: "iframe,video,p", preParseHtml: function(t2) {
  var e3 = $$6(t2), n2 = e3;
  if ("p" === wn$2(e3)) {
    var r2 = e3.children();
    if (1 === r2.length) {
      var o2 = r2[0], i2 = o2.tagName.toLowerCase();
      ["iframe", "video"].includes(i2) && (n2 = $$6(o2));
    }
  }
  var u2 = wn$2(n2);
  if ("iframe" !== u2 && "video" !== u2)
    return n2[0];
  if ("video" === n2.parent().attr("data-w-e-type"))
    return n2[0];
  var a2 = $$6('<div data-w-e-type="video" data-w-e-is-void></div>');
  return a2.append(n2), a2[0];
} }, _n$2 = W$2(W$2.bind), Dn$2 = function(t2, e3) {
  return bt$2(t2), void 0 === e3 ? t2 : _n$2 ? _n$2(t2, e3) : function() {
    return t2.apply(e3, arguments);
  };
}, $n$2 = Array.isArray || function(t2) {
  return "Array" == X$2(t2);
}, Hn$2 = function() {
}, Bn$2 = [], Gn$2 = ot$2("Reflect", "construct"), Wn$2 = /^\s*(?:class|function)\b/, Un$2 = W$2(Wn$2.exec), Kn$2 = !Wn$2.exec(Hn$2), Xn$2 = function(t2) {
  if (!et$2(t2))
    return false;
  try {
    return Gn$2(Hn$2, Bn$2, t2), true;
  } catch (t3) {
    return false;
  }
}, Yn$2 = !Gn$2 || C$2(function() {
  var t2;
  return Xn$2(Xn$2.call) || !Xn$2(Object) || !Xn$2(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!et$2(t2))
    return false;
  switch (cn$2(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return Kn$2 || !!Un$2(Wn$2, ue$2(t2));
} : Xn$2, qn$2 = Ft$2("species"), Jn$2 = R$2.Array, Qn$2 = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return $n$2(t3) && (e4 = t3.constructor, (Yn$2(e4) && (e4 === Jn$2 || $n$2(e4.prototype)) || nt$2(e4) && null === (e4 = e4[qn$2])) && (e4 = void 0)), void 0 === e4 ? Jn$2 : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, Zn$2 = W$2([].push), tr$1 = function(t2) {
  var e3 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
  return function(c2, s2, f2, l2) {
    for (var d3, p2, v2 = Pt$2(c2), h2 = J$2(v2), y2 = Dn$2(s2, f2), g2 = Ce$2(h2), m2 = 0, b2 = l2 || Qn$2, w2 = e3 ? b2(c2, g2) : n2 || u2 ? b2(c2, 0) : void 0; g2 > m2; m2++)
      if ((a2 || m2 in h2) && (p2 = y2(d3 = h2[m2], m2, v2), t2))
        if (e3)
          w2[m2] = p2;
        else if (p2)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return d3;
            case 6:
              return m2;
            case 2:
              Zn$2(w2, d3);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              Zn$2(w2, d3);
          }
    return i2 ? -1 : r2 || o2 ? o2 : w2;
  };
}, er$1 = { forEach: tr$1(0), map: tr$1(1), filter: tr$1(2), some: tr$1(3), every: tr$1(4), find: tr$1(5), findIndex: tr$1(6), filterReject: tr$1(7) }, nr$1 = er$1.find, rr$1 = true;
"find" in [] && Array(1).find(function() {
  rr$1 = false;
}), tn$2({ target: "Array", proto: true, forced: rr$1 }, { find: function(t2) {
  return nr$1(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), Vn$2("find");
var or$1 = rn$2 ? {}.toString : function() {
  return "[object " + cn$2(this) + "]";
};
function ir$1(t2, e3, n2, r2) {
  return void 0 === e3 && (e3 = ""), void 0 === n2 && (n2 = "auto"), void 0 === r2 && (r2 = "auto"), { type: "video", src: t2, poster: e3, width: n2, height: r2, children: [{ text: "" }] };
}
rn$2 || Ee$2(Object.prototype, "toString", or$1, { unsafe: true });
var ur$1, ar$1, cr$1 = { selector: 'div[data-w-e-type="video"]', parseElemHtml: function(t2, e3, n2) {
  var r2 = $$6(t2), o2 = "", i2 = "", u2 = "auto", a2 = "auto", c2 = r2.find("iframe");
  if (c2.length > 0)
    return u2 = c2.attr("width") || "auto", a2 = c2.attr("height") || "auto", ir$1(o2 = c2[0].outerHTML, i2, u2, a2);
  var s2 = r2.find("video");
  return (o2 = s2.attr("src") || "") || s2.length > 0 && (o2 = s2.find("source").attr("src") || ""), u2 = s2.attr("width") || "auto", a2 = s2.attr("height") || "auto", ir$1(o2, i2 = s2.attr("poster") || "", u2, a2);
} }, sr$1 = function() {
  var t2 = Jt$2(this), e3 = "";
  return t2.global && (e3 += "g"), t2.ignoreCase && (e3 += "i"), t2.multiline && (e3 += "m"), t2.dotAll && (e3 += "s"), t2.unicode && (e3 += "u"), t2.sticky && (e3 += "y"), e3;
}, fr$1 = R$2.RegExp, lr$1 = C$2(function() {
  var t2 = fr$1("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), dr$1 = lr$1 || C$2(function() {
  return !fr$1("a", "y").sticky;
}), pr$1 = { BROKEN_CARET: lr$1 || C$2(function() {
  var t2 = fr$1("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}), MISSED_STICKY: dr$1, UNSUPPORTED_Y: lr$1 }, vr$1 = R$2.RegExp, hr$1 = C$2(function() {
  var t2 = vr$1(".", "s");
  return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
}), yr$1 = R$2.RegExp, gr$1 = C$2(function() {
  var t2 = yr$1("(?<a>b)", "g");
  return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
}), mr$1 = be$2.get, br$1 = jt$2("native-string-replace", String.prototype.replace), wr$1 = RegExp.prototype.exec, Sr$1 = wr$1, xr$1 = W$2("".charAt), Or$1 = W$2("".indexOf), Er$1 = W$2("".replace), jr$1 = W$2("".slice), Ir$1 = (ar$1 = /b*/g, V$2(wr$1, ur$1 = /a/, "a"), V$2(wr$1, ar$1, "a"), 0 !== ur$1.lastIndex || 0 !== ar$1.lastIndex), Pr$1 = pr$1.BROKEN_CARET, Tr$1 = void 0 !== /()??/.exec("")[1];
(Ir$1 || Tr$1 || Pr$1 || hr$1 || gr$1) && (Sr$1 = function(t2) {
  var e3, n2, r2, o2, i2, u2, a2, c2 = this, s2 = mr$1(c2), f2 = fn$2(t2), l2 = s2.raw;
  if (l2)
    return l2.lastIndex = c2.lastIndex, e3 = V$2(Sr$1, l2, f2), c2.lastIndex = l2.lastIndex, e3;
  var d3 = s2.groups, p2 = Pr$1 && c2.sticky, v2 = V$2(sr$1, c2), h2 = c2.source, y2 = 0, g2 = f2;
  if (p2 && (v2 = Er$1(v2, "y", ""), -1 === Or$1(v2, "g") && (v2 += "g"), g2 = jr$1(f2, c2.lastIndex), c2.lastIndex > 0 && (!c2.multiline || c2.multiline && "\n" !== xr$1(f2, c2.lastIndex - 1)) && (h2 = "(?: " + h2 + ")", g2 = " " + g2, y2++), n2 = new RegExp("^(?:" + h2 + ")", v2)), Tr$1 && (n2 = new RegExp("^" + h2 + "$(?!\\s)", v2)), Ir$1 && (r2 = c2.lastIndex), o2 = V$2(wr$1, p2 ? n2 : c2, g2), p2 ? o2 ? (o2.input = jr$1(o2.input, y2), o2[0] = jr$1(o2[0], y2), o2.index = c2.lastIndex, c2.lastIndex += o2[0].length) : c2.lastIndex = 0 : Ir$1 && o2 && (c2.lastIndex = c2.global ? o2.index + o2[0].length : r2), Tr$1 && o2 && o2.length > 1 && V$2(br$1, o2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && d3)
    for (o2.groups = u2 = Cn$2(null), i2 = 0; i2 < d3.length; i2++)
      u2[(a2 = d3[i2])[0]] = o2[a2[1]];
  return o2;
});
var Mr$1 = Sr$1;
tn$2({ target: "RegExp", proto: true, forced: /./.exec !== Mr$1 }, { exec: Mr$1 });
var Ar$1 = Function.prototype, kr$1 = Ar$1.apply, Rr$1 = Ar$1.bind, Cr$1 = Ar$1.call, Nr$1 = "object" == typeof Reflect && Reflect.apply || (Rr$1 ? Cr$1.bind(kr$1) : function() {
  return Cr$1.apply(kr$1, arguments);
}), Lr$1 = Ft$2("species"), Vr$1 = RegExp.prototype, zr$1 = W$2("".charAt), Fr$1 = W$2("".charCodeAt), _r$1 = W$2("".slice), Dr$1 = function(t2) {
  return function(e3, n2) {
    var r2, o2, i2 = fn$2(Z$2(e3)), u2 = Pe$2(n2), a2 = i2.length;
    return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = Fr$1(i2, u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = Fr$1(i2, u2 + 1)) < 56320 || o2 > 57343 ? t2 ? zr$1(i2, u2) : r2 : t2 ? _r$1(i2, u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, $r$1 = { codeAt: Dr$1(false), charAt: Dr$1(true) }, Hr$1 = $r$1.charAt, Br$1 = function(t2, e3, n2) {
  return e3 + (n2 ? Hr$1(t2, e3).length : 1);
}, Gr$1 = Math.floor, Wr$1 = W$2("".charAt), Ur$1 = W$2("".replace), Kr$1 = W$2("".slice), Xr$1 = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, Yr$1 = /\$([$&'`]|\d{1,2})/g, qr$1 = function(t2, e3, n2, r2, o2, i2) {
  var u2 = n2 + t2.length, a2 = r2.length, c2 = Yr$1;
  return void 0 !== o2 && (o2 = Pt$2(o2), c2 = Xr$1), Ur$1(i2, c2, function(i3, c3) {
    var s2;
    switch (Wr$1(c3, 0)) {
      case "$":
        return "$";
      case "&":
        return t2;
      case "`":
        return Kr$1(e3, 0, n2);
      case "'":
        return Kr$1(e3, u2);
      case "<":
        s2 = o2[Kr$1(c3, 1, -1)];
        break;
      default:
        var f2 = +c3;
        if (0 === f2)
          return i3;
        if (f2 > a2) {
          var l2 = Gr$1(f2 / 10);
          return 0 === l2 ? i3 : l2 <= a2 ? void 0 === r2[l2 - 1] ? Wr$1(c3, 1) : r2[l2 - 1] + Wr$1(c3, 1) : i3;
        }
        s2 = r2[f2 - 1];
    }
    return void 0 === s2 ? "" : s2;
  });
}, Jr$1 = R$2.TypeError, Qr$1 = function(t2, e3) {
  var n2 = t2.exec;
  if (et$2(n2)) {
    var r2 = V$2(n2, t2, e3);
    return null !== r2 && Jt$2(r2), r2;
  }
  if ("RegExp" === X$2(t2))
    return V$2(Mr$1, t2, e3);
  throw Jr$1("RegExp#exec called on incompatible receiver");
}, Zr$1 = Ft$2("replace"), to$1 = Math.max, eo$1 = Math.min, no$1 = W$2([].concat), ro$1 = W$2([].push), oo$1 = W$2("".indexOf), io$1 = W$2("".slice), uo$1 = "$0" === "a".replace(/./, "$0"), ao$1 = !!/./[Zr$1] && "" === /./[Zr$1]("a", "$0");
function co$1(t2) {
  return void 0 === t2 && (t2 = "r"), t2 + "-" + nanoid$3();
}
!function(t2, e3, n2, r2) {
  var o2 = Ft$2(t2), i2 = !C$2(function() {
    var e4 = {};
    return e4[o2] = function() {
      return 7;
    }, 7 != ""[t2](e4);
  }), u2 = i2 && !C$2(function() {
    var e4 = false, n3 = /a/;
    return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[Lr$1] = function() {
      return n3;
    }, n3.flags = "", n3[o2] = /./[o2]), n3.exec = function() {
      return e4 = true, null;
    }, n3[o2](""), !e4;
  });
  if (!i2 || !u2 || n2) {
    var a2 = W$2(/./[o2]), c2 = e3(o2, ""[t2], function(t3, e4, n3, r3, o3) {
      var u3 = W$2(t3), c3 = e4.exec;
      return c3 === Mr$1 || c3 === Vr$1.exec ? i2 && !o3 ? { done: true, value: a2(e4, n3, r3) } : { done: true, value: u3(n3, e4, r3) } : { done: false };
    });
    Ee$2(String.prototype, t2, c2[0]), Ee$2(Vr$1, o2, c2[1]);
  }
  r2 && ee$2(Vr$1[o2], "sham", true);
}("replace", function(t2, e3, n2) {
  var r2 = ao$1 ? "$" : "$0";
  return [function(t3, n3) {
    var r3 = Z$2(this), o2 = null == t3 ? void 0 : wt$2(t3, Zr$1);
    return o2 ? V$2(o2, t3, r3, n3) : V$2(e3, fn$2(r3), t3, n3);
  }, function(t3, o2) {
    var i2 = Jt$2(this), u2 = fn$2(t3);
    if ("string" == typeof o2 && -1 === oo$1(o2, r2) && -1 === oo$1(o2, "$<")) {
      var a2 = n2(e3, i2, u2, o2);
      if (a2.done)
        return a2.value;
    }
    var c2 = et$2(o2);
    c2 || (o2 = fn$2(o2));
    var s2 = i2.global;
    if (s2) {
      var f2 = i2.unicode;
      i2.lastIndex = 0;
    }
    for (var l2 = []; ; ) {
      var d3 = Qr$1(i2, u2);
      if (null === d3)
        break;
      if (ro$1(l2, d3), !s2)
        break;
      "" === fn$2(d3[0]) && (i2.lastIndex = Br$1(u2, Re$2(i2.lastIndex), f2));
    }
    for (var p2, v2 = "", h2 = 0, y2 = 0; y2 < l2.length; y2++) {
      for (var g2 = fn$2((d3 = l2[y2])[0]), m2 = to$1(eo$1(Pe$2(d3.index), u2.length), 0), b2 = [], w2 = 1; w2 < d3.length; w2++)
        ro$1(b2, void 0 === (p2 = d3[w2]) ? p2 : String(p2));
      var S2 = d3.groups;
      if (c2) {
        var x2 = no$1([g2], b2, m2, u2);
        void 0 !== S2 && ro$1(x2, S2);
        var O2 = fn$2(Nr$1(o2, void 0, x2));
      } else
        O2 = qr$1(g2, u2, m2, b2, S2, o2);
      m2 >= h2 && (v2 += io$1(u2, h2, m2) + O2, h2 = m2 + g2.length);
    }
    return v2 + io$1(u2, h2);
  }];
}, !!C$2(function() {
  var t2 = /./;
  return t2.exec = function() {
    var t3 = [];
    return t3.groups = { a: "7" }, t3;
  }, "7" !== "".replace(t2, "$<a>");
}) || !uo$1 || ao$1);
var so$1 = R$2.Promise, fo$1 = function(t2, e3, n2) {
  for (var r2 in e3)
    Ee$2(t2, r2, e3[r2], n2);
  return t2;
}, lo$1 = R$2.String, po$1 = R$2.TypeError, vo$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t2, e3 = false, n2 = {};
  try {
    (t2 = W$2(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n2, []), e3 = n2 instanceof Array;
  } catch (t3) {
  }
  return function(n3, r2) {
    return Jt$2(n3), function(t3) {
      if ("object" == typeof t3 || et$2(t3))
        return t3;
      throw po$1("Can't set " + lo$1(t3) + " as a prototype");
    }(r2), e3 ? t2(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), ho$1 = te$2.f, yo$1 = Ft$2("toStringTag"), go$1 = function(t2, e3, n2) {
  t2 && !Mt$2(t2 = n2 ? t2 : t2.prototype, yo$1) && ho$1(t2, yo$1, { configurable: true, value: e3 });
}, mo$1 = Ft$2("species"), bo$1 = R$2.TypeError, wo$1 = function(t2, e3) {
  if (it$2(e3, t2))
    return t2;
  throw bo$1("Incorrect invocation");
}, So$1 = {}, xo$1 = Ft$2("iterator"), Oo$1 = Array.prototype, Eo$1 = Ft$2("iterator"), jo$1 = function(t2) {
  if (null != t2)
    return wt$2(t2, Eo$1) || wt$2(t2, "@@iterator") || So$1[cn$2(t2)];
}, Io$1 = R$2.TypeError, Po$1 = function(t2, e3, n2) {
  var r2, o2;
  Jt$2(t2);
  try {
    if (!(r2 = wt$2(t2, "return"))) {
      if ("throw" === e3)
        throw n2;
      return n2;
    }
    r2 = V$2(r2, t2);
  } catch (t3) {
    o2 = true, r2 = t3;
  }
  if ("throw" === e3)
    throw n2;
  if (o2)
    throw r2;
  return Jt$2(r2), n2;
}, To$1 = R$2.TypeError, Mo$1 = function(t2, e3) {
  this.stopped = t2, this.result = e3;
}, Ao$1 = Mo$1.prototype, ko$1 = function(t2, e3, n2) {
  var r2, o2, i2, u2, a2, c2, s2, f2, l2 = n2 && n2.that, d3 = !(!n2 || !n2.AS_ENTRIES), p2 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), h2 = Dn$2(e3, l2), y2 = function(t3) {
    return r2 && Po$1(r2, "normal", t3), new Mo$1(true, t3);
  }, g2 = function(t3) {
    return d3 ? (Jt$2(t3), v2 ? h2(t3[0], t3[1], y2) : h2(t3[0], t3[1])) : v2 ? h2(t3, y2) : h2(t3);
  };
  if (p2)
    r2 = t2;
  else {
    if (!(o2 = jo$1(t2)))
      throw To$1(gt$2(t2) + " is not iterable");
    if (void 0 !== (f2 = o2) && (So$1.Array === f2 || Oo$1[xo$1] === f2)) {
      for (i2 = 0, u2 = Ce$2(t2); u2 > i2; i2++)
        if ((a2 = g2(t2[i2])) && it$2(Ao$1, a2))
          return a2;
      return new Mo$1(false);
    }
    r2 = function(t3, e4) {
      var n3 = arguments.length < 2 ? jo$1(t3) : e4;
      if (bt$2(n3))
        return Jt$2(V$2(n3, t3));
      throw Io$1(gt$2(t3) + " is not iterable");
    }(t2, o2);
  }
  for (c2 = r2.next; !(s2 = V$2(c2, r2)).done; ) {
    try {
      a2 = g2(s2.value);
    } catch (t3) {
      Po$1(r2, "throw", t3);
    }
    if ("object" == typeof a2 && a2 && it$2(Ao$1, a2))
      return a2;
  }
  return new Mo$1(false);
}, Ro$1 = Ft$2("iterator"), Co$1 = false;
try {
  var No$1 = 0, Lo$1 = { next: function() {
    return { done: !!No$1++ };
  }, return: function() {
    Co$1 = true;
  } };
  Lo$1[Ro$1] = function() {
    return this;
  }, Array.from(Lo$1, function() {
    throw 2;
  });
} catch (t2) {
}
var Vo$1, zo$1, Fo$1, _o$1, Do$1 = function(t2, e3) {
  if (!e3 && !Co$1)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[Ro$1] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, t2(r2);
  } catch (t3) {
  }
  return n2;
}, $o$1 = R$2.TypeError, Ho$1 = Ft$2("species"), Bo$1 = function(t2, e3) {
  var n2, r2 = Jt$2(t2).constructor;
  return void 0 === r2 || null == (n2 = Jt$2(r2)[Ho$1]) ? e3 : function(t3) {
    if (Yn$2(t3))
      return t3;
    throw $o$1(gt$2(t3) + " is not a constructor");
  }(n2);
}, Go$1 = W$2([].slice), Wo$1 = /(?:ipad|iphone|ipod).*applewebkit/i.test(ut$2), Uo$1 = "process" == X$2(R$2.process), Ko$1 = R$2.setImmediate, Xo$1 = R$2.clearImmediate, Yo$1 = R$2.process, qo$1 = R$2.Dispatch, Jo$1 = R$2.Function, Qo$1 = R$2.MessageChannel, Zo$1 = R$2.String, ti$1 = 0, ei$1 = {};
try {
  Vo$1 = R$2.location;
} catch (t2) {
}
var ni$1 = function(t2) {
  if (Mt$2(ei$1, t2)) {
    var e3 = ei$1[t2];
    delete ei$1[t2], e3();
  }
}, ri$1 = function(t2) {
  return function() {
    ni$1(t2);
  };
}, oi$1 = function(t2) {
  ni$1(t2.data);
}, ii$1 = function(t2) {
  R$2.postMessage(Zo$1(t2), Vo$1.protocol + "//" + Vo$1.host);
};
Ko$1 && Xo$1 || (Ko$1 = function(t2) {
  var e3 = Go$1(arguments, 1);
  return ei$1[++ti$1] = function() {
    Nr$1(et$2(t2) ? t2 : Jo$1(t2), void 0, e3);
  }, zo$1(ti$1), ti$1;
}, Xo$1 = function(t2) {
  delete ei$1[t2];
}, Uo$1 ? zo$1 = function(t2) {
  Yo$1.nextTick(ri$1(t2));
} : qo$1 && qo$1.now ? zo$1 = function(t2) {
  qo$1.now(ri$1(t2));
} : Qo$1 && !Wo$1 ? (_o$1 = (Fo$1 = new Qo$1()).port2, Fo$1.port1.onmessage = oi$1, zo$1 = Dn$2(_o$1.postMessage, _o$1)) : R$2.addEventListener && et$2(R$2.postMessage) && !R$2.importScripts && Vo$1 && "file:" !== Vo$1.protocol && !C$2(ii$1) ? (zo$1 = ii$1, R$2.addEventListener("message", oi$1, false)) : zo$1 = "onreadystatechange" in Wt$2("script") ? function(t2) {
  Pn$2.appendChild(Wt$2("script")).onreadystatechange = function() {
    Pn$2.removeChild(this), ni$1(t2);
  };
} : function(t2) {
  setTimeout(ri$1(t2), 0);
});
var ui$1, ai$1, ci$1, si$1, fi$1, li$1, di$1, pi$1, vi$1 = { set: Ko$1, clear: Xo$1 }, hi$1 = /ipad|iphone|ipod/i.test(ut$2) && void 0 !== R$2.Pebble, yi$1 = /web0s(?!.*chrome)/i.test(ut$2), gi$1 = Xt$2.f, mi$1 = vi$1.set, bi$1 = R$2.MutationObserver || R$2.WebKitMutationObserver, wi$1 = R$2.document, Si$1 = R$2.process, xi$1 = R$2.Promise, Oi$1 = gi$1(R$2, "queueMicrotask"), Ei$1 = Oi$1 && Oi$1.value;
Ei$1 || (ui$1 = function() {
  var t2, e3;
  for (Uo$1 && (t2 = Si$1.domain) && t2.exit(); ai$1; ) {
    e3 = ai$1.fn, ai$1 = ai$1.next;
    try {
      e3();
    } catch (t3) {
      throw ai$1 ? si$1() : ci$1 = void 0, t3;
    }
  }
  ci$1 = void 0, t2 && t2.enter();
}, Wo$1 || Uo$1 || yi$1 || !bi$1 || !wi$1 ? !hi$1 && xi$1 && xi$1.resolve ? ((di$1 = xi$1.resolve(void 0)).constructor = xi$1, pi$1 = Dn$2(di$1.then, di$1), si$1 = function() {
  pi$1(ui$1);
}) : Uo$1 ? si$1 = function() {
  Si$1.nextTick(ui$1);
} : (mi$1 = Dn$2(mi$1, R$2), si$1 = function() {
  mi$1(ui$1);
}) : (fi$1 = true, li$1 = wi$1.createTextNode(""), new bi$1(ui$1).observe(li$1, { characterData: true }), si$1 = function() {
  li$1.data = fi$1 = !fi$1;
}));
var ji$1, Ii$1, Pi$1, Ti$1, Mi$1 = Ei$1 || function(t2) {
  var e3 = { fn: t2, next: void 0 };
  ci$1 && (ci$1.next = e3), ai$1 || (ai$1 = e3, si$1()), ci$1 = e3;
}, Ai$1 = function(t2) {
  var e3, n2;
  this.promise = new t2(function(t3, r2) {
    if (void 0 !== e3 || void 0 !== n2)
      throw TypeError("Bad Promise constructor");
    e3 = t3, n2 = r2;
  }), this.resolve = bt$2(e3), this.reject = bt$2(n2);
}, ki$1 = { f: function(t2) {
  return new Ai$1(t2);
} }, Ri$1 = function(t2) {
  try {
    return { error: false, value: t2() };
  } catch (t3) {
    return { error: true, value: t3 };
  }
}, Ci$1 = "object" == typeof window, Ni$1 = vi$1.set, Li$1 = Ft$2("species"), Vi$1 = "Promise", zi$1 = be$2.getterFor(Vi$1), Fi$1 = be$2.set, _i$1 = be$2.getterFor(Vi$1), Di$1 = so$1 && so$1.prototype, $i$1 = so$1, Hi$1 = Di$1, Bi$1 = R$2.TypeError, Gi$1 = R$2.document, Wi$1 = R$2.process, Ui$1 = ki$1.f, Ki$1 = Ui$1, Xi$1 = !!(Gi$1 && Gi$1.createEvent && R$2.dispatchEvent), Yi$1 = et$2(R$2.PromiseRejectionEvent), qi$1 = false, Ji$1 = Qe$2(Vi$1, function() {
  var t2 = ue$2($i$1), e3 = t2 !== String($i$1);
  if (!e3 && 66 === lt$2)
    return true;
  if (lt$2 >= 51 && /native code/.test(t2))
    return false;
  var n2 = new $i$1(function(t3) {
    t3(1);
  }), r2 = function(t3) {
    t3(function() {
    }, function() {
    });
  };
  return (n2.constructor = {})[Li$1] = r2, !(qi$1 = n2.then(function() {
  }) instanceof r2) || !e3 && Ci$1 && !Yi$1;
}), Qi$1 = Ji$1 || !Do$1(function(t2) {
  $i$1.all(t2).catch(function() {
  });
}), Zi$1 = function(t2) {
  var e3;
  return !(!nt$2(t2) || !et$2(e3 = t2.then)) && e3;
}, tu$1 = function(t2, e3) {
  if (!t2.notified) {
    t2.notified = true;
    var n2 = t2.reactions;
    Mi$1(function() {
      for (var r2 = t2.value, o2 = 1 == t2.state, i2 = 0; n2.length > i2; ) {
        var u2, a2, c2, s2 = n2[i2++], f2 = o2 ? s2.ok : s2.fail, l2 = s2.resolve, d3 = s2.reject, p2 = s2.domain;
        try {
          f2 ? (o2 || (2 === t2.rejection && ou$1(t2), t2.rejection = 1), true === f2 ? u2 = r2 : (p2 && p2.enter(), u2 = f2(r2), p2 && (p2.exit(), c2 = true)), u2 === s2.promise ? d3(Bi$1("Promise-chain cycle")) : (a2 = Zi$1(u2)) ? V$2(a2, u2, l2, d3) : l2(u2)) : d3(r2);
        } catch (t3) {
          p2 && !c2 && p2.exit(), d3(t3);
        }
      }
      t2.reactions = [], t2.notified = false, e3 && !t2.rejection && nu$1(t2);
    });
  }
}, eu$1 = function(t2, e3, n2) {
  var r2, o2;
  Xi$1 ? ((r2 = Gi$1.createEvent("Event")).promise = e3, r2.reason = n2, r2.initEvent(t2, false, true), R$2.dispatchEvent(r2)) : r2 = { promise: e3, reason: n2 }, !Yi$1 && (o2 = R$2["on" + t2]) ? o2(r2) : "unhandledrejection" === t2 && function(t3, e4) {
    var n3 = R$2.console;
    n3 && n3.error && (1 == arguments.length ? n3.error(t3) : n3.error(t3, e4));
  }("Unhandled promise rejection", n2);
}, nu$1 = function(t2) {
  V$2(Ni$1, R$2, function() {
    var e3, n2 = t2.facade, r2 = t2.value;
    if (ru$1(t2) && (e3 = Ri$1(function() {
      Uo$1 ? Wi$1.emit("unhandledRejection", r2, n2) : eu$1("unhandledrejection", n2, r2);
    }), t2.rejection = Uo$1 || ru$1(t2) ? 2 : 1, e3.error))
      throw e3.value;
  });
}, ru$1 = function(t2) {
  return 1 !== t2.rejection && !t2.parent;
}, ou$1 = function(t2) {
  V$2(Ni$1, R$2, function() {
    var e3 = t2.facade;
    Uo$1 ? Wi$1.emit("rejectionHandled", e3) : eu$1("rejectionhandled", e3, t2.value);
  });
}, iu$1 = function(t2, e3, n2) {
  return function(r2) {
    t2(e3, r2, n2);
  };
}, uu$1 = function(t2, e3, n2) {
  t2.done || (t2.done = true, n2 && (t2 = n2), t2.value = e3, t2.state = 2, tu$1(t2, true));
}, au$1 = function(t2, e3, n2) {
  if (!t2.done) {
    t2.done = true, n2 && (t2 = n2);
    try {
      if (t2.facade === e3)
        throw Bi$1("Promise can't be resolved itself");
      var r2 = Zi$1(e3);
      r2 ? Mi$1(function() {
        var n3 = { done: false };
        try {
          V$2(r2, e3, iu$1(au$1, n3, t2), iu$1(uu$1, n3, t2));
        } catch (e4) {
          uu$1(n3, e4, t2);
        }
      }) : (t2.value = e3, t2.state = 1, tu$1(t2, false));
    } catch (e4) {
      uu$1({ done: false }, e4, t2);
    }
  }
};
if (Ji$1 && (Hi$1 = ($i$1 = function(t2) {
  wo$1(this, Hi$1), bt$2(t2), V$2(ji$1, this);
  var e3 = zi$1(this);
  try {
    t2(iu$1(au$1, e3), iu$1(uu$1, e3));
  } catch (t3) {
    uu$1(e3, t3);
  }
}).prototype, (ji$1 = function(t2) {
  Fi$1(this, { type: Vi$1, done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
}).prototype = fo$1(Hi$1, { then: function(t2, e3) {
  var n2 = _i$1(this), r2 = n2.reactions, o2 = Ui$1(Bo$1(this, $i$1));
  return o2.ok = !et$2(t2) || t2, o2.fail = et$2(e3) && e3, o2.domain = Uo$1 ? Wi$1.domain : void 0, n2.parent = true, r2[r2.length] = o2, 0 != n2.state && tu$1(n2, false), o2.promise;
}, catch: function(t2) {
  return this.then(void 0, t2);
} }), Ii$1 = function() {
  var t2 = new ji$1(), e3 = zi$1(t2);
  this.promise = t2, this.resolve = iu$1(au$1, e3), this.reject = iu$1(uu$1, e3);
}, ki$1.f = Ui$1 = function(t2) {
  return t2 === $i$1 || t2 === Pi$1 ? new Ii$1(t2) : Ki$1(t2);
}, et$2(so$1) && Di$1 !== Object.prototype)) {
  Ti$1 = Di$1.then, qi$1 || (Ee$2(Di$1, "then", function(t2, e3) {
    var n2 = this;
    return new $i$1(function(t3, e4) {
      V$2(Ti$1, n2, t3, e4);
    }).then(t2, e3);
  }, { unsafe: true }), Ee$2(Di$1, "catch", Hi$1.catch, { unsafe: true }));
  try {
    delete Di$1.constructor;
  } catch (t2) {
  }
  vo$1 && vo$1(Di$1, Hi$1);
}
function cu$1(t2, e3, n2) {
  return void 0 === n2 && (n2 = ""), x$2(this, void 0, void 0, function() {
    var r2, o2, i2, a2, c2, s2, f2;
    return O$2(this, function(l2) {
      switch (l2.label) {
        case 0:
          return e3 ? (t2.restoreSelection(), r2 = t2.getMenuConfig("insertVideo"), o2 = r2.onInsertedVideo, i2 = r2.checkVideo, a2 = r2.parseVideoSrc, [4, i2(e3)]) : [2];
        case 1:
          return "string" == typeof (c2 = l2.sent()) ? (t2.alert(c2, "error"), [2]) : null == c2 ? [2] : [4, a2(e3)];
        case 2:
          return 0 !== (s2 = l2.sent()).trim().indexOf("<iframe ") && (s2 = s2.replace(/</g, "&lt;").replace(/>/g, "&gt;")), f2 = { type: "video", src: s2, poster: n2, children: [{ text: "" }] }, Promise.resolve().then(function() {
            Transforms.insertNodes(t2, f2);
          }), o2(f2), [2];
      }
    });
  });
}
function su$1() {
  return co$1("w-e-insert-video");
}
tn$2({ global: true, wrap: true, forced: Ji$1 }, { Promise: $i$1 }), go$1($i$1, Vi$1, false), function(t2) {
  var e3 = ot$2(t2), n2 = te$2.f;
  N$2 && e3 && !e3[mo$1] && n2(e3, mo$1, { configurable: true, get: function() {
    return this;
  } });
}(Vi$1), Pi$1 = ot$2(Vi$1), tn$2({ target: Vi$1, stat: true, forced: Ji$1 }, { reject: function(t2) {
  var e3 = Ui$1(this);
  return V$2(e3.reject, void 0, t2), e3.promise;
} }), tn$2({ target: Vi$1, stat: true, forced: Ji$1 }, { resolve: function(t2) {
  return function(t3, e3) {
    if (Jt$2(t3), nt$2(e3) && e3.constructor === t3)
      return e3;
    var n2 = ki$1.f(t3);
    return (0, n2.resolve)(e3), n2.promise;
  }(this, t2);
} }), tn$2({ target: Vi$1, stat: true, forced: Qi$1 }, { all: function(t2) {
  var e3 = this, n2 = Ui$1(e3), r2 = n2.resolve, o2 = n2.reject, i2 = Ri$1(function() {
    var n3 = bt$2(e3.resolve), i3 = [], u2 = 0, a2 = 1;
    ko$1(t2, function(t3) {
      var c2 = u2++, s2 = false;
      a2++, V$2(n3, e3, t3).then(function(t4) {
        s2 || (s2 = true, i3[c2] = t4, --a2 || r2(i3));
      }, o2);
    }), --a2 || r2(i3);
  });
  return i2.error && o2(i2.value), n2.promise;
}, race: function(t2) {
  var e3 = this, n2 = Ui$1(e3), r2 = n2.reject, o2 = Ri$1(function() {
    var o3 = bt$2(e3.resolve);
    ko$1(t2, function(t3) {
      V$2(o3, e3, t3).then(n2.resolve, r2);
    });
  });
  return o2.error && r2(o2.value), n2.promise;
} });
var fu$1 = function() {
  function t2() {
    this.title = lp$1("videoModule.insertVideo"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>', this.tag = "button", this.showModal = true, this.modalWidth = 320, this.$content = null, this.srcInputId = su$1(), this.posterInputId = su$1(), this.buttonId = su$1();
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || !!rl$1.getSelectedElems(t3).some(function(n3) {
      return "pre" === rl$1.getNodeType(n3) || !!t3.isVoid(n3);
    }));
  }, t2.prototype.getModalPositionNode = function(t3) {
    return null;
  }, t2.prototype.getModalContentElem = function(t3) {
    var e3 = this, i2 = this, u2 = i2.srcInputId, a2 = i2.posterInputId, c2 = i2.buttonId, s2 = j$2(Wd$1(lp$1("videoModule.videoSrc"), u2, lp$1("videoModule.videoSrcPlaceHolder")), 2), l2 = s2[0], d3 = s2[1], p2 = j$2(Wd$1(lp$1("videoModule.videoPoster"), a2, lp$1("videoModule.videoPosterPlaceHolder")), 2), v2 = p2[0], h2 = p2[1], y2 = $$6(d3), g2 = $$6(h2), m2 = j$2(zd$1(c2, lp$1("videoModule.ok")), 1)[0];
    if (null == this.$content) {
      var b2 = $$6("<div></div>");
      b2.on("click", "#" + c2, function(n2) {
        return x$2(e3, void 0, void 0, function() {
          var e4, r2;
          return O$2(this, function(o2) {
            switch (o2.label) {
              case 0:
                return n2.preventDefault(), e4 = b2.find("#" + u2).val().trim(), r2 = b2.find("#" + a2).val().trim(), [4, cu$1(t3, e4, r2)];
              case 1:
                return o2.sent(), t3.hidePanelOrModal(), [2];
            }
          });
        });
      }), this.$content = b2;
    }
    var w2 = this.$content;
    return w2.empty(), w2.append(l2), w2.append(v2), w2.append(m2), y2.val(""), g2.val(""), setTimeout(function() {
      y2.focus();
    }), w2[0];
  }, t2;
}(), lu$1 = W$2([].join), du$1 = J$2 != Object, pu$1 = function(t2, e3) {
  var n2 = [][t2];
  return !!n2 && C$2(function() {
    n2.call(null, e3 || function() {
      throw 1;
    }, 1);
  });
}("join", ",");
tn$2({ target: "Array", proto: true, forced: du$1 || !pu$1 }, { join: function(t2) {
  return lu$1(tt$2(this), void 0 === t2 ? "," : t2);
} });
var vu$1, hu$1, yu$1, gu$1 = !C$2(function() {
  function t2() {
  }
  return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
}), mu$1 = fe$2("IE_PROTO"), bu$1 = R$2.Object, wu$1 = bu$1.prototype, Su$1 = gu$1 ? bu$1.getPrototypeOf : function(t2) {
  var e3 = Pt$2(t2);
  if (Mt$2(e3, mu$1))
    return e3[mu$1];
  var n2 = e3.constructor;
  return et$2(n2) && e3 instanceof n2 ? n2.prototype : e3 instanceof bu$1 ? wu$1 : null;
}, xu$1 = Ft$2("iterator"), Ou$1 = false;
[].keys && ("next" in (yu$1 = [].keys()) ? (hu$1 = Su$1(Su$1(yu$1))) !== Object.prototype && (vu$1 = hu$1) : Ou$1 = true);
var Eu$1 = null == vu$1 || C$2(function() {
  var t2 = {};
  return vu$1[xu$1].call(t2) !== t2;
});
Eu$1 && (vu$1 = {}), et$2(vu$1[xu$1]) || Ee$2(vu$1, xu$1, function() {
  return this;
});
var ju$1 = { IteratorPrototype: vu$1, BUGGY_SAFARI_ITERATORS: Ou$1 }, Iu$1 = ju$1.IteratorPrototype, Pu$1 = function() {
  return this;
}, Tu$1 = Oe$2.PROPER, Mu$1 = Oe$2.CONFIGURABLE, Au$1 = ju$1.IteratorPrototype, ku$1 = ju$1.BUGGY_SAFARI_ITERATORS, Ru$1 = Ft$2("iterator"), Cu$1 = function() {
  return this;
}, Nu$1 = function(t2, e3, n2, r2, o2, i2, u2) {
  !function(t3, e4, n3, r3) {
    var o3 = e4 + " Iterator";
    t3.prototype = Cn$2(Iu$1, { next: D$2(+!r3, n3) }), go$1(t3, o3, false), So$1[o3] = Pu$1;
  }(n2, e3, r2);
  var a2, c2, s2, f2 = function(t3) {
    if (t3 === o2 && h2)
      return h2;
    if (!ku$1 && t3 in p2)
      return p2[t3];
    switch (t3) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, t3);
        };
    }
    return function() {
      return new n2(this);
    };
  }, l2 = e3 + " Iterator", d3 = false, p2 = t2.prototype, v2 = p2[Ru$1] || p2["@@iterator"] || o2 && p2[o2], h2 = !ku$1 && v2 || f2(o2), y2 = "Array" == e3 && p2.entries || v2;
  if (y2 && (a2 = Su$1(y2.call(new t2()))) !== Object.prototype && a2.next && (Su$1(a2) !== Au$1 && (vo$1 ? vo$1(a2, Au$1) : et$2(a2[Ru$1]) || Ee$2(a2, Ru$1, Cu$1)), go$1(a2, l2, true)), Tu$1 && "values" == o2 && v2 && "values" !== v2.name && (Mu$1 ? ee$2(p2, "name", "values") : (d3 = true, h2 = function() {
    return V$2(v2, this);
  })), o2)
    if (c2 = { values: f2("values"), keys: i2 ? h2 : f2("keys"), entries: f2("entries") }, u2)
      for (s2 in c2)
        (ku$1 || d3 || !(s2 in p2)) && Ee$2(p2, s2, c2[s2]);
    else
      tn$2({ target: e3, proto: true, forced: ku$1 || d3 }, c2);
  return p2[Ru$1] !== h2 && Ee$2(p2, Ru$1, h2, { name: o2 }), So$1[e3] = h2, c2;
}, Lu$1 = be$2.set, Vu$1 = be$2.getterFor("Array Iterator"), zu$1 = Nu$1(Array, "Array", function(t2, e3) {
  Lu$1(this, { type: "Array Iterator", target: tt$2(t2), index: 0, kind: e3 });
}, function() {
  var t2 = Vu$1(this), e3 = t2.target, n2 = t2.kind, r2 = t2.index++;
  return !e3 || r2 >= e3.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e3[r2], done: false } : { value: [r2, e3[r2]], done: false };
}, "values");
So$1.Arguments = So$1.Array, Vn$2("keys"), Vn$2("values"), Vn$2("entries");
var Fu$1 = $r$1.charAt, _u$1 = be$2.set, Du$1 = be$2.getterFor("String Iterator");
Nu$1(String, "String", function(t2) {
  _u$1(this, { type: "String Iterator", string: fn$2(t2), index: 0 });
}, function() {
  var t2, e3 = Du$1(this), n2 = e3.string, r2 = e3.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (t2 = Fu$1(n2, r2), e3.index += t2.length, { value: t2, done: false });
});
var $u$1 = function(t2, e3, n2) {
  var r2 = Ht$2(e3);
  r2 in t2 ? te$2.f(t2, r2, D$2(0, n2)) : t2[r2] = n2;
}, Hu$1 = R$2.Array, Bu$1 = Math.max, Gu$1 = $e$2.f, Wu$1 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], Uu$1 = function(t2) {
  try {
    return Gu$1(t2);
  } catch (t3) {
    return function(t4, e3, n2) {
      for (var r2 = Ce$2(t4), o2 = Ae$2(e3, r2), i2 = Ae$2(void 0 === n2 ? r2 : n2, r2), u2 = Hu$1(Bu$1(i2 - o2, 0)), a2 = 0; o2 < i2; o2++, a2++)
        $u$1(u2, a2, t4[o2]);
      return u2.length = a2, u2;
    }(Wu$1);
  }
}, Ku$1 = { f: function(t2) {
  return Wu$1 && "Window" == X$2(t2) ? Uu$1(t2) : Gu$1(tt$2(t2));
} }, Xu$1 = C$2(function() {
  if ("function" == typeof ArrayBuffer) {
    var t2 = new ArrayBuffer(8);
    Object.isExtensible(t2) && Object.defineProperty(t2, "a", { value: 8 });
  }
}), Yu$1 = Object.isExtensible, qu$1 = C$2(function() {
  Yu$1(1);
}) || Xu$1 ? function(t2) {
  return !!nt$2(t2) && ((!Xu$1 || "ArrayBuffer" != X$2(t2)) && (!Yu$1 || Yu$1(t2)));
} : Yu$1, Ju$1 = !C$2(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), Qu$1 = T$2(function(t2) {
  var e3 = te$2.f, n2 = false, r2 = Ct$2("meta"), o2 = 0, i2 = function(t3) {
    e3(t3, r2, { value: { objectID: "O" + o2++, weakData: {} } });
  }, u2 = t2.exports = { enable: function() {
    u2.enable = function() {
    }, n2 = true;
    var t3 = $e$2.f, e4 = W$2([].splice), o3 = {};
    o3[r2] = 1, t3(o3).length && ($e$2.f = function(n3) {
      for (var o4 = t3(n3), i3 = 0, u3 = o4.length; i3 < u3; i3++)
        if (o4[i3] === r2) {
          e4(o4, i3, 1);
          break;
        }
      return o4;
    }, tn$2({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: Ku$1.f }));
  }, fastKey: function(t3, e4) {
    if (!nt$2(t3))
      return "symbol" == typeof t3 ? t3 : ("string" == typeof t3 ? "S" : "P") + t3;
    if (!Mt$2(t3, r2)) {
      if (!qu$1(t3))
        return "F";
      if (!e4)
        return "E";
      i2(t3);
    }
    return t3[r2].objectID;
  }, getWeakData: function(t3, e4) {
    if (!Mt$2(t3, r2)) {
      if (!qu$1(t3))
        return true;
      if (!e4)
        return false;
      i2(t3);
    }
    return t3[r2].weakData;
  }, onFreeze: function(t3) {
    return Ju$1 && n2 && qu$1(t3) && !Mt$2(t3, r2) && i2(t3), t3;
  } };
  le$2[r2] = true;
}), Zu$1 = Qu$1.getWeakData, ta$2 = be$2.set, ea$2 = be$2.getterFor, na$2 = er$1.find, ra$2 = er$1.findIndex, oa$2 = W$2([].splice), ia$2 = 0, ua$2 = function(t2) {
  return t2.frozen || (t2.frozen = new aa$2());
}, aa$2 = function() {
  this.entries = [];
}, ca$2 = function(t2, e3) {
  return na$2(t2.entries, function(t3) {
    return t3[0] === e3;
  });
};
aa$2.prototype = { get: function(t2) {
  var e3 = ca$2(this, t2);
  if (e3)
    return e3[1];
}, has: function(t2) {
  return !!ca$2(this, t2);
}, set: function(t2, e3) {
  var n2 = ca$2(this, t2);
  n2 ? n2[1] = e3 : this.entries.push([t2, e3]);
}, delete: function(t2) {
  var e3 = ra$2(this.entries, function(e4) {
    return e4[0] === t2;
  });
  return ~e3 && oa$2(this.entries, e3, 1), !!~e3;
} };
var sa$2, fa$2 = { getConstructor: function(t2, e3, n2, r2) {
  var o2 = t2(function(t3, o3) {
    wo$1(t3, i2), ta$2(t3, { type: e3, id: ia$2++, frozen: void 0 }), null != o3 && ko$1(o3, t3[r2], { that: t3, AS_ENTRIES: n2 });
  }), i2 = o2.prototype, u2 = ea$2(e3), a2 = function(t3, e4, n3) {
    var r3 = u2(t3), o3 = Zu$1(Jt$2(e4), true);
    return true === o3 ? ua$2(r3).set(e4, n3) : o3[r3.id] = n3, t3;
  };
  return fo$1(i2, { delete: function(t3) {
    var e4 = u2(this);
    if (!nt$2(t3))
      return false;
    var n3 = Zu$1(t3);
    return true === n3 ? ua$2(e4).delete(t3) : n3 && Mt$2(n3, e4.id) && delete n3[e4.id];
  }, has: function(t3) {
    var e4 = u2(this);
    if (!nt$2(t3))
      return false;
    var n3 = Zu$1(t3);
    return true === n3 ? ua$2(e4).has(t3) : n3 && Mt$2(n3, e4.id);
  } }), fo$1(i2, n2 ? { get: function(t3) {
    var e4 = u2(this);
    if (nt$2(t3)) {
      var n3 = Zu$1(t3);
      return true === n3 ? ua$2(e4).get(t3) : n3 ? n3[e4.id] : void 0;
    }
  }, set: function(t3, e4) {
    return a2(this, t3, e4);
  } } : { add: function(t3) {
    return a2(this, t3, true);
  } }), o2;
} }, la$2 = be$2.enforce, da$2 = !R$2.ActiveXObject && "ActiveXObject" in R$2, pa$2 = function(t2) {
  return function() {
    return t2(this, arguments.length ? arguments[0] : void 0);
  };
}, va$2 = function(t2, e3, n2) {
  var r2 = -1 !== t2.indexOf("Map"), o2 = -1 !== t2.indexOf("Weak"), i2 = r2 ? "set" : "add", u2 = R$2[t2], a2 = u2 && u2.prototype, c2 = u2, s2 = {}, f2 = function(t3) {
    var e4 = W$2(a2[t3]);
    Ee$2(a2, t3, "add" == t3 ? function(t4) {
      return e4(this, 0 === t4 ? 0 : t4), this;
    } : "delete" == t3 ? function(t4) {
      return !(o2 && !nt$2(t4)) && e4(this, 0 === t4 ? 0 : t4);
    } : "get" == t3 ? function(t4) {
      return o2 && !nt$2(t4) ? void 0 : e4(this, 0 === t4 ? 0 : t4);
    } : "has" == t3 ? function(t4) {
      return !(o2 && !nt$2(t4)) && e4(this, 0 === t4 ? 0 : t4);
    } : function(t4, n3) {
      return e4(this, 0 === t4 ? 0 : t4, n3), this;
    });
  };
  if (Qe$2(t2, !et$2(u2) || !(o2 || a2.forEach && !C$2(function() {
    new u2().entries().next();
  }))))
    c2 = n2.getConstructor(e3, t2, r2, i2), Qu$1.enable();
  else if (Qe$2(t2, true)) {
    var l2 = new c2(), d3 = l2[i2](o2 ? {} : -0, 1) != l2, p2 = C$2(function() {
      l2.has(1);
    }), v2 = Do$1(function(t3) {
      new u2(t3);
    }), h2 = !o2 && C$2(function() {
      for (var t3 = new u2(), e4 = 5; e4--; )
        t3[i2](e4, e4);
      return !t3.has(-0);
    });
    v2 || ((c2 = e3(function(t3, e4) {
      wo$1(t3, a2);
      var n3 = function(t4, e5, n4) {
        var r3, o3;
        return vo$1 && et$2(r3 = e5.constructor) && r3 !== n4 && nt$2(o3 = r3.prototype) && o3 !== n4.prototype && vo$1(t4, o3), t4;
      }(new u2(), t3, c2);
      return null != e4 && ko$1(e4, n3[i2], { that: n3, AS_ENTRIES: r2 }), n3;
    })).prototype = a2, a2.constructor = c2), (p2 || h2) && (f2("delete"), f2("has"), r2 && f2("get")), (h2 || d3) && f2(i2), o2 && a2.clear && delete a2.clear;
  }
  return s2[t2] = c2, tn$2({ global: true, forced: c2 != u2 }, s2), go$1(c2, t2), o2 || n2.setStrong(c2, t2, r2), c2;
}("WeakMap", pa$2, fa$2);
if (ce$2 && da$2) {
  sa$2 = fa$2.getConstructor(pa$2, "WeakMap", true), Qu$1.enable();
  var ha$1 = va$2.prototype, ya$1 = W$2(ha$1.delete), ga$1 = W$2(ha$1.has), ma$1 = W$2(ha$1.get), ba$1 = W$2(ha$1.set);
  fo$1(ha$1, { delete: function(t2) {
    if (nt$2(t2) && !qu$1(t2)) {
      var e3 = la$2(this);
      return e3.frozen || (e3.frozen = new sa$2()), ya$1(this, t2) || e3.frozen.delete(t2);
    }
    return ya$1(this, t2);
  }, has: function(t2) {
    if (nt$2(t2) && !qu$1(t2)) {
      var e3 = la$2(this);
      return e3.frozen || (e3.frozen = new sa$2()), ga$1(this, t2) || e3.frozen.has(t2);
    }
    return ga$1(this, t2);
  }, get: function(t2) {
    if (nt$2(t2) && !qu$1(t2)) {
      var e3 = la$2(this);
      return e3.frozen || (e3.frozen = new sa$2()), ga$1(this, t2) ? ma$1(this, t2) : e3.frozen.get(t2);
    }
    return ma$1(this, t2);
  }, set: function(t2, e3) {
    if (nt$2(t2) && !qu$1(t2)) {
      var n2 = la$2(this);
      n2.frozen || (n2.frozen = new sa$2()), ga$1(this, t2) ? ba$1(this, t2, e3) : n2.frozen.set(t2, e3);
    } else
      ba$1(this, t2, e3);
    return this;
  } });
}
var wa$1 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Sa$1 = Wt$2("span").classList, xa$1 = Sa$1 && Sa$1.constructor && Sa$1.constructor.prototype, Oa$1 = xa$1 === Object.prototype ? void 0 : xa$1, Ea$1 = Ft$2("iterator"), ja = Ft$2("toStringTag"), Ia$1 = zu$1.values, Pa$1 = function(t2, e3) {
  if (t2) {
    if (t2[Ea$1] !== Ia$1)
      try {
        ee$2(t2, Ea$1, Ia$1);
      } catch (e4) {
        t2[Ea$1] = Ia$1;
      }
    if (t2[ja] || ee$2(t2, ja, e3), wa$1[e3]) {
      for (var n2 in zu$1)
        if (t2[n2] !== zu$1[n2])
          try {
            ee$2(t2, n2, zu$1[n2]);
          } catch (e4) {
            t2[n2] = zu$1[n2];
          }
    }
  }
};
for (var Ta$1 in wa$1)
  Pa$1(R$2[Ta$1] && R$2[Ta$1].prototype, Ta$1);
Pa$1(Oa$1, "DOMTokenList");
var Ma$1 = Oe$2.EXISTS, Aa$1 = te$2.f, ka$1 = Function.prototype, Ra$1 = W$2(ka$1.toString), Ca$1 = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, Na$1 = W$2(Ca$1.exec);
N$2 && !Ma$1 && Aa$1(ka$1, "name", { configurable: true, get: function() {
  try {
    return Na$1(Ca$1, Ra$1(this))[1];
  } catch (t2) {
    return "";
  }
} });
var La$1 = Ft$2("species"), Va = function(t2) {
  return lt$2 >= 51 || !C$2(function() {
    var e3 = [];
    return (e3.constructor = {})[La$1] = function() {
      return { foo: 1 };
    }, 1 !== e3[t2](Boolean).foo;
  });
}("slice"), za = Ft$2("species"), Fa$1 = R$2.Array, _a$1 = Math.max;
function Da$1(t2) {
  return t2.getMenuConfig("uploadVideo");
}
tn$2({ target: "Array", proto: true, forced: !Va }, { slice: function(t2, e3) {
  var n2, r2, o2, i2 = tt$2(this), u2 = Ce$2(i2), a2 = Ae$2(t2, u2), c2 = Ae$2(void 0 === e3 ? u2 : e3, u2);
  if ($n$2(i2) && (n2 = i2.constructor, (Yn$2(n2) && (n2 === Fa$1 || $n$2(n2.prototype)) || nt$2(n2) && null === (n2 = n2[za])) && (n2 = void 0), n2 === Fa$1 || void 0 === n2))
    return Go$1(i2, a2, c2);
  for (r2 = new (void 0 === n2 ? Fa$1 : n2)(_a$1(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++)
    a2 in i2 && $u$1(r2, o2, i2[a2]);
  return r2.length = o2, r2;
} });
var $a$1 = /* @__PURE__ */ new WeakMap();
function Ha(t2, e3) {
  return x$2(this, void 0, void 0, function() {
    var n2, r2, o2, u2;
    return O$2(this, function(a2) {
      switch (a2.label) {
        case 0:
          return n2 = function(t3) {
            var e4 = $a$1.get(t3);
            if (null != e4)
              return e4;
            var n3 = Da$1(t3), r3 = n3.onSuccess, o3 = n3.onProgress, u3 = n3.onFailed, a3 = n3.customInsert, c2 = n3.onError;
            return e4 = hh(S$2(S$2({}, n3), { onProgress: function(e5) {
              t3.showProgressBar(e5), o3 && o3(e5);
            }, onSuccess: function(e5, n4) {
              if (a3)
                a3(n4, function(e6, n5) {
                  return cu$1(t3, e6, n5);
                });
              else {
                var o4 = n4.errno, i2 = void 0 === o4 ? 1 : o4, c3 = n4.data, s2 = void 0 === c3 ? {} : c3;
                if (0 !== i2)
                  return console.error("'" + e5.name + "' upload failed", n4), void u3(e5, n4);
                var f2 = s2.url, l2 = void 0 === f2 ? "" : f2, d3 = s2.poster;
                cu$1(t3, l2, void 0 === d3 ? "" : d3), r3(e5, n4);
              }
            }, onError: function(t4, e5, n4) {
              var r4 = t4.name;
              console.error("'" + r4 + " upload error", e5, n4), c2 && c2(t4, e5, n4);
            } })), $a$1.set(t3, e4), e4;
          }(t2), r2 = e3.name, o2 = e3.type, u2 = e3.size, n2.addFile({ name: r2, type: o2, size: u2, data: e3 }), [4, n2.upload()];
        case 1:
          return a2.sent(), [2];
      }
    });
  });
}
var Ba$1 = function() {
  function t2() {
    this.title = lp$1("videoModule.uploadVideo"), this.iconSvg = '<svg viewBox="0 0 1056 1024"><path d="M805.902261 521.819882a251.441452 251.441452 0 0 0-251.011972 246.600033 251.051015 251.051015 0 1 0 502.023944 8.823877 253.237463 253.237463 0 0 0-251.011972-255.42391z m59.463561 240.001647v129.898403h-116.701631v-129.898403h-44.041298l101.279368-103.504859 101.279368 103.504859z" p-id="6802"></path><path d="M788.254507 0.000781H99.094092A98.663439 98.663439 0 0 0 0.001171 99.093701v590.067495a98.663439 98.663439 0 0 0 99.092921 99.092921h411.7549a266.434235 266.434235 0 0 1-2.186448-41.815807 275.843767 275.843767 0 0 1 275.180024-270.729042 270.650955 270.650955 0 0 1 103.504859 19.834201V99.093701A101.51363 101.51363 0 0 0 788.254507 0.000781zM295.054441 640.747004V147.507894l394.146189 246.600033z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.getMenuConfig(t3), r2 = n2.allowedFileTypes, o2 = void 0 === r2 ? [] : r2, i2 = n2.customBrowseAndUpload;
    if (i2)
      i2(function(e4) {
        return cu$1(t3, e4);
      });
    else {
      var u2 = "";
      o2.length > 0 && (u2 = 'accept="' + o2.join(", ") + '"');
      var a2 = $$6("body"), c2 = $$6('<input type="file" ' + u2 + " multiple/>");
      c2.hide(), a2.append(c2), c2.click(), c2.on("change", function() {
        var e4 = c2[0].files;
        !function(t4, e5) {
          var n3, r3;
          x$2(this, void 0, void 0, function() {
            var o3, i3, u3, a3, c3, s2;
            return O$2(this, function(f2) {
              switch (f2.label) {
                case 0:
                  if (null == e5)
                    return [2];
                  o3 = Array.prototype.slice.call(e5), i3 = Da$1(t4).customUpload, f2.label = 1;
                case 1:
                  f2.trys.push([1, 9, 10, 15]), u3 = I$2(o3), f2.label = 2;
                case 2:
                  return [4, u3.next()];
                case 3:
                  return (a3 = f2.sent()).done ? [3, 8] : (c3 = a3.value, i3 ? [4, i3(c3, function(e6, n4) {
                    return cu$1(t4, e6, n4);
                  })] : [3, 5]);
                case 4:
                  return f2.sent(), [3, 7];
                case 5:
                  return [4, Ha(t4, c3)];
                case 6:
                  f2.sent(), f2.label = 7;
                case 7:
                  return [3, 2];
                case 8:
                  return [3, 15];
                case 9:
                  return s2 = f2.sent(), n3 = { error: s2 }, [3, 15];
                case 10:
                  return f2.trys.push([10, , 13, 14]), a3 && !a3.done && (r3 = u3.return) ? [4, r3.call(u3)] : [3, 12];
                case 11:
                  f2.sent(), f2.label = 12;
                case 12:
                  return [3, 14];
                case 13:
                  if (n3)
                    throw n3.error;
                  return [7];
                case 14:
                  return [7];
                case 15:
                  return [2];
              }
            });
          });
        }(t3, e4);
      });
    }
  }, t2.prototype.isDisabled = function(t3) {
    var n2 = t3.selection;
    return null == n2 || (!Range.isCollapsed(n2) || !!rl$1.getSelectedElems(t3).some(function(n3) {
      return "pre" === rl$1.getNodeType(n3) || !!t3.isVoid(n3);
    }));
  }, t2.prototype.getMenuConfig = function(t3) {
    return t3.getMenuConfig("uploadVideo");
  }, t2;
}(), Ga = Oe$2.PROPER, Wa = RegExp.prototype, Ua$1 = Wa.toString, Ka = W$2(sr$1), Xa = C$2(function() {
  return "/a/b" != Ua$1.call({ source: "a", flags: "b" });
}), Ya = Ga && "toString" != Ua$1.name;
function qa() {
  return co$1("w-e-insert-video");
}
(Xa || Ya) && Ee$2(RegExp.prototype, "toString", function() {
  var t2 = Jt$2(this), e3 = fn$2(t2.source), n2 = t2.flags;
  return "/" + e3 + "/" + fn$2(void 0 === n2 && it$2(Wa, t2) && !("flags" in Wa) ? Ka(t2) : n2);
}, { unsafe: true });
var Ja = function() {
  function t2() {
    this.title = lp$1("videoModule.editSize"), this.tag = "button", this.showModal = true, this.modalWidth = 320, this.$content = null, this.widthInputId = qa(), this.heightInputId = qa(), this.buttonId = qa();
  }
  return t2.prototype.getSelectedVideoNode = function(t3) {
    return rl$1.getSelectedNodeByType(t3, "video");
  }, t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.exec = function(t3, e3) {
  }, t2.prototype.isDisabled = function(t3) {
    return null == t3.selection || null == this.getSelectedVideoNode(t3);
  }, t2.prototype.getModalPositionNode = function(t3) {
    return this.getSelectedVideoNode(t3);
  }, t2.prototype.getModalContentElem = function(t3) {
    var i2 = this, a2 = i2.widthInputId, c2 = i2.heightInputId, s2 = i2.buttonId, l2 = j$2(Wd$1(lp$1("videoModule.width"), a2, "auto"), 2), d3 = l2[0], p2 = l2[1], v2 = $$6(p2), h2 = j$2(Wd$1(lp$1("videoModule.height"), c2, "auto"), 2), y2 = h2[0], g2 = h2[1], m2 = $$6(g2), b2 = j$2(zd$1(s2, lp$1("videoModule.ok")), 1)[0];
    if (null == this.$content) {
      var w2 = $$6("<div></div>");
      w2.on("click", "#" + s2, function(n2) {
        n2.preventDefault();
        var r2 = w2.find("#" + a2).val().trim(), o2 = w2.find("#" + c2).val().trim(), i3 = parseInt(r2), s3 = parseInt(o2), f2 = i3 ? i3.toString() : "auto", l3 = s3 ? s3.toString() : "auto";
        t3.restoreSelection(), Transforms.setNodes(t3, { width: f2, height: l3 }, { match: function(t4) {
          return rl$1.checkNodeType(t4, "video");
        } }), t3.hidePanelOrModal();
      }), this.$content = w2;
    }
    var S2 = this.$content;
    S2.empty(), S2.append(d3), S2.append(y2), S2.append(b2);
    var x2 = this.getSelectedVideoNode(t3);
    if (null == x2)
      return S2[0];
    var O2 = x2.width, E2 = void 0 === O2 ? "auto" : O2, I2 = x2.height, P2 = void 0 === I2 ? "auto" : I2;
    return v2.val(E2), m2.val(P2), setTimeout(function() {
      v2.focus();
    }), S2[0];
  }, t2;
}();
var Qa = { renderElems: [xn$2], elemsToHtml: [En$2], preParseHtml: [Fn$2], parseElemsHtml: [cr$1], menus: [{ key: "insertVideo", factory: function() {
  return new fu$1();
}, config: { onInsertedVideo: function(t2) {
}, checkVideo: function(t2) {
  return true;
}, parseVideoSrc: function(t2) {
  return t2;
} } }, { key: "uploadVideo", factory: function() {
  return new Ba$1();
}, config: { server: "", fieldName: "wangeditor-uploaded-video", maxFileSize: 10485760, maxNumberOfFiles: 5, allowedFileTypes: ["video/*"], meta: {}, metaWithUrl: false, withCredentials: false, timeout: 3e4, onBeforeUpload: function(t2) {
  return t2;
}, onProgress: function(t2) {
}, onSuccess: function(t2, e3) {
}, onFailed: function(t2, e3) {
}, onError: function(t2, e3, n2) {
} } }, { key: "editVideoSize", factory: function() {
  return new Ja();
} }], editorPlugin: function(t2) {
  var n2 = t2.isVoid, r2 = t2.normalizeNode, o2 = t2;
  return o2.isVoid = function(t3) {
    return "video" === t3.type || n2(t3);
  }, o2.normalizeNode = function(t3) {
    var n3 = j$2(t3, 2), i2 = n3[0], a2 = n3[1];
    "video" === rl$1.getNodeType(i2) && (rl$1.isLastNode(o2, i2) && Transforms.insertNodes(o2, rl$1.genEmptyParagraph(), { at: [a2[0] + 1] }));
    return r2([i2, a2]);
  }, o2;
} };
ip$1("en", { uploadImgModule: { uploadImage: "Upload Image", uploadError: "{{fileName}} upload error" } }), ip$1("zh-CN", { uploadImgModule: { uploadImage: "\u4E0A\u4F20\u56FE\u7247", uploadError: "{{fileName}} \u4E0A\u4F20\u51FA\u9519" } });
var p$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function v$1(t2) {
  var e3 = { exports: {} };
  return t2(e3, e3.exports), e3.exports;
}
var d$1, h$1, y$1 = function(t2) {
  return t2 && t2.Math == Math && t2;
}, g$1 = y$1("object" == typeof globalThis && globalThis) || y$1("object" == typeof window && window) || y$1("object" == typeof self && self) || y$1("object" == typeof p$1 && p$1) || function() {
  return this;
}() || Function("return this")(), m$1 = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, b$1 = !m$1(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), w$1 = Function.prototype.call, S$1 = w$1.bind ? w$1.bind(w$1) : function() {
  return w$1.apply(w$1, arguments);
}, x$1 = {}.propertyIsEnumerable, O$1 = Object.getOwnPropertyDescriptor, E$1 = { f: O$1 && !x$1.call({ 1: 2 }, 1) ? function(t2) {
  var e3 = O$1(this, t2);
  return !!e3 && e3.enumerable;
} : x$1 }, j$1 = function(t2, e3) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e3 };
}, I$1 = Function.prototype, T$1 = I$1.bind, A$1 = I$1.call, P$1 = T$1 && T$1.bind(A$1), R$1 = T$1 ? function(t2) {
  return t2 && P$1(A$1, t2);
} : function(t2) {
  return t2 && function() {
    return A$1.apply(t2, arguments);
  };
}, k$1 = R$1({}.toString), M$1 = R$1("".slice), L$1 = function(t2) {
  return M$1(k$1(t2), 8, -1);
}, F$1 = g$1.Object, _$1 = R$1("".split), C$1 = m$1(function() {
  return !F$1("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == L$1(t2) ? _$1(t2, "") : F$1(t2);
} : F$1, z$1 = g$1.TypeError, D$1 = function(t2) {
  if (null == t2)
    throw z$1("Can't call method on " + t2);
  return t2;
}, N$1 = function(t2) {
  return C$1(D$1(t2));
}, G$1 = function(t2) {
  return "function" == typeof t2;
}, U$1 = function(t2) {
  return "object" == typeof t2 ? null !== t2 : G$1(t2);
}, B$1 = function(t2) {
  return G$1(t2) ? t2 : void 0;
}, V$1 = function(t2, e3) {
  return arguments.length < 2 ? B$1(g$1[t2]) : g$1[t2] && g$1[t2][e3];
}, W$1 = R$1({}.isPrototypeOf), H$1 = V$1("navigator", "userAgent") || "", K$1 = g$1.process, Y$1 = g$1.Deno, X$1 = K$1 && K$1.versions || Y$1 && Y$1.version, q$1 = X$1 && X$1.v8;
q$1 && (h$1 = (d$1 = q$1.split("."))[0] > 0 && d$1[0] < 4 ? 1 : +(d$1[0] + d$1[1])), !h$1 && H$1 && (!(d$1 = H$1.match(/Edge\/(\d+)/)) || d$1[1] >= 74) && (d$1 = H$1.match(/Chrome\/(\d+)/)) && (h$1 = +d$1[1]);
var $$1 = h$1, J$1 = !!Object.getOwnPropertySymbols && !m$1(function() {
  var t2 = Symbol();
  return !String(t2) || !(Object(t2) instanceof Symbol) || !Symbol.sham && $$1 && $$1 < 41;
}), Q$1 = J$1 && !Symbol.sham && "symbol" == typeof Symbol.iterator, Z$1 = g$1.Object, tt$1 = Q$1 ? function(t2) {
  return "symbol" == typeof t2;
} : function(t2) {
  var e3 = V$1("Symbol");
  return G$1(e3) && W$1(e3.prototype, Z$1(t2));
}, et$1 = g$1.String, nt$1 = function(t2) {
  try {
    return et$1(t2);
  } catch (t3) {
    return "Object";
  }
}, rt$1 = g$1.TypeError, ot$1 = function(t2) {
  if (G$1(t2))
    return t2;
  throw rt$1(nt$1(t2) + " is not a function");
}, it$1 = function(t2, e3) {
  var n2 = t2[e3];
  return null == n2 ? void 0 : ot$1(n2);
}, ut$1 = g$1.TypeError, at$1 = Object.defineProperty, ct$1 = function(t2, e3) {
  try {
    at$1(g$1, t2, { value: e3, configurable: true, writable: true });
  } catch (n2) {
    g$1[t2] = e3;
  }
  return e3;
}, ft$1 = g$1["__core-js_shared__"] || ct$1("__core-js_shared__", {}), st$1 = v$1(function(t2) {
  (t2.exports = function(t3, e3) {
    return ft$1[t3] || (ft$1[t3] = void 0 !== e3 ? e3 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), lt$1 = g$1.Object, pt$1 = function(t2) {
  return lt$1(D$1(t2));
}, vt$1 = R$1({}.hasOwnProperty), dt$1 = Object.hasOwn || function(t2, e3) {
  return vt$1(pt$1(t2), e3);
}, ht$1 = 0, yt$1 = Math.random(), gt$1 = R$1(1 .toString), mt$1 = function(t2) {
  return "Symbol(" + (void 0 === t2 ? "" : t2) + ")_" + gt$1(++ht$1 + yt$1, 36);
}, bt$1 = st$1("wks"), wt$1 = g$1.Symbol, St$1 = wt$1 && wt$1.for, xt$1 = Q$1 ? wt$1 : wt$1 && wt$1.withoutSetter || mt$1, Ot$1 = function(t2) {
  if (!dt$1(bt$1, t2) || !J$1 && "string" != typeof bt$1[t2]) {
    var e3 = "Symbol." + t2;
    J$1 && dt$1(wt$1, t2) ? bt$1[t2] = wt$1[t2] : bt$1[t2] = Q$1 && St$1 ? St$1(e3) : xt$1(e3);
  }
  return bt$1[t2];
}, Et$1 = g$1.TypeError, jt$1 = Ot$1("toPrimitive"), It$1 = function(t2, e3) {
  if (!U$1(t2) || tt$1(t2))
    return t2;
  var n2, r2 = it$1(t2, jt$1);
  if (r2) {
    if (void 0 === e3 && (e3 = "default"), n2 = S$1(r2, t2, e3), !U$1(n2) || tt$1(n2))
      return n2;
    throw Et$1("Can't convert object to primitive value");
  }
  return void 0 === e3 && (e3 = "number"), function(t3, e4) {
    var n3, r3;
    if ("string" === e4 && G$1(n3 = t3.toString) && !U$1(r3 = S$1(n3, t3)))
      return r3;
    if (G$1(n3 = t3.valueOf) && !U$1(r3 = S$1(n3, t3)))
      return r3;
    if ("string" !== e4 && G$1(n3 = t3.toString) && !U$1(r3 = S$1(n3, t3)))
      return r3;
    throw ut$1("Can't convert object to primitive value");
  }(t2, e3);
}, Tt$1 = function(t2) {
  var e3 = It$1(t2, "string");
  return tt$1(e3) ? e3 : e3 + "";
}, At$1 = g$1.document, Pt$1 = U$1(At$1) && U$1(At$1.createElement), Rt$1 = function(t2) {
  return Pt$1 ? At$1.createElement(t2) : {};
}, kt$1 = !b$1 && !m$1(function() {
  return 7 != Object.defineProperty(Rt$1("div"), "a", { get: function() {
    return 7;
  } }).a;
}), Mt$1 = Object.getOwnPropertyDescriptor, Lt$1 = { f: b$1 ? Mt$1 : function(t2, e3) {
  if (t2 = N$1(t2), e3 = Tt$1(e3), kt$1)
    try {
      return Mt$1(t2, e3);
    } catch (t3) {
    }
  if (dt$1(t2, e3))
    return j$1(!S$1(E$1.f, t2, e3), t2[e3]);
} }, Ft$1 = g$1.String, _t$1 = g$1.TypeError, Ct$1 = function(t2) {
  if (U$1(t2))
    return t2;
  throw _t$1(Ft$1(t2) + " is not an object");
}, zt$1 = g$1.TypeError, Dt$1 = Object.defineProperty, Nt$1 = { f: b$1 ? Dt$1 : function(t2, e3, n2) {
  if (Ct$1(t2), e3 = Tt$1(e3), Ct$1(n2), kt$1)
    try {
      return Dt$1(t2, e3, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw zt$1("Accessors not supported");
  return "value" in n2 && (t2[e3] = n2.value), t2;
} }, Gt$1 = b$1 ? function(t2, e3, n2) {
  return Nt$1.f(t2, e3, j$1(1, n2));
} : function(t2, e3, n2) {
  return t2[e3] = n2, t2;
}, Ut$1 = R$1(Function.toString);
G$1(ft$1.inspectSource) || (ft$1.inspectSource = function(t2) {
  return Ut$1(t2);
});
var Bt$1, Vt$1, Wt$1, Ht$1 = ft$1.inspectSource, Kt$1 = g$1.WeakMap, Yt$1 = G$1(Kt$1) && /native code/.test(Ht$1(Kt$1)), Xt$1 = st$1("keys"), qt$1 = function(t2) {
  return Xt$1[t2] || (Xt$1[t2] = mt$1(t2));
}, $t$1 = {}, Jt$1 = g$1.TypeError, Qt$1 = g$1.WeakMap;
if (Yt$1 || ft$1.state) {
  var Zt$1 = ft$1.state || (ft$1.state = new Qt$1()), te$1 = R$1(Zt$1.get), ee$1 = R$1(Zt$1.has), ne$1 = R$1(Zt$1.set);
  Bt$1 = function(t2, e3) {
    if (ee$1(Zt$1, t2))
      throw new Jt$1("Object already initialized");
    return e3.facade = t2, ne$1(Zt$1, t2, e3), e3;
  }, Vt$1 = function(t2) {
    return te$1(Zt$1, t2) || {};
  }, Wt$1 = function(t2) {
    return ee$1(Zt$1, t2);
  };
} else {
  var re$1 = qt$1("state");
  $t$1[re$1] = true, Bt$1 = function(t2, e3) {
    if (dt$1(t2, re$1))
      throw new Jt$1("Object already initialized");
    return e3.facade = t2, Gt$1(t2, re$1, e3), e3;
  }, Vt$1 = function(t2) {
    return dt$1(t2, re$1) ? t2[re$1] : {};
  }, Wt$1 = function(t2) {
    return dt$1(t2, re$1);
  };
}
var oe$1 = { set: Bt$1, get: Vt$1, has: Wt$1, enforce: function(t2) {
  return Wt$1(t2) ? Vt$1(t2) : Bt$1(t2, {});
}, getterFor: function(t2) {
  return function(e3) {
    var n2;
    if (!U$1(e3) || (n2 = Vt$1(e3)).type !== t2)
      throw Jt$1("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, ie$1 = Function.prototype, ue$1 = b$1 && Object.getOwnPropertyDescriptor, ae$1 = dt$1(ie$1, "name"), ce$1 = { EXISTS: ae$1, PROPER: ae$1 && "something" === function() {
}.name, CONFIGURABLE: ae$1 && (!b$1 || b$1 && ue$1(ie$1, "name").configurable) }, fe$1 = v$1(function(t2) {
  var e3 = ce$1.CONFIGURABLE, n2 = oe$1.get, r2 = oe$1.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, n3, i2, u2) {
    var a2, c2 = !!u2 && !!u2.unsafe, f2 = !!u2 && !!u2.enumerable, s2 = !!u2 && !!u2.noTargetGet, l2 = u2 && void 0 !== u2.name ? u2.name : n3;
    G$1(i2) && ("Symbol(" === String(l2).slice(0, 7) && (l2 = "[" + String(l2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!dt$1(i2, "name") || e3 && i2.name !== l2) && Gt$1(i2, "name", l2), (a2 = r2(i2)).source || (a2.source = o2.join("string" == typeof l2 ? l2 : ""))), t3 !== g$1 ? (c2 ? !s2 && t3[n3] && (f2 = true) : delete t3[n3], f2 ? t3[n3] = i2 : Gt$1(t3, n3, i2)) : f2 ? t3[n3] = i2 : ct$1(n3, i2);
  })(Function.prototype, "toString", function() {
    return G$1(this) && n2(this).source || Ht$1(this);
  });
}), se$1 = Math.ceil, le$1 = Math.floor, pe$1 = function(t2) {
  var e3 = +t2;
  return e3 != e3 || 0 === e3 ? 0 : (e3 > 0 ? le$1 : se$1)(e3);
}, ve$1 = Math.max, de$1 = Math.min, he$1 = function(t2, e3) {
  var n2 = pe$1(t2);
  return n2 < 0 ? ve$1(n2 + e3, 0) : de$1(n2, e3);
}, ye$1 = Math.min, ge$1 = function(t2) {
  return t2 > 0 ? ye$1(pe$1(t2), 9007199254740991) : 0;
}, me$1 = function(t2) {
  return ge$1(t2.length);
}, be$1 = function(t2) {
  return function(e3, n2, r2) {
    var o2, i2 = N$1(e3), u2 = me$1(i2), a2 = he$1(r2, u2);
    if (t2 && n2 != n2) {
      for (; u2 > a2; )
        if ((o2 = i2[a2++]) != o2)
          return true;
    } else
      for (; u2 > a2; a2++)
        if ((t2 || a2 in i2) && i2[a2] === n2)
          return t2 || a2 || 0;
    return !t2 && -1;
  };
}, we$1 = { includes: be$1(true), indexOf: be$1(false) }.indexOf, Se$1 = R$1([].push), xe$1 = function(t2, e3) {
  var n2, r2 = N$1(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !dt$1($t$1, n2) && dt$1(r2, n2) && Se$1(i2, n2);
  for (; e3.length > o2; )
    dt$1(r2, n2 = e3[o2++]) && (~we$1(i2, n2) || Se$1(i2, n2));
  return i2;
}, Oe$1 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Ee$1 = Oe$1.concat("length", "prototype"), je$1 = { f: Object.getOwnPropertyNames || function(t2) {
  return xe$1(t2, Ee$1);
} }, Ie$1 = { f: Object.getOwnPropertySymbols }, Te$1 = R$1([].concat), Ae$1 = V$1("Reflect", "ownKeys") || function(t2) {
  var e3 = je$1.f(Ct$1(t2)), n2 = Ie$1.f;
  return n2 ? Te$1(e3, n2(t2)) : e3;
}, Pe$1 = function(t2, e3) {
  for (var n2 = Ae$1(e3), r2 = Nt$1.f, o2 = Lt$1.f, i2 = 0; i2 < n2.length; i2++) {
    var u2 = n2[i2];
    dt$1(t2, u2) || r2(t2, u2, o2(e3, u2));
  }
}, Re$1 = /#|\.prototype\./, ke$1 = function(t2, e3) {
  var n2 = Le$1[Me$1(t2)];
  return n2 == _e$1 || n2 != Fe$1 && (G$1(e3) ? m$1(e3) : !!e3);
}, Me$1 = ke$1.normalize = function(t2) {
  return String(t2).replace(Re$1, ".").toLowerCase();
}, Le$1 = ke$1.data = {}, Fe$1 = ke$1.NATIVE = "N", _e$1 = ke$1.POLYFILL = "P", Ce$1 = ke$1, ze$1 = Lt$1.f, De$1 = function(t2, e3) {
  var n2, r2, o2, i2, u2, a2 = t2.target, c2 = t2.global, f2 = t2.stat;
  if (n2 = c2 ? g$1 : f2 ? g$1[a2] || ct$1(a2, {}) : (g$1[a2] || {}).prototype)
    for (r2 in e3) {
      if (i2 = e3[r2], o2 = t2.noTargetGet ? (u2 = ze$1(n2, r2)) && u2.value : n2[r2], !Ce$1(c2 ? r2 : a2 + (f2 ? "." : "#") + r2, t2.forced) && void 0 !== o2) {
        if (typeof i2 == typeof o2)
          continue;
        Pe$1(i2, o2);
      }
      (t2.sham || o2 && o2.sham) && Gt$1(i2, "sham", true), fe$1(n2, r2, i2, t2);
    }
}, Ne$1 = Array.isArray || function(t2) {
  return "Array" == L$1(t2);
}, Ge$1 = {};
Ge$1[Ot$1("toStringTag")] = "z";
var Ue$1, Be$1 = "[object z]" === String(Ge$1), Ve$1 = Ot$1("toStringTag"), We$1 = g$1.Object, He$1 = "Arguments" == L$1(function() {
  return arguments;
}()), Ke$1 = Be$1 ? L$1 : function(t2) {
  var e3, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e4) {
    try {
      return t3[e4];
    } catch (t4) {
    }
  }(e3 = We$1(t2), Ve$1)) ? n2 : He$1 ? L$1(e3) : "Object" == (r2 = L$1(e3)) && G$1(e3.callee) ? "Arguments" : r2;
}, Ye$1 = function() {
}, Xe$1 = [], qe$1 = V$1("Reflect", "construct"), $e$1 = /^\s*(?:class|function)\b/, Je$1 = R$1($e$1.exec), Qe$1 = !$e$1.exec(Ye$1), Ze$1 = function(t2) {
  if (!G$1(t2))
    return false;
  try {
    return qe$1(Ye$1, Xe$1, t2), true;
  } catch (t3) {
    return false;
  }
}, tn$1 = !qe$1 || m$1(function() {
  var t2;
  return Ze$1(Ze$1.call) || !Ze$1(Object) || !Ze$1(function() {
    t2 = true;
  }) || t2;
}) ? function(t2) {
  if (!G$1(t2))
    return false;
  switch (Ke$1(t2)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return Qe$1 || !!Je$1($e$1, Ht$1(t2));
} : Ze$1, en$1 = function(t2, e3, n2) {
  var r2 = Tt$1(e3);
  r2 in t2 ? Nt$1.f(t2, r2, j$1(0, n2)) : t2[r2] = n2;
}, nn$1 = Ot$1("species"), rn$1 = R$1([].slice), on$1 = (Ue$1 = "slice", $$1 >= 51 || !m$1(function() {
  var t2 = [];
  return (t2.constructor = {})[nn$1] = function() {
    return { foo: 1 };
  }, 1 !== t2[Ue$1](Boolean).foo;
})), un$1 = Ot$1("species"), an$1 = g$1.Array, cn$1 = Math.max;
De$1({ target: "Array", proto: true, forced: !on$1 }, { slice: function(t2, e3) {
  var n2, r2, o2, i2 = N$1(this), u2 = me$1(i2), a2 = he$1(t2, u2), c2 = he$1(void 0 === e3 ? u2 : e3, u2);
  if (Ne$1(i2) && (n2 = i2.constructor, (tn$1(n2) && (n2 === an$1 || Ne$1(n2.prototype)) || U$1(n2) && null === (n2 = n2[un$1])) && (n2 = void 0), n2 === an$1 || void 0 === n2))
    return rn$1(i2, a2, c2);
  for (r2 = new (void 0 === n2 ? an$1 : n2)(cn$1(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++)
    a2 in i2 && en$1(r2, o2, i2[a2]);
  return r2.length = o2, r2;
} });
var fn$1 = Be$1 ? {}.toString : function() {
  return "[object " + Ke$1(this) + "]";
};
Be$1 || fe$1(Object.prototype, "toString", fn$1, { unsafe: true });
var sn$1, ln$1 = g$1.String, pn$1 = function(t2) {
  if ("Symbol" === Ke$1(t2))
    throw TypeError("Cannot convert a Symbol value to a string");
  return ln$1(t2);
}, vn$1 = function() {
  var t2 = Ct$1(this), e3 = "";
  return t2.global && (e3 += "g"), t2.ignoreCase && (e3 += "i"), t2.multiline && (e3 += "m"), t2.dotAll && (e3 += "s"), t2.unicode && (e3 += "u"), t2.sticky && (e3 += "y"), e3;
}, dn$1 = g$1.RegExp, hn$1 = m$1(function() {
  var t2 = dn$1("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), yn$1 = hn$1 || m$1(function() {
  return !dn$1("a", "y").sticky;
}), gn$1 = { BROKEN_CARET: hn$1 || m$1(function() {
  var t2 = dn$1("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}), MISSED_STICKY: yn$1, UNSUPPORTED_Y: hn$1 }, mn$1 = Object.keys || function(t2) {
  return xe$1(t2, Oe$1);
}, bn$1 = b$1 ? Object.defineProperties : function(t2, e3) {
  Ct$1(t2);
  for (var n2, r2 = N$1(e3), o2 = mn$1(e3), i2 = o2.length, u2 = 0; i2 > u2; )
    Nt$1.f(t2, n2 = o2[u2++], r2[n2]);
  return t2;
}, wn$1 = V$1("document", "documentElement"), Sn$1 = qt$1("IE_PROTO"), xn$1 = function() {
}, On$1 = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, En$1 = function(t2) {
  t2.write(On$1("")), t2.close();
  var e3 = t2.parentWindow.Object;
  return t2 = null, e3;
}, jn$1 = function() {
  try {
    sn$1 = new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e3;
  jn$1 = "undefined" != typeof document ? document.domain && sn$1 ? En$1(sn$1) : ((e3 = Rt$1("iframe")).style.display = "none", wn$1.appendChild(e3), e3.src = String("javascript:"), (t2 = e3.contentWindow.document).open(), t2.write(On$1("document.F=Object")), t2.close(), t2.F) : En$1(sn$1);
  for (var n2 = Oe$1.length; n2--; )
    delete jn$1.prototype[Oe$1[n2]];
  return jn$1();
};
$t$1[Sn$1] = true;
var In$1, Tn$1, An$1 = Object.create || function(t2, e3) {
  var n2;
  return null !== t2 ? (xn$1.prototype = Ct$1(t2), n2 = new xn$1(), xn$1.prototype = null, n2[Sn$1] = t2) : n2 = jn$1(), void 0 === e3 ? n2 : bn$1(n2, e3);
}, Pn$1 = g$1.RegExp, Rn$1 = m$1(function() {
  var t2 = Pn$1(".", "s");
  return !(t2.dotAll && t2.exec("\n") && "s" === t2.flags);
}), kn$1 = g$1.RegExp, Mn$1 = m$1(function() {
  var t2 = kn$1("(?<a>b)", "g");
  return "b" !== t2.exec("b").groups.a || "bc" !== "b".replace(t2, "$<a>c");
}), Ln$1 = oe$1.get, Fn$1 = st$1("native-string-replace", String.prototype.replace), _n$1 = RegExp.prototype.exec, Cn$1 = _n$1, zn$1 = R$1("".charAt), Dn$1 = R$1("".indexOf), Nn$1 = R$1("".replace), Gn$1 = R$1("".slice), Un$1 = (Tn$1 = /b*/g, S$1(_n$1, In$1 = /a/, "a"), S$1(_n$1, Tn$1, "a"), 0 !== In$1.lastIndex || 0 !== Tn$1.lastIndex), Bn$1 = gn$1.BROKEN_CARET, Vn$1 = void 0 !== /()??/.exec("")[1];
(Un$1 || Vn$1 || Bn$1 || Rn$1 || Mn$1) && (Cn$1 = function(t2) {
  var e3, n2, r2, o2, i2, u2, a2, c2 = this, f2 = Ln$1(c2), s2 = pn$1(t2), l2 = f2.raw;
  if (l2)
    return l2.lastIndex = c2.lastIndex, e3 = S$1(Cn$1, l2, s2), c2.lastIndex = l2.lastIndex, e3;
  var p2 = f2.groups, v2 = Bn$1 && c2.sticky, d3 = S$1(vn$1, c2), h2 = c2.source, y2 = 0, g2 = s2;
  if (v2 && (d3 = Nn$1(d3, "y", ""), -1 === Dn$1(d3, "g") && (d3 += "g"), g2 = Gn$1(s2, c2.lastIndex), c2.lastIndex > 0 && (!c2.multiline || c2.multiline && "\n" !== zn$1(s2, c2.lastIndex - 1)) && (h2 = "(?: " + h2 + ")", g2 = " " + g2, y2++), n2 = new RegExp("^(?:" + h2 + ")", d3)), Vn$1 && (n2 = new RegExp("^" + h2 + "$(?!\\s)", d3)), Un$1 && (r2 = c2.lastIndex), o2 = S$1(_n$1, v2 ? n2 : c2, g2), v2 ? o2 ? (o2.input = Gn$1(o2.input, y2), o2[0] = Gn$1(o2[0], y2), o2.index = c2.lastIndex, c2.lastIndex += o2[0].length) : c2.lastIndex = 0 : Un$1 && o2 && (c2.lastIndex = c2.global ? o2.index + o2[0].length : r2), Vn$1 && o2 && o2.length > 1 && S$1(Fn$1, o2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (o2[i2] = void 0);
  }), o2 && p2)
    for (o2.groups = u2 = An$1(null), i2 = 0; i2 < p2.length; i2++)
      u2[(a2 = p2[i2])[0]] = o2[a2[1]];
  return o2;
});
var Wn$1 = Cn$1;
De$1({ target: "RegExp", proto: true, forced: /./.exec !== Wn$1 }, { exec: Wn$1 });
var Hn$1 = Function.prototype, Kn$1 = Hn$1.apply, Yn$1 = Hn$1.bind, Xn$1 = Hn$1.call, qn$1 = "object" == typeof Reflect && Reflect.apply || (Yn$1 ? Xn$1.bind(Kn$1) : function() {
  return Xn$1.apply(Kn$1, arguments);
}), $n$1 = Ot$1("species"), Jn$1 = RegExp.prototype, Qn$1 = Ot$1("match"), Zn$1 = g$1.TypeError, tr = Ot$1("species"), er = function(t2, e3) {
  var n2, r2 = Ct$1(t2).constructor;
  return void 0 === r2 || null == (n2 = Ct$1(r2)[tr]) ? e3 : function(t3) {
    if (tn$1(t3))
      return t3;
    throw Zn$1(nt$1(t3) + " is not a constructor");
  }(n2);
}, nr = R$1("".charAt), rr = R$1("".charCodeAt), or = R$1("".slice), ir = function(t2) {
  return function(e3, n2) {
    var r2, o2, i2 = pn$1(D$1(e3)), u2 = pe$1(n2), a2 = i2.length;
    return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = rr(i2, u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = rr(i2, u2 + 1)) < 56320 || o2 > 57343 ? t2 ? nr(i2, u2) : r2 : t2 ? or(i2, u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, ur = { codeAt: ir(false), charAt: ir(true) }, ar = ur.charAt, cr = function(t2, e3, n2) {
  return e3 + (n2 ? ar(t2, e3).length : 1);
}, fr = g$1.Array, sr = Math.max, lr = function(t2, e3, n2) {
  for (var r2 = me$1(t2), o2 = he$1(e3, r2), i2 = he$1(void 0 === n2 ? r2 : n2, r2), u2 = fr(sr(i2 - o2, 0)), a2 = 0; o2 < i2; o2++, a2++)
    en$1(u2, a2, t2[o2]);
  return u2.length = a2, u2;
}, pr = g$1.TypeError, vr = function(t2, e3) {
  var n2 = t2.exec;
  if (G$1(n2)) {
    var r2 = S$1(n2, t2, e3);
    return null !== r2 && Ct$1(r2), r2;
  }
  if ("RegExp" === L$1(t2))
    return S$1(Wn$1, t2, e3);
  throw pr("RegExp#exec called on incompatible receiver");
}, dr = gn$1.UNSUPPORTED_Y, hr = Math.min, yr = [].push, gr = R$1(/./.exec), mr = R$1(yr), br = R$1("".slice);
!function(t2, e3, n2, r2) {
  var o2 = Ot$1(t2), i2 = !m$1(function() {
    var e4 = {};
    return e4[o2] = function() {
      return 7;
    }, 7 != ""[t2](e4);
  }), u2 = i2 && !m$1(function() {
    var e4 = false, n3 = /a/;
    return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[$n$1] = function() {
      return n3;
    }, n3.flags = "", n3[o2] = /./[o2]), n3.exec = function() {
      return e4 = true, null;
    }, n3[o2](""), !e4;
  });
  if (!i2 || !u2 || n2) {
    var a2 = R$1(/./[o2]), c2 = e3(o2, ""[t2], function(t3, e4, n3, r3, o3) {
      var u3 = R$1(t3), c3 = e4.exec;
      return c3 === Wn$1 || c3 === Jn$1.exec ? i2 && !o3 ? { done: true, value: a2(e4, n3, r3) } : { done: true, value: u3(n3, e4, r3) } : { done: false };
    });
    fe$1(String.prototype, t2, c2[0]), fe$1(Jn$1, o2, c2[1]);
  }
  r2 && Gt$1(Jn$1[o2], "sham", true);
}("split", function(t2, e3, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
    var r3, o2, i2 = pn$1(D$1(this)), u2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === u2)
      return [];
    if (void 0 === t3)
      return [i2];
    if (!U$1(r3 = t3) || !(void 0 !== (o2 = r3[Qn$1]) ? o2 : "RegExp" == L$1(r3)))
      return S$1(e3, i2, t3, u2);
    for (var a2, c2, f2, s2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), p2 = 0, v2 = new RegExp(t3.source, l2 + "g"); (a2 = S$1(Wn$1, v2, i2)) && !((c2 = v2.lastIndex) > p2 && (mr(s2, br(i2, p2, a2.index)), a2.length > 1 && a2.index < i2.length && qn$1(yr, s2, lr(a2, 1)), f2 = a2[0].length, p2 = c2, s2.length >= u2)); )
      v2.lastIndex === a2.index && v2.lastIndex++;
    return p2 === i2.length ? !f2 && gr(v2, "") || mr(s2, "") : mr(s2, br(i2, p2)), s2.length > u2 ? lr(s2, 0, u2) : s2;
  } : "0".split(void 0, 0).length ? function(t3, n3) {
    return void 0 === t3 && 0 === n3 ? [] : S$1(e3, this, t3, n3);
  } : e3, [function(e4, n3) {
    var o2 = D$1(this), i2 = null == e4 ? void 0 : it$1(e4, t2);
    return i2 ? S$1(i2, e4, o2, n3) : S$1(r2, pn$1(o2), e4, n3);
  }, function(t3, o2) {
    var i2 = Ct$1(this), u2 = pn$1(t3), a2 = n2(r2, i2, u2, o2, r2 !== e3);
    if (a2.done)
      return a2.value;
    var c2 = er(i2, RegExp), f2 = i2.unicode, s2 = (i2.ignoreCase ? "i" : "") + (i2.multiline ? "m" : "") + (i2.unicode ? "u" : "") + (dr ? "g" : "y"), l2 = new c2(dr ? "^(?:" + i2.source + ")" : i2, s2), p2 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === p2)
      return [];
    if (0 === u2.length)
      return null === vr(l2, u2) ? [u2] : [];
    for (var v2 = 0, d3 = 0, h2 = []; d3 < u2.length; ) {
      l2.lastIndex = dr ? 0 : d3;
      var y2, g2 = vr(l2, dr ? br(u2, d3) : u2);
      if (null === g2 || (y2 = hr(ge$1(l2.lastIndex + (dr ? d3 : 0)), u2.length)) === v2)
        d3 = cr(u2, d3, f2);
      else {
        if (mr(h2, br(u2, v2, d3)), h2.length === p2)
          return h2;
        for (var m2 = 1; m2 <= g2.length - 1; m2++)
          if (mr(h2, g2[m2]), h2.length === p2)
            return h2;
        d3 = v2 = y2;
      }
    }
    return mr(h2, br(u2, v2)), h2;
  }];
}, !!m$1(function() {
  var t2 = /(?:)/, e3 = t2.exec;
  t2.exec = function() {
    return e3.apply(this, arguments);
  };
  var n2 = "ab".split(t2);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), dr);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var wr = function() {
  return wr = Object.assign || function(t2) {
    for (var e3, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
      for (var o2 in e3 = arguments[n2])
        Object.prototype.hasOwnProperty.call(e3, o2) && (t2[o2] = e3[o2]);
    return t2;
  }, wr.apply(this, arguments);
};
function Sr(t2, e3, n2, r2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function u2(t3) {
      try {
        c2(r2.next(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function a2(t3) {
      try {
        c2(r2.throw(t3));
      } catch (t4) {
        i2(t4);
      }
    }
    function c2(t3) {
      var e4;
      t3.done ? o2(t3.value) : (e4 = t3.value, e4 instanceof n2 ? e4 : new n2(function(t4) {
        t4(e4);
      })).then(u2, a2);
    }
    c2((r2 = r2.apply(t2, e3 || [])).next());
  });
}
function xr(t2, e3) {
  var n2, r2, o2, i2, u2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function a2(i3) {
    return function(a3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; u2; )
          try {
            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
              return o2;
            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
              case 0:
              case 1:
                o2 = i4;
                break;
              case 4:
                return u2.label++, { value: i4[1], done: false };
              case 5:
                u2.label++, r2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = u2.ops.pop(), u2.trys.pop();
                continue;
              default:
                if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                  u2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                  u2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && u2.label < o2[1]) {
                  u2.label = o2[1], o2 = i4;
                  break;
                }
                if (o2 && u2.label < o2[2]) {
                  u2.label = o2[2], u2.ops.push(i4);
                  break;
                }
                o2[2] && u2.ops.pop(), u2.trys.pop();
                continue;
            }
            i4 = e3.call(t2, u2);
          } catch (t3) {
            i4 = [6, t3], r2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      }([i3, a3]);
    };
  }
}
function Or(t2) {
  var e3 = "function" == typeof Symbol && Symbol.iterator, n2 = e3 && t2[e3], r2 = 0;
  if (n2)
    return n2.call(t2);
  if (t2 && "number" == typeof t2.length)
    return { next: function() {
      return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
    } };
  throw new TypeError(e3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Er(t2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e3, n2 = t2[Symbol.asyncIterator];
  return n2 ? n2.call(t2) : (t2 = Or(t2), e3 = {}, r2("next"), r2("throw"), r2("return"), e3[Symbol.asyncIterator] = function() {
    return this;
  }, e3);
  function r2(n3) {
    e3[n3] = t2[n3] && function(e4) {
      return new Promise(function(r3, o2) {
        (function(t3, e5, n4, r4) {
          Promise.resolve(r4).then(function(e6) {
            t3({ value: e6, done: n4 });
          }, e5);
        })(r3, o2, (e4 = t2[n3](e4)).done, e4.value);
      });
    };
  }
}
var jr = Ot$1("unscopables"), Ir = Array.prototype;
null == Ir[jr] && Nt$1.f(Ir, jr, { configurable: true, value: An$1(null) });
var Tr, Ar, Pr, Rr = function(t2) {
  Ir[jr][t2] = true;
}, kr = {}, Mr = !m$1(function() {
  function t2() {
  }
  return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
}), Lr = qt$1("IE_PROTO"), Fr = g$1.Object, _r = Fr.prototype, Cr = Mr ? Fr.getPrototypeOf : function(t2) {
  var e3 = pt$1(t2);
  if (dt$1(e3, Lr))
    return e3[Lr];
  var n2 = e3.constructor;
  return G$1(n2) && e3 instanceof n2 ? n2.prototype : e3 instanceof Fr ? _r : null;
}, zr = Ot$1("iterator"), Dr = false;
[].keys && ("next" in (Pr = [].keys()) ? (Ar = Cr(Cr(Pr))) !== Object.prototype && (Tr = Ar) : Dr = true);
var Nr = null == Tr || m$1(function() {
  var t2 = {};
  return Tr[zr].call(t2) !== t2;
});
Nr && (Tr = {}), G$1(Tr[zr]) || fe$1(Tr, zr, function() {
  return this;
});
var Gr = { IteratorPrototype: Tr, BUGGY_SAFARI_ITERATORS: Dr }, Ur = Nt$1.f, Br = Ot$1("toStringTag"), Vr = function(t2, e3, n2) {
  t2 && !dt$1(t2 = n2 ? t2 : t2.prototype, Br) && Ur(t2, Br, { configurable: true, value: e3 });
}, Wr = Gr.IteratorPrototype, Hr = function() {
  return this;
}, Kr = g$1.String, Yr = g$1.TypeError, Xr = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t2, e3 = false, n2 = {};
  try {
    (t2 = R$1(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n2, []), e3 = n2 instanceof Array;
  } catch (t3) {
  }
  return function(n3, r2) {
    return Ct$1(n3), function(t3) {
      if ("object" == typeof t3 || G$1(t3))
        return t3;
      throw Yr("Can't set " + Kr(t3) + " as a prototype");
    }(r2), e3 ? t2(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), qr = ce$1.PROPER, $r = ce$1.CONFIGURABLE, Jr = Gr.IteratorPrototype, Qr = Gr.BUGGY_SAFARI_ITERATORS, Zr = Ot$1("iterator"), to = function() {
  return this;
}, eo = function(t2, e3, n2, r2, o2, i2, u2) {
  !function(t3, e4, n3, r3) {
    var o3 = e4 + " Iterator";
    t3.prototype = An$1(Wr, { next: j$1(+!r3, n3) }), Vr(t3, o3, false), kr[o3] = Hr;
  }(n2, e3, r2);
  var a2, c2, f2, s2 = function(t3) {
    if (t3 === o2 && h2)
      return h2;
    if (!Qr && t3 in v2)
      return v2[t3];
    switch (t3) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, t3);
        };
    }
    return function() {
      return new n2(this);
    };
  }, l2 = e3 + " Iterator", p2 = false, v2 = t2.prototype, d3 = v2[Zr] || v2["@@iterator"] || o2 && v2[o2], h2 = !Qr && d3 || s2(o2), y2 = "Array" == e3 && v2.entries || d3;
  if (y2 && (a2 = Cr(y2.call(new t2()))) !== Object.prototype && a2.next && (Cr(a2) !== Jr && (Xr ? Xr(a2, Jr) : G$1(a2[Zr]) || fe$1(a2, Zr, to)), Vr(a2, l2, true)), qr && "values" == o2 && d3 && "values" !== d3.name && ($r ? Gt$1(v2, "name", "values") : (p2 = true, h2 = function() {
    return S$1(d3, this);
  })), o2)
    if (c2 = { values: s2("values"), keys: i2 ? h2 : s2("keys"), entries: s2("entries") }, u2)
      for (f2 in c2)
        (Qr || p2 || !(f2 in v2)) && fe$1(v2, f2, c2[f2]);
    else
      De$1({ target: e3, proto: true, forced: Qr || p2 }, c2);
  return v2[Zr] !== h2 && fe$1(v2, Zr, h2, { name: o2 }), kr[e3] = h2, c2;
}, no = oe$1.set, ro = oe$1.getterFor("Array Iterator"), oo = eo(Array, "Array", function(t2, e3) {
  no(this, { type: "Array Iterator", target: N$1(t2), index: 0, kind: e3 });
}, function() {
  var t2 = ro(this), e3 = t2.target, n2 = t2.kind, r2 = t2.index++;
  return !e3 || r2 >= e3.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e3[r2], done: false } : { value: [r2, e3[r2]], done: false };
}, "values");
kr.Arguments = kr.Array, Rr("keys"), Rr("values"), Rr("entries");
var io = ur.charAt, uo = oe$1.set, ao = oe$1.getterFor("String Iterator");
eo(String, "String", function(t2) {
  uo(this, { type: "String Iterator", string: pn$1(t2), index: 0 });
}, function() {
  var t2, e3 = ao(this), n2 = e3.string, r2 = e3.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (t2 = io(n2, r2), e3.index += t2.length, { value: t2, done: false });
});
var co = function(t2, e3, n2) {
  for (var r2 in e3)
    fe$1(t2, r2, e3[r2], n2);
  return t2;
}, fo = je$1.f, so = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], lo = { f: function(t2) {
  return so && "Window" == L$1(t2) ? function(t3) {
    try {
      return fo(t3);
    } catch (t4) {
      return lr(so);
    }
  }(t2) : fo(N$1(t2));
} }, po = m$1(function() {
  if ("function" == typeof ArrayBuffer) {
    var t2 = new ArrayBuffer(8);
    Object.isExtensible(t2) && Object.defineProperty(t2, "a", { value: 8 });
  }
}), vo = Object.isExtensible, ho = m$1(function() {
  vo(1);
}) || po ? function(t2) {
  return !!U$1(t2) && ((!po || "ArrayBuffer" != L$1(t2)) && (!vo || vo(t2)));
} : vo, yo = !m$1(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), go = v$1(function(t2) {
  var e3 = Nt$1.f, n2 = false, r2 = mt$1("meta"), o2 = 0, i2 = function(t3) {
    e3(t3, r2, { value: { objectID: "O" + o2++, weakData: {} } });
  }, u2 = t2.exports = { enable: function() {
    u2.enable = function() {
    }, n2 = true;
    var t3 = je$1.f, e4 = R$1([].splice), o3 = {};
    o3[r2] = 1, t3(o3).length && (je$1.f = function(n3) {
      for (var o4 = t3(n3), i3 = 0, u3 = o4.length; i3 < u3; i3++)
        if (o4[i3] === r2) {
          e4(o4, i3, 1);
          break;
        }
      return o4;
    }, De$1({ target: "Object", stat: true, forced: true }, { getOwnPropertyNames: lo.f }));
  }, fastKey: function(t3, e4) {
    if (!U$1(t3))
      return "symbol" == typeof t3 ? t3 : ("string" == typeof t3 ? "S" : "P") + t3;
    if (!dt$1(t3, r2)) {
      if (!ho(t3))
        return "F";
      if (!e4)
        return "E";
      i2(t3);
    }
    return t3[r2].objectID;
  }, getWeakData: function(t3, e4) {
    if (!dt$1(t3, r2)) {
      if (!ho(t3))
        return true;
      if (!e4)
        return false;
      i2(t3);
    }
    return t3[r2].weakData;
  }, onFreeze: function(t3) {
    return yo && n2 && ho(t3) && !dt$1(t3, r2) && i2(t3), t3;
  } };
  $t$1[r2] = true;
}), mo = R$1(R$1.bind), bo = function(t2, e3) {
  return ot$1(t2), void 0 === e3 ? t2 : mo ? mo(t2, e3) : function() {
    return t2.apply(e3, arguments);
  };
}, wo = Ot$1("iterator"), So = Array.prototype, xo = Ot$1("iterator"), Oo = function(t2) {
  if (null != t2)
    return it$1(t2, xo) || it$1(t2, "@@iterator") || kr[Ke$1(t2)];
}, Eo = g$1.TypeError, jo = function(t2, e3, n2) {
  var r2, o2;
  Ct$1(t2);
  try {
    if (!(r2 = it$1(t2, "return"))) {
      if ("throw" === e3)
        throw n2;
      return n2;
    }
    r2 = S$1(r2, t2);
  } catch (t3) {
    o2 = true, r2 = t3;
  }
  if ("throw" === e3)
    throw n2;
  if (o2)
    throw r2;
  return Ct$1(r2), n2;
}, Io = g$1.TypeError, To = function(t2, e3) {
  this.stopped = t2, this.result = e3;
}, Ao = To.prototype, Po = function(t2, e3, n2) {
  var r2, o2, i2, u2, a2, c2, f2, s2, l2 = n2 && n2.that, p2 = !(!n2 || !n2.AS_ENTRIES), v2 = !(!n2 || !n2.IS_ITERATOR), d3 = !(!n2 || !n2.INTERRUPTED), h2 = bo(e3, l2), y2 = function(t3) {
    return r2 && jo(r2, "normal", t3), new To(true, t3);
  }, g2 = function(t3) {
    return p2 ? (Ct$1(t3), d3 ? h2(t3[0], t3[1], y2) : h2(t3[0], t3[1])) : d3 ? h2(t3, y2) : h2(t3);
  };
  if (v2)
    r2 = t2;
  else {
    if (!(o2 = Oo(t2)))
      throw Io(nt$1(t2) + " is not iterable");
    if (void 0 !== (s2 = o2) && (kr.Array === s2 || So[wo] === s2)) {
      for (i2 = 0, u2 = me$1(t2); u2 > i2; i2++)
        if ((a2 = g2(t2[i2])) && W$1(Ao, a2))
          return a2;
      return new To(false);
    }
    r2 = function(t3, e4) {
      var n3 = arguments.length < 2 ? Oo(t3) : e4;
      if (ot$1(n3))
        return Ct$1(S$1(n3, t3));
      throw Eo(nt$1(t3) + " is not iterable");
    }(t2, o2);
  }
  for (c2 = r2.next; !(f2 = S$1(c2, r2)).done; ) {
    try {
      a2 = g2(f2.value);
    } catch (t3) {
      jo(r2, "throw", t3);
    }
    if ("object" == typeof a2 && a2 && W$1(Ao, a2))
      return a2;
  }
  return new To(false);
}, Ro = g$1.TypeError, ko = function(t2, e3) {
  if (W$1(e3, t2))
    return t2;
  throw Ro("Incorrect invocation");
}, Mo = Ot$1("iterator"), Lo = false;
try {
  var Fo = 0, _o = { next: function() {
    return { done: !!Fo++ };
  }, return: function() {
    Lo = true;
  } };
  _o[Mo] = function() {
    return this;
  }, Array.from(_o, function() {
    throw 2;
  });
} catch (t2) {
}
var Co = function(t2, e3) {
  if (!e3 && !Lo)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[Mo] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, t2(r2);
  } catch (t3) {
  }
  return n2;
}, zo = Ot$1("species"), Do = g$1.Array, No = function(t2, e3) {
  return new (function(t3) {
    var e4;
    return Ne$1(t3) && (e4 = t3.constructor, (tn$1(e4) && (e4 === Do || Ne$1(e4.prototype)) || U$1(e4) && null === (e4 = e4[zo])) && (e4 = void 0)), void 0 === e4 ? Do : e4;
  }(t2))(0 === e3 ? 0 : e3);
}, Go = R$1([].push), Uo = function(t2) {
  var e3 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
  return function(c2, f2, s2, l2) {
    for (var p2, v2, d3 = pt$1(c2), h2 = C$1(d3), y2 = bo(f2, s2), g2 = me$1(h2), m2 = 0, b2 = l2 || No, w2 = e3 ? b2(c2, g2) : n2 || u2 ? b2(c2, 0) : void 0; g2 > m2; m2++)
      if ((a2 || m2 in h2) && (v2 = y2(p2 = h2[m2], m2, d3), t2))
        if (e3)
          w2[m2] = v2;
        else if (v2)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return p2;
            case 6:
              return m2;
            case 2:
              Go(w2, p2);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              Go(w2, p2);
          }
    return i2 ? -1 : r2 || o2 ? o2 : w2;
  };
}, Bo = { forEach: Uo(0), map: Uo(1), filter: Uo(2), some: Uo(3), every: Uo(4), find: Uo(5), findIndex: Uo(6), filterReject: Uo(7) }, Vo = go.getWeakData, Wo = oe$1.set, Ho = oe$1.getterFor, Ko = Bo.find, Yo = Bo.findIndex, Xo = R$1([].splice), qo = 0, $o = function(t2) {
  return t2.frozen || (t2.frozen = new Jo());
}, Jo = function() {
  this.entries = [];
}, Qo = function(t2, e3) {
  return Ko(t2.entries, function(t3) {
    return t3[0] === e3;
  });
};
Jo.prototype = { get: function(t2) {
  var e3 = Qo(this, t2);
  if (e3)
    return e3[1];
}, has: function(t2) {
  return !!Qo(this, t2);
}, set: function(t2, e3) {
  var n2 = Qo(this, t2);
  n2 ? n2[1] = e3 : this.entries.push([t2, e3]);
}, delete: function(t2) {
  var e3 = Yo(this.entries, function(e4) {
    return e4[0] === t2;
  });
  return ~e3 && Xo(this.entries, e3, 1), !!~e3;
} };
var Zo, ti = { getConstructor: function(t2, e3, n2, r2) {
  var o2 = t2(function(t3, o3) {
    ko(t3, i2), Wo(t3, { type: e3, id: qo++, frozen: void 0 }), null != o3 && Po(o3, t3[r2], { that: t3, AS_ENTRIES: n2 });
  }), i2 = o2.prototype, u2 = Ho(e3), a2 = function(t3, e4, n3) {
    var r3 = u2(t3), o3 = Vo(Ct$1(e4), true);
    return true === o3 ? $o(r3).set(e4, n3) : o3[r3.id] = n3, t3;
  };
  return co(i2, { delete: function(t3) {
    var e4 = u2(this);
    if (!U$1(t3))
      return false;
    var n3 = Vo(t3);
    return true === n3 ? $o(e4).delete(t3) : n3 && dt$1(n3, e4.id) && delete n3[e4.id];
  }, has: function(t3) {
    var e4 = u2(this);
    if (!U$1(t3))
      return false;
    var n3 = Vo(t3);
    return true === n3 ? $o(e4).has(t3) : n3 && dt$1(n3, e4.id);
  } }), co(i2, n2 ? { get: function(t3) {
    var e4 = u2(this);
    if (U$1(t3)) {
      var n3 = Vo(t3);
      return true === n3 ? $o(e4).get(t3) : n3 ? n3[e4.id] : void 0;
    }
  }, set: function(t3, e4) {
    return a2(this, t3, e4);
  } } : { add: function(t3) {
    return a2(this, t3, true);
  } }), o2;
} }, ei = oe$1.enforce, ni = !g$1.ActiveXObject && "ActiveXObject" in g$1, ri = function(t2) {
  return function() {
    return t2(this, arguments.length ? arguments[0] : void 0);
  };
}, oi = function(t2, e3, n2) {
  var r2 = -1 !== t2.indexOf("Map"), o2 = -1 !== t2.indexOf("Weak"), i2 = r2 ? "set" : "add", u2 = g$1[t2], a2 = u2 && u2.prototype, c2 = u2, f2 = {}, s2 = function(t3) {
    var e4 = R$1(a2[t3]);
    fe$1(a2, t3, "add" == t3 ? function(t4) {
      return e4(this, 0 === t4 ? 0 : t4), this;
    } : "delete" == t3 ? function(t4) {
      return !(o2 && !U$1(t4)) && e4(this, 0 === t4 ? 0 : t4);
    } : "get" == t3 ? function(t4) {
      return o2 && !U$1(t4) ? void 0 : e4(this, 0 === t4 ? 0 : t4);
    } : "has" == t3 ? function(t4) {
      return !(o2 && !U$1(t4)) && e4(this, 0 === t4 ? 0 : t4);
    } : function(t4, n3) {
      return e4(this, 0 === t4 ? 0 : t4, n3), this;
    });
  };
  if (Ce$1(t2, !G$1(u2) || !(o2 || a2.forEach && !m$1(function() {
    new u2().entries().next();
  }))))
    c2 = n2.getConstructor(e3, t2, r2, i2), go.enable();
  else if (Ce$1(t2, true)) {
    var l2 = new c2(), p2 = l2[i2](o2 ? {} : -0, 1) != l2, v2 = m$1(function() {
      l2.has(1);
    }), d3 = Co(function(t3) {
      new u2(t3);
    }), h2 = !o2 && m$1(function() {
      for (var t3 = new u2(), e4 = 5; e4--; )
        t3[i2](e4, e4);
      return !t3.has(-0);
    });
    d3 || ((c2 = e3(function(t3, e4) {
      ko(t3, a2);
      var n3 = function(t4, e5, n4) {
        var r3, o3;
        return Xr && G$1(r3 = e5.constructor) && r3 !== n4 && U$1(o3 = r3.prototype) && o3 !== n4.prototype && Xr(t4, o3), t4;
      }(new u2(), t3, c2);
      return null != e4 && Po(e4, n3[i2], { that: n3, AS_ENTRIES: r2 }), n3;
    })).prototype = a2, a2.constructor = c2), (v2 || h2) && (s2("delete"), s2("has"), r2 && s2("get")), (h2 || p2) && s2(i2), o2 && a2.clear && delete a2.clear;
  }
  return f2[t2] = c2, De$1({ global: true, forced: c2 != u2 }, f2), Vr(c2, t2), o2 || n2.setStrong(c2, t2, r2), c2;
}("WeakMap", ri, ti);
if (Yt$1 && ni) {
  Zo = ti.getConstructor(ri, "WeakMap", true), go.enable();
  var ii = oi.prototype, ui = R$1(ii.delete), ai = R$1(ii.has), ci = R$1(ii.get), fi = R$1(ii.set);
  co(ii, { delete: function(t2) {
    if (U$1(t2) && !ho(t2)) {
      var e3 = ei(this);
      return e3.frozen || (e3.frozen = new Zo()), ui(this, t2) || e3.frozen.delete(t2);
    }
    return ui(this, t2);
  }, has: function(t2) {
    if (U$1(t2) && !ho(t2)) {
      var e3 = ei(this);
      return e3.frozen || (e3.frozen = new Zo()), ai(this, t2) || e3.frozen.has(t2);
    }
    return ai(this, t2);
  }, get: function(t2) {
    if (U$1(t2) && !ho(t2)) {
      var e3 = ei(this);
      return e3.frozen || (e3.frozen = new Zo()), ai(this, t2) ? ci(this, t2) : e3.frozen.get(t2);
    }
    return ci(this, t2);
  }, set: function(t2, e3) {
    if (U$1(t2) && !ho(t2)) {
      var n2 = ei(this);
      n2.frozen || (n2.frozen = new Zo()), ai(this, t2) ? fi(this, t2, e3) : n2.frozen.set(t2, e3);
    } else
      fi(this, t2, e3);
    return this;
  } });
}
var si = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, li = Rt$1("span").classList, pi = li && li.constructor && li.constructor.prototype, vi = pi === Object.prototype ? void 0 : pi, di = Ot$1("iterator"), hi = Ot$1("toStringTag"), yi = oo.values, gi = function(t2, e3) {
  if (t2) {
    if (t2[di] !== yi)
      try {
        Gt$1(t2, di, yi);
      } catch (e4) {
        t2[di] = yi;
      }
    if (t2[hi] || Gt$1(t2, hi, e3), si[e3]) {
      for (var n2 in oo)
        if (t2[n2] !== oo[n2])
          try {
            Gt$1(t2, n2, oo[n2]);
          } catch (e4) {
            t2[n2] = oo[n2];
          }
    }
  }
};
for (var mi in si)
  gi(g$1[mi] && g$1[mi].prototype, mi);
gi(vi, "DOMTokenList");
var bi = ce$1.EXISTS, wi = Nt$1.f, Si = Function.prototype, xi = R$1(Si.toString), Oi = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/, Ei = R$1(Oi.exec);
b$1 && !bi && wi(Si, "name", { configurable: true, get: function() {
  try {
    return Ei(Oi, xi(this))[1];
  } catch (t2) {
    return "";
  }
} });
var ji = function(t2, e3) {
  var n2 = [][t2];
  return !!n2 && m$1(function() {
    n2.call(null, e3 || function() {
      throw 1;
    }, 1);
  });
}, Ii = Bo.forEach, Ti = ji("forEach") ? [].forEach : function(t2) {
  return Ii(this, t2, arguments.length > 1 ? arguments[1] : void 0);
}, Ai = function(t2) {
  if (t2 && t2.forEach !== Ti)
    try {
      Gt$1(t2, "forEach", Ti);
    } catch (e3) {
      t2.forEach = Ti;
    }
};
for (var Pi in si)
  si[Pi] && Ai(g$1[Pi] && g$1[Pi].prototype);
Ai(vi);
var Ri, ki, Mi, Li, Fi = g$1.Promise, _i = Ot$1("species"), Ci = /(?:ipad|iphone|ipod).*applewebkit/i.test(H$1), zi = "process" == L$1(g$1.process), Di = g$1.setImmediate, Ni = g$1.clearImmediate, Gi = g$1.process, Ui = g$1.Dispatch, Bi = g$1.Function, Vi = g$1.MessageChannel, Wi = g$1.String, Hi = 0, Ki = {};
try {
  Ri = g$1.location;
} catch (t2) {
}
var Yi = function(t2) {
  if (dt$1(Ki, t2)) {
    var e3 = Ki[t2];
    delete Ki[t2], e3();
  }
}, Xi = function(t2) {
  return function() {
    Yi(t2);
  };
}, qi = function(t2) {
  Yi(t2.data);
}, $i = function(t2) {
  g$1.postMessage(Wi(t2), Ri.protocol + "//" + Ri.host);
};
Di && Ni || (Di = function(t2) {
  var e3 = rn$1(arguments, 1);
  return Ki[++Hi] = function() {
    qn$1(G$1(t2) ? t2 : Bi(t2), void 0, e3);
  }, ki(Hi), Hi;
}, Ni = function(t2) {
  delete Ki[t2];
}, zi ? ki = function(t2) {
  Gi.nextTick(Xi(t2));
} : Ui && Ui.now ? ki = function(t2) {
  Ui.now(Xi(t2));
} : Vi && !Ci ? (Li = (Mi = new Vi()).port2, Mi.port1.onmessage = qi, ki = bo(Li.postMessage, Li)) : g$1.addEventListener && G$1(g$1.postMessage) && !g$1.importScripts && Ri && "file:" !== Ri.protocol && !m$1($i) ? (ki = $i, g$1.addEventListener("message", qi, false)) : ki = "onreadystatechange" in Rt$1("script") ? function(t2) {
  wn$1.appendChild(Rt$1("script")).onreadystatechange = function() {
    wn$1.removeChild(this), Yi(t2);
  };
} : function(t2) {
  setTimeout(Xi(t2), 0);
});
var Ji, Qi, Zi, tu, eu, nu, ru, ou, iu = { set: Di, clear: Ni }, uu = /ipad|iphone|ipod/i.test(H$1) && void 0 !== g$1.Pebble, au = /web0s(?!.*chrome)/i.test(H$1), cu = Lt$1.f, fu = iu.set, su = g$1.MutationObserver || g$1.WebKitMutationObserver, lu = g$1.document, pu = g$1.process, vu = g$1.Promise, du = cu(g$1, "queueMicrotask"), hu = du && du.value;
hu || (Ji = function() {
  var t2, e3;
  for (zi && (t2 = pu.domain) && t2.exit(); Qi; ) {
    e3 = Qi.fn, Qi = Qi.next;
    try {
      e3();
    } catch (t3) {
      throw Qi ? tu() : Zi = void 0, t3;
    }
  }
  Zi = void 0, t2 && t2.enter();
}, Ci || zi || au || !su || !lu ? !uu && vu && vu.resolve ? ((ru = vu.resolve(void 0)).constructor = vu, ou = bo(ru.then, ru), tu = function() {
  ou(Ji);
}) : zi ? tu = function() {
  pu.nextTick(Ji);
} : (fu = bo(fu, g$1), tu = function() {
  fu(Ji);
}) : (eu = true, nu = lu.createTextNode(""), new su(Ji).observe(nu, { characterData: true }), tu = function() {
  nu.data = eu = !eu;
}));
var yu, gu, mu, bu, wu = hu || function(t2) {
  var e3 = { fn: t2, next: void 0 };
  Zi && (Zi.next = e3), Qi || (Qi = e3, tu()), Zi = e3;
}, Su = function(t2) {
  var e3, n2;
  this.promise = new t2(function(t3, r2) {
    if (void 0 !== e3 || void 0 !== n2)
      throw TypeError("Bad Promise constructor");
    e3 = t3, n2 = r2;
  }), this.resolve = ot$1(e3), this.reject = ot$1(n2);
}, xu = { f: function(t2) {
  return new Su(t2);
} }, Ou = function(t2) {
  try {
    return { error: false, value: t2() };
  } catch (t3) {
    return { error: true, value: t3 };
  }
}, Eu = "object" == typeof window, ju = iu.set, Iu = Ot$1("species"), Tu = "Promise", Au = oe$1.getterFor(Tu), Pu = oe$1.set, Ru = oe$1.getterFor(Tu), ku = Fi && Fi.prototype, Mu = Fi, Lu = ku, Fu = g$1.TypeError, _u = g$1.document, Cu = g$1.process, zu = xu.f, Du = zu, Nu = !!(_u && _u.createEvent && g$1.dispatchEvent), Gu = G$1(g$1.PromiseRejectionEvent), Uu = false, Bu = Ce$1(Tu, function() {
  var t2 = Ht$1(Mu), e3 = t2 !== String(Mu);
  if (!e3 && 66 === $$1)
    return true;
  if ($$1 >= 51 && /native code/.test(t2))
    return false;
  var n2 = new Mu(function(t3) {
    t3(1);
  }), r2 = function(t3) {
    t3(function() {
    }, function() {
    });
  };
  return (n2.constructor = {})[Iu] = r2, !(Uu = n2.then(function() {
  }) instanceof r2) || !e3 && Eu && !Gu;
}), Vu = Bu || !Co(function(t2) {
  Mu.all(t2).catch(function() {
  });
}), Wu = function(t2) {
  var e3;
  return !(!U$1(t2) || !G$1(e3 = t2.then)) && e3;
}, Hu = function(t2, e3) {
  if (!t2.notified) {
    t2.notified = true;
    var n2 = t2.reactions;
    wu(function() {
      for (var r2 = t2.value, o2 = 1 == t2.state, i2 = 0; n2.length > i2; ) {
        var u2, a2, c2, f2 = n2[i2++], s2 = o2 ? f2.ok : f2.fail, l2 = f2.resolve, p2 = f2.reject, v2 = f2.domain;
        try {
          s2 ? (o2 || (2 === t2.rejection && qu(t2), t2.rejection = 1), true === s2 ? u2 = r2 : (v2 && v2.enter(), u2 = s2(r2), v2 && (v2.exit(), c2 = true)), u2 === f2.promise ? p2(Fu("Promise-chain cycle")) : (a2 = Wu(u2)) ? S$1(a2, u2, l2, p2) : l2(u2)) : p2(r2);
        } catch (t3) {
          v2 && !c2 && v2.exit(), p2(t3);
        }
      }
      t2.reactions = [], t2.notified = false, e3 && !t2.rejection && Yu(t2);
    });
  }
}, Ku = function(t2, e3, n2) {
  var r2, o2;
  Nu ? ((r2 = _u.createEvent("Event")).promise = e3, r2.reason = n2, r2.initEvent(t2, false, true), g$1.dispatchEvent(r2)) : r2 = { promise: e3, reason: n2 }, !Gu && (o2 = g$1["on" + t2]) ? o2(r2) : "unhandledrejection" === t2 && function(t3, e4) {
    var n3 = g$1.console;
    n3 && n3.error && (1 == arguments.length ? n3.error(t3) : n3.error(t3, e4));
  }("Unhandled promise rejection", n2);
}, Yu = function(t2) {
  S$1(ju, g$1, function() {
    var e3, n2 = t2.facade, r2 = t2.value;
    if (Xu(t2) && (e3 = Ou(function() {
      zi ? Cu.emit("unhandledRejection", r2, n2) : Ku("unhandledrejection", n2, r2);
    }), t2.rejection = zi || Xu(t2) ? 2 : 1, e3.error))
      throw e3.value;
  });
}, Xu = function(t2) {
  return 1 !== t2.rejection && !t2.parent;
}, qu = function(t2) {
  S$1(ju, g$1, function() {
    var e3 = t2.facade;
    zi ? Cu.emit("rejectionHandled", e3) : Ku("rejectionhandled", e3, t2.value);
  });
}, $u = function(t2, e3, n2) {
  return function(r2) {
    t2(e3, r2, n2);
  };
}, Ju = function(t2, e3, n2) {
  t2.done || (t2.done = true, n2 && (t2 = n2), t2.value = e3, t2.state = 2, Hu(t2, true));
}, Qu = function(t2, e3, n2) {
  if (!t2.done) {
    t2.done = true, n2 && (t2 = n2);
    try {
      if (t2.facade === e3)
        throw Fu("Promise can't be resolved itself");
      var r2 = Wu(e3);
      r2 ? wu(function() {
        var n3 = { done: false };
        try {
          S$1(r2, e3, $u(Qu, n3, t2), $u(Ju, n3, t2));
        } catch (e4) {
          Ju(n3, e4, t2);
        }
      }) : (t2.value = e3, t2.state = 1, Hu(t2, false));
    } catch (e4) {
      Ju({ done: false }, e4, t2);
    }
  }
};
if (Bu && (Lu = (Mu = function(t2) {
  ko(this, Lu), ot$1(t2), S$1(yu, this);
  var e3 = Au(this);
  try {
    t2($u(Qu, e3), $u(Ju, e3));
  } catch (t3) {
    Ju(e3, t3);
  }
}).prototype, (yu = function(t2) {
  Pu(this, { type: Tu, done: false, notified: false, parent: false, reactions: [], rejection: false, state: 0, value: void 0 });
}).prototype = co(Lu, { then: function(t2, e3) {
  var n2 = Ru(this), r2 = n2.reactions, o2 = zu(er(this, Mu));
  return o2.ok = !G$1(t2) || t2, o2.fail = G$1(e3) && e3, o2.domain = zi ? Cu.domain : void 0, n2.parent = true, r2[r2.length] = o2, 0 != n2.state && Hu(n2, false), o2.promise;
}, catch: function(t2) {
  return this.then(void 0, t2);
} }), gu = function() {
  var t2 = new yu(), e3 = Au(t2);
  this.promise = t2, this.resolve = $u(Qu, e3), this.reject = $u(Ju, e3);
}, xu.f = zu = function(t2) {
  return t2 === Mu || t2 === mu ? new gu(t2) : Du(t2);
}, G$1(Fi) && ku !== Object.prototype)) {
  bu = ku.then, Uu || (fe$1(ku, "then", function(t2, e3) {
    var n2 = this;
    return new Mu(function(t3, e4) {
      S$1(bu, n2, t3, e4);
    }).then(t2, e3);
  }, { unsafe: true }), fe$1(ku, "catch", Lu.catch, { unsafe: true }));
  try {
    delete ku.constructor;
  } catch (t2) {
  }
  Xr && Xr(ku, Lu);
}
De$1({ global: true, wrap: true, forced: Bu }, { Promise: Mu }), Vr(Mu, Tu, false), function(t2) {
  var e3 = V$1(t2), n2 = Nt$1.f;
  b$1 && e3 && !e3[_i] && n2(e3, _i, { configurable: true, get: function() {
    return this;
  } });
}(Tu), mu = V$1(Tu), De$1({ target: Tu, stat: true, forced: Bu }, { reject: function(t2) {
  var e3 = zu(this);
  return S$1(e3.reject, void 0, t2), e3.promise;
} }), De$1({ target: Tu, stat: true, forced: Bu }, { resolve: function(t2) {
  return function(t3, e3) {
    if (Ct$1(t3), U$1(e3) && e3.constructor === t3)
      return e3;
    var n2 = xu.f(t3);
    return (0, n2.resolve)(e3), n2.promise;
  }(this, t2);
} }), De$1({ target: Tu, stat: true, forced: Vu }, { all: function(t2) {
  var e3 = this, n2 = zu(e3), r2 = n2.resolve, o2 = n2.reject, i2 = Ou(function() {
    var n3 = ot$1(e3.resolve), i3 = [], u2 = 0, a2 = 1;
    Po(t2, function(t3) {
      var c2 = u2++, f2 = false;
      a2++, S$1(n3, e3, t3).then(function(t4) {
        f2 || (f2 = true, i3[c2] = t4, --a2 || r2(i3));
      }, o2);
    }), --a2 || r2(i3);
  });
  return i2.error && o2(i2.value), n2.promise;
}, race: function(t2) {
  var e3 = this, n2 = zu(e3), r2 = n2.reject, o2 = Ou(function() {
    var o3 = ot$1(e3.resolve);
    Po(t2, function(t3) {
      S$1(o3, e3, t3).then(n2.resolve, r2);
    });
  });
  return o2.error && r2(o2.value), n2.promise;
} });
var Zu = ce$1.PROPER, ta$1 = RegExp.prototype, ea$1 = ta$1.toString, na$1 = R$1(vn$1), ra$1 = m$1(function() {
  return "/a/b" != ea$1.call({ source: "a", flags: "b" });
}), oa$1 = Zu && "toString" != ea$1.name;
(ra$1 || oa$1) && fe$1(RegExp.prototype, "toString", function() {
  var t2 = Ct$1(this), e3 = pn$1(t2.source), n2 = t2.flags;
  return "/" + e3 + "/" + pn$1(void 0 === n2 && W$1(ta$1, t2) && !("flags" in ta$1) ? na$1(t2) : n2);
}, { unsafe: true });
var ia$1 = /* @__PURE__ */ new WeakMap();
function ua$1(t2) {
  return t2.getMenuConfig("uploadImage");
}
function aa$1(t2, e3) {
  return Sr(this, void 0, void 0, function() {
    return xr(this, function(n2) {
      return [2, new Promise(function(n3) {
        var o2 = new FileReader();
        o2.readAsDataURL(e3), o2.onload = function() {
          var i2 = o2.result;
          if (i2) {
            var u2 = i2.toString(), a2 = 0 === u2.indexOf("data:image") ? "" : u2;
            Ia$2(t2, u2, e3.name, a2), n3("ok");
          }
        };
      })];
    });
  });
}
function ca$1(t2, n2) {
  return Sr(this, void 0, void 0, function() {
    var o2, i2, u2, a2;
    return xr(this, function(c2) {
      switch (c2.label) {
        case 0:
          return o2 = function(t3) {
            var n3 = ia$1.get(t3);
            if (null != n3)
              return n3;
            var o3 = ua$1(t3), i3 = o3.onSuccess, u3 = o3.onProgress, a3 = o3.onFailed, c3 = o3.customInsert, f2 = o3.onError;
            return n3 = hh(wr(wr({}, o3), { onProgress: function(e3) {
              t3.showProgressBar(e3), u3 && u3(e3);
            }, onSuccess: function(e3, n4) {
              if (c3)
                c3(n4, function(e4, n5, o5) {
                  return Ia$2(t3, e4, n5, o5);
                });
              else {
                var o4 = n4.errno, u4 = void 0 === o4 ? 1 : o4, f3 = n4.data, s2 = void 0 === f3 ? {} : f3;
                if (0 !== u4)
                  return console.error("'" + e3.name + "' upload failed", n4), void a3(e3, n4);
                if (Array.isArray(s2))
                  s2.forEach(function(e4) {
                    var n5 = e4.url, o5 = void 0 === n5 ? "" : n5, i4 = e4.alt, u5 = void 0 === i4 ? "" : i4, a4 = e4.href;
                    Ia$2(t3, o5, u5, void 0 === a4 ? "" : a4);
                  });
                else {
                  var l2 = s2.url, p2 = void 0 === l2 ? "" : l2, v2 = s2.alt, d3 = void 0 === v2 ? "" : v2, h2 = s2.href;
                  Ia$2(t3, p2, d3, void 0 === h2 ? "" : h2);
                }
                i3(e3, n4);
              }
            }, onError: function(t4, e3, n4) {
              var r2 = t4.name;
              console.error("'" + r2 + " upload error", e3, n4), f2 && f2(t4, e3, n4);
            } })), ia$1.set(t3, n3), n3;
          }(t2), i2 = n2.name, u2 = n2.type, a2 = n2.size, o2.addFile({ name: i2, type: u2, size: a2, data: n2 }), [4, o2.upload()];
        case 1:
          return c2.sent(), [2];
      }
    });
  });
}
function fa$1(t2, e3) {
  var n2, o2;
  return Sr(this, void 0, void 0, function() {
    var i2, u2, a2, c2, f2, s2, l2, p2, v2;
    return xr(this, function(d3) {
      switch (d3.label) {
        case 0:
          if (null == e3)
            return [2];
          i2 = Array.prototype.slice.call(e3), u2 = ua$1(t2), a2 = u2.customUpload, c2 = u2.base64LimitSize, d3.label = 1;
        case 1:
          d3.trys.push([1, 11, 12, 17]), f2 = Er(i2), d3.label = 2;
        case 2:
          return [4, f2.next()];
        case 3:
          return (s2 = d3.sent()).done ? [3, 10] : (l2 = s2.value, p2 = l2.size, c2 && p2 <= c2 ? [4, aa$1(t2, l2)] : [3, 5]);
        case 4:
          return d3.sent(), [3, 9];
        case 5:
          return a2 ? [4, a2(l2, function(e4, n3, o3) {
            return Ia$2(t2, e4, n3, o3);
          })] : [3, 7];
        case 6:
          return d3.sent(), [3, 9];
        case 7:
          return [4, ca$1(t2, l2)];
        case 8:
          d3.sent(), d3.label = 9;
        case 9:
          return [3, 2];
        case 10:
          return [3, 17];
        case 11:
          return v2 = d3.sent(), n2 = { error: v2 }, [3, 17];
        case 12:
          return d3.trys.push([12, , 15, 16]), s2 && !s2.done && (o2 = f2.return) ? [4, o2.call(f2)] : [3, 14];
        case 13:
          d3.sent(), d3.label = 14;
        case 14:
          return [3, 16];
        case 15:
          if (n2)
            throw n2.error;
          return [7];
        case 16:
          return [7];
        case 17:
          return [2];
      }
    });
  });
}
var sa$1 = R$1([].join), la$1 = C$1 != Object, pa$1 = ji("join", ",");
De$1({ target: "Array", proto: true, forced: la$1 || !pa$1 }, { join: function(t2) {
  return sa$1(N$1(this), void 0 === t2 ? "," : t2);
} });
append && ($$6.fn.append = append), on$7 && ($$6.fn.on = on$7), remove && ($$6.fn.remove = remove), val && ($$6.fn.val = val), click && ($$6.fn.click = click), hide && ($$6.fn.hide = hide);
var va$1 = function() {
  function t2() {
    this.title = lp$1("uploadImgModule.uploadImage"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M828.708571 585.045333a48.761905 48.761905 0 0 0-48.737523 48.761905v18.529524l-72.143238-72.167619a135.972571 135.972571 0 0 0-191.585524 0l-34.133334 34.133333-120.880762-120.953905a138.898286 138.898286 0 0 0-191.585523 0l-72.167619 72.167619V292.400762a48.786286 48.786286 0 0 1 48.761904-48.761905h341.23581a48.737524 48.737524 0 0 0 34.474667-83.285333 48.737524 48.737524 0 0 0-34.474667-14.287238H146.236952A146.212571 146.212571 0 0 0 0 292.400762v585.289143A146.358857 146.358857 0 0 0 146.236952 1024h584.996572a146.212571 146.212571 0 0 0 146.236952-146.310095V633.807238a48.786286 48.786286 0 0 0-48.761905-48.761905zM146.261333 926.45181a48.737524 48.737524 0 0 1-48.761904-48.761905v-174.128762l141.409523-141.458286a38.497524 38.497524 0 0 1 53.126096 0l154.526476 154.624 209.627428 209.724953H146.236952z m633.734096-48.761905c-0.073143 9.337905-3.145143 18.383238-8.777143 25.843809l-219.843048-220.94019 34.133333-34.133334a37.546667 37.546667 0 0 1 53.613715 0l140.873143 141.897143V877.714286zM1009.615238 160.231619L863.329524 13.897143a48.737524 48.737524 0 0 0-16.091429-10.24c-11.849143-4.87619-25.161143-4.87619-37.059047 0a48.761905 48.761905 0 0 0-16.067048 10.24l-146.236952 146.334476a49.005714 49.005714 0 0 0 69.217523 69.241905l62.902858-63.390476v272.627809a48.761905 48.761905 0 1 0 97.475047 0V166.083048l62.902857 63.390476a48.737524 48.737524 0 0 0 69.217524 0 48.761905 48.761905 0 0 0 0-69.241905z"></path></svg>', this.tag = "button";
  }
  return t2.prototype.getValue = function(t3) {
    return "";
  }, t2.prototype.isActive = function(t3) {
    return false;
  }, t2.prototype.isDisabled = function(t3) {
    return La$2(t3);
  }, t2.prototype.getMenuConfig = function(t3) {
    return t3.getMenuConfig("uploadImage");
  }, t2.prototype.exec = function(t3, e3) {
    var n2 = this.getMenuConfig(t3), o2 = n2.allowedFileTypes, u2 = void 0 === o2 ? [] : o2, a2 = n2.customBrowseAndUpload;
    if (a2)
      a2(function(e4, n3, o3) {
        return Ia$2(t3, e4, n3, o3);
      });
    else {
      var c2 = "";
      u2.length > 0 && (c2 = 'accept="' + u2.join(", ") + '"');
      var f2 = $$6("body"), s2 = $$6('<input type="file" ' + c2 + " multiple/>");
      s2.hide(), f2.append(s2), s2.click(), s2.on("change", function() {
        var e4 = s2[0].files;
        fa$1(t3, e4);
      });
    }
  }, t2;
}();
var da$1 = { menus: [{ key: "uploadImage", factory: function() {
  return new va$1();
}, config: { server: "", fieldName: "wangeditor-uploaded-image", maxFileSize: 2097152, maxNumberOfFiles: 100, allowedFileTypes: ["image/*"], meta: {}, metaWithUrl: false, withCredentials: false, timeout: 1e4, onBeforeUpload: function(t2) {
  return t2;
}, onProgress: function(t2) {
}, onSuccess: function(t2, e3) {
}, onFailed: function(t2, e3) {
}, onError: function(t2, e3, n2) {
}, base64LimitSize: 0 } }], editorPlugin: function(t2) {
  var e3 = t2.insertData, n2 = t2;
  return n2.insertData = function(r2) {
    if (La$2(n2))
      e3(r2);
    else if (r2.getData("text/plain"))
      e3(r2);
    else {
      var i2 = r2.files;
      if (i2.length <= 0)
        e3(r2);
      else
        Array.prototype.slice.call(i2).some(function(t3) {
          return "image" === function(t4, e4) {
            var n3 = "function" == typeof Symbol && t4[Symbol.iterator];
            if (!n3)
              return t4;
            var r3, o2, i3 = n3.call(t4), u2 = [];
            try {
              for (; (void 0 === e4 || e4-- > 0) && !(r3 = i3.next()).done; )
                u2.push(r3.value);
            } catch (t5) {
              o2 = { error: t5 };
            } finally {
              try {
                r3 && !r3.done && (n3 = i3.return) && n3.call(i3);
              } finally {
                if (o2)
                  throw o2.error;
              }
            }
            return u2;
          }(t3.type.split("/"), 1)[0];
        }) ? fa$1(t2, i2) : e3(r2);
    }
  }, n2;
} };
ip$1("en", { highLightModule: { selectLang: "Language" } }), ip$1("zh-CN", { highLightModule: { selectLang: "\u9009\u62E9\u8BED\u8A00" } });
var l = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function u(e3) {
  var t2 = { exports: {} };
  return e3(t2, t2.exports), t2.exports;
}
var c, d, p = function(e3) {
  return e3 && e3.Math == Math && e3;
}, g = p("object" == typeof globalThis && globalThis) || p("object" == typeof window && window) || p("object" == typeof self && self) || p("object" == typeof l && l) || function() {
  return this;
}() || Function("return this")(), f = Object.defineProperty, b = function(e3, t2) {
  try {
    f(g, e3, { value: t2, configurable: true, writable: true });
  } catch (n2) {
    g[e3] = t2;
  }
  return t2;
}, h$5 = g["__core-js_shared__"] || b("__core-js_shared__", {}), m = u(function(e3) {
  (e3.exports = function(e4, t2) {
    return h$5[e4] || (h$5[e4] = void 0 !== t2 ? t2 : {});
  })("versions", []).push({ version: "3.19.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), y = Function.prototype, E = y.bind, S = y.call, v = E && E.bind(S), w = E ? function(e3) {
  return e3 && v(S, e3);
} : function(e3) {
  return e3 && function() {
    return S.apply(e3, arguments);
  };
}, k = g.TypeError, A = function(e3) {
  if (null == e3)
    throw k("Can't call method on " + e3);
  return e3;
}, x = g.Object, T = function(e3) {
  return x(A(e3));
}, _ = w({}.hasOwnProperty), O = Object.hasOwn || function(e3, t2) {
  return _(T(e3), t2);
}, I = 0, R = Math.random(), N = w(1 .toString), L = function(e3) {
  return "Symbol(" + (void 0 === e3 ? "" : e3) + ")_" + N(++I + R, 36);
}, P = function(e3) {
  return "function" == typeof e3;
}, C = function(e3) {
  return P(e3) ? e3 : void 0;
}, F = function(e3, t2) {
  return arguments.length < 2 ? C(g[e3]) : g[e3] && g[e3][t2];
}, D = F("navigator", "userAgent") || "", M = g.process, $ = g.Deno, B = M && M.versions || $ && $.version, U = B && B.v8;
U && (d = (c = U.split("."))[0] > 0 && c[0] < 4 ? 1 : +(c[0] + c[1])), !d && D && (!(c = D.match(/Edge\/(\d+)/)) || c[1] >= 74) && (c = D.match(/Chrome\/(\d+)/)) && (d = +c[1]);
var j = d, z = function(e3) {
  try {
    return !!e3();
  } catch (e4) {
    return true;
  }
}, G = !!Object.getOwnPropertySymbols && !z(function() {
  var e3 = Symbol();
  return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && j && j < 41;
}), H = G && !Symbol.sham && "symbol" == typeof Symbol.iterator, q = m("wks"), Y = g.Symbol, X = Y && Y.for, W = H ? Y : Y && Y.withoutSetter || L, Z = function(e3) {
  if (!O(q, e3) || !G && "string" != typeof q[e3]) {
    var t2 = "Symbol." + e3;
    G && O(Y, e3) ? q[e3] = Y[e3] : q[e3] = H && X ? X(t2) : W(t2);
  }
  return q[e3];
}, V = {};
V[Z("toStringTag")] = "z";
var K = "[object z]" === String(V), J = !z(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), Q = function(e3) {
  return "object" == typeof e3 ? null !== e3 : P(e3);
}, ee = g.document, te = Q(ee) && Q(ee.createElement), ne = function(e3) {
  return te ? ee.createElement(e3) : {};
}, ae = !J && !z(function() {
  return 7 != Object.defineProperty(ne("div"), "a", { get: function() {
    return 7;
  } }).a;
}), re = g.String, ie = g.TypeError, se = function(e3) {
  if (Q(e3))
    return e3;
  throw ie(re(e3) + " is not an object");
}, oe = Function.prototype.call, le = oe.bind ? oe.bind(oe) : function() {
  return oe.apply(oe, arguments);
}, ue = w({}.isPrototypeOf), ce = g.Object, de = H ? function(e3) {
  return "symbol" == typeof e3;
} : function(e3) {
  var t2 = F("Symbol");
  return P(t2) && ue(t2.prototype, ce(e3));
}, pe = g.String, ge = function(e3) {
  try {
    return pe(e3);
  } catch (e4) {
    return "Object";
  }
}, fe = g.TypeError, be = function(e3) {
  if (P(e3))
    return e3;
  throw fe(ge(e3) + " is not a function");
}, he = function(e3, t2) {
  var n2 = e3[t2];
  return null == n2 ? void 0 : be(n2);
}, me = g.TypeError, ye = g.TypeError, Ee = Z("toPrimitive"), Se = function(e3, t2) {
  if (!Q(e3) || de(e3))
    return e3;
  var n2, a2 = he(e3, Ee);
  if (a2) {
    if (void 0 === t2 && (t2 = "default"), n2 = le(a2, e3, t2), !Q(n2) || de(n2))
      return n2;
    throw ye("Can't convert object to primitive value");
  }
  return void 0 === t2 && (t2 = "number"), function(e4, t3) {
    var n3, a3;
    if ("string" === t3 && P(n3 = e4.toString) && !Q(a3 = le(n3, e4)))
      return a3;
    if (P(n3 = e4.valueOf) && !Q(a3 = le(n3, e4)))
      return a3;
    if ("string" !== t3 && P(n3 = e4.toString) && !Q(a3 = le(n3, e4)))
      return a3;
    throw me("Can't convert object to primitive value");
  }(e3, t2);
}, ve = function(e3) {
  var t2 = Se(e3, "string");
  return de(t2) ? t2 : t2 + "";
}, we = g.TypeError, ke = Object.defineProperty, Ae = { f: J ? ke : function(e3, t2, n2) {
  if (se(e3), t2 = ve(t2), se(n2), ae)
    try {
      return ke(e3, t2, n2);
    } catch (e4) {
    }
  if ("get" in n2 || "set" in n2)
    throw we("Accessors not supported");
  return "value" in n2 && (e3[t2] = n2.value), e3;
} }, xe = function(e3, t2) {
  return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
}, Te = J ? function(e3, t2, n2) {
  return Ae.f(e3, t2, xe(1, n2));
} : function(e3, t2, n2) {
  return e3[t2] = n2, e3;
}, _e = w(Function.toString);
P(h$5.inspectSource) || (h$5.inspectSource = function(e3) {
  return _e(e3);
});
var Oe, Ie, Re, Ne = h$5.inspectSource, Le = g.WeakMap, Pe = P(Le) && /native code/.test(Ne(Le)), Ce = m("keys"), Fe = function(e3) {
  return Ce[e3] || (Ce[e3] = L(e3));
}, De = {}, Me = g.TypeError, $e = g.WeakMap;
if (Pe || h$5.state) {
  var Be = h$5.state || (h$5.state = new $e()), Ue = w(Be.get), je = w(Be.has), ze = w(Be.set);
  Oe = function(e3, t2) {
    if (je(Be, e3))
      throw new Me("Object already initialized");
    return t2.facade = e3, ze(Be, e3, t2), t2;
  }, Ie = function(e3) {
    return Ue(Be, e3) || {};
  }, Re = function(e3) {
    return je(Be, e3);
  };
} else {
  var Ge = Fe("state");
  De[Ge] = true, Oe = function(e3, t2) {
    if (O(e3, Ge))
      throw new Me("Object already initialized");
    return t2.facade = e3, Te(e3, Ge, t2), t2;
  }, Ie = function(e3) {
    return O(e3, Ge) ? e3[Ge] : {};
  }, Re = function(e3) {
    return O(e3, Ge);
  };
}
var He = { set: Oe, get: Ie, has: Re, enforce: function(e3) {
  return Re(e3) ? Ie(e3) : Oe(e3, {});
}, getterFor: function(e3) {
  return function(t2) {
    var n2;
    if (!Q(t2) || (n2 = Ie(t2)).type !== e3)
      throw Me("Incompatible receiver, " + e3 + " required");
    return n2;
  };
} }, qe = Function.prototype, Ye = J && Object.getOwnPropertyDescriptor, Xe = O(qe, "name"), We = { EXISTS: Xe, PROPER: Xe && "something" === function() {
}.name, CONFIGURABLE: Xe && (!J || J && Ye(qe, "name").configurable) }, Ze = u(function(e3) {
  var t2 = We.CONFIGURABLE, n2 = He.get, a2 = He.enforce, r2 = String(String).split("String");
  (e3.exports = function(e4, n3, i2, s2) {
    var o2, l2 = !!s2 && !!s2.unsafe, u2 = !!s2 && !!s2.enumerable, c2 = !!s2 && !!s2.noTargetGet, d3 = s2 && void 0 !== s2.name ? s2.name : n3;
    P(i2) && ("Symbol(" === String(d3).slice(0, 7) && (d3 = "[" + String(d3).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!O(i2, "name") || t2 && i2.name !== d3) && Te(i2, "name", d3), (o2 = a2(i2)).source || (o2.source = r2.join("string" == typeof d3 ? d3 : ""))), e4 !== g ? (l2 ? !c2 && e4[n3] && (u2 = true) : delete e4[n3], u2 ? e4[n3] = i2 : Te(e4, n3, i2)) : u2 ? e4[n3] = i2 : b(n3, i2);
  })(Function.prototype, "toString", function() {
    return P(this) && n2(this).source || Ne(this);
  });
}), Ve = w({}.toString), Ke = w("".slice), Je = function(e3) {
  return Ke(Ve(e3), 8, -1);
}, Qe = Z("toStringTag"), et = g.Object, tt = "Arguments" == Je(function() {
  return arguments;
}()), nt = K ? Je : function(e3) {
  var t2, n2, a2;
  return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (n2 = function(e4, t3) {
    try {
      return e4[t3];
    } catch (e5) {
    }
  }(t2 = et(e3), Qe)) ? n2 : tt ? Je(t2) : "Object" == (a2 = Je(t2)) && P(t2.callee) ? "Arguments" : a2;
}, at = K ? {}.toString : function() {
  return "[object " + nt(this) + "]";
};
K || Ze(Object.prototype, "toString", at, { unsafe: true });
var rt, it, st = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, ot = ne("span").classList, lt = ot && ot.constructor && ot.constructor.prototype, ut = lt === Object.prototype ? void 0 : lt, ct = w(w.bind), dt = g.Object, pt = w("".split), gt = z(function() {
  return !dt("z").propertyIsEnumerable(0);
}) ? function(e3) {
  return "String" == Je(e3) ? pt(e3, "") : dt(e3);
} : dt, ft = Math.ceil, bt = Math.floor, ht = function(e3) {
  var t2 = +e3;
  return t2 != t2 || 0 === t2 ? 0 : (t2 > 0 ? bt : ft)(t2);
}, mt = Math.min, yt = function(e3) {
  return e3 > 0 ? mt(ht(e3), 9007199254740991) : 0;
}, Et = function(e3) {
  return yt(e3.length);
}, St = Array.isArray || function(e3) {
  return "Array" == Je(e3);
}, vt = function() {
}, wt = [], kt = F("Reflect", "construct"), At = /^\s*(?:class|function)\b/, xt = w(At.exec), Tt = !At.exec(vt), _t = function(e3) {
  if (!P(e3))
    return false;
  try {
    return kt(vt, wt, e3), true;
  } catch (e4) {
    return false;
  }
}, Ot = !kt || z(function() {
  var e3;
  return _t(_t.call) || !_t(Object) || !_t(function() {
    e3 = true;
  }) || e3;
}) ? function(e3) {
  if (!P(e3))
    return false;
  switch (nt(e3)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  return Tt || !!xt(At, Ne(e3));
} : _t, It = Z("species"), Rt = g.Array, Nt = function(e3, t2) {
  return new (function(e4) {
    var t3;
    return St(e4) && (t3 = e4.constructor, (Ot(t3) && (t3 === Rt || St(t3.prototype)) || Q(t3) && null === (t3 = t3[It])) && (t3 = void 0)), void 0 === t3 ? Rt : t3;
  }(e3))(0 === t2 ? 0 : t2);
}, Lt = w([].push), Pt = function(e3) {
  var t2 = 1 == e3, n2 = 2 == e3, a2 = 3 == e3, r2 = 4 == e3, i2 = 6 == e3, s2 = 7 == e3, o2 = 5 == e3 || i2;
  return function(l2, u2, c2, d3) {
    for (var p2, g2, f2 = T(l2), b2 = gt(f2), h2 = function(e4, t3) {
      return be(e4), void 0 === t3 ? e4 : ct ? ct(e4, t3) : function() {
        return e4.apply(t3, arguments);
      };
    }(u2, c2), m2 = Et(b2), y2 = 0, E2 = d3 || Nt, S2 = t2 ? E2(l2, m2) : n2 || s2 ? E2(l2, 0) : void 0; m2 > y2; y2++)
      if ((o2 || y2 in b2) && (g2 = h2(p2 = b2[y2], y2, f2), e3))
        if (t2)
          S2[y2] = g2;
        else if (g2)
          switch (e3) {
            case 3:
              return true;
            case 5:
              return p2;
            case 6:
              return y2;
            case 2:
              Lt(S2, p2);
          }
        else
          switch (e3) {
            case 4:
              return false;
            case 7:
              Lt(S2, p2);
          }
    return i2 ? -1 : a2 || r2 ? r2 : S2;
  };
}, Ct = { forEach: Pt(0), map: Pt(1), filter: Pt(2), some: Pt(3), every: Pt(4), find: Pt(5), findIndex: Pt(6), filterReject: Pt(7) }.forEach, Ft = !!(it = []["forEach"]) && z(function() {
  it.call(null, rt || function() {
    throw 1;
  }, 1);
}) ? [].forEach : function(e3) {
  return Ct(this, e3, arguments.length > 1 ? arguments[1] : void 0);
}, Dt = function(e3) {
  if (e3 && e3.forEach !== Ft)
    try {
      Te(e3, "forEach", Ft);
    } catch (t2) {
      e3.forEach = Ft;
    }
};
for (var Mt in st)
  st[Mt] && Dt(g[Mt] && g[Mt].prototype);
Dt(ut);
var $t = {}.propertyIsEnumerable, Bt = Object.getOwnPropertyDescriptor, Ut = { f: Bt && !$t.call({ 1: 2 }, 1) ? function(e3) {
  var t2 = Bt(this, e3);
  return !!t2 && t2.enumerable;
} : $t }, jt = function(e3) {
  return gt(A(e3));
}, zt = Object.getOwnPropertyDescriptor, Gt = { f: J ? zt : function(e3, t2) {
  if (e3 = jt(e3), t2 = ve(t2), ae)
    try {
      return zt(e3, t2);
    } catch (e4) {
    }
  if (O(e3, t2))
    return xe(!le(Ut.f, e3, t2), e3[t2]);
} }, Ht = Math.max, qt = Math.min, Yt = function(e3, t2) {
  var n2 = ht(e3);
  return n2 < 0 ? Ht(n2 + t2, 0) : qt(n2, t2);
}, Xt = function(e3) {
  return function(t2, n2, a2) {
    var r2, i2 = jt(t2), s2 = Et(i2), o2 = Yt(a2, s2);
    if (e3 && n2 != n2) {
      for (; s2 > o2; )
        if ((r2 = i2[o2++]) != r2)
          return true;
    } else
      for (; s2 > o2; o2++)
        if ((e3 || o2 in i2) && i2[o2] === n2)
          return e3 || o2 || 0;
    return !e3 && -1;
  };
}, Wt = { includes: Xt(true), indexOf: Xt(false) }.indexOf, Zt = w([].push), Vt = function(e3, t2) {
  var n2, a2 = jt(e3), r2 = 0, i2 = [];
  for (n2 in a2)
    !O(De, n2) && O(a2, n2) && Zt(i2, n2);
  for (; t2.length > r2; )
    O(a2, n2 = t2[r2++]) && (~Wt(i2, n2) || Zt(i2, n2));
  return i2;
}, Kt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], Jt = Kt.concat("length", "prototype"), Qt = { f: Object.getOwnPropertyNames || function(e3) {
  return Vt(e3, Jt);
} }, en = { f: Object.getOwnPropertySymbols }, tn = w([].concat), nn = F("Reflect", "ownKeys") || function(e3) {
  var t2 = Qt.f(se(e3)), n2 = en.f;
  return n2 ? tn(t2, n2(e3)) : t2;
}, an = function(e3, t2) {
  for (var n2 = nn(t2), a2 = Ae.f, r2 = Gt.f, i2 = 0; i2 < n2.length; i2++) {
    var s2 = n2[i2];
    O(e3, s2) || a2(e3, s2, r2(t2, s2));
  }
}, rn = /#|\.prototype\./, sn = function(e3, t2) {
  var n2 = ln[on(e3)];
  return n2 == cn || n2 != un && (P(t2) ? z(t2) : !!t2);
}, on = sn.normalize = function(e3) {
  return String(e3).replace(rn, ".").toLowerCase();
}, ln = sn.data = {}, un = sn.NATIVE = "N", cn = sn.POLYFILL = "P", dn = sn, pn = Gt.f, gn = function(e3, t2) {
  var n2, a2, r2, i2, s2, o2 = e3.target, l2 = e3.global, u2 = e3.stat;
  if (n2 = l2 ? g : u2 ? g[o2] || b(o2, {}) : (g[o2] || {}).prototype)
    for (a2 in t2) {
      if (i2 = t2[a2], r2 = e3.noTargetGet ? (s2 = pn(n2, a2)) && s2.value : n2[a2], !dn(l2 ? a2 : o2 + (u2 ? "." : "#") + a2, e3.forced) && void 0 !== r2) {
        if (typeof i2 == typeof r2)
          continue;
        an(i2, r2);
      }
      (e3.sham || r2 && r2.sham) && Te(i2, "sham", true), Ze(n2, a2, i2, e3);
    }
}, fn = Object.keys || function(e3) {
  return Vt(e3, Kt);
}, bn = Object.assign, hn = Object.defineProperty, mn = w([].concat), yn = !bn || z(function() {
  if (J && 1 !== bn({ b: 1 }, bn(hn({}, "a", { enumerable: true, get: function() {
    hn(this, "b", { value: 3, enumerable: false });
  } }), { b: 2 })).b)
    return true;
  var e3 = {}, t2 = {}, n2 = Symbol(), a2 = "abcdefghijklmnopqrst";
  return e3[n2] = 7, a2.split("").forEach(function(e4) {
    t2[e4] = e4;
  }), 7 != bn({}, e3)[n2] || fn(bn({}, t2)).join("") != a2;
}) ? function(e3, t2) {
  for (var n2 = T(e3), a2 = arguments.length, r2 = 1, i2 = en.f, s2 = Ut.f; a2 > r2; )
    for (var o2, l2 = gt(arguments[r2++]), u2 = i2 ? mn(fn(l2), i2(l2)) : fn(l2), c2 = u2.length, d3 = 0; c2 > d3; )
      o2 = u2[d3++], J && !le(s2, l2, o2) || (n2[o2] = l2[o2]);
  return n2;
} : bn;
gn({ target: "Object", stat: true, forced: Object.assign !== yn }, { assign: yn });
var En = u(function(e3) {
  var t2 = function(e4) {
    var t3 = /\blang(?:uage)?-([\w-]+)\b/i, n2 = 0, a2 = {}, r2 = { manual: e4.Prism && e4.Prism.manual, disableWorkerMessageHandler: e4.Prism && e4.Prism.disableWorkerMessageHandler, util: { encode: function e5(t4) {
      return t4 instanceof i2 ? new i2(t4.type, e5(t4.content), t4.alias) : Array.isArray(t4) ? t4.map(e5) : t4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
    }, type: function(e5) {
      return Object.prototype.toString.call(e5).slice(8, -1);
    }, objId: function(e5) {
      return e5.__id || Object.defineProperty(e5, "__id", { value: ++n2 }), e5.__id;
    }, clone: function e5(t4, n3) {
      var a3, i3;
      switch (n3 = n3 || {}, r2.util.type(t4)) {
        case "Object":
          if (i3 = r2.util.objId(t4), n3[i3])
            return n3[i3];
          for (var s3 in a3 = {}, n3[i3] = a3, t4)
            t4.hasOwnProperty(s3) && (a3[s3] = e5(t4[s3], n3));
          return a3;
        case "Array":
          return i3 = r2.util.objId(t4), n3[i3] ? n3[i3] : (a3 = [], n3[i3] = a3, t4.forEach(function(t5, r3) {
            a3[r3] = e5(t5, n3);
          }), a3);
        default:
          return t4;
      }
    }, getLanguage: function(e5) {
      for (; e5 && !t3.test(e5.className); )
        e5 = e5.parentElement;
      return e5 ? (e5.className.match(t3) || [, "none"])[1].toLowerCase() : "none";
    }, currentScript: function() {
      if ("undefined" == typeof document)
        return null;
      if ("currentScript" in document)
        return document.currentScript;
      try {
        throw new Error();
      } catch (a3) {
        var e5 = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(a3.stack) || [])[1];
        if (e5) {
          var t4 = document.getElementsByTagName("script");
          for (var n3 in t4)
            if (t4[n3].src == e5)
              return t4[n3];
        }
        return null;
      }
    }, isActive: function(e5, t4, n3) {
      for (var a3 = "no-" + t4; e5; ) {
        var r3 = e5.classList;
        if (r3.contains(t4))
          return true;
        if (r3.contains(a3))
          return false;
        e5 = e5.parentElement;
      }
      return !!n3;
    } }, languages: { plain: a2, plaintext: a2, text: a2, txt: a2, extend: function(e5, t4) {
      var n3 = r2.util.clone(r2.languages[e5]);
      for (var a3 in t4)
        n3[a3] = t4[a3];
      return n3;
    }, insertBefore: function(e5, t4, n3, a3) {
      var i3 = (a3 = a3 || r2.languages)[e5], s3 = {};
      for (var o3 in i3)
        if (i3.hasOwnProperty(o3)) {
          if (o3 == t4)
            for (var l3 in n3)
              n3.hasOwnProperty(l3) && (s3[l3] = n3[l3]);
          n3.hasOwnProperty(o3) || (s3[o3] = i3[o3]);
        }
      var u3 = a3[e5];
      return a3[e5] = s3, r2.languages.DFS(r2.languages, function(t5, n4) {
        n4 === u3 && t5 != e5 && (this[t5] = s3);
      }), s3;
    }, DFS: function e5(t4, n3, a3, i3) {
      i3 = i3 || {};
      var s3 = r2.util.objId;
      for (var o3 in t4)
        if (t4.hasOwnProperty(o3)) {
          n3.call(t4, o3, t4[o3], a3 || o3);
          var l3 = t4[o3], u3 = r2.util.type(l3);
          "Object" !== u3 || i3[s3(l3)] ? "Array" !== u3 || i3[s3(l3)] || (i3[s3(l3)] = true, e5(l3, n3, o3, i3)) : (i3[s3(l3)] = true, e5(l3, n3, null, i3));
        }
    } }, plugins: {}, highlightAll: function(e5, t4) {
      r2.highlightAllUnder(document, e5, t4);
    }, highlightAllUnder: function(e5, t4, n3) {
      var a3 = { callback: n3, container: e5, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' };
      r2.hooks.run("before-highlightall", a3), a3.elements = Array.prototype.slice.apply(a3.container.querySelectorAll(a3.selector)), r2.hooks.run("before-all-elements-highlight", a3);
      for (var i3, s3 = 0; i3 = a3.elements[s3++]; )
        r2.highlightElement(i3, true === t4, a3.callback);
    }, highlightElement: function(n3, a3, i3) {
      var s3 = r2.util.getLanguage(n3), o3 = r2.languages[s3];
      n3.className = n3.className.replace(t3, "").replace(/\s+/g, " ") + " language-" + s3;
      var l3 = n3.parentElement;
      l3 && "pre" === l3.nodeName.toLowerCase() && (l3.className = l3.className.replace(t3, "").replace(/\s+/g, " ") + " language-" + s3);
      var u3 = { element: n3, language: s3, grammar: o3, code: n3.textContent };
      function c3(e5) {
        u3.highlightedCode = e5, r2.hooks.run("before-insert", u3), u3.element.innerHTML = u3.highlightedCode, r2.hooks.run("after-highlight", u3), r2.hooks.run("complete", u3), i3 && i3.call(u3.element);
      }
      if (r2.hooks.run("before-sanity-check", u3), (l3 = u3.element.parentElement) && "pre" === l3.nodeName.toLowerCase() && !l3.hasAttribute("tabindex") && l3.setAttribute("tabindex", "0"), !u3.code)
        return r2.hooks.run("complete", u3), void (i3 && i3.call(u3.element));
      if (r2.hooks.run("before-highlight", u3), u3.grammar)
        if (a3 && e4.Worker) {
          var d4 = new Worker(r2.filename);
          d4.onmessage = function(e5) {
            c3(e5.data);
          }, d4.postMessage(JSON.stringify({ language: u3.language, code: u3.code, immediateClose: true }));
        } else
          c3(r2.highlight(u3.code, u3.grammar, u3.language));
      else
        c3(r2.util.encode(u3.code));
    }, highlight: function(e5, t4, n3) {
      var a3 = { code: e5, grammar: t4, language: n3 };
      return r2.hooks.run("before-tokenize", a3), a3.tokens = r2.tokenize(a3.code, a3.grammar), r2.hooks.run("after-tokenize", a3), i2.stringify(r2.util.encode(a3.tokens), a3.language);
    }, tokenize: function(e5, t4) {
      var n3 = t4.rest;
      if (n3) {
        for (var a3 in n3)
          t4[a3] = n3[a3];
        delete t4.rest;
      }
      var r3 = new l2();
      return u2(r3, r3.head, e5), o2(e5, r3, t4, r3.head, 0), function(e6) {
        var t5 = [], n4 = e6.head.next;
        for (; n4 !== e6.tail; )
          t5.push(n4.value), n4 = n4.next;
        return t5;
      }(r3);
    }, hooks: { all: {}, add: function(e5, t4) {
      var n3 = r2.hooks.all;
      n3[e5] = n3[e5] || [], n3[e5].push(t4);
    }, run: function(e5, t4) {
      var n3 = r2.hooks.all[e5];
      if (n3 && n3.length)
        for (var a3, i3 = 0; a3 = n3[i3++]; )
          a3(t4);
    } }, Token: i2 };
    function i2(e5, t4, n3, a3) {
      this.type = e5, this.content = t4, this.alias = n3, this.length = 0 | (a3 || "").length;
    }
    function s2(e5, t4, n3, a3) {
      e5.lastIndex = t4;
      var r3 = e5.exec(n3);
      if (r3 && a3 && r3[1]) {
        var i3 = r3[1].length;
        r3.index += i3, r3[0] = r3[0].slice(i3);
      }
      return r3;
    }
    function o2(e5, t4, n3, a3, l3, d4) {
      for (var p3 in n3)
        if (n3.hasOwnProperty(p3) && n3[p3]) {
          var g3 = n3[p3];
          g3 = Array.isArray(g3) ? g3 : [g3];
          for (var f2 = 0; f2 < g3.length; ++f2) {
            if (d4 && d4.cause == p3 + "," + f2)
              return;
            var b2 = g3[f2], h2 = b2.inside, m2 = !!b2.lookbehind, y2 = !!b2.greedy, E2 = b2.alias;
            if (y2 && !b2.pattern.global) {
              var S2 = b2.pattern.toString().match(/[imsuy]*$/)[0];
              b2.pattern = RegExp(b2.pattern.source, S2 + "g");
            }
            for (var v2 = b2.pattern || b2, w2 = a3.next, k2 = l3; w2 !== t4.tail && !(d4 && k2 >= d4.reach); k2 += w2.value.length, w2 = w2.next) {
              var A2 = w2.value;
              if (t4.length > e5.length)
                return;
              if (!(A2 instanceof i2)) {
                var x2, T2 = 1;
                if (y2) {
                  if (!(x2 = s2(v2, k2, e5, m2)))
                    break;
                  var _2 = x2.index, O2 = x2.index + x2[0].length, I2 = k2;
                  for (I2 += w2.value.length; _2 >= I2; )
                    I2 += (w2 = w2.next).value.length;
                  if (k2 = I2 -= w2.value.length, w2.value instanceof i2)
                    continue;
                  for (var R2 = w2; R2 !== t4.tail && (I2 < O2 || "string" == typeof R2.value); R2 = R2.next)
                    T2++, I2 += R2.value.length;
                  T2--, A2 = e5.slice(k2, I2), x2.index -= k2;
                } else if (!(x2 = s2(v2, 0, A2, m2)))
                  continue;
                _2 = x2.index;
                var N2 = x2[0], L2 = A2.slice(0, _2), P2 = A2.slice(_2 + N2.length), C2 = k2 + A2.length;
                d4 && C2 > d4.reach && (d4.reach = C2);
                var F2 = w2.prev;
                if (L2 && (F2 = u2(t4, F2, L2), k2 += L2.length), c2(t4, F2, T2), w2 = u2(t4, F2, new i2(p3, h2 ? r2.tokenize(N2, h2) : N2, E2, N2)), P2 && u2(t4, w2, P2), T2 > 1) {
                  var D2 = { cause: p3 + "," + f2, reach: C2 };
                  o2(e5, t4, n3, w2.prev, k2, D2), d4 && D2.reach > d4.reach && (d4.reach = D2.reach);
                }
              }
            }
          }
        }
    }
    function l2() {
      var e5 = { value: null, prev: null, next: null }, t4 = { value: null, prev: e5, next: null };
      e5.next = t4, this.head = e5, this.tail = t4, this.length = 0;
    }
    function u2(e5, t4, n3) {
      var a3 = t4.next, r3 = { value: n3, prev: t4, next: a3 };
      return t4.next = r3, a3.prev = r3, e5.length++, r3;
    }
    function c2(e5, t4, n3) {
      for (var a3 = t4.next, r3 = 0; r3 < n3 && a3 !== e5.tail; r3++)
        a3 = a3.next;
      t4.next = a3, a3.prev = t4, e5.length -= r3;
    }
    if (e4.Prism = r2, i2.stringify = function e5(t4, n3) {
      if ("string" == typeof t4)
        return t4;
      if (Array.isArray(t4)) {
        var a3 = "";
        return t4.forEach(function(t5) {
          a3 += e5(t5, n3);
        }), a3;
      }
      var i3 = { type: t4.type, content: e5(t4.content, n3), tag: "span", classes: ["token", t4.type], attributes: {}, language: n3 }, s3 = t4.alias;
      s3 && (Array.isArray(s3) ? Array.prototype.push.apply(i3.classes, s3) : i3.classes.push(s3)), r2.hooks.run("wrap", i3);
      var o3 = "";
      for (var l3 in i3.attributes)
        o3 += " " + l3 + '="' + (i3.attributes[l3] || "").replace(/"/g, "&quot;") + '"';
      return "<" + i3.tag + ' class="' + i3.classes.join(" ") + '"' + o3 + ">" + i3.content + "</" + i3.tag + ">";
    }, !e4.document)
      return e4.addEventListener ? (r2.disableWorkerMessageHandler || e4.addEventListener("message", function(t4) {
        var n3 = JSON.parse(t4.data), a3 = n3.language, i3 = n3.code, s3 = n3.immediateClose;
        e4.postMessage(r2.highlight(i3, r2.languages[a3], a3)), s3 && e4.close();
      }, false), r2) : r2;
    var d3 = r2.util.currentScript();
    function p2() {
      r2.manual || r2.highlightAll();
    }
    if (d3 && (r2.filename = d3.src, d3.hasAttribute("data-manual") && (r2.manual = true)), !r2.manual) {
      var g2 = document.readyState;
      "loading" === g2 || "interactive" === g2 && d3 && d3.defer ? document.addEventListener("DOMContentLoaded", p2) : window.requestAnimationFrame ? window.requestAnimationFrame(p2) : window.setTimeout(p2, 16);
    }
    return r2;
  }("undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {});
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  e3.exports && (e3.exports = t2), void 0 !== l && (l.Prism = t2), t2.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, t2.languages.markup.tag.inside["attr-value"].inside.entity = t2.languages.markup.entity, t2.languages.markup.doctype.inside["internal-subset"].inside = t2.languages.markup, t2.hooks.add("wrap", function(e4) {
    "entity" === e4.type && (e4.attributes.title = e4.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(t2.languages.markup.tag, "addInlined", { value: function(e4, n2) {
    var a2 = {};
    a2["language-" + n2] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: t2.languages[n2] }, a2.cdata = /^<!\[CDATA\[|\]\]>$/i;
    var r2 = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: a2 } };
    r2["language-" + n2] = { pattern: /[\s\S]+/, inside: t2.languages[n2] };
    var i2 = {};
    i2[e4] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
      return e4;
    }), "i"), lookbehind: true, greedy: true, inside: r2 }, t2.languages.insertBefore("markup", "cdata", i2);
  } }), Object.defineProperty(t2.languages.markup.tag, "addAttribute", { value: function(e4, n2) {
    t2.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e4 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n2, "language-" + n2], inside: t2.languages[n2] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
  } }), t2.languages.html = t2.languages.markup, t2.languages.mathml = t2.languages.markup, t2.languages.svg = t2.languages.markup, t2.languages.xml = t2.languages.extend("markup", {}), t2.languages.ssml = t2.languages.xml, t2.languages.atom = t2.languages.xml, t2.languages.rss = t2.languages.xml, function(e4) {
    var t3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    e4.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/, inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + t3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + t3.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t3.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: t3, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e4.languages.css.atrule.inside.rest = e4.languages.css;
    var n2 = e4.languages.markup;
    n2 && (n2.tag.addInlined("style", "css"), n2.tag.addAttribute("style", "css"));
  }(t2), t2.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, t2.languages.javascript = t2.languages.extend("clike", { "class-name": [t2.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), t2.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, t2.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/, lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: t2.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: t2.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: t2.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: t2.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: t2.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), t2.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: t2.languages.javascript } }, string: /[\s\S]+/ } } }), t2.languages.markup && (t2.languages.markup.tag.addInlined("script", "javascript"), t2.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), t2.languages.js = t2.languages.javascript, function() {
    if (void 0 !== t2 && "undefined" != typeof document) {
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var e4 = { js: "javascript", py: "python", rb: "ruby", ps1: "powershell", psm1: "powershell", sh: "bash", bat: "batch", h: "c", tex: "latex" }, n2 = "data-src-status", a2 = "loading", r2 = "loaded", i2 = 'pre[data-src]:not([data-src-status="loaded"]):not([data-src-status="loading"])', s2 = /\blang(?:uage)?-([\w-]+)\b/i;
      t2.hooks.add("before-highlightall", function(e5) {
        e5.selector += ", " + i2;
      }), t2.hooks.add("before-sanity-check", function(s3) {
        var o3 = s3.element;
        if (o3.matches(i2)) {
          s3.code = "", o3.setAttribute(n2, a2);
          var u2 = o3.appendChild(document.createElement("CODE"));
          u2.textContent = "Loading\u2026";
          var c2 = o3.getAttribute("data-src"), d3 = s3.language;
          if ("none" === d3) {
            var p2 = (/\.(\w+)$/.exec(c2) || [, "none"])[1];
            d3 = e4[p2] || p2;
          }
          l2(u2, d3), l2(o3, d3);
          var g2 = t2.plugins.autoloader;
          g2 && g2.loadLanguages(d3);
          var f2 = new XMLHttpRequest();
          f2.open("GET", c2, true), f2.onreadystatechange = function() {
            var e5, a3;
            4 == f2.readyState && (f2.status < 400 && f2.responseText ? (o3.setAttribute(n2, r2), u2.textContent = f2.responseText, t2.highlightElement(u2)) : (o3.setAttribute(n2, "failed"), f2.status >= 400 ? u2.textContent = (e5 = f2.status, a3 = f2.statusText, "\u2716 Error " + e5 + " while fetching file: " + a3) : u2.textContent = "\u2716 Error: File does not exist or is empty"));
          }, f2.send(null);
        }
      }), t2.plugins.fileHighlight = { highlight: function(e5) {
        for (var n3, a3 = (e5 || document).querySelectorAll(i2), r3 = 0; n3 = a3[r3++]; )
          t2.highlightElement(n3);
      } };
      var o2 = false;
      t2.fileHighlight = function() {
        o2 || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), o2 = true), t2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    }
    function l2(e5, t3) {
      var n3 = e5.className;
      n3 = n3.replace(s2, " ") + " language-" + t3, e5.className = n3.replace(/\s+/g, " ").trim();
    }
  }();
});
!function(e3) {
  var t2 = e3.util.clone(e3.languages.javascript), n2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a2 = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r2 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function i2(e4, t3) {
    return e4 = e4.replace(/<S>/g, function() {
      return n2;
    }).replace(/<BRACES>/g, function() {
      return a2;
    }).replace(/<SPREAD>/g, function() {
      return r2;
    }), RegExp(e4, t3);
  }
  r2 = i2(r2).source, e3.languages.jsx = e3.languages.extend("markup", t2), e3.languages.jsx.tag.pattern = i2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), e3.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/i, e3.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/i, e3.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, e3.languages.jsx.tag.inside.comment = t2.comment, e3.languages.insertBefore("inside", "attr-name", { spread: { pattern: i2(/<SPREAD>/.source), inside: e3.languages.jsx } }, e3.languages.jsx.tag), e3.languages.insertBefore("inside", "special-attr", { script: { pattern: i2(/=<BRACES>/.source), inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: e3.languages.jsx }, alias: "language-javascript" } }, e3.languages.jsx.tag);
  var s2 = function(e4) {
    return e4 ? "string" == typeof e4 ? e4 : "string" == typeof e4.content ? e4.content : e4.content.map(s2).join("") : "";
  }, o2 = function(t3) {
    for (var n3 = [], a3 = 0; a3 < t3.length; a3++) {
      var r3 = t3[a3], i3 = false;
      if ("string" != typeof r3 && ("tag" === r3.type && r3.content[0] && "tag" === r3.content[0].type ? "</" === r3.content[0].content[0].content ? n3.length > 0 && n3[n3.length - 1].tagName === s2(r3.content[0].content[1]) && n3.pop() : "/>" === r3.content[r3.content.length - 1].content || n3.push({ tagName: s2(r3.content[0].content[1]), openedBraces: 0 }) : n3.length > 0 && "punctuation" === r3.type && "{" === r3.content ? n3[n3.length - 1].openedBraces++ : n3.length > 0 && n3[n3.length - 1].openedBraces > 0 && "punctuation" === r3.type && "}" === r3.content ? n3[n3.length - 1].openedBraces-- : i3 = true), (i3 || "string" == typeof r3) && n3.length > 0 && 0 === n3[n3.length - 1].openedBraces) {
        var l2 = s2(r3);
        a3 < t3.length - 1 && ("string" == typeof t3[a3 + 1] || "plain-text" === t3[a3 + 1].type) && (l2 += s2(t3[a3 + 1]), t3.splice(a3 + 1, 1)), a3 > 0 && ("string" == typeof t3[a3 - 1] || "plain-text" === t3[a3 - 1].type) && (l2 = s2(t3[a3 - 1]) + l2, t3.splice(a3 - 1, 1), a3--), t3[a3] = new e3.Token("plain-text", l2, null, l2);
      }
      r3.content && "string" != typeof r3.content && o2(r3.content);
    }
  };
  e3.hooks.add("after-tokenize", function(e4) {
    "jsx" !== e4.language && "tsx" !== e4.language || o2(e4.tokens);
  });
}(Prism), function(e3) {
  e3.languages.typescript = e3.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ }), e3.languages.typescript.keyword.push(/\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e3.languages.typescript.parameter;
  var t2 = e3.languages.extend("typescript", {});
  delete t2["class-name"], e3.languages.typescript["class-name"].inside = t2, e3.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t2 } } } }), e3.languages.ts = e3.languages.typescript;
}(Prism), Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e3) {
  "entity" === e3.type && (e3.attributes.title = e3.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e3, t2) {
  var n2 = {};
  n2["language-" + t2] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[t2] }, n2.cdata = /^<!\[CDATA\[|\]\]>$/i;
  var a2 = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: n2 } };
  a2["language-" + t2] = { pattern: /[\s\S]+/, inside: Prism.languages[t2] };
  var r2 = {};
  r2[e3] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e3;
  }), "i"), lookbehind: true, greedy: true, inside: a2 }, Prism.languages.insertBefore("markup", "cdata", r2);
} }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e3, t2) {
  Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e3 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [t2, "language-" + t2], inside: Prism.languages[t2] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|iota|nil|true|false)\b/, number: /(?:\b0x[a-f\d]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[-+]?\d+)?)i?/i, operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/ }), delete Prism.languages.go["class-name"], function(e3) {
  var t2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/, n2 = [{ pattern: /\b(?:false|true)\b/i, alias: "boolean" }, { pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i, greedy: true, lookbehind: true }, { pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i, greedy: true, lookbehind: true }, /\b(?:null)\b/i, /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/], a2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i, r2 = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/, i2 = /[{}\[\](),:;]/;
  e3.languages.php = { delimiter: { pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i, alias: "important" }, comment: t2, variable: /\$+(?:\w+\b|(?=\{))/i, package: { pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, lookbehind: true, inside: { punctuation: /\\/ } }, "class-name-definition": { pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i, lookbehind: true, alias: "class-name" }, "function-definition": { pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i, lookbehind: true, alias: "function" }, keyword: [{ pattern: /(\(\s*)\b(?:bool|boolean|int|integer|float|string|object|array)\b(?=\s*\))/i, alias: "type-casting", greedy: true, lookbehind: true }, { pattern: /([(,?]\s*)\b(?:bool|int|float|string|object|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b(?=\s*\$)/i, alias: "type-hint", greedy: true, lookbehind: true }, { pattern: /([(,?]\s*[\w|]\|\s*)(?:null|false)\b(?=\s*\$)/i, alias: "type-hint", greedy: true, lookbehind: true }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b/i, alias: "return-type", greedy: true, lookbehind: true }, { pattern: /(\)\s*:\s*(?:\?\s*)?[\w|]\|\s*)(?:null|false)\b/i, alias: "return-type", greedy: true, lookbehind: true }, { pattern: /\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|iterable|(?:null|false)(?=\s*\|))\b/i, alias: "type-declaration", greedy: true }, { pattern: /(\|\s*)(?:null|false)\b/i, alias: "type-declaration", greedy: true, lookbehind: true }, { pattern: /\b(?:parent|self|static)(?=\s*::)/i, alias: "static-context", greedy: true }, { pattern: /(\byield\s+)from\b/i, lookbehind: true }, /\bclass\b/i, { pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i, lookbehind: true }], "argument-name": { pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i, lookbehind: true }, "class-name": [{ pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i, greedy: true, lookbehind: true }, { pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i, greedy: true, lookbehind: true }, { pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i, greedy: true }, { pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i, alias: "class-name-fully-qualified", greedy: true, lookbehind: true, inside: { punctuation: /\\/ } }, { pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i, alias: "class-name-fully-qualified", greedy: true, inside: { punctuation: /\\/ } }, { pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: "class-name-fully-qualified", greedy: true, lookbehind: true, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*\$)/i, alias: "type-declaration", greedy: true }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ["class-name-fully-qualified", "type-declaration"], greedy: true, inside: { punctuation: /\\/ } }, { pattern: /\b[a-z_]\w*(?=\s*::)/i, alias: "static-context", greedy: true }, { pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i, alias: ["class-name-fully-qualified", "static-context"], greedy: true, inside: { punctuation: /\\/ } }, { pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i, alias: "type-hint", greedy: true, lookbehind: true }, { pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i, alias: ["class-name-fully-qualified", "type-hint"], greedy: true, lookbehind: true, inside: { punctuation: /\\/ } }, { pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i, alias: "return-type", greedy: true, lookbehind: true }, { pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i, alias: ["class-name-fully-qualified", "return-type"], greedy: true, lookbehind: true, inside: { punctuation: /\\/ } }], constant: n2, function: { pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i, lookbehind: true, inside: { punctuation: /\\/ } }, property: { pattern: /(->\s*)\w+/, lookbehind: true }, number: a2, operator: r2, punctuation: i2 };
  var s2 = { pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/, lookbehind: true, inside: e3.languages.php }, o2 = [{ pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/, alias: "nowdoc-string", greedy: true, inside: { delimiter: { pattern: /^<<<'[^']+'|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<'?|[';]$/ } } } }, { pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i, alias: "heredoc-string", greedy: true, inside: { delimiter: { pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i, alias: "symbol", inside: { punctuation: /^<<<"?|[";]$/ } }, interpolation: s2 } }, { pattern: /`(?:\\[\s\S]|[^\\`])*`/, alias: "backtick-quoted-string", greedy: true }, { pattern: /'(?:\\[\s\S]|[^\\'])*'/, alias: "single-quoted-string", greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, alias: "double-quoted-string", greedy: true, inside: { interpolation: s2 } }];
  e3.languages.insertBefore("php", "variable", { string: o2, attribute: { pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im, greedy: true, inside: { "attribute-content": { pattern: /^(#\[)[\s\S]+(?=\]$)/, lookbehind: true, inside: { comment: t2, string: o2, "attribute-class-name": [{ pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i, alias: "class-name", greedy: true, lookbehind: true }, { pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i, alias: ["class-name", "class-name-fully-qualified"], greedy: true, lookbehind: true, inside: { punctuation: /\\/ } }], constant: n2, number: a2, operator: r2, punctuation: i2 } }, delimiter: { pattern: /^#\[|\]$/, alias: "punctuation" } } } }), e3.hooks.add("before-tokenize", function(t3) {
    if (/<\?/.test(t3.code)) {
      e3.languages["markup-templating"].buildPlaceholders(t3, "php", /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/gi);
    }
  }), e3.hooks.add("after-tokenize", function(t3) {
    e3.languages["markup-templating"].tokenizePlaceholders(t3, "php");
  });
}(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } }, constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/ }), delete Prism.languages.c.boolean, Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true }, "string-interpolation": { pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/im, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:True|False|None)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?\b/i, operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, function(e3) {
  var t2 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/, n2 = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source, a2 = { pattern: RegExp(n2 + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source), lookbehind: true, inside: { namespace: { pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/, inside: { punctuation: /\./ } }, punctuation: /\./ } };
  e3.languages.java = e3.languages.extend("clike", { "class-name": [a2, { pattern: RegExp(n2 + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source), lookbehind: true, inside: a2.inside }], keyword: t2, function: [e3.languages.clike.function, { pattern: /(::\s*)[a-z_]\w*/, lookbehind: true }], number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i, operator: { pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m, lookbehind: true } }), e3.languages.insertBefore("java", "string", { "triple-quoted-string": { pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/, greedy: true, alias: "string" } }), e3.languages.insertBefore("java", "class-name", { annotation: { pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/, lookbehind: true, alias: "punctuation" }, generics: { pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/, inside: { "class-name": a2, keyword: t2, punctuation: /[<>(),.:]/, operator: /[?&|]/ } }, namespace: { pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
    return t2.source;
  })), lookbehind: true, inside: { punctuation: /\./ } } });
}(Prism), function(e3) {
  var t2 = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n2 = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return t2.source;
  });
  e3.languages.cpp = e3.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return t2.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: t2, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:true|false)\b/ }), e3.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:module|import)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return n2;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e3.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e3.languages.cpp } } } }), e3.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e3.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e3.languages.extend("cpp", {}) } }), e3.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e3.languages.cpp["base-clause"]);
}(Prism), function(e3) {
  function t2(e4, t3) {
    return e4.replace(/<<(\d+)>>/g, function(e5, n3) {
      return "(?:" + t3[+n3] + ")";
    });
  }
  function n2(e4, n3, a3) {
    return RegExp(t2(e4, n3), a3 || "");
  }
  function a2(e4, t3) {
    for (var n3 = 0; n3 < t3; n3++)
      e4 = e4.replace(/<<self>>/g, function() {
        return "(?:" + e4 + ")";
      });
    return e4.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var r2 = "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void", i2 = "class enum interface record struct", s2 = "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)", o2 = "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield";
  function l2(e4) {
    return "\\b(?:" + e4.trim().replace(/ /g, "|") + ")\\b";
  }
  var u2 = l2(i2), c2 = RegExp(l2(r2 + " " + i2 + " " + s2 + " " + o2)), d3 = l2(i2 + " " + s2 + " " + o2), p2 = l2(r2 + " " + i2 + " " + o2), g2 = a2(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2), f2 = a2(/\((?:[^()]|<<self>>)*\)/.source, 2), b2 = /@?\b[A-Za-z_]\w*\b/.source, h2 = t2(/<<0>>(?:\s*<<1>>)?/.source, [b2, g2]), m2 = t2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [d3, h2]), y2 = /\[\s*(?:,\s*)*\]/.source, E2 = t2(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [m2, y2]), S2 = t2(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [g2, f2, y2]), v2 = t2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [S2]), w2 = t2(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [v2, m2, y2]), k2 = { keyword: c2, punctuation: /[<>()?,.:[\]]/ }, A2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source, x2 = /"(?:\\.|[^\\"\r\n])*"/.source, T2 = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  e3.languages.csharp = e3.languages.extend("clike", { string: [{ pattern: n2(/(^|[^$\\])<<0>>/.source, [T2]), lookbehind: true, greedy: true }, { pattern: n2(/(^|[^@$\\])<<0>>/.source, [x2]), lookbehind: true, greedy: true }, { pattern: RegExp(A2), greedy: true, alias: "character" }], "class-name": [{ pattern: n2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [m2]), lookbehind: true, inside: k2 }, { pattern: n2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [b2, w2]), lookbehind: true, inside: k2 }, { pattern: n2(/(\busing\s+)<<0>>(?=\s*=)/.source, [b2]), lookbehind: true }, { pattern: n2(/(\b<<0>>\s+)<<1>>/.source, [u2, h2]), lookbehind: true, inside: k2 }, { pattern: n2(/(\bcatch\s*\(\s*)<<0>>/.source, [m2]), lookbehind: true, inside: k2 }, { pattern: n2(/(\bwhere\s+)<<0>>/.source, [b2]), lookbehind: true }, { pattern: n2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [E2]), lookbehind: true, inside: k2 }, { pattern: n2(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [w2, p2, b2]), inside: k2 }], keyword: c2, number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:ul|lu|[dflmu])?\b/i, operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/, punctuation: /\?\.?|::|[{}[\];(),.:]/ }), e3.languages.insertBefore("csharp", "number", { range: { pattern: /\.\./, alias: "operator" } }), e3.languages.insertBefore("csharp", "punctuation", { "named-parameter": { pattern: n2(/([(,]\s*)<<0>>(?=\s*:)/.source, [b2]), lookbehind: true, alias: "punctuation" } }), e3.languages.insertBefore("csharp", "class-name", { namespace: { pattern: n2(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [b2]), lookbehind: true, inside: { punctuation: /\./ } }, "type-expression": { pattern: n2(/(\b(?:default|typeof|sizeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [f2]), lookbehind: true, alias: "class-name", inside: k2 }, "return-type": { pattern: n2(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [w2, m2]), inside: k2, alias: "class-name" }, "constructor-invocation": { pattern: n2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [w2]), lookbehind: true, inside: k2, alias: "class-name" }, "generic-method": { pattern: n2(/<<0>>\s*<<1>>(?=\s*\()/.source, [b2, g2]), inside: { function: n2(/^<<0>>/.source, [b2]), generic: { pattern: RegExp(g2), alias: "class-name", inside: k2 } } }, "type-list": { pattern: n2(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [u2, h2, b2, w2, c2.source, f2, /\bnew\s*\(\s*\)/.source]), lookbehind: true, inside: { "record-arguments": { pattern: n2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [h2, f2]), lookbehind: true, greedy: true, inside: e3.languages.csharp }, keyword: c2, "class-name": { pattern: RegExp(w2), greedy: true, inside: k2 }, punctuation: /[,()]/ } }, preprocessor: { pattern: /(^[\t ]*)#.*/m, lookbehind: true, alias: "property", inside: { directive: { pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/, lookbehind: true, alias: "keyword" } } } });
  var _2 = x2 + "|" + A2, O2 = t2(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [_2]), I2 = a2(t2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [O2]), 2), R2 = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source, N2 = t2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [m2, I2]);
  e3.languages.insertBefore("csharp", "class-name", { attribute: { pattern: n2(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [R2, N2]), lookbehind: true, greedy: true, inside: { target: { pattern: n2(/^<<0>>(?=\s*:)/.source, [R2]), alias: "keyword" }, "attribute-arguments": { pattern: n2(/\(<<0>>*\)/.source, [I2]), inside: e3.languages.csharp }, "class-name": { pattern: RegExp(m2), inside: { punctuation: /\./ } }, punctuation: /[:,]/ } } });
  var L2 = /:[^}\r\n]+/.source, P2 = a2(t2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [O2]), 2), C2 = t2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [P2, L2]), F2 = a2(t2(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [_2]), 2), D2 = t2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [F2, L2]);
  function M2(t3, a3) {
    return { interpolation: { pattern: n2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [t3]), lookbehind: true, inside: { "format-string": { pattern: n2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [a3, L2]), lookbehind: true, inside: { punctuation: /^:/ } }, punctuation: /^\{|\}$/, expression: { pattern: /[\s\S]+/, alias: "language-csharp", inside: e3.languages.csharp } } }, string: /[\s\S]+/ };
  }
  e3.languages.insertBefore("csharp", "string", { "interpolation-string": [{ pattern: n2(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [C2]), lookbehind: true, greedy: true, inside: M2(C2, P2) }, { pattern: n2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [D2]), lookbehind: true, greedy: true, inside: M2(D2, F2) }] });
}(Prism), Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp, Prism.languages["visual-basic"] = { comment: { pattern: /(?:[']|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i, inside: { keyword: /^REM/i } }, directive: { pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:[^\S\r\n]_[^\S\r\n]*(?:\r\n?|\n)|.)+/i, alias: "comment", greedy: true }, string: { pattern: /\$?["](?:["]{2}|[^"])*["]C?/i, greedy: true }, date: { pattern: /#[^\S\r\n]*(?:\d+([/-])\d+\1\d+(?:[^\S\r\n]+(?:\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?))?|\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?)[^\S\r\n]*#/i, alias: "builtin" }, number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:U?[ILS]|[FRD])?/i, boolean: /\b(?:True|False|Nothing)\b/i, keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Until|Xor)\b/i, operator: [/[+\-*/\\^<=>&#@$%!]/, { pattern: /([^\S\r\n])_(?=[^\S\r\n]*[\r\n])/, lookbehind: true }], punctuation: /[{}().,:?]/ }, Prism.languages.vb = Prism.languages["visual-basic"], Prism.languages.vba = Prism.languages["visual-basic"], Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:TRUE|FALSE|NULL)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(e3) {
  e3.languages.ruby = e3.languages.extend("clike", { comment: [/#.*/, { pattern: /^=begin\s[\s\S]*?^=end/m, greedy: true }], "class-name": { pattern: /(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/ });
  var t2 = { pattern: /#\{[^}]+\}/, inside: { delimiter: { pattern: /^#\{|\}$/, alias: "tag" }, rest: e3.languages.ruby } };
  delete e3.languages.ruby.function, e3.languages.insertBefore("ruby", "keyword", { regex: [{ pattern: RegExp(/%r/.source + "(?:" + [/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S])*\)/.source, /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source, /<(?:[^<>\\]|\\[\s\S])*>/.source].join("|") + ")" + /[egimnosux]{0,6}/.source), greedy: true, inside: { interpolation: t2 } }, { pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/, lookbehind: true, greedy: true, inside: { interpolation: t2 } }], variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/, symbol: { pattern: /(^|[^:]):[a-zA-Z_]\w*(?:[?!]|\b)/, lookbehind: true }, "method-definition": { pattern: /(\bdef\s+)[\w.]+/, lookbehind: true, inside: { function: /\w+$/, rest: e3.languages.ruby } } }), e3.languages.insertBefore("ruby", "number", { builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/, constant: /\b[A-Z]\w*(?:[?!]|\b)/ }), e3.languages.ruby.string = [{ pattern: RegExp(/%[qQiIwWxs]?/.source + "(?:" + [/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source, /\((?:[^()\\]|\\[\s\S])*\)/.source, /\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source, /\[(?:[^\[\]\\]|\\[\s\S])*\]/.source, /<(?:[^<>\\]|\\[\s\S])*>/.source].join("|") + ")"), greedy: true, inside: { interpolation: t2 } }, { pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/, greedy: true, inside: { interpolation: t2 } }, { pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i, alias: "heredoc-string", greedy: true, inside: { delimiter: { pattern: /^<<[-~]?[a-z_]\w*|[a-z_]\w*$/i, alias: "symbol", inside: { punctuation: /^<<[-~]?/ } }, interpolation: t2 } }, { pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i, alias: "heredoc-string", greedy: true, inside: { delimiter: { pattern: /^<<[-~]?'[a-z_]\w*'|[a-z_]\w*$/i, alias: "symbol", inside: { punctuation: /^<<[-~]?'|'$/ } } } }], e3.languages.rb = e3.languages.ruby;
}(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:true|false)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:true|false)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e3) {
  e3.inside.interpolation.inside = Prism.languages.swift;
}), function(e3) {
  var t2 = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", n2 = { pattern: /(^(["']?)\w+\2)[ \t]+\S.*/, lookbehind: true, alias: "punctuation", inside: null }, a2 = { bash: n2, environment: { pattern: RegExp("\\$" + t2), alias: "constant" }, variable: [{ pattern: /\$?\(\([\s\S]+?\)\)/, greedy: true, inside: { variable: [{ pattern: /(^\$\(\([\s\S]+)\)\)/, lookbehind: true }, /^\$\(\(/], number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/, operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/, punctuation: /\(\(?|\)\)?|,|;/ } }, { pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/, greedy: true, inside: { variable: /^\$\(|^`|\)$|`$/ } }, { pattern: /\$\{[^}]+\}/, greedy: true, inside: { operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/, punctuation: /[\[\]]/, environment: { pattern: RegExp("(\\{)" + t2), lookbehind: true, alias: "constant" } } }, /\$(?:\w+|[#?*!@$])/], entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/ };
  e3.languages.bash = { shebang: { pattern: /^#!\s*\/.*/, alias: "important" }, comment: { pattern: /(^|[^"{\\$])#.*/, lookbehind: true }, "function-name": [{ pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/, lookbehind: true, alias: "function" }, { pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/, alias: "function" }], "for-or-select": { pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/, alias: "variable", lookbehind: true }, "assign-left": { pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/, inside: { environment: { pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + t2), lookbehind: true, alias: "constant" } }, alias: "variable", lookbehind: true }, string: [{ pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/, lookbehind: true, greedy: true, inside: a2 }, { pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/, lookbehind: true, greedy: true, inside: { bash: n2 } }, { pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/, lookbehind: true, greedy: true, inside: a2 }, { pattern: /(^|[^$\\])'[^']*'/, lookbehind: true, greedy: true }, { pattern: /\$'(?:[^'\\]|\\[\s\S])*'/, greedy: true, inside: { entity: a2.entity } }], environment: { pattern: RegExp("\\$?" + t2), alias: "constant" }, variable: a2.variable, function: { pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/, lookbehind: true }, keyword: { pattern: /(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/, lookbehind: true }, builtin: { pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/, lookbehind: true, alias: "class-name" }, boolean: { pattern: /(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/, lookbehind: true }, "file-descriptor": { pattern: /\B&\d\b/, alias: "important" }, operator: { pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/, inside: { "file-descriptor": { pattern: /^\d/, alias: "important" } } }, punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/, number: { pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/, lookbehind: true } }, n2.inside = e3.languages.bash;
  for (var r2 = ["comment", "function-name", "for-or-select", "assign-left", "string", "environment", "function", "keyword", "builtin", "boolean", "file-descriptor", "operator", "punctuation", "number"], i2 = a2.variable[1].inside, s2 = 0; s2 < r2.length; s2++)
    i2[r2[s2]] = e3.languages.bash[r2[s2]];
  e3.languages.shell = e3.languages.bash;
}(Prism), function(e3) {
  var t2 = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n2(e4) {
    return e4 = e4.replace(/<inner>/g, function() {
      return t2;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e4 + ")");
  }
  var a2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, r2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return a2;
  }), i2 = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  e3.languages.markdown = e3.languages.extend("markup", {}), e3.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "font-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: e3.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + r2 + i2 + "(?:" + r2 + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + r2 + i2 + ")(?:" + r2 + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(a2), inside: e3.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + r2 + ")" + i2 + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + r2 + "$"), inside: { "table-header": { pattern: RegExp(a2), alias: "important", inside: e3.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: n2(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: n2(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: n2(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: n2(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(t3) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(n3) {
      t3 !== n3 && (e3.languages.markdown[t3].inside.content.inside[n3] = e3.languages.markdown[n3]);
    });
  }), e3.hooks.add("after-tokenize", function(e4) {
    "markdown" !== e4.language && "md" !== e4.language || function e5(t3) {
      if (t3 && "string" != typeof t3)
        for (var n3 = 0, a3 = t3.length; n3 < a3; n3++) {
          var r3 = t3[n3];
          if ("code" === r3.type) {
            var i3 = r3.content[1], s3 = r3.content[3];
            if (i3 && s3 && "code-language" === i3.type && "code-block" === s3.type && "string" == typeof i3.content) {
              var o3 = i3.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), l3 = "language-" + (o3 = (/[a-z][\w-]*/i.exec(o3) || [""])[0].toLowerCase());
              s3.alias ? "string" == typeof s3.alias ? s3.alias = [s3.alias, l3] : s3.alias.push(l3) : s3.alias = [l3];
            }
          } else
            e5(r3.content);
        }
    }(e4.tokens);
  }), e3.hooks.add("wrap", function(t3) {
    if ("code-block" === t3.type) {
      for (var n3 = "", a3 = 0, r3 = t3.classes.length; a3 < r3; a3++) {
        var i3 = t3.classes[a3], u2 = /language-(.+)/.exec(i3);
        if (u2) {
          n3 = u2[1];
          break;
        }
      }
      var c2 = e3.languages[n3];
      if (c2)
        t3.content = e3.highlight(function(e4) {
          var t4 = e4.replace(s2, "");
          return t4 = t4.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e5, t5) {
            var n4;
            if ("#" === (t5 = t5.toLowerCase())[0])
              return n4 = "x" === t5[1] ? parseInt(t5.slice(2), 16) : Number(t5.slice(1)), l2(n4);
            var a4 = o2[t5];
            return a4 || e5;
          });
        }(t3.content), c2, n3);
      else if (n3 && "none" !== n3 && e3.plugins.autoloader) {
        var d3 = "md-" + new Date().valueOf() + "-" + Math.floor(1e16 * Math.random());
        t3.attributes.id = d3, e3.plugins.autoloader.loadLanguages(n3, function() {
          var t4 = document.getElementById(d3);
          t4 && (t4.innerHTML = e3.highlight(t4.textContent, e3.languages[n3], n3));
        });
      }
    }
  });
  var s2 = RegExp(e3.languages.markup.tag.pattern.source, "gi"), o2 = { amp: "&", lt: "<", gt: ">", quot: '"' }, l2 = String.fromCodePoint || String.fromCharCode;
  e3.languages.md = e3.languages.markdown;
}(Prism);
var Sn = ["comment", "prolog", "doctype", "cdata", "punctuation", "namespace", "property", "tag", "boolean", "number", "constant", "symbol", "deleted", "selector", "attr-name", "string", "builtin", "inserted", "operator", "entity", "url", "string", "atrule", "attr-value", "keyword", "function", "class-name", "regex", "important", "variable", "bold", "italic", "entity", "char"];
function vn(e3) {
  return "string" == typeof e3 ? e3.length : "string" == typeof e3.content ? e3.content.length : e3.content.reduce(function(e4, t2) {
    return e4 + vn(t2);
  }, 0);
}
var wn, kn = g.String, An = function(e3) {
  if ("Symbol" === nt(e3))
    throw TypeError("Cannot convert a Symbol value to a string");
  return kn(e3);
}, xn = function() {
  var e3 = se(this), t2 = "";
  return e3.global && (t2 += "g"), e3.ignoreCase && (t2 += "i"), e3.multiline && (t2 += "m"), e3.dotAll && (t2 += "s"), e3.unicode && (t2 += "u"), e3.sticky && (t2 += "y"), t2;
}, Tn = g.RegExp, _n = z(function() {
  var e3 = Tn("a", "y");
  return e3.lastIndex = 2, null != e3.exec("abcd");
}), On = _n || z(function() {
  return !Tn("a", "y").sticky;
}), In = { BROKEN_CARET: _n || z(function() {
  var e3 = Tn("^r", "gy");
  return e3.lastIndex = 2, null != e3.exec("str");
}), MISSED_STICKY: On, UNSUPPORTED_Y: _n }, Rn = J ? Object.defineProperties : function(e3, t2) {
  se(e3);
  for (var n2, a2 = jt(t2), r2 = fn(t2), i2 = r2.length, s2 = 0; i2 > s2; )
    Ae.f(e3, n2 = r2[s2++], a2[n2]);
  return e3;
}, Nn = F("document", "documentElement"), Ln = Fe("IE_PROTO"), Pn = function() {
}, Cn = function(e3) {
  return "<script>" + e3 + "<\/script>";
}, Fn = function(e3) {
  e3.write(Cn("")), e3.close();
  var t2 = e3.parentWindow.Object;
  return e3 = null, t2;
}, Dn = function() {
  try {
    wn = new ActiveXObject("htmlfile");
  } catch (e4) {
  }
  var e3, t2;
  Dn = "undefined" != typeof document ? document.domain && wn ? Fn(wn) : ((t2 = ne("iframe")).style.display = "none", Nn.appendChild(t2), t2.src = String("javascript:"), (e3 = t2.contentWindow.document).open(), e3.write(Cn("document.F=Object")), e3.close(), e3.F) : Fn(wn);
  for (var n2 = Kt.length; n2--; )
    delete Dn.prototype[Kt[n2]];
  return Dn();
};
De[Ln] = true;
var Mn, $n, Bn = Object.create || function(e3, t2) {
  var n2;
  return null !== e3 ? (Pn.prototype = se(e3), n2 = new Pn(), Pn.prototype = null, n2[Ln] = e3) : n2 = Dn(), void 0 === t2 ? n2 : Rn(n2, t2);
}, Un = g.RegExp, jn = z(function() {
  var e3 = Un(".", "s");
  return !(e3.dotAll && e3.exec("\n") && "s" === e3.flags);
}), zn = g.RegExp, Gn = z(function() {
  var e3 = zn("(?<a>b)", "g");
  return "b" !== e3.exec("b").groups.a || "bc" !== "b".replace(e3, "$<a>c");
}), Hn = He.get, qn = m("native-string-replace", String.prototype.replace), Yn = RegExp.prototype.exec, Xn = Yn, Wn = w("".charAt), Zn = w("".indexOf), Vn = w("".replace), Kn = w("".slice), Jn = ($n = /b*/g, le(Yn, Mn = /a/, "a"), le(Yn, $n, "a"), 0 !== Mn.lastIndex || 0 !== $n.lastIndex), Qn = In.BROKEN_CARET, ea = void 0 !== /()??/.exec("")[1];
(Jn || ea || Qn || jn || Gn) && (Xn = function(e3) {
  var t2, n2, a2, r2, i2, s2, o2, l2 = this, u2 = Hn(l2), c2 = An(e3), d3 = u2.raw;
  if (d3)
    return d3.lastIndex = l2.lastIndex, t2 = le(Xn, d3, c2), l2.lastIndex = d3.lastIndex, t2;
  var p2 = u2.groups, g2 = Qn && l2.sticky, f2 = le(xn, l2), b2 = l2.source, h2 = 0, m2 = c2;
  if (g2 && (f2 = Vn(f2, "y", ""), -1 === Zn(f2, "g") && (f2 += "g"), m2 = Kn(c2, l2.lastIndex), l2.lastIndex > 0 && (!l2.multiline || l2.multiline && "\n" !== Wn(c2, l2.lastIndex - 1)) && (b2 = "(?: " + b2 + ")", m2 = " " + m2, h2++), n2 = new RegExp("^(?:" + b2 + ")", f2)), ea && (n2 = new RegExp("^" + b2 + "$(?!\\s)", f2)), Jn && (a2 = l2.lastIndex), r2 = le(Yn, g2 ? n2 : l2, m2), g2 ? r2 ? (r2.input = Kn(r2.input, h2), r2[0] = Kn(r2[0], h2), r2.index = l2.lastIndex, l2.lastIndex += r2[0].length) : l2.lastIndex = 0 : Jn && r2 && (l2.lastIndex = l2.global ? r2.index + r2[0].length : a2), ea && r2 && r2.length > 1 && le(qn, r2[0], n2, function() {
    for (i2 = 1; i2 < arguments.length - 2; i2++)
      void 0 === arguments[i2] && (r2[i2] = void 0);
  }), r2 && p2)
    for (r2.groups = s2 = Bn(null), i2 = 0; i2 < p2.length; i2++)
      s2[(o2 = p2[i2])[0]] = r2[o2[1]];
  return r2;
});
var ta = Xn;
gn({ target: "RegExp", proto: true, forced: /./.exec !== ta }, { exec: ta });
var na = Function.prototype, aa = na.apply, ra = na.bind, ia = na.call, sa = "object" == typeof Reflect && Reflect.apply || (ra ? ia.bind(aa) : function() {
  return ia.apply(aa, arguments);
}), oa = Z("species"), la = RegExp.prototype, ua = Z("match"), ca = g.TypeError, da = Z("species"), pa = function(e3, t2) {
  var n2, a2 = se(e3).constructor;
  return void 0 === a2 || null == (n2 = se(a2)[da]) ? t2 : function(e4) {
    if (Ot(e4))
      return e4;
    throw ca(ge(e4) + " is not a constructor");
  }(n2);
}, ga = w("".charAt), fa = w("".charCodeAt), ba = w("".slice), ha = function(e3) {
  return function(t2, n2) {
    var a2, r2, i2 = An(A(t2)), s2 = ht(n2), o2 = i2.length;
    return s2 < 0 || s2 >= o2 ? e3 ? "" : void 0 : (a2 = fa(i2, s2)) < 55296 || a2 > 56319 || s2 + 1 === o2 || (r2 = fa(i2, s2 + 1)) < 56320 || r2 > 57343 ? e3 ? ga(i2, s2) : a2 : e3 ? ba(i2, s2, s2 + 2) : r2 - 56320 + (a2 - 55296 << 10) + 65536;
  };
}, ma = { codeAt: ha(false), charAt: ha(true) }.charAt, ya = function(e3, t2, n2) {
  return t2 + (n2 ? ma(e3, t2).length : 1);
}, Ea = g.Array, Sa = Math.max, va = function(e3, t2, n2) {
  for (var a2, r2, i2, s2, o2 = Et(e3), l2 = Yt(t2, o2), u2 = Yt(void 0 === n2 ? o2 : n2, o2), c2 = Ea(Sa(u2 - l2, 0)), d3 = 0; l2 < u2; l2++, d3++)
    a2 = c2, r2 = d3, i2 = e3[l2], s2 = void 0, (s2 = ve(r2)) in a2 ? Ae.f(a2, s2, xe(0, i2)) : a2[s2] = i2;
  return c2.length = d3, c2;
}, wa = g.TypeError, ka = function(e3, t2) {
  var n2 = e3.exec;
  if (P(n2)) {
    var a2 = le(n2, e3, t2);
    return null !== a2 && se(a2), a2;
  }
  if ("RegExp" === Je(e3))
    return le(ta, e3, t2);
  throw wa("RegExp#exec called on incompatible receiver");
}, Aa = In.UNSUPPORTED_Y, xa = Math.min, Ta = [].push, _a = w(/./.exec), Oa = w(Ta), Ia = w("".slice);
!function(e3, t2, n2, a2) {
  var r2 = Z(e3), i2 = !z(function() {
    var t3 = {};
    return t3[r2] = function() {
      return 7;
    }, 7 != ""[e3](t3);
  }), s2 = i2 && !z(function() {
    var t3 = false, n3 = /a/;
    return "split" === e3 && ((n3 = {}).constructor = {}, n3.constructor[oa] = function() {
      return n3;
    }, n3.flags = "", n3[r2] = /./[r2]), n3.exec = function() {
      return t3 = true, null;
    }, n3[r2](""), !t3;
  });
  if (!i2 || !s2 || n2) {
    var o2 = w(/./[r2]), l2 = t2(r2, ""[e3], function(e4, t3, n3, a3, r3) {
      var s3 = w(e4), l3 = t3.exec;
      return l3 === ta || l3 === la.exec ? i2 && !r3 ? { done: true, value: o2(t3, n3, a3) } : { done: true, value: s3(n3, t3, a3) } : { done: false };
    });
    Ze(String.prototype, e3, l2[0]), Ze(la, r2, l2[1]);
  }
  a2 && Te(la[r2], "sham", true);
}("split", function(e3, t2, n2) {
  var a2;
  return a2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e4, n3) {
    var a3, r2, i2 = An(A(this)), s2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === s2)
      return [];
    if (void 0 === e4)
      return [i2];
    if (!Q(a3 = e4) || !(void 0 !== (r2 = a3[ua]) ? r2 : "RegExp" == Je(a3)))
      return le(t2, i2, e4, s2);
    for (var o2, l2, u2, c2 = [], d3 = (e4.ignoreCase ? "i" : "") + (e4.multiline ? "m" : "") + (e4.unicode ? "u" : "") + (e4.sticky ? "y" : ""), p2 = 0, g2 = new RegExp(e4.source, d3 + "g"); (o2 = le(ta, g2, i2)) && !((l2 = g2.lastIndex) > p2 && (Oa(c2, Ia(i2, p2, o2.index)), o2.length > 1 && o2.index < i2.length && sa(Ta, c2, va(o2, 1)), u2 = o2[0].length, p2 = l2, c2.length >= s2)); )
      g2.lastIndex === o2.index && g2.lastIndex++;
    return p2 === i2.length ? !u2 && _a(g2, "") || Oa(c2, "") : Oa(c2, Ia(i2, p2)), c2.length > s2 ? va(c2, 0, s2) : c2;
  } : "0".split(void 0, 0).length ? function(e4, n3) {
    return void 0 === e4 && 0 === n3 ? [] : le(t2, this, e4, n3);
  } : t2, [function(t3, n3) {
    var r2 = A(this), i2 = null == t3 ? void 0 : he(t3, e3);
    return i2 ? le(i2, t3, r2, n3) : le(a2, An(r2), t3, n3);
  }, function(e4, r2) {
    var i2 = se(this), s2 = An(e4), o2 = n2(a2, i2, s2, r2, a2 !== t2);
    if (o2.done)
      return o2.value;
    var l2 = pa(i2, RegExp), u2 = i2.unicode, c2 = (i2.ignoreCase ? "i" : "") + (i2.multiline ? "m" : "") + (i2.unicode ? "u" : "") + (Aa ? "g" : "y"), d3 = new l2(Aa ? "^(?:" + i2.source + ")" : i2, c2), p2 = void 0 === r2 ? 4294967295 : r2 >>> 0;
    if (0 === p2)
      return [];
    if (0 === s2.length)
      return null === ka(d3, s2) ? [s2] : [];
    for (var g2 = 0, f2 = 0, b2 = []; f2 < s2.length; ) {
      d3.lastIndex = Aa ? 0 : f2;
      var h2, m2 = ka(d3, Aa ? Ia(s2, f2) : s2);
      if (null === m2 || (h2 = xa(yt(d3.lastIndex + (Aa ? f2 : 0)), s2.length)) === g2)
        f2 = ya(s2, f2, u2);
      else {
        if (Oa(b2, Ia(s2, g2, f2)), b2.length === p2)
          return b2;
        for (var y2 = 1; y2 <= m2.length - 1; y2++)
          if (Oa(b2, m2[y2]), b2.length === p2)
            return b2;
        f2 = g2 = h2;
      }
    }
    return Oa(b2, Ia(s2, g2)), b2;
  }];
}, !!z(function() {
  var e3 = /(?:)/, t2 = e3.exec;
  e3.exec = function() {
    return t2.apply(this, arguments);
  };
  var n2 = "ab".split(e3);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), Aa), gn({ global: true }, { globalThis: g }), attr && ($$6.fn.attr = attr);
var Ra = We.PROPER, Na = RegExp.prototype, La = Na.toString, Pa = w(xn), Ca = z(function() {
  return "/a/b" != La.call({ source: "a", flags: "b" });
}), Fa = Ra && "toString" != La.name;
(Ca || Fa) && Ze(RegExp.prototype, "toString", function() {
  var e3 = se(this), t2 = An(e3.source), n2 = e3.flags;
  return "/" + t2 + "/" + An(void 0 === n2 && ue(Na, e3) && !("flags" in Na) ? Pa(e3) : n2);
}, { unsafe: true });
var Da = function() {
  function e3() {
    this.title = lp$1("highLightModule.selectLang"), this.iconSvg = '<svg viewBox="0 0 1024 1024"><path d="M64 64v896h896V64H64z m487.6 698.8c0 87.2-51.2 127-125.8 127-67.4 0-106.4-34.8-126.4-77l68.6-41.4c13.2 23.4 25.2 43.2 54.2 43.2 27.6 0 45.2-10.8 45.2-53V475.4h84.2v287.4z m199.2 127c-78.2 0-128.8-37.2-153.4-86l68.6-39.6c18 29.4 41.6 51.2 83 51.2 34.8 0 57.2-17.4 57.2-41.6 0-28.8-22.8-39-61.4-56l-21-9c-60.8-25.8-101-58.4-101-127 0-63.2 48.2-111.2 123.2-111.2 53.6 0 92 18.6 119.6 67.4L800 580c-14.4-25.8-30-36-54.2-36-24.6 0-40.2 15.6-40.2 36 0 25.2 15.6 35.4 51.8 51.2l21 9c71.6 30.6 111.8 62 111.8 132.4 0 75.6-59.6 117.2-139.4 117.2z"></path></svg>', this.tag = "select", this.width = 95, this.selectPanelWidth = 115;
  }
  return e3.prototype.getOptions = function(e4) {
    var t2 = [], n2 = e4.getMenuConfig("codeSelectLang").codeLangs, a2 = void 0 === n2 ? [] : n2;
    t2.push({ text: "plain text", value: "" }), a2.forEach(function(e5) {
      var n3 = e5.text, a3 = e5.value;
      t2.push({ text: n3, value: a3 });
    });
    var r2 = this.getValue(e4);
    return t2.forEach(function(e5) {
      e5.value === r2 ? e5.selected = true : delete e5.selected;
    }), t2;
  }, e3.prototype.isActive = function(e4) {
    return false;
  }, e3.prototype.getValue = function(e4) {
    var t2 = this.getSelectCodeElem(e4);
    if (null == t2)
      return "";
    if (!Element$1.isElement(t2))
      return "";
    var n2 = t2.language.toString(), a2 = e4.getMenuConfig("codeSelectLang").codeLangs;
    return (void 0 === a2 ? [] : a2).some(function(e5) {
      return e5.value === n2;
    }) ? n2 : "";
  }, e3.prototype.isDisabled = function(e4) {
    return null == e4.selection || !this.getSelectCodeElem(e4);
  }, e3.prototype.exec = function(e4, n2) {
    if (null != this.getSelectCodeElem(e4)) {
      var a2 = { language: n2.toString() };
      Transforms.setNodes(e4, a2, { match: function(e5) {
        return rl$1.checkNodeType(e5, "code");
      } });
    }
  }, e3.prototype.getSelectCodeElem = function(e4) {
    var n2 = rl$1.getSelectedNodeByType(e4, "code");
    if (null == n2)
      return null;
    var a2 = rl$1.getParentNode(e4, n2);
    return Element$1.isElement(a2) ? "pre" !== a2.type ? null : n2 : null;
  }, e3;
}();
var Ma = { renderStyle: function(e3, t2) {
  var n2 = e3, a2 = t2, r2 = "";
  return Sn.forEach(function(e4) {
    n2[e4] && (r2 = e4);
  }), r2 && function(e4, t3) {
    null == e4.data && (e4.data = {});
    var n3 = e4.data;
    null == n3.props && (n3.props = {}), Object.assign(n3.props, { className: t3 });
  }(a2, r2 = "token " + r2), a2;
}, parseStyleHtml: function(e3, n2, r2) {
  var s2 = $$6(e3);
  if (!Element$1.isElement(n2))
    return n2;
  if ("code" !== rl$1.getNodeType(n2))
    return n2;
  var o2 = n2, l2 = s2.attr("class") || "";
  return 0 === l2.indexOf("language-") ? o2.language = l2.split("-")[1] || "" : o2.language = l2.toLowerCase(), o2;
}, menus: [{ key: "codeSelectLang", factory: function() {
  return new Da();
}, config: { codeLangs: [{ text: "CSS", value: "css" }, { text: "HTML", value: "html" }, { text: "XML", value: "xml" }, { text: "Javascript", value: "javascript" }, { text: "Typescript", value: "typescript" }, { text: "JSX", value: "jsx" }, { text: "Go", value: "go" }, { text: "PHP", value: "php" }, { text: "C", value: "c" }, { text: "Python", value: "python" }, { text: "Java", value: "java" }, { text: "C++", value: "cpp" }, { text: "C#", value: "csharp" }, { text: "Visual Basic", value: "visual-basic" }, { text: "SQL", value: "sql" }, { text: "Ruby", value: "ruby" }, { text: "Swift", value: "swift" }, { text: "Bash", value: "bash" }, { text: "Markdown", value: "markdown" }] } }], elemsToHtml: [{ type: "code", elemToHtml: function(e3, t2) {
  var n2 = e3.language, a2 = void 0 === n2 ? "" : n2;
  return "<code " + (a2 ? 'class="language-' + a2 + '"' : "") + ">" + t2 + "</code>";
} }] }, $a = /"/g, Ba = w("".replace);
gn({ target: "String", proto: true, forced: function(e3) {
  return z(function() {
    var t2 = ""[e3]('"');
    return t2 !== t2.toLowerCase() || t2.split('"').length > 3;
  });
}("anchor") }, { anchor: function(e3) {
  return t2 = "a", n2 = "name", a2 = e3, r2 = An(A(this)), i2 = "<" + t2, "" !== n2 && (i2 += " " + n2 + '="' + Ba(An(a2), $a, "&quot;") + '"'), i2 + ">" + r2 + "</" + t2 + ">";
  var t2, n2, a2, r2, i2;
} });
var Ua = function(e3) {
  var n2, a2, r2, i2 = function(e4, t2) {
    var n3 = "function" == typeof Symbol && e4[Symbol.iterator];
    if (!n3)
      return e4;
    var a3, r3, i3 = n3.call(e4), s3 = [];
    try {
      for (; (void 0 === t2 || t2-- > 0) && !(a3 = i3.next()).done; )
        s3.push(a3.value);
    } catch (e5) {
      r3 = { error: e5 };
    } finally {
      try {
        a3 && !a3.done && (n3 = i3.return) && n3.call(i3);
      } finally {
        if (r3)
          throw r3.error;
      }
    }
    return s3;
  }(e3, 2), s2 = i2[0], l2 = i2[1], u2 = [], c2 = function(e4) {
    if (!Text.isText(e4))
      return null;
    var n3 = rl$1.getParentNode(null, e4);
    if (n3 && "code" === rl$1.getNodeType(n3)) {
      var a3 = rl$1.getParentNode(null, n3);
      if (a3 && "pre" === rl$1.getNodeType(a3))
        return n3;
    }
    return null;
  }(s2);
  if (null == c2)
    return u2;
  var d3 = c2.language, p2 = void 0 === d3 ? "" : d3;
  if (!p2)
    return u2;
  var g2 = function(e4, t2) {
    if (!t2)
      return [];
    var n3 = En.languages[t2];
    return n3 ? En.tokenize(e4.text, n3) : [];
  }(s2, p2), f2 = 0;
  try {
    for (var b2 = function(e4) {
      var t2 = "function" == typeof Symbol && Symbol.iterator, n3 = t2 && e4[t2], a3 = 0;
      if (n3)
        return n3.call(e4);
      if (e4 && "number" == typeof e4.length)
        return { next: function() {
          return e4 && a3 >= e4.length && (e4 = void 0), { value: e4 && e4[a3++], done: !e4 };
        } };
      throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }(g2), h2 = b2.next(); !h2.done; h2 = b2.next()) {
      var m2 = h2.value, y2 = f2 + vn(m2);
      "string" != typeof m2 && u2.push(((r2 = {})[m2.type] = true, r2.anchor = { path: l2, offset: f2 }, r2.focus = { path: l2, offset: y2 }, r2)), f2 = y2;
    }
  } catch (e4) {
    n2 = { error: e4 };
  } finally {
    try {
      h2 && !h2.done && (a2 = b2.return) && a2.call(b2);
    } finally {
      if (n2)
        throw n2.error;
    }
  }
  return u2;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var Boot = function() {
  function Boot2() {
    throw new Error("\u4E0D\u80FD\u5B9E\u4F8B\u5316\nCan not construct a instance");
  }
  Boot2.setEditorConfig = function(newConfig) {
    if (newConfig === void 0) {
      newConfig = {};
    }
    this.editorConfig = __assign(__assign({}, this.editorConfig), newConfig);
  };
  Boot2.setSimpleEditorConfig = function(newConfig) {
    if (newConfig === void 0) {
      newConfig = {};
    }
    this.simpleEditorConfig = __assign(__assign({}, this.simpleEditorConfig), newConfig);
  };
  Boot2.setToolbarConfig = function(newConfig) {
    if (newConfig === void 0) {
      newConfig = {};
    }
    this.toolbarConfig = __assign(__assign({}, this.toolbarConfig), newConfig);
  };
  Boot2.setSimpleToolbarConfig = function(newConfig) {
    if (newConfig === void 0) {
      newConfig = {};
    }
    this.simpleToolbarConfig = __assign(__assign({}, this.simpleToolbarConfig), newConfig);
  };
  Boot2.registerPlugin = function(plugin) {
    this.plugins.push(plugin);
  };
  Boot2.registerMenu = function(menuConf, customConfig) {
    sl$1(menuConf, customConfig);
  };
  Boot2.registerRenderElem = function(renderElemConf) {
    td$1(renderElemConf);
  };
  Boot2.registerRenderStyle = function(fn2) {
    Zf$1(fn2);
  };
  Boot2.registerElemToHtml = function(elemToHtmlConf) {
    Ll$1(elemToHtmlConf);
  };
  Boot2.registerStyleToHtml = function(fn2) {
    Nl$1(fn2);
  };
  Boot2.registerPreParseHtml = function(preParseHtmlConf) {
    yc$1(preParseHtmlConf);
  };
  Boot2.registerParseElemHtml = function(parseElemHtmlConf) {
    xc$1(parseElemHtmlConf);
  };
  Boot2.registerParseStyleHtml = function(fn2) {
    bc$1(fn2);
  };
  Boot2.registerModule = function(module) {
    registerModule(module);
  };
  Boot2.editorConfig = {};
  Boot2.simpleEditorConfig = {};
  Boot2.toolbarConfig = {};
  Boot2.simpleToolbarConfig = {};
  Boot2.plugins = [];
  return Boot2;
}();
function registerModule(module) {
  var menus2 = module.menus, renderElems = module.renderElems, renderStyle = module.renderStyle, elemsToHtml = module.elemsToHtml, styleToHtml = module.styleToHtml, preParseHtml = module.preParseHtml, parseElemsHtml = module.parseElemsHtml, parseStyleHtml = module.parseStyleHtml, editorPlugin = module.editorPlugin;
  if (menus2) {
    menus2.forEach(function(menu) {
      return Boot.registerMenu(menu);
    });
  }
  if (renderElems) {
    renderElems.forEach(function(renderElemConf) {
      return Boot.registerRenderElem(renderElemConf);
    });
  }
  if (renderStyle) {
    Boot.registerRenderStyle(renderStyle);
  }
  if (elemsToHtml) {
    elemsToHtml.forEach(function(elemToHtmlConf) {
      return Boot.registerElemToHtml(elemToHtmlConf);
    });
  }
  if (styleToHtml) {
    Boot.registerStyleToHtml(styleToHtml);
  }
  if (preParseHtml) {
    preParseHtml.forEach(function(conf) {
      return Boot.registerPreParseHtml(conf);
    });
  }
  if (parseElemsHtml) {
    parseElemsHtml.forEach(function(parseElemHtmlConf) {
      return Boot.registerParseElemHtml(parseElemHtmlConf);
    });
  }
  if (parseStyleHtml) {
    Boot.registerParseStyleHtml(parseStyleHtml);
  }
  if (editorPlugin) {
    Boot.registerPlugin(editorPlugin);
  }
}
Gd.forEach(function(module) {
  return registerModule(module);
});
registerModule(no$3);
registerModule(yi$2);
registerModule(Qa);
registerModule(da$1);
registerModule(Ma);
var INDENT_RIGHT_SVG = '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>';
var JUSTIFY_LEFT_SVG = '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>';
var IMAGE_SVG = '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>';
var MORE_SVG = '<svg viewBox="0 0 1024 1024"><path d="M204.8 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M505.6 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M806.4 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path></svg>';
var VIDEO_SVG = '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>';
function genDefaultToolbarKeys() {
  return [
    "headerSelect",
    "blockquote",
    "|",
    "bold",
    "underline",
    "italic",
    {
      key: "group-more-style",
      title: lp$1("editor.more"),
      iconSvg: MORE_SVG,
      menuKeys: ["through", "code", "sup", "sub", "clearStyle"]
    },
    "color",
    "bgColor",
    "|",
    "fontSize",
    "fontFamily",
    "lineHeight",
    "|",
    "bulletedList",
    "numberedList",
    "todo",
    {
      key: "group-justify",
      title: lp$1("editor.justify"),
      iconSvg: JUSTIFY_LEFT_SVG,
      menuKeys: ["justifyLeft", "justifyRight", "justifyCenter", "justifyJustify"]
    },
    {
      key: "group-indent",
      title: lp$1("editor.indent"),
      iconSvg: INDENT_RIGHT_SVG,
      menuKeys: ["indent", "delIndent"]
    },
    "|",
    "emotion",
    "insertLink",
    {
      key: "group-image",
      title: lp$1("editor.image"),
      iconSvg: IMAGE_SVG,
      menuKeys: ["insertImage", "uploadImage"]
    },
    {
      key: "group-video",
      title: lp$1("editor.video"),
      iconSvg: VIDEO_SVG,
      menuKeys: ["insertVideo", "uploadVideo"]
    },
    "insertTable",
    "codeBlock",
    "divider",
    "|",
    "undo",
    "redo",
    "|",
    "fullScreen"
  ];
}
function genSimpleToolbarKeys() {
  return [
    "blockquote",
    "header1",
    "header2",
    "header3",
    "|",
    "bold",
    "underline",
    "italic",
    "through",
    "color",
    "bgColor",
    "clearStyle",
    "|",
    "bulletedList",
    "numberedList",
    "todo",
    "justifyLeft",
    "justifyRight",
    "justifyCenter",
    "|",
    "insertLink",
    {
      key: "group-image",
      title: lp$1("editor.image"),
      iconSvg: IMAGE_SVG,
      menuKeys: ["insertImage", "uploadImage"]
    },
    "insertVideo",
    "insertTable",
    "codeBlock",
    "|",
    "undo",
    "redo",
    "|",
    "fullScreen"
  ];
}
var COMMON_HOVERBAR_KEYS = {
  link: {
    menuKeys: ["editLink", "unLink", "viewLink"]
  },
  image: {
    menuKeys: [
      "imageWidth30",
      "imageWidth50",
      "imageWidth100",
      "editImage",
      "viewImageLink",
      "deleteImage"
    ]
  },
  pre: {
    menuKeys: ["enter", "codeBlock", "codeSelectLang"]
  },
  table: {
    menuKeys: [
      "enter",
      "tableHeader",
      "tableFullWidth",
      "insertTableRow",
      "deleteTableRow",
      "insertTableCol",
      "deleteTableCol",
      "deleteTable"
    ]
  },
  divider: {
    menuKeys: ["enter"]
  },
  video: {
    menuKeys: ["enter", "editVideoSize"]
  }
};
function genDefaultHoverbarKeys() {
  return __assign(__assign({}, COMMON_HOVERBAR_KEYS), {
    text: {
      menuKeys: [
        "headerSelect",
        "insertLink",
        "bulletedList",
        "|",
        "bold",
        "through",
        "color",
        "bgColor",
        "clearStyle"
      ]
    }
  });
}
function genSimpleHoverbarKeys() {
  return COMMON_HOVERBAR_KEYS;
}
function getDefaultEditorConfig() {
  return {
    hoverbarKeys: genDefaultHoverbarKeys()
  };
}
function getSimpleEditorConfig() {
  return {
    hoverbarKeys: genSimpleHoverbarKeys()
  };
}
function getDefaultToolbarConfig() {
  return {
    toolbarKeys: genDefaultToolbarKeys()
  };
}
function getSimpleToolbarConfig() {
  return {
    toolbarKeys: genSimpleToolbarKeys()
  };
}
var defaultEditorConfig = getDefaultEditorConfig();
Boot.setEditorConfig(__assign(__assign({}, defaultEditorConfig), { decorate: Ua }));
var simpleEditorConfig = getSimpleEditorConfig();
Boot.setSimpleEditorConfig(__assign(__assign({}, simpleEditorConfig), { decorate: Ua }));
var defaultToolbarConfig = getDefaultToolbarConfig();
Boot.setToolbarConfig(defaultToolbarConfig);
var simpleToolbarConfig = getSimpleToolbarConfig();
Boot.setSimpleToolbarConfig(simpleToolbarConfig);
function createEditor(option) {
  if (option === void 0) {
    option = {};
  }
  var _a2 = option.selector, selector = _a2 === void 0 ? "" : _a2, _b2 = option.content, content = _b2 === void 0 ? [] : _b2, html2 = option.html, _c2 = option.config, config2 = _c2 === void 0 ? {} : _c2, _d2 = option.mode, mode = _d2 === void 0 ? "default" : _d2;
  var globalConfig2 = mode === "simple" ? Boot.simpleEditorConfig : Boot.editorConfig;
  var newHoverbarKeys = __assign(__assign({}, globalConfig2.hoverbarKeys || {}), config2.hoverbarKeys || {});
  var editor = eh({
    selector,
    config: __assign(__assign(__assign({}, globalConfig2), config2), { hoverbarKeys: newHoverbarKeys }),
    content,
    html: html2,
    plugins: Boot.plugins
  });
  return editor;
}
function createToolbar(option) {
  var selector = option.selector, editor = option.editor, _a2 = option.config, config2 = _a2 === void 0 ? {} : _a2, _b2 = option.mode, mode = _b2 === void 0 ? "default" : _b2;
  if (!selector) {
    throw new Error("Cannot find 'selector' when create toolbar");
  }
  var globalConfig2 = mode === "simple" ? Boot.simpleToolbarConfig : Boot.toolbarConfig;
  var toolbar = ah(editor, {
    selector,
    config: __assign(__assign({}, globalConfig2), config2)
  });
  return toolbar;
}
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
function genErrorInfo(fnName) {
  let info2 = `\u8BF7\u4F7F\u7528 '@${fnName}' \u4E8B\u4EF6\uFF0C\u4E0D\u8981\u653E\u5728 props \u4E2D`;
  info2 += `
Please use '@${fnName}' event instead of props`;
  return info2;
}
var _export_sfc = (sfc, props) => {
  for (const [key, val2] of props) {
    sfc[key] = val2;
  }
  return sfc;
};
const _sfc_main$1 = defineComponent({
  props: {
    mode: {
      type: String,
      default: "default"
    },
    defaultContent: {
      type: Array,
      default: []
    },
    defaultHtml: {
      type: String,
      default: ""
    },
    defaultConfig: {
      type: Object,
      default: {}
    },
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(props, context) {
    const box2 = ref$1(null);
    const editorRef = shallowRef$1(null);
    const curValue = ref$1("");
    const initEditor = () => {
      if (!box2.value)
        return;
      const defaultContent = toRaw(props.defaultContent);
      createEditor({
        selector: box2.value,
        mode: props.mode,
        content: defaultContent || [],
        html: props.defaultHtml || props.modelValue || "",
        config: __spreadProps(__spreadValues({}, props.defaultConfig), {
          onCreated(editor) {
            editorRef.value = editor;
            context.emit("onCreated", editor);
            if (props.defaultConfig.onCreated) {
              const info2 = genErrorInfo("onCreated");
              throw new Error(info2);
            }
          },
          onChange(editor) {
            const editorHtml = editor.getHtml();
            curValue.value = editorHtml;
            context.emit("update:modelValue", editorHtml);
            context.emit("onChange", editor);
            if (props.defaultConfig.onChange) {
              const info2 = genErrorInfo("onChange");
              throw new Error(info2);
            }
          },
          onDestroyed(editor) {
            context.emit("onDestroyed", editor);
            if (props.defaultConfig.onDestroyed) {
              const info2 = genErrorInfo("onDestroyed");
              throw new Error(info2);
            }
          },
          onMaxLength(editor) {
            context.emit("onMaxLength", editor);
            if (props.defaultConfig.onMaxLength) {
              const info2 = genErrorInfo("onMaxLength");
              throw new Error(info2);
            }
          },
          onFocus(editor) {
            context.emit("onFocus", editor);
            if (props.defaultConfig.onFocus) {
              const info2 = genErrorInfo("onFocus");
              throw new Error(info2);
            }
          },
          onBlur(editor) {
            context.emit("onBlur", editor);
            if (props.defaultConfig.onBlur) {
              const info2 = genErrorInfo("onBlur");
              throw new Error(info2);
            }
          },
          customAlert(info2, type2) {
            context.emit("customAlert", info2, type2);
            if (props.defaultConfig.customAlert) {
              const info22 = genErrorInfo("customAlert");
              throw new Error(info22);
            }
          },
          customPaste: (editor, event) => {
            if (props.defaultConfig.customPaste) {
              const info2 = genErrorInfo("customPaste");
              throw new Error(info2);
            }
            let res;
            context.emit("customPaste", editor, event, (val2) => {
              res = val2;
            });
            return res;
          }
        })
      });
    };
    function setHtml(newHtml) {
      const editor = editorRef.value;
      if (editor == null)
        return;
      editor.setHtml(newHtml);
    }
    onMounted$1(() => {
      initEditor();
    });
    watch$1(() => props.modelValue, (newVal) => {
      if (newVal === curValue.value)
        return;
      setHtml(newVal);
    });
    return {
      box: box2
    };
  }
});
const _hoisted_1$1 = {
  ref: "box",
  style: { "height": "100%" }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, null, 512);
}
var Editor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main$2 = defineComponent({
  props: {
    editor: {
      type: Object
    },
    mode: {
      type: String,
      default: "default"
    },
    defaultConfig: {
      type: Object,
      default: {}
    }
  },
  setup(props) {
    const selector = ref$1(null);
    const create2 = (editor) => {
      if (!selector.value)
        return;
      if (editor == null) {
        throw new Error("Not found instance of Editor when create <Toolbar/> component");
      }
      if (rl$1.getToolbar(editor))
        return;
      createToolbar({
        editor,
        selector: selector.value || "<div></div>",
        mode: props.mode,
        config: props.defaultConfig
      });
    };
    watchEffect(() => {
      const { editor } = props;
      if (editor == null)
        return;
      create2(editor);
    });
    return {
      selector
    };
  }
});
const _hoisted_1$2 = { ref: "selector" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$2, null, 512);
}
var Toolbar = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]);
var FitsEditor_vue_vue_type_style_index_0_scoped_true_lang = "";
var style_css_vue_type_style_index_1_src_lang = "";
const _hoisted_1 = { class: "editor-contain" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "FitsEditor",
  props: {
    modelValue: {
      type: [String],
      default: ""
    },
    excludeKeys: {
      type: Array
    },
    toolbarKeys: {
      type: Array
    },
    isButton: {
      type: Boolean,
      default: false
    },
    isEditer: {
      type: Boolean,
      default: true
    },
    ToolbarClass: {
      type: String
    },
    EditorClass: {
      type: String
    },
    placeholder: {
      type: String
    },
    autoFocus: {
      type: Boolean,
      default: true
    },
    isScroll: {
      type: Boolean,
      default: true
    },
    isPreview: {
      type: Boolean,
      default: true
    },
    isToolbar: {
      type: Boolean,
      default: false
    },
    isInfinite: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "update:modelValue",
    "uploadImg",
    "uploadVideo",
    "onCreated",
    "onChanged",
    "getText",
    "beforeUploadImg",
    "afterUploadImg",
    "beforeEditordestory",
    "afterEditordestory"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const editorRef = shallowRef$1();
    let editer = ref$1(true);
    let dialogVisible = ref$1(false);
    let dialogImageUrl = ref$1([]);
    let whichImg = ref$1(0);
    const state = reactive$1({
      toolbarConfig: {},
      editorConfig: {
        placeholder: props.placeholder ? props.placeholder : "\u8BF7\u8F93\u5165\u5185\u5BB9...",
        scroll: props.isScroll,
        autoFocus: props.autoFocus,
        MENU_CONF: {
          uploadImage: {
            async customUpload(file, insertFn) {
              emit("beforeUploadImg", file);
              emit("uploadImg", file, (data5) => {
                insertFn(data5.url, data5.alt, data5.href);
              });
              emit("afterUploadImg", file);
            }
          },
          uploadVideo: {
            async customUpload(file, insertFn) {
              emit("uploadVideo", file, (data5) => {
                insertFn(data5.url, data5.poster);
              });
            }
          }
        },
        hoverbarKeys: {
          "image": {
            menuKeys: []
          },
          "link": {
            menuKeys: []
          },
          "pre": {
            menuKeys: []
          },
          "table": {
            menuKeys: []
          },
          "divider": {
            menuKeys: []
          },
          "video": {
            menuKeys: []
          },
          "text": {
            menuKeys: []
          }
        }
      },
      defaultHtml: props.modelValue,
      mode: "default",
      editer: true
    });
    const { toolbarConfig, editorConfig, defaultHtml, mode } = toRefs$1(state);
    onMounted$1(() => {
      if (props.toolbarKeys) {
        Object.assign(toolbarConfig.value, { "toolbarKeys": props.toolbarKeys });
      }
      if (props.excludeKeys) {
        Object.assign(toolbarConfig.value, { "excludeKeys": props.excludeKeys });
      } else {
        Object.assign(toolbarConfig.value, { "excludeKeys": ["group-video"] });
      }
    });
    const handleCreated = (editor) => {
      editorRef.value = editor;
      emit("onCreated");
    };
    function handleChange2(editor) {
      emit("update:modelValue", editor.getHtml());
      emit("onChanged", editor.getHtml());
      emit("getText", editor.getText());
    }
    watch$1(() => props.isEditer, (newVal) => {
      if (props.isEditer) {
        editorRef.value.enable();
        editer.value = true;
      } else {
        editorRef.value.disable();
        editer.value = false;
        if (props.isPreview) {
          let doms = editorRef.value.getEditableContainer();
          let imgs = doms.getElementsByTagName("img");
          if (imgs.length != 0) {
            dialogImageUrl.value = [];
            for (let i2 = 0; i2 < imgs.length; i2++) {
              dialogImageUrl.value.push(imgs[i2].currentSrc);
              imgs[i2].onclick = () => {
                if (editer.value == false) {
                  whichImg.value = i2;
                  dialogVisible.value = true;
                }
              };
            }
          }
        }
      }
    });
    const isFocus = () => {
      editorRef.value.focus();
    };
    onBeforeUnmount(() => {
      const editor = editorRef.value;
      if (editor == null)
        return;
      emit("beforeEditordestory", editor.getHtml());
      editor.destroy();
      emit("afterEditordestory", editor.getHtml());
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        unref$1(dialogVisible) ? (openBlock(), createBlock(unref$1(ElImageViewer), {
          key: 0,
          "initial-index": unref$1(whichImg),
          "url-list": unref$1(dialogImageUrl),
          onClose: _cache[0] || (_cache[0] = ($event) => isRef(dialogVisible) ? dialogVisible.value = false : dialogVisible = false),
          infinite: props.isInfinite
        }, null, 8, ["initial-index", "url-list", "infinite"])) : createCommentVNode("", true),
        createElementVNode("div", {
          class: "wangeditorClass",
          onClick: isFocus
        }, [
          withDirectives(createVNode(unref$1(Toolbar), {
            class: normalizeClass(["toolbarClass", _ctx.$props.ToolbarClass]),
            editor: unref$1(editorRef),
            defaultConfig: unref$1(toolbarConfig),
            mode: unref$1(mode)
          }, null, 8, ["class", "editor", "defaultConfig", "mode"]), [
            [vShow, unref$1(editer) || __props.isToolbar]
          ]),
          createVNode(unref$1(Editor), {
            class: normalizeClass(["editorClass", _ctx.$props.EditorClass]),
            defaultConfig: unref$1(editorConfig),
            modelValue: unref$1(defaultHtml),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(defaultHtml) ? defaultHtml.value = $event : null),
            onOnChange: handleChange2,
            mode: unref$1(mode),
            onOnCreated: handleCreated
          }, null, 8, ["class", "defaultConfig", "modelValue", "mode"])
        ])
      ]);
    };
  }
});
var FitsEditor = /* @__PURE__ */ _export_sfc$2(_sfc_main, [["__scopeId", "data-v-d71f5044"]]);
const FitAdminUI = {
  install: (app) => {
    app.component("FitsTreeSelect", FitsTreeSelect);
    app.component("FitsIconSelect", FitsIconSelect);
    app.component("FitsCheckboxAll", _sfc_main$x);
    app.component("FitsFormCreate", _sfc_main$w);
    app.component("FitsDialog", FitsDialog);
    app.component("FitsDrawer", FitsDrawer);
    app.component("FitsFormDialog", FitsFormDialog);
    app.component("FormTitle", FormTitle);
    app.component("FitsCard", FitsCard);
    app.component("FitsEcharts", FitsEcharts);
    app.component("FitsForm", _sfc_main$o);
    app.component("FitsListSearch", FitsListSearch);
    app.component("FitsNoData", FitsNoData);
    app.component("FitsTable", _sfc_main$3);
    app.component("ListSeachBtnGroud", ListSeachBtnGroud);
    app.component("FitsEditor", FitsEditor);
  }
};
export { FitAdminUI as default };
